"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .authenticationmethodoptions import AuthenticationMethodOptions
from .authenticationmethodoptions1 import AuthenticationMethodOptions1
from .authenticationmethodoptionsauthtokensitems import (
    AuthenticationMethodOptionsAuthTokensItems,
)
from .authenticationmethodoptionss3collectorconf import (
    AuthenticationMethodOptionsS3CollectorConf,
)
from .authenticationmethodoptionssasl import AuthenticationMethodOptionsSasl
from .authenticationprotocoloptionsv3user import AuthenticationProtocolOptionsV3User
from .authenticationtype import AuthenticationType, AuthenticationTypeTypedDict
from .authenticationtype1 import AuthenticationType1, AuthenticationType1TypedDict
from .authenticationtypeoptions import AuthenticationTypeOptions
from .authenticationtypeoptionslokiauth import AuthenticationTypeOptionsLokiAuth
from .authenticationtypeoptionsprometheusauth import (
    AuthenticationTypeOptionsPrometheusAuth,
)
from .certificatetypeazureblobauthtypeclientcert import (
    CertificateTypeAzureBlobAuthTypeClientCert,
    CertificateTypeAzureBlobAuthTypeClientCertTypedDict,
)
from .checkpointingtype import CheckpointingType, CheckpointingTypeTypedDict
from .datacompressionformatoptionspersistence import (
    DataCompressionFormatOptionsPersistence,
)
from .diskspoolingtype import DiskSpoolingType, DiskSpoolingTypeTypedDict
from .googleauthenticationmethodoptions import GoogleAuthenticationMethodOptions
from .itemstypeauthtokens import ItemsTypeAuthTokens, ItemsTypeAuthTokensTypedDict
from .itemstypeauthtokensext import (
    ItemsTypeAuthTokensExt,
    ItemsTypeAuthTokensExtTypedDict,
)
from .itemstypeconnectionsoptional import (
    ItemsTypeConnectionsOptional,
    ItemsTypeConnectionsOptionalTypedDict,
)
from .itemstypeextrahttpheaders import (
    ItemsTypeExtraHTTPHeaders,
    ItemsTypeExtraHTTPHeadersTypedDict,
)
from .itemstypemetadata import ItemsTypeMetadata, ItemsTypeMetadataTypedDict
from .itemstyperules import ItemsTypeRules, ItemsTypeRulesTypedDict
from .itemstypesearchfilter import ItemsTypeSearchFilter, ItemsTypeSearchFilterTypedDict
from .kafkaschemaregistryauthenticationtype import (
    KafkaSchemaRegistryAuthenticationType,
    KafkaSchemaRegistryAuthenticationTypeTypedDict,
)
from .logleveloptionscontentconfigitems import LogLevelOptionsContentConfigItems
from .maximumtlsversionoptionskafkaschemaregistrytls import (
    MaximumTLSVersionOptionsKafkaSchemaRegistryTLS,
)
from .minimumtlsversionoptionskafkaschemaregistrytls import (
    MinimumTLSVersionOptionsKafkaSchemaRegistryTLS,
)
from .modeoptionshost import ModeOptionsHost
from .outputmodeoptionssplunkcollectorconf import OutputModeOptionsSplunkCollectorConf
from .pqtype import PqType, PqTypeTypedDict
from .preprocesstype import PreprocessType, PreprocessTypeTypedDict
from .processtype import ProcessType, ProcessTypeTypedDict
from .protocoloptionstargetsitems import ProtocolOptionsTargetsItems
from .recordtypeoptions import RecordTypeOptions
from .retryrulestype import RetryRulesType, RetryRulesTypeTypedDict
from .retryrulestype1 import RetryRulesType1, RetryRulesType1TypedDict
from .signatureversionoptions import SignatureVersionOptions
from .signatureversionoptions1 import SignatureVersionOptions1
from .signatureversionoptions2 import SignatureVersionOptions2
from .signatureversionoptions3 import SignatureVersionOptions3
from .signatureversionoptionss3collectorconf import (
    SignatureVersionOptionsS3CollectorConf,
)
from .subscriptionplanoptions import SubscriptionPlanOptions
from .tagafterprocessingoptions import TagAfterProcessingOptions
from .tlssettingsclientsidetype import (
    TLSSettingsClientSideType,
    TLSSettingsClientSideTypeTypedDict,
)
from .tlssettingsclientsidetypekafkaschemaregistry import (
    TLSSettingsClientSideTypeKafkaSchemaRegistry,
    TLSSettingsClientSideTypeKafkaSchemaRegistryTypedDict,
)
from .tlssettingsserversidetype import (
    TLSSettingsServerSideType,
    TLSSettingsServerSideTypeTypedDict,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils import (
    FieldMetadata,
    PathParamMetadata,
    RequestMetadata,
    get_discriminator,
)
from enum import Enum
import pydantic
from pydantic import Discriminator, Tag, field_serializer, model_serializer
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class CreateInputSystemByPackTypeCloudflareHec(str, Enum):
    CLOUDFLARE_HEC = "cloudflare_hec"


class CreateInputSystemByPackAuthenticationMethodCloudflareHec(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select Secret to use a text secret to authenticate"""

    SECRET = "secret"


class CreateInputSystemByPackAuthTokenCloudflareHecTypedDict(TypedDict):
    auth_type: NotRequired[CreateInputSystemByPackAuthenticationMethodCloudflareHec]
    r"""Select Secret to use a text secret to authenticate"""
    token_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    token: NotRequired[Any]
    enabled: NotRequired[bool]
    description: NotRequired[str]
    allowed_indexes_at_token: NotRequired[List[str]]
    r"""Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events referencing this token"""


class CreateInputSystemByPackAuthTokenCloudflareHec(BaseModel):
    auth_type: Annotated[
        Optional[CreateInputSystemByPackAuthenticationMethodCloudflareHec],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Select Secret to use a text secret to authenticate"""

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored text secret"""

    token: Optional[Any] = None

    enabled: Optional[bool] = None

    description: Optional[str] = None

    allowed_indexes_at_token: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedIndexesAtToken")
    ] = None
    r"""Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events referencing this token"""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackAuthenticationMethodCloudflareHec(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "tokenSecret",
                "token",
                "enabled",
                "description",
                "allowedIndexesAtToken",
                "metadata",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputCloudflareHecTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeCloudflareHec
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    hec_api: str
    r"""Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[
        List[CreateInputSystemByPackAuthTokenCloudflareHecTypedDict]
    ]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[Any]
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to every event. May be overridden by fields added at the token or request level."""
    allowed_indexes: NotRequired[List[str]]
    r"""List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level."""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    access_control_allow_origin: NotRequired[List[str]]
    r"""HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards."""
    access_control_allow_headers: NotRequired[List[str]]
    r"""HTTP headers that @{product} will send to allowed origins as \"Access-Control-Allow-Headers\" in a CORS preflight response. Use \"*\" to allow all headers."""
    emit_token_metrics: NotRequired[bool]
    r"""Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputCloudflareHec(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeCloudflareHec

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    hec_api: Annotated[str, pydantic.Field(alias="hecAPI")]
    r"""Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[
        Optional[List[CreateInputSystemByPackAuthTokenCloudflareHec]],
        pydantic.Field(alias="authTokens"),
    ] = None
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[Any], pydantic.Field(alias="enableHealthCheck")
    ] = None

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to every event. May be overridden by fields added at the token or request level."""

    allowed_indexes: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedIndexes")
    ] = None
    r"""List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level."""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    access_control_allow_origin: Annotated[
        Optional[List[str]], pydantic.Field(alias="accessControlAllowOrigin")
    ] = None
    r"""HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards."""

    access_control_allow_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="accessControlAllowHeaders")
    ] = None
    r"""HTTP headers that @{product} will send to allowed origins as \"Access-Control-Allow-Headers\" in a CORS preflight response. Use \"*\" to allow all headers."""

    emit_token_metrics: Annotated[
        Optional[bool], pydantic.Field(alias="emitTokenMetrics")
    ] = None
    r"""Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "metadata",
                "allowedIndexes",
                "breakerRulesets",
                "staleChannelFlushMs",
                "accessControlAllowOrigin",
                "accessControlAllowHeaders",
                "emitTokenMetrics",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeZscalerHec(str, Enum):
    ZSCALER_HEC = "zscaler_hec"


class CreateInputSystemByPackAuthTokenZscalerHecTypedDict(TypedDict):
    token: str
    r"""Shared secret to be provided by any client (Authorization: <token>)"""
    auth_type: NotRequired[AuthenticationMethodOptionsAuthTokensItems]
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""
    token_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    enabled: NotRequired[bool]
    description: NotRequired[str]
    allowed_indexes_at_token: NotRequired[List[str]]
    r"""Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events referencing this token"""


class CreateInputSystemByPackAuthTokenZscalerHec(BaseModel):
    token: str
    r"""Shared secret to be provided by any client (Authorization: <token>)"""

    auth_type: Annotated[
        Optional[AuthenticationMethodOptionsAuthTokensItems],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored text secret"""

    enabled: Optional[bool] = None

    description: Optional[str] = None

    allowed_indexes_at_token: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedIndexesAtToken")
    ] = None
    r"""Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events referencing this token"""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsAuthTokensItems(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "tokenSecret",
                "enabled",
                "description",
                "allowedIndexesAtToken",
                "metadata",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputZscalerHecTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeZscalerHec
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    hec_api: str
    r"""Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[List[CreateInputSystemByPackAuthTokenZscalerHecTypedDict]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[Any]
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to every event. May be overridden by fields added at the token or request level."""
    allowed_indexes: NotRequired[List[str]]
    r"""List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level."""
    hec_acks: NotRequired[bool]
    r"""Whether to enable Zscaler HEC acknowledgements"""
    access_control_allow_origin: NotRequired[List[str]]
    r"""Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards."""
    access_control_allow_headers: NotRequired[List[str]]
    r"""Optionally, list HTTP headers that @{product} will send to allowed origins as \"Access-Control-Allow-Headers\" in a CORS preflight response. Use \"*\" to allow all headers."""
    emit_token_metrics: NotRequired[bool]
    r"""Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""
    template_hec_api: NotRequired[str]
    r"""Binds 'hecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'hecAPI' at runtime."""


class CreateInputSystemByPackInputZscalerHec(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeZscalerHec

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    hec_api: Annotated[str, pydantic.Field(alias="hecAPI")]
    r"""Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[
        Optional[List[CreateInputSystemByPackAuthTokenZscalerHec]],
        pydantic.Field(alias="authTokens"),
    ] = None
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[Any], pydantic.Field(alias="enableHealthCheck")
    ] = None

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to every event. May be overridden by fields added at the token or request level."""

    allowed_indexes: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedIndexes")
    ] = None
    r"""List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level."""

    hec_acks: Annotated[Optional[bool], pydantic.Field(alias="hecAcks")] = None
    r"""Whether to enable Zscaler HEC acknowledgements"""

    access_control_allow_origin: Annotated[
        Optional[List[str]], pydantic.Field(alias="accessControlAllowOrigin")
    ] = None
    r"""Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards."""

    access_control_allow_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="accessControlAllowHeaders")
    ] = None
    r"""Optionally, list HTTP headers that @{product} will send to allowed origins as \"Access-Control-Allow-Headers\" in a CORS preflight response. Use \"*\" to allow all headers."""

    emit_token_metrics: Annotated[
        Optional[bool], pydantic.Field(alias="emitTokenMetrics")
    ] = None
    r"""Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    template_hec_api: Annotated[
        Optional[str], pydantic.Field(alias="__template_hecAPI")
    ] = None
    r"""Binds 'hecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'hecAPI' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "metadata",
                "allowedIndexes",
                "hecAcks",
                "accessControlAllowOrigin",
                "accessControlAllowHeaders",
                "emitTokenMetrics",
                "description",
                "__template_host",
                "__template_port",
                "__template_hecAPI",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeSecurityLake(str, Enum):
    SECURITY_LAKE = "security_lake"


class CreateInputSystemByPackInputSecurityLakeTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeSecurityLake
    queue_name: str
    r"""The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    file_filter: NotRequired[str]
    r"""Regex matching file names to download and process. Defaults to: .*"""
    aws_account_id: NotRequired[str]
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    region: NotRequired[str]
    r"""AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region."""
    endpoint: NotRequired[str]
    r"""S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptionsS3CollectorConf]
    r"""Signature version to use for signing S3 requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    max_messages: NotRequired[float]
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""
    visibility_timeout: NotRequired[float]
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""
    num_receivers: NotRequired[float]
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""
    socket_timeout: NotRequired[float]
    r"""Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure."""
    skip_on_error: NotRequired[bool]
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""
    include_sqs_metadata: NotRequired[bool]
    r"""Attach SQS notification metadata to a __sqsMetadata field on each event"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access Amazon S3"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    enable_sqs_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials when accessing Amazon SQS"""
    preprocess: NotRequired[PreprocessTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    parquet_chunk_size_mb: NotRequired[float]
    r"""Maximum file size for each Parquet chunk"""
    parquet_chunk_download_timeout: NotRequired[float]
    r"""The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified."""
    checkpointing: NotRequired[CheckpointingTypeTypedDict]
    poll_timeout: NotRequired[float]
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""
    encoding: NotRequired[str]
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    tag_after_processing: NotRequired[TagAfterProcessingOptions]
    processed_tag_key: NotRequired[str]
    r"""The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""
    processed_tag_value: NotRequired[str]
    r"""The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""
    template_queue_name: NotRequired[str]
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""
    template_aws_account_id: NotRequired[str]
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""


class CreateInputSystemByPackInputSecurityLake(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeSecurityLake

    queue_name: Annotated[str, pydantic.Field(alias="queueName")]
    r"""The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    file_filter: Annotated[Optional[str], pydantic.Field(alias="fileFilter")] = None
    r"""Regex matching file names to download and process. Defaults to: .*"""

    aws_account_id: Annotated[Optional[str], pydantic.Field(alias="awsAccountId")] = (
        None
    )
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    region: Optional[str] = None
    r"""AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region."""

    endpoint: Optional[str] = None
    r"""S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptionsS3CollectorConf],
        pydantic.Field(alias="signatureVersion"),
    ] = None
    r"""Signature version to use for signing S3 requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    max_messages: Annotated[Optional[float], pydantic.Field(alias="maxMessages")] = None
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""

    visibility_timeout: Annotated[
        Optional[float], pydantic.Field(alias="visibilityTimeout")
    ] = None
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""

    num_receivers: Annotated[Optional[float], pydantic.Field(alias="numReceivers")] = (
        None
    )
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure."""

    skip_on_error: Annotated[Optional[bool], pydantic.Field(alias="skipOnError")] = None
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""

    include_sqs_metadata: Annotated[
        Optional[bool], pydantic.Field(alias="includeSqsMetadata")
    ] = None
    r"""Attach SQS notification metadata to a __sqsMetadata field on each event"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access Amazon S3"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    enable_sqs_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableSQSAssumeRole")
    ] = None
    r"""Use Assume Role credentials when accessing Amazon SQS"""

    preprocess: Optional[PreprocessType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    parquet_chunk_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="parquetChunkSizeMB")
    ] = None
    r"""Maximum file size for each Parquet chunk"""

    parquet_chunk_download_timeout: Annotated[
        Optional[float], pydantic.Field(alias="parquetChunkDownloadTimeout")
    ] = None
    r"""The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified."""

    checkpointing: Optional[CheckpointingType] = None

    poll_timeout: Annotated[Optional[float], pydantic.Field(alias="pollTimeout")] = None
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""

    encoding: Optional[str] = None
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    tag_after_processing: Annotated[
        Optional[TagAfterProcessingOptions], pydantic.Field(alias="tagAfterProcessing")
    ] = None

    processed_tag_key: Annotated[
        Optional[str], pydantic.Field(alias="processedTagKey")
    ] = None
    r"""The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""

    processed_tag_value: Annotated[
        Optional[str], pydantic.Field(alias="processedTagValue")
    ] = None
    r"""The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""

    template_queue_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_queueName")
    ] = None
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""

    template_aws_account_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsAccountId")
    ] = None
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("tag_after_processing")
    def serialize_tag_after_processing(self, value):
        if isinstance(value, str):
            try:
                return models.TagAfterProcessingOptions(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "fileFilter",
                "awsAccountId",
                "awsAuthenticationMethod",
                "awsSecretKey",
                "region",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "breakerRulesets",
                "staleChannelFlushMs",
                "maxMessages",
                "visibilityTimeout",
                "numReceivers",
                "socketTimeout",
                "skipOnError",
                "includeSqsMetadata",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "enableSQSAssumeRole",
                "preprocess",
                "metadata",
                "parquetChunkSizeMB",
                "parquetChunkDownloadTimeout",
                "checkpointing",
                "pollTimeout",
                "encoding",
                "description",
                "awsApiKey",
                "awsSecret",
                "tagAfterProcessing",
                "processedTagKey",
                "processedTagValue",
                "__template_queueName",
                "__template_awsAccountId",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
                "__template_awsApiKey",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeNetflow(str, Enum):
    NETFLOW = "netflow"


class CreateInputSystemByPackInputNetflowTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeNetflow
    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    enable_pass_through: NotRequired[bool]
    r"""Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota."""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist."""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    template_cache_minutes: NotRequired[float]
    r"""Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage."""
    v5_enabled: NotRequired[bool]
    r"""Accept messages in Netflow V5 format."""
    v9_enabled: NotRequired[bool]
    r"""Accept messages in Netflow V9 format."""
    ipfix_enabled: NotRequired[bool]
    r"""Accept messages in IPFIX format."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputNetflow(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeNetflow

    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    enable_pass_through: Annotated[
        Optional[bool], pydantic.Field(alias="enablePassThrough")
    ] = None
    r"""Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota."""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist."""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    template_cache_minutes: Annotated[
        Optional[float], pydantic.Field(alias="templateCacheMinutes")
    ] = None
    r"""Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage."""

    v5_enabled: Annotated[Optional[bool], pydantic.Field(alias="v5Enabled")] = None
    r"""Accept messages in Netflow V5 format."""

    v9_enabled: Annotated[Optional[bool], pydantic.Field(alias="v9Enabled")] = None
    r"""Accept messages in Netflow V9 format."""

    ipfix_enabled: Annotated[Optional[bool], pydantic.Field(alias="ipfixEnabled")] = (
        None
    )
    r"""Accept messages in IPFIX format."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "enablePassThrough",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "udpSocketRxBufSize",
                "templateCacheMinutes",
                "v5Enabled",
                "v9Enabled",
                "ipfixEnabled",
                "metadata",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeWizWebhook(str, Enum):
    WIZ_WEBHOOK = "wiz_webhook"


class CreateInputSystemByPackInputWizWebhookTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeWizWebhook
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[List[str]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    allowed_paths: NotRequired[List[str]]
    r"""List of URI paths accepted by this input. Wildcards are supported (such as /api/v*/hook). Defaults to allow all."""
    allowed_methods: NotRequired[List[str]]
    r"""List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all."""
    auth_tokens_ext: NotRequired[List[ItemsTypeAuthTokensExtTypedDict]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputWizWebhook(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeWizWebhook

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[Optional[List[str]], pydantic.Field(alias="authTokens")] = (
        None
    )
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    allowed_paths: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedPaths")
    ] = None
    r"""List of URI paths accepted by this input. Wildcards are supported (such as /api/v*/hook). Defaults to allow all."""

    allowed_methods: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedMethods")
    ] = None
    r"""List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all."""

    auth_tokens_ext: Annotated[
        Optional[List[ItemsTypeAuthTokensExt]], pydantic.Field(alias="authTokensExt")
    ] = None
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "breakerRulesets",
                "staleChannelFlushMs",
                "metadata",
                "allowedPaths",
                "allowedMethods",
                "authTokensExt",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeWiz(str, Enum):
    WIZ = "wiz"


class CreateInputSystemByPackManageStateTypedDict(TypedDict):
    pass


class CreateInputSystemByPackManageState(BaseModel):
    pass


class CreateInputSystemByPackLogLevelWiz(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Collector runtime log level"""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CreateInputSystemByPackContentConfigWizTypedDict(TypedDict):
    content_type: str
    r"""The name of the Wiz query"""
    content_query: str
    r"""Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`."""
    cron_schedule: str
    r"""A cron schedule on which to run this job"""
    earliest: str
    r"""Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)"""
    latest: str
    r"""Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)"""
    content_description: NotRequired[str]
    enabled: NotRequired[bool]
    state_tracking: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""
    state_update_expression: NotRequired[str]
    r"""JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information."""
    state_merge_expression: NotRequired[str]
    r"""JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep."""
    manage_state: NotRequired[CreateInputSystemByPackManageStateTypedDict]
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time."""
    log_level: NotRequired[CreateInputSystemByPackLogLevelWiz]
    r"""Collector runtime log level"""
    max_pages: NotRequired[float]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages."""


class CreateInputSystemByPackContentConfigWiz(BaseModel):
    content_type: Annotated[str, pydantic.Field(alias="contentType")]
    r"""The name of the Wiz query"""

    content_query: Annotated[str, pydantic.Field(alias="contentQuery")]
    r"""Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`."""

    cron_schedule: Annotated[str, pydantic.Field(alias="cronSchedule")]
    r"""A cron schedule on which to run this job"""

    earliest: str
    r"""Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)"""

    latest: str
    r"""Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)"""

    content_description: Annotated[
        Optional[str], pydantic.Field(alias="contentDescription")
    ] = None

    enabled: Optional[bool] = None

    state_tracking: Annotated[Optional[bool], pydantic.Field(alias="stateTracking")] = (
        None
    )
    r"""Track collection progress between consecutive scheduled executions"""

    state_update_expression: Annotated[
        Optional[str], pydantic.Field(alias="stateUpdateExpression")
    ] = None
    r"""JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information."""

    state_merge_expression: Annotated[
        Optional[str], pydantic.Field(alias="stateMergeExpression")
    ] = None
    r"""JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep."""

    manage_state: Annotated[
        Optional[CreateInputSystemByPackManageState],
        pydantic.Field(alias="manageState"),
    ] = None

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = None
    r"""Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time."""

    log_level: Annotated[
        Optional[CreateInputSystemByPackLogLevelWiz], pydantic.Field(alias="logLevel")
    ] = None
    r"""Collector runtime log level"""

    max_pages: Annotated[Optional[float], pydantic.Field(alias="maxPages")] = None
    r"""Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages."""

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackLogLevelWiz(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "contentDescription",
                "enabled",
                "stateTracking",
                "stateUpdateExpression",
                "stateMergeExpression",
                "manageState",
                "jobTimeout",
                "logLevel",
                "maxPages",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputWizTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeWiz
    endpoint: str
    r"""The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql"""
    auth_url: str
    r"""The authentication URL to generate an OAuth token"""
    client_id: str
    r"""The client ID of the Wiz application"""
    content_config: List[CreateInputSystemByPackContentConfigWizTypedDict]
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_audience_override: NotRequired[str]
    r"""The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used."""
    request_timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    auth_type: NotRequired[AuthenticationMethodOptions1]
    r"""Enter client secret directly, or select a stored secret"""
    description: NotRequired[str]
    client_secret: NotRequired[str]
    r"""The client secret of the Wiz application"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_endpoint: NotRequired[str]
    r"""Binds 'endpoint' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'endpoint' at runtime."""
    template_auth_url: NotRequired[str]
    r"""Binds 'authUrl' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'authUrl' at runtime."""
    template_client_id: NotRequired[str]
    r"""Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime."""


class CreateInputSystemByPackInputWiz(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeWiz

    endpoint: str
    r"""The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql"""

    auth_url: Annotated[str, pydantic.Field(alias="authUrl")]
    r"""The authentication URL to generate an OAuth token"""

    client_id: Annotated[str, pydantic.Field(alias="clientId")]
    r"""The client ID of the Wiz application"""

    content_config: Annotated[
        List[CreateInputSystemByPackContentConfigWiz],
        pydantic.Field(alias="contentConfig"),
    ]

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_audience_override: Annotated[
        Optional[str], pydantic.Field(alias="authAudienceOverride")
    ] = None
    r"""The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = None
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = None
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = None
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = None
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    auth_type: Annotated[
        Optional[AuthenticationMethodOptions1], pydantic.Field(alias="authType")
    ] = None
    r"""Enter client secret directly, or select a stored secret"""

    description: Optional[str] = None

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""The client secret of the Wiz application"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_endpoint: Annotated[
        Optional[str], pydantic.Field(alias="__template_endpoint")
    ] = None
    r"""Binds 'endpoint' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'endpoint' at runtime."""

    template_auth_url: Annotated[
        Optional[str], pydantic.Field(alias="__template_authUrl")
    ] = None
    r"""Binds 'authUrl' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'authUrl' at runtime."""

    template_client_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_clientId")
    ] = None
    r"""Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptions1(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authAudienceOverride",
                "requestTimeout",
                "keepAliveTime",
                "maxMissedKeepAlives",
                "ttl",
                "ignoreGroupJobsLimit",
                "metadata",
                "retryRules",
                "authType",
                "description",
                "clientSecret",
                "textSecret",
                "__template_endpoint",
                "__template_authUrl",
                "__template_clientId",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputJournalFilesType(str, Enum):
    JOURNAL_FILES = "journal_files"


class CreateInputSystemByPackInputJournalFilesRuleTypedDict(TypedDict):
    filter_: str
    r"""JavaScript expression applied to Journal objects. Return 'true' to include it."""
    description: NotRequired[str]
    r"""Optional description of this rule's purpose"""


class CreateInputSystemByPackInputJournalFilesRule(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""JavaScript expression applied to Journal objects. Return 'true' to include it."""

    description: Optional[str] = None
    r"""Optional description of this rule's purpose"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["description"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputJournalFilesTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackInputJournalFilesType
    path: str
    r"""Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID."""
    journals: List[str]
    r"""The full path of discovered journals are matched against this wildcard list."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between scanning for journals."""
    rules: NotRequired[List[CreateInputSystemByPackInputJournalFilesRuleTypedDict]]
    r"""Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true."""
    current_boot: NotRequired[bool]
    r"""Skip log messages that are not part of the current boot session."""
    max_age_dur: NotRequired[str]
    r"""The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]


class CreateInputSystemByPackInputJournalFiles(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackInputJournalFilesType

    path: str
    r"""Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID."""

    journals: List[str]
    r"""The full path of discovered journals are matched against this wildcard list."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = None
    r"""Time, in seconds, between scanning for journals."""

    rules: Optional[List[CreateInputSystemByPackInputJournalFilesRule]] = None
    r"""Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true."""

    current_boot: Annotated[Optional[bool], pydantic.Field(alias="currentBoot")] = None
    r"""Skip log messages that are not part of the current boot session."""

    max_age_dur: Annotated[Optional[str], pydantic.Field(alias="maxAgeDur")] = None
    r"""The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "interval",
                "rules",
                "currentBoot",
                "maxAgeDur",
                "metadata",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeRawUDP(str, Enum):
    RAW_UDP = "raw_udp"


class CreateInputSystemByPackInputRawUDPTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeRawUDP
    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    single_msg_udp_packets: NotRequired[bool]
    r"""If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines."""
    ingest_raw_bytes: NotRequired[bool]
    r"""If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram."""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputRawUDP(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeRawUDP

    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = None
    r"""Maximum number of events to buffer when downstream is blocking."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to send data"""

    single_msg_udp_packets: Annotated[
        Optional[bool], pydantic.Field(alias="singleMsgUdpPackets")
    ] = None
    r"""If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines."""

    ingest_raw_bytes: Annotated[
        Optional[bool], pydantic.Field(alias="ingestRawBytes")
    ] = None
    r"""If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram."""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "maxBufferSize",
                "ipWhitelistRegex",
                "singleMsgUdpPackets",
                "ingestRawBytes",
                "udpSocketRxBufSize",
                "metadata",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeWinEventLogs(str, Enum):
    WIN_EVENT_LOGS = "win_event_logs"


class CreateInputSystemByPackReadMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Read all stored and future event logs, or only future events"""

    # Entire log
    OLDEST = "oldest"
    # From last entry
    NEWEST = "newest"


class CreateInputSystemByPackEventFormat(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of individual events"""

    # JSON
    JSON = "json"
    # XML
    XML = "xml"


class CreateInputSystemByPackInputWinEventLogsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeWinEventLogs
    log_names: List[str]
    r"""Enter the event logs to collect. Run \"Get-WinEvent -ListLog *\" in PowerShell to see the available logs."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    read_mode: NotRequired[CreateInputSystemByPackReadMode]
    r"""Read all stored and future event logs, or only future events"""
    event_format: NotRequired[CreateInputSystemByPackEventFormat]
    r"""Format of individual events"""
    disable_native_module: NotRequired[bool]
    r"""Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)"""
    interval: NotRequired[float]
    r"""Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)"""
    batch_size: NotRequired[float]
    r"""The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    max_event_bytes: NotRequired[float]
    r"""The maximum number of bytes in an event before it is flushed to the pipelines"""
    description: NotRequired[str]
    disable_json_rendering: NotRequired[bool]
    r"""Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)"""
    disable_xml_rendering: NotRequired[bool]
    r"""Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)"""


class CreateInputSystemByPackInputWinEventLogs(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeWinEventLogs

    log_names: Annotated[List[str], pydantic.Field(alias="logNames")]
    r"""Enter the event logs to collect. Run \"Get-WinEvent -ListLog *\" in PowerShell to see the available logs."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    read_mode: Annotated[
        Optional[CreateInputSystemByPackReadMode], pydantic.Field(alias="readMode")
    ] = None
    r"""Read all stored and future event logs, or only future events"""

    event_format: Annotated[
        Optional[CreateInputSystemByPackEventFormat],
        pydantic.Field(alias="eventFormat"),
    ] = None
    r"""Format of individual events"""

    disable_native_module: Annotated[
        Optional[bool], pydantic.Field(alias="disableNativeModule")
    ] = None
    r"""Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)"""

    interval: Optional[float] = None
    r"""Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)"""

    batch_size: Annotated[Optional[float], pydantic.Field(alias="batchSize")] = None
    r"""The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    max_event_bytes: Annotated[
        Optional[float], pydantic.Field(alias="maxEventBytes")
    ] = None
    r"""The maximum number of bytes in an event before it is flushed to the pipelines"""

    description: Optional[str] = None

    disable_json_rendering: Annotated[
        Optional[bool], pydantic.Field(alias="disableJsonRendering")
    ] = None
    r"""Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)"""

    disable_xml_rendering: Annotated[
        Optional[bool], pydantic.Field(alias="disableXmlRendering")
    ] = None
    r"""Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)"""

    @field_serializer("read_mode")
    def serialize_read_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackReadMode(value)
            except ValueError:
                return value
        return value

    @field_serializer("event_format")
    def serialize_event_format(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackEventFormat(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "readMode",
                "eventFormat",
                "disableNativeModule",
                "interval",
                "batchSize",
                "metadata",
                "maxEventBytes",
                "description",
                "disableJsonRendering",
                "disableXmlRendering",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeWef(str, Enum):
    WEF = "wef"


class CreateInputSystemByPackAuthenticationMethodWef(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""How to authenticate incoming client connections"""

    # Client certificate
    CLIENT_CERT = "clientCert"
    # Kerberos
    KERBEROS = "kerberos"


class CreateInputSystemByPackMTLSSettingsTypedDict(TypedDict):
    priv_key_path: str
    r"""Path on server containing the private key to use. PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path on server containing certificates to use. PEM format. Can reference $ENV_VARS."""
    ca_path: str
    r"""Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it."""
    disabled: NotRequired[bool]
    r"""Enable TLS"""
    reject_unauthorized: NotRequired[bool]
    r"""Required for WEF certificate authentication"""
    request_cert: NotRequired[bool]
    r"""Required for WEF certificate authentication"""
    certificate_name: NotRequired[str]
    r"""Name of the predefined certificate"""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt private key"""
    common_name_regex: NotRequired[str]
    r"""Regex matching allowable common names in peer certificates' subject attribute"""
    min_version: NotRequired[MinimumTLSVersionOptionsKafkaSchemaRegistryTLS]
    max_version: NotRequired[MaximumTLSVersionOptionsKafkaSchemaRegistryTLS]
    ocsp_check: NotRequired[bool]
    r"""Enable OCSP check of certificate"""
    keytab: NotRequired[Any]
    principal: NotRequired[Any]
    ocsp_check_fail_close: NotRequired[bool]
    r"""If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors."""


class CreateInputSystemByPackMTLSSettings(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path on server containing the private key to use. PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path on server containing certificates to use. PEM format. Can reference $ENV_VARS."""

    ca_path: Annotated[str, pydantic.Field(alias="caPath")]
    r"""Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it."""

    disabled: Optional[bool] = None
    r"""Enable TLS"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Required for WEF certificate authentication"""

    request_cert: Annotated[Optional[bool], pydantic.Field(alias="requestCert")] = None
    r"""Required for WEF certificate authentication"""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""Name of the predefined certificate"""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt private key"""

    common_name_regex: Annotated[
        Optional[str], pydantic.Field(alias="commonNameRegex")
    ] = None
    r"""Regex matching allowable common names in peer certificates' subject attribute"""

    min_version: Annotated[
        Optional[MinimumTLSVersionOptionsKafkaSchemaRegistryTLS],
        pydantic.Field(alias="minVersion"),
    ] = None

    max_version: Annotated[
        Optional[MaximumTLSVersionOptionsKafkaSchemaRegistryTLS],
        pydantic.Field(alias="maxVersion"),
    ] = None

    ocsp_check: Annotated[Optional[bool], pydantic.Field(alias="ocspCheck")] = None
    r"""Enable OCSP check of certificate"""

    keytab: Optional[Any] = None

    principal: Optional[Any] = None

    ocsp_check_fail_close: Annotated[
        Optional[bool], pydantic.Field(alias="ocspCheckFailClose")
    ] = None
    r"""If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors."""

    @field_serializer("min_version")
    def serialize_min_version(self, value):
        if isinstance(value, str):
            try:
                return models.MinimumTLSVersionOptionsKafkaSchemaRegistryTLS(value)
            except ValueError:
                return value
        return value

    @field_serializer("max_version")
    def serialize_max_version(self, value):
        if isinstance(value, str):
            try:
                return models.MaximumTLSVersionOptionsKafkaSchemaRegistryTLS(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "rejectUnauthorized",
                "requestCert",
                "certificateName",
                "passphrase",
                "commonNameRegex",
                "minVersion",
                "maxVersion",
                "ocspCheck",
                "keytab",
                "principal",
                "ocspCheckFailClose",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackFormat(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Content format in which the endpoint should deliver events"""

    RAW = "Raw"
    RENDERED_TEXT = "RenderedText"


class CreateInputSystemByPackQueryBuilderMode(str, Enum, metaclass=utils.OpenEnumMeta):
    SIMPLE = "simple"
    XML = "xml"


class CreateInputSystemByPackQueryTypedDict(TypedDict):
    path: str
    r"""The Path attribute from the relevant XML Select element"""
    query_expression: str
    r"""The XPath query inside the relevant XML Select element"""


class CreateInputSystemByPackQuery(BaseModel):
    path: str
    r"""The Path attribute from the relevant XML Select element"""

    query_expression: Annotated[str, pydantic.Field(alias="queryExpression")]
    r"""The XPath query inside the relevant XML Select element"""


class CreateInputSystemByPackSubscriptionTypedDict(TypedDict):
    subscription_name: str
    content_format: CreateInputSystemByPackFormat
    r"""Content format in which the endpoint should deliver events"""
    heartbeat_interval: float
    r"""Maximum time (in seconds) between endpoint checkins before considering it unavailable"""
    batch_timeout: float
    r"""Interval (in seconds) over which the endpoint should collect events before sending them to Stream"""
    targets: List[str]
    r"""The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com"""
    version: NotRequired[str]
    r"""Version UUID for this subscription. If any subscription parameters are modified, this value will change."""
    read_existing_events: NotRequired[bool]
    r"""Newly subscribed endpoints will send previously existing events. Disable to receive new events only."""
    send_bookmarks: NotRequired[bool]
    r"""Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details."""
    compress: NotRequired[bool]
    r"""Receive compressed events from the source"""
    locale: NotRequired[str]
    r"""The RFC-3066 locale the Windows clients should use when sending events. Defaults to \"en-US\"."""
    query_selector: NotRequired[CreateInputSystemByPackQueryBuilderMode]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events ingested under this subscription"""
    queries: NotRequired[List[CreateInputSystemByPackQueryTypedDict]]
    xml_query: NotRequired[str]
    r"""The XPath query to use for selecting events"""


class CreateInputSystemByPackSubscription(BaseModel):
    subscription_name: Annotated[str, pydantic.Field(alias="subscriptionName")]

    content_format: Annotated[
        CreateInputSystemByPackFormat, pydantic.Field(alias="contentFormat")
    ]
    r"""Content format in which the endpoint should deliver events"""

    heartbeat_interval: Annotated[float, pydantic.Field(alias="heartbeatInterval")]
    r"""Maximum time (in seconds) between endpoint checkins before considering it unavailable"""

    batch_timeout: Annotated[float, pydantic.Field(alias="batchTimeout")]
    r"""Interval (in seconds) over which the endpoint should collect events before sending them to Stream"""

    targets: List[str]
    r"""The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com"""

    version: Optional[str] = None
    r"""Version UUID for this subscription. If any subscription parameters are modified, this value will change."""

    read_existing_events: Annotated[
        Optional[bool], pydantic.Field(alias="readExistingEvents")
    ] = None
    r"""Newly subscribed endpoints will send previously existing events. Disable to receive new events only."""

    send_bookmarks: Annotated[Optional[bool], pydantic.Field(alias="sendBookmarks")] = (
        None
    )
    r"""Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details."""

    compress: Optional[bool] = None
    r"""Receive compressed events from the source"""

    locale: Optional[str] = None
    r"""The RFC-3066 locale the Windows clients should use when sending events. Defaults to \"en-US\"."""

    query_selector: Annotated[
        Optional[CreateInputSystemByPackQueryBuilderMode],
        pydantic.Field(alias="querySelector"),
    ] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events ingested under this subscription"""

    queries: Optional[List[CreateInputSystemByPackQuery]] = None

    xml_query: Annotated[Optional[str], pydantic.Field(alias="xmlQuery")] = None
    r"""The XPath query to use for selecting events"""

    @field_serializer("content_format")
    def serialize_content_format(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackFormat(value)
            except ValueError:
                return value
        return value

    @field_serializer("query_selector")
    def serialize_query_selector(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackQueryBuilderMode(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "version",
                "readExistingEvents",
                "sendBookmarks",
                "compress",
                "locale",
                "querySelector",
                "metadata",
                "queries",
                "xmlQuery",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputWefTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeWef
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    subscriptions: List[CreateInputSystemByPackSubscriptionTypedDict]
    r"""Subscriptions to events on forwarding endpoints"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_method: NotRequired[CreateInputSystemByPackAuthenticationMethodWef]
    r"""How to authenticate incoming client connections"""
    tls: NotRequired[CreateInputSystemByPackMTLSSettingsTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events in the __headers field"""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    ca_fingerprint: NotRequired[str]
    r"""SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain"""
    keytab: NotRequired[str]
    r"""Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided."""
    principal: NotRequired[str]
    r"""Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>"""
    allow_machine_id_mismatch: NotRequired[bool]
    r"""Allow events to be ingested even if their MachineID does not match the client certificate CN"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    log_fingerprint_mismatch: NotRequired[bool]
    r"""Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder."""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputWef(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeWef

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    subscriptions: List[CreateInputSystemByPackSubscription]
    r"""Subscriptions to events on forwarding endpoints"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_method: Annotated[
        Optional[CreateInputSystemByPackAuthenticationMethodWef],
        pydantic.Field(alias="authMethod"),
    ] = None
    r"""How to authenticate incoming client connections"""

    tls: Optional[CreateInputSystemByPackMTLSSettings] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events in the __headers field"""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    ca_fingerprint: Annotated[Optional[str], pydantic.Field(alias="caFingerprint")] = (
        None
    )
    r"""SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain"""

    keytab: Optional[str] = None
    r"""Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided."""

    principal: Optional[str] = None
    r"""Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>"""

    allow_machine_id_mismatch: Annotated[
        Optional[bool], pydantic.Field(alias="allowMachineIdMismatch")
    ] = None
    r"""Allow events to be ingested even if their MachineID does not match the client certificate CN"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    log_fingerprint_mismatch: Annotated[
        Optional[bool], pydantic.Field(alias="logFingerprintMismatch")
    ] = None
    r"""Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder."""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @field_serializer("auth_method")
    def serialize_auth_method(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackAuthenticationMethodWef(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authMethod",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "socketTimeout",
                "caFingerprint",
                "keytab",
                "principal",
                "allowMachineIdMismatch",
                "metadata",
                "description",
                "logFingerprintMismatch",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeAppscope(str, Enum):
    APPSCOPE = "appscope"


class CreateInputSystemByPackAllowTypedDict(TypedDict):
    procname: str
    r"""Specify the name of a process or family of processes."""
    config: str
    r"""Choose a config to apply to processes that match the process name and/or argument."""
    arg: NotRequired[str]
    r"""Specify a string to substring-match against process command-line."""


class CreateInputSystemByPackAllow(BaseModel):
    procname: str
    r"""Specify the name of a process or family of processes."""

    config: str
    r"""Choose a config to apply to processes that match the process name and/or argument."""

    arg: Optional[str] = None
    r"""Specify a string to substring-match against process command-line."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["arg"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackFilterAppscopeTypedDict(TypedDict):
    allow: NotRequired[List[CreateInputSystemByPackAllowTypedDict]]
    r"""Specify processes that AppScope should be loaded into, and the config to use."""
    transport_url: NotRequired[str]
    r"""To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL."""


class CreateInputSystemByPackFilterAppscope(BaseModel):
    allow: Optional[List[CreateInputSystemByPackAllow]] = None
    r"""Specify processes that AppScope should be loaded into, and the config to use."""

    transport_url: Annotated[Optional[str], pydantic.Field(alias="transportURL")] = None
    r"""To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["allow", "transportURL"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackPersistenceAppscopeTypedDict(TypedDict):
    enable: NotRequired[bool]
    r"""Spool events and metrics on disk for Cribl Edge and Search"""
    time_window: NotRequired[str]
    r"""Time span for each file bucket"""
    max_data_size: NotRequired[str]
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""
    max_data_time: NotRequired[str]
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""
    compress: NotRequired[DataCompressionFormatOptionsPersistence]
    dest_path: NotRequired[str]
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope"""


class CreateInputSystemByPackPersistenceAppscope(BaseModel):
    enable: Optional[bool] = None
    r"""Spool events and metrics on disk for Cribl Edge and Search"""

    time_window: Annotated[Optional[str], pydantic.Field(alias="timeWindow")] = None
    r"""Time span for each file bucket"""

    max_data_size: Annotated[Optional[str], pydantic.Field(alias="maxDataSize")] = None
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""

    max_data_time: Annotated[Optional[str], pydantic.Field(alias="maxDataTime")] = None
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""

    compress: Optional[DataCompressionFormatOptionsPersistence] = None

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope"""

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.DataCompressionFormatOptionsPersistence(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enable",
                "timeWindow",
                "maxDataSize",
                "maxDataTime",
                "compress",
                "destPath",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputAppscopeTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeAppscope
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to establish a connection"""
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""
    socket_idle_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""
    socket_ending_max_wait: NotRequired[float]
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""
    socket_max_lifespan: NotRequired[float]
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""
    enable_proxy_header: NotRequired[bool]
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    enable_unix_path: NotRequired[bool]
    r"""Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port."""
    filter_: NotRequired[CreateInputSystemByPackFilterAppscopeTypedDict]
    persistence: NotRequired[CreateInputSystemByPackPersistenceAppscopeTypedDict]
    auth_type: NotRequired[AuthenticationMethodOptionsAuthTokensItems]
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""
    description: NotRequired[str]
    host: NotRequired[str]
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: NotRequired[float]
    r"""Port to listen on"""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    unix_socket_path: NotRequired[str]
    r"""Path to the UNIX domain socket to listen on."""
    unix_socket_perms: NotRequired[str]
    r"""Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions."""
    auth_token: NotRequired[str]
    r"""Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputAppscope(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeAppscope

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to establish a connection"""

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""

    socket_idle_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketIdleTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""

    socket_ending_max_wait: Annotated[
        Optional[float], pydantic.Field(alias="socketEndingMaxWait")
    ] = None
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""

    socket_max_lifespan: Annotated[
        Optional[float], pydantic.Field(alias="socketMaxLifespan")
    ] = None
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    enable_unix_path: Annotated[
        Optional[bool], pydantic.Field(alias="enableUnixPath")
    ] = None
    r"""Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port."""

    filter_: Annotated[
        Optional[CreateInputSystemByPackFilterAppscope], pydantic.Field(alias="filter")
    ] = None

    persistence: Optional[CreateInputSystemByPackPersistenceAppscope] = None

    auth_type: Annotated[
        Optional[AuthenticationMethodOptionsAuthTokensItems],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""

    description: Optional[str] = None

    host: Optional[str] = None
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: Optional[float] = None
    r"""Port to listen on"""

    tls: Optional[TLSSettingsServerSideType] = None

    unix_socket_path: Annotated[
        Optional[str], pydantic.Field(alias="unixSocketPath")
    ] = None
    r"""Path to the UNIX domain socket to listen on."""

    unix_socket_perms: Annotated[
        Optional[str], pydantic.Field(alias="unixSocketPerms")
    ] = None
    r"""Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions."""

    auth_token: Annotated[Optional[str], pydantic.Field(alias="authToken")] = None
    r"""Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsAuthTokensItems(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "ipWhitelistRegex",
                "maxActiveCxn",
                "socketIdleTimeout",
                "socketEndingMaxWait",
                "socketMaxLifespan",
                "enableProxyHeader",
                "metadata",
                "breakerRulesets",
                "staleChannelFlushMs",
                "enableUnixPath",
                "filter",
                "persistence",
                "authType",
                "description",
                "host",
                "port",
                "tls",
                "unixSocketPath",
                "unixSocketPerms",
                "authToken",
                "textSecret",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeTCP(str, Enum):
    TCP = "tcp"


class CreateInputSystemByPackInputTCPTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeTCP
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to establish a connection"""
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""
    socket_idle_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""
    socket_ending_max_wait: NotRequired[float]
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""
    socket_max_lifespan: NotRequired[float]
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""
    enable_proxy_header: NotRequired[bool]
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    enable_header: NotRequired[bool]
    r"""Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { \"authToken\" : \"myToken\", \"fields\": { \"field1\": \"value1\", \"field2\": \"value2\" } }"""
    preprocess: NotRequired[PreprocessTypeTypedDict]
    description: NotRequired[str]
    auth_token: NotRequired[str]
    r"""Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted."""
    auth_type: NotRequired[AuthenticationMethodOptionsAuthTokensItems]
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputTCP(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeTCP

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to establish a connection"""

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""

    socket_idle_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketIdleTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""

    socket_ending_max_wait: Annotated[
        Optional[float], pydantic.Field(alias="socketEndingMaxWait")
    ] = None
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""

    socket_max_lifespan: Annotated[
        Optional[float], pydantic.Field(alias="socketMaxLifespan")
    ] = None
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { \"authToken\" : \"myToken\", \"fields\": { \"field1\": \"value1\", \"field2\": \"value2\" } }"""

    preprocess: Optional[PreprocessType] = None

    description: Optional[str] = None

    auth_token: Annotated[Optional[str], pydantic.Field(alias="authToken")] = None
    r"""Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted."""

    auth_type: Annotated[
        Optional[AuthenticationMethodOptionsAuthTokensItems],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsAuthTokensItems(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "ipWhitelistRegex",
                "maxActiveCxn",
                "socketIdleTimeout",
                "socketEndingMaxWait",
                "socketMaxLifespan",
                "enableProxyHeader",
                "metadata",
                "breakerRulesets",
                "staleChannelFlushMs",
                "enableHeader",
                "preprocess",
                "description",
                "authToken",
                "authType",
                "textSecret",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputFileType(str, Enum):
    FILE = "file"


class CreateInputSystemByPackInputFileMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Choose how to discover files to monitor"""

    # Manual
    MANUAL = "manual"
    # Auto
    AUTO = "auto"


class CreateInputSystemByPackInputFileTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackInputFileType
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    mode: NotRequired[CreateInputSystemByPackInputFileMode]
    r"""Choose how to discover files to monitor"""
    interval: NotRequired[float]
    r"""Time, in seconds, between scanning for files"""
    filenames: NotRequired[List[str]]
    r"""The full path of discovered files are matched against this wildcard list"""
    filter_archived_files: NotRequired[bool]
    r"""Apply filename allowlist to file entries in archive file types, like tar or zip."""
    tail_only: NotRequired[bool]
    r"""Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head."""
    idle_timeout: NotRequired[float]
    r"""Time, in seconds, before an idle file is closed"""
    min_age_dur: NotRequired[str]
    r"""The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters."""
    max_age_dur: NotRequired[str]
    r"""The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with \"Check file modification times\". Leave empty to apply no age filters."""
    check_file_mod_time: NotRequired[bool]
    r"""Skip files with modification times earlier than the maximum age duration"""
    force_text: NotRequired[bool]
    r"""Forces files containing binary data to be streamed as text"""
    hash_len: NotRequired[float]
    r"""Length of file header bytes to use in hash for unique file identification"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    description: NotRequired[str]
    path: NotRequired[str]
    r"""Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/."""
    depth: NotRequired[float]
    r"""Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth."""
    suppress_missing_path_errors: NotRequired[bool]
    delete_files: NotRequired[bool]
    r"""Delete files after they have been collected"""
    salt_hash: NotRequired[bool]
    r"""Salt the file hash with the Source file path. Ensures that all files with the same header hash, such as CSV files, are ingested. Moving or renaming the file, or toggling this after starting the Source will cause re-ingestion."""
    include_unidentifiable_binary: NotRequired[bool]
    r"""Stream binary files as Base64-encoded chunks."""


class CreateInputSystemByPackInputFile(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackInputFileType

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    mode: Optional[CreateInputSystemByPackInputFileMode] = None
    r"""Choose how to discover files to monitor"""

    interval: Optional[float] = None
    r"""Time, in seconds, between scanning for files"""

    filenames: Optional[List[str]] = None
    r"""The full path of discovered files are matched against this wildcard list"""

    filter_archived_files: Annotated[
        Optional[bool], pydantic.Field(alias="filterArchivedFiles")
    ] = None
    r"""Apply filename allowlist to file entries in archive file types, like tar or zip."""

    tail_only: Annotated[Optional[bool], pydantic.Field(alias="tailOnly")] = None
    r"""Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head."""

    idle_timeout: Annotated[Optional[float], pydantic.Field(alias="idleTimeout")] = None
    r"""Time, in seconds, before an idle file is closed"""

    min_age_dur: Annotated[Optional[str], pydantic.Field(alias="minAgeDur")] = None
    r"""The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters."""

    max_age_dur: Annotated[Optional[str], pydantic.Field(alias="maxAgeDur")] = None
    r"""The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with \"Check file modification times\". Leave empty to apply no age filters."""

    check_file_mod_time: Annotated[
        Optional[bool], pydantic.Field(alias="checkFileModTime")
    ] = None
    r"""Skip files with modification times earlier than the maximum age duration"""

    force_text: Annotated[Optional[bool], pydantic.Field(alias="forceText")] = None
    r"""Forces files containing binary data to be streamed as text"""

    hash_len: Annotated[Optional[float], pydantic.Field(alias="hashLen")] = None
    r"""Length of file header bytes to use in hash for unique file identification"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    description: Optional[str] = None

    path: Optional[str] = None
    r"""Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/."""

    depth: Optional[float] = None
    r"""Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth."""

    suppress_missing_path_errors: Annotated[
        Optional[bool], pydantic.Field(alias="suppressMissingPathErrors")
    ] = None

    delete_files: Annotated[Optional[bool], pydantic.Field(alias="deleteFiles")] = None
    r"""Delete files after they have been collected"""

    salt_hash: Annotated[Optional[bool], pydantic.Field(alias="saltHash")] = None
    r"""Salt the file hash with the Source file path. Ensures that all files with the same header hash, such as CSV files, are ingested. Moving or renaming the file, or toggling this after starting the Source will cause re-ingestion."""

    include_unidentifiable_binary: Annotated[
        Optional[bool], pydantic.Field(alias="includeUnidentifiableBinary")
    ] = None
    r"""Stream binary files as Base64-encoded chunks."""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackInputFileMode(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "mode",
                "interval",
                "filenames",
                "filterArchivedFiles",
                "tailOnly",
                "idleTimeout",
                "minAgeDur",
                "maxAgeDur",
                "checkFileModTime",
                "forceText",
                "hashLen",
                "metadata",
                "breakerRulesets",
                "staleChannelFlushMs",
                "description",
                "path",
                "depth",
                "suppressMissingPathErrors",
                "deleteFiles",
                "saltHash",
                "includeUnidentifiableBinary",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputSyslogType2(str, Enum):
    SYSLOG = "syslog"


class CreateInputSystemByPackInputSyslogSyslog2TypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackInputSyslogType2
    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    tcp_port: float
    r"""Enter TCP port number to listen on. Not required if listening on UDP."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    udp_port: NotRequired[float]
    r"""Enter UDP port number to listen on. Not required if listening on TCP."""
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking. Only applies to UDP."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    timestamp_timezone: NotRequired[str]
    r"""Timezone to assign to timestamps without timezone info"""
    single_msg_udp_packets: NotRequired[bool]
    r"""Treat UDP packet data received as full syslog message"""
    enable_proxy_header: NotRequired[bool]
    r"""Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2"""
    keep_fields_list: NotRequired[List[str]]
    r"""Wildcard list of fields to keep from source data; * = ALL (default)"""
    octet_counting: NotRequired[bool]
    r"""Enable if incoming messages use octet counting per RFC 6587."""
    infer_framing: NotRequired[bool]
    r"""Enable if we should infer the syslog framing of the incoming messages."""
    strictly_infer_octet_counting: NotRequired[bool]
    r"""Enable if we should infer octet counting only if the messages comply with RFC 5424."""
    allow_non_standard_app_name: NotRequired[bool]
    r"""Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages."""
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited."""
    socket_idle_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""
    socket_ending_max_wait: NotRequired[float]
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""
    socket_max_lifespan: NotRequired[float]
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    enable_load_balancing: NotRequired[bool]
    r"""Load balance traffic across all Worker Processes"""
    description: NotRequired[str]
    enable_enhanced_proxy_header_parsing: NotRequired[bool]
    r"""When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise."""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_udp_port: NotRequired[str]
    r"""Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime."""
    template_tcp_port: NotRequired[str]
    r"""Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime."""


class CreateInputSystemByPackInputSyslogSyslog2(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackInputSyslogType2

    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    tcp_port: Annotated[float, pydantic.Field(alias="tcpPort")]
    r"""Enter TCP port number to listen on. Not required if listening on UDP."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    udp_port: Annotated[Optional[float], pydantic.Field(alias="udpPort")] = None
    r"""Enter UDP port number to listen on. Not required if listening on TCP."""

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = None
    r"""Maximum number of events to buffer when downstream is blocking. Only applies to UDP."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to send data"""

    timestamp_timezone: Annotated[
        Optional[str], pydantic.Field(alias="timestampTimezone")
    ] = None
    r"""Timezone to assign to timestamps without timezone info"""

    single_msg_udp_packets: Annotated[
        Optional[bool], pydantic.Field(alias="singleMsgUdpPackets")
    ] = None
    r"""Treat UDP packet data received as full syslog message"""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2"""

    keep_fields_list: Annotated[
        Optional[List[str]], pydantic.Field(alias="keepFieldsList")
    ] = None
    r"""Wildcard list of fields to keep from source data; * = ALL (default)"""

    octet_counting: Annotated[Optional[bool], pydantic.Field(alias="octetCounting")] = (
        None
    )
    r"""Enable if incoming messages use octet counting per RFC 6587."""

    infer_framing: Annotated[Optional[bool], pydantic.Field(alias="inferFraming")] = (
        None
    )
    r"""Enable if we should infer the syslog framing of the incoming messages."""

    strictly_infer_octet_counting: Annotated[
        Optional[bool], pydantic.Field(alias="strictlyInferOctetCounting")
    ] = None
    r"""Enable if we should infer octet counting only if the messages comply with RFC 5424."""

    allow_non_standard_app_name: Annotated[
        Optional[bool], pydantic.Field(alias="allowNonStandardAppName")
    ] = None
    r"""Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages."""

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited."""

    socket_idle_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketIdleTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""

    socket_ending_max_wait: Annotated[
        Optional[float], pydantic.Field(alias="socketEndingMaxWait")
    ] = None
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""

    socket_max_lifespan: Annotated[
        Optional[float], pydantic.Field(alias="socketMaxLifespan")
    ] = None
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""

    tls: Optional[TLSSettingsServerSideType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    enable_load_balancing: Annotated[
        Optional[bool], pydantic.Field(alias="enableLoadBalancing")
    ] = None
    r"""Load balance traffic across all Worker Processes"""

    description: Optional[str] = None

    enable_enhanced_proxy_header_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableEnhancedProxyHeaderParsing")
    ] = None
    r"""When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise."""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_udp_port: Annotated[
        Optional[str], pydantic.Field(alias="__template_udpPort")
    ] = None
    r"""Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime."""

    template_tcp_port: Annotated[
        Optional[str], pydantic.Field(alias="__template_tcpPort")
    ] = None
    r"""Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "udpPort",
                "maxBufferSize",
                "ipWhitelistRegex",
                "timestampTimezone",
                "singleMsgUdpPackets",
                "enableProxyHeader",
                "keepFieldsList",
                "octetCounting",
                "inferFraming",
                "strictlyInferOctetCounting",
                "allowNonStandardAppName",
                "maxActiveCxn",
                "socketIdleTimeout",
                "socketEndingMaxWait",
                "socketMaxLifespan",
                "tls",
                "metadata",
                "udpSocketRxBufSize",
                "enableLoadBalancing",
                "description",
                "enableEnhancedProxyHeaderParsing",
                "__template_host",
                "__template_udpPort",
                "__template_tcpPort",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputSyslogType1(str, Enum):
    SYSLOG = "syslog"


class CreateInputSystemByPackInputSyslogSyslog1TypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackInputSyslogType1
    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    udp_port: float
    r"""Enter UDP port number to listen on. Not required if listening on TCP."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tcp_port: NotRequired[float]
    r"""Enter TCP port number to listen on. Not required if listening on UDP."""
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking. Only applies to UDP."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    timestamp_timezone: NotRequired[str]
    r"""Timezone to assign to timestamps without timezone info"""
    single_msg_udp_packets: NotRequired[bool]
    r"""Treat UDP packet data received as full syslog message"""
    enable_proxy_header: NotRequired[bool]
    r"""Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2"""
    keep_fields_list: NotRequired[List[str]]
    r"""Wildcard list of fields to keep from source data; * = ALL (default)"""
    octet_counting: NotRequired[bool]
    r"""Enable if incoming messages use octet counting per RFC 6587."""
    infer_framing: NotRequired[bool]
    r"""Enable if we should infer the syslog framing of the incoming messages."""
    strictly_infer_octet_counting: NotRequired[bool]
    r"""Enable if we should infer octet counting only if the messages comply with RFC 5424."""
    allow_non_standard_app_name: NotRequired[bool]
    r"""Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages."""
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited."""
    socket_idle_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""
    socket_ending_max_wait: NotRequired[float]
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""
    socket_max_lifespan: NotRequired[float]
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    enable_load_balancing: NotRequired[bool]
    r"""Load balance traffic across all Worker Processes"""
    description: NotRequired[str]
    enable_enhanced_proxy_header_parsing: NotRequired[bool]
    r"""When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise."""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_udp_port: NotRequired[str]
    r"""Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime."""
    template_tcp_port: NotRequired[str]
    r"""Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime."""


class CreateInputSystemByPackInputSyslogSyslog1(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackInputSyslogType1

    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    udp_port: Annotated[float, pydantic.Field(alias="udpPort")]
    r"""Enter UDP port number to listen on. Not required if listening on TCP."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tcp_port: Annotated[Optional[float], pydantic.Field(alias="tcpPort")] = None
    r"""Enter TCP port number to listen on. Not required if listening on UDP."""

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = None
    r"""Maximum number of events to buffer when downstream is blocking. Only applies to UDP."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to send data"""

    timestamp_timezone: Annotated[
        Optional[str], pydantic.Field(alias="timestampTimezone")
    ] = None
    r"""Timezone to assign to timestamps without timezone info"""

    single_msg_udp_packets: Annotated[
        Optional[bool], pydantic.Field(alias="singleMsgUdpPackets")
    ] = None
    r"""Treat UDP packet data received as full syslog message"""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2"""

    keep_fields_list: Annotated[
        Optional[List[str]], pydantic.Field(alias="keepFieldsList")
    ] = None
    r"""Wildcard list of fields to keep from source data; * = ALL (default)"""

    octet_counting: Annotated[Optional[bool], pydantic.Field(alias="octetCounting")] = (
        None
    )
    r"""Enable if incoming messages use octet counting per RFC 6587."""

    infer_framing: Annotated[Optional[bool], pydantic.Field(alias="inferFraming")] = (
        None
    )
    r"""Enable if we should infer the syslog framing of the incoming messages."""

    strictly_infer_octet_counting: Annotated[
        Optional[bool], pydantic.Field(alias="strictlyInferOctetCounting")
    ] = None
    r"""Enable if we should infer octet counting only if the messages comply with RFC 5424."""

    allow_non_standard_app_name: Annotated[
        Optional[bool], pydantic.Field(alias="allowNonStandardAppName")
    ] = None
    r"""Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages."""

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited."""

    socket_idle_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketIdleTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""

    socket_ending_max_wait: Annotated[
        Optional[float], pydantic.Field(alias="socketEndingMaxWait")
    ] = None
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""

    socket_max_lifespan: Annotated[
        Optional[float], pydantic.Field(alias="socketMaxLifespan")
    ] = None
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""

    tls: Optional[TLSSettingsServerSideType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    enable_load_balancing: Annotated[
        Optional[bool], pydantic.Field(alias="enableLoadBalancing")
    ] = None
    r"""Load balance traffic across all Worker Processes"""

    description: Optional[str] = None

    enable_enhanced_proxy_header_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableEnhancedProxyHeaderParsing")
    ] = None
    r"""When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise."""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_udp_port: Annotated[
        Optional[str], pydantic.Field(alias="__template_udpPort")
    ] = None
    r"""Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime."""

    template_tcp_port: Annotated[
        Optional[str], pydantic.Field(alias="__template_tcpPort")
    ] = None
    r"""Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tcpPort",
                "maxBufferSize",
                "ipWhitelistRegex",
                "timestampTimezone",
                "singleMsgUdpPackets",
                "enableProxyHeader",
                "keepFieldsList",
                "octetCounting",
                "inferFraming",
                "strictlyInferOctetCounting",
                "allowNonStandardAppName",
                "maxActiveCxn",
                "socketIdleTimeout",
                "socketEndingMaxWait",
                "socketMaxLifespan",
                "tls",
                "metadata",
                "udpSocketRxBufSize",
                "enableLoadBalancing",
                "description",
                "enableEnhancedProxyHeaderParsing",
                "__template_host",
                "__template_udpPort",
                "__template_tcpPort",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateInputSystemByPackInputSyslogUnionTypedDict = TypeAliasType(
    "CreateInputSystemByPackInputSyslogUnionTypedDict",
    Union[
        CreateInputSystemByPackInputSyslogSyslog1TypedDict,
        CreateInputSystemByPackInputSyslogSyslog2TypedDict,
    ],
)


CreateInputSystemByPackInputSyslogUnion = TypeAliasType(
    "CreateInputSystemByPackInputSyslogUnion",
    Union[
        CreateInputSystemByPackInputSyslogSyslog1,
        CreateInputSystemByPackInputSyslogSyslog2,
    ],
)


class CreateInputSystemByPackTypeSqs(str, Enum):
    SQS = "sqs"


class CreateInputSystemByPackQueueType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The queue type used (or created)"""

    # Standard
    STANDARD = "standard"
    # FIFO
    FIFO = "fifo"


class CreateInputSystemByPackInputSqsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeSqs
    queue_name: str
    r"""The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""
    queue_type: CreateInputSystemByPackQueueType
    r"""The queue type used (or created)"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    aws_account_id: NotRequired[str]
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""
    create_queue: NotRequired[bool]
    r"""Create queue if it does not exist"""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    region: NotRequired[str]
    r"""AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region."""
    endpoint: NotRequired[str]
    r"""SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptions3]
    r"""Signature version to use for signing SQS requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access SQS"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    max_messages: NotRequired[float]
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""
    visibility_timeout: NotRequired[float]
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    poll_timeout: NotRequired[float]
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    num_receivers: NotRequired[float]
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""
    template_queue_name: NotRequired[str]
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""
    template_aws_account_id: NotRequired[str]
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""


class CreateInputSystemByPackInputSqs(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeSqs

    queue_name: Annotated[str, pydantic.Field(alias="queueName")]
    r"""The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""

    queue_type: Annotated[
        CreateInputSystemByPackQueueType, pydantic.Field(alias="queueType")
    ]
    r"""The queue type used (or created)"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    aws_account_id: Annotated[Optional[str], pydantic.Field(alias="awsAccountId")] = (
        None
    )
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""

    create_queue: Annotated[Optional[bool], pydantic.Field(alias="createQueue")] = None
    r"""Create queue if it does not exist"""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    region: Optional[str] = None
    r"""AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region."""

    endpoint: Optional[str] = None
    r"""SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptions3], pydantic.Field(alias="signatureVersion")
    ] = None
    r"""Signature version to use for signing SQS requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access SQS"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    max_messages: Annotated[Optional[float], pydantic.Field(alias="maxMessages")] = None
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""

    visibility_timeout: Annotated[
        Optional[float], pydantic.Field(alias="visibilityTimeout")
    ] = None
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    poll_timeout: Annotated[Optional[float], pydantic.Field(alias="pollTimeout")] = None
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    num_receivers: Annotated[Optional[float], pydantic.Field(alias="numReceivers")] = (
        None
    )
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""

    template_queue_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_queueName")
    ] = None
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""

    template_aws_account_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsAccountId")
    ] = None
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    @field_serializer("queue_type")
    def serialize_queue_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackQueueType(value)
            except ValueError:
                return value
        return value

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions3(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "awsAccountId",
                "createQueue",
                "awsAuthenticationMethod",
                "awsSecretKey",
                "region",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "maxMessages",
                "visibilityTimeout",
                "metadata",
                "pollTimeout",
                "description",
                "awsApiKey",
                "awsSecret",
                "numReceivers",
                "__template_queueName",
                "__template_awsAccountId",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
                "__template_awsApiKey",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeModelDrivenTelemetry(str, Enum):
    MODEL_DRIVEN_TELEMETRY = "model_driven_telemetry"


class CreateInputSystemByPackInputModelDrivenTelemetryTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeModelDrivenTelemetry
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""
    shutdown_timeout_ms: NotRequired[float]
    r"""Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000."""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputModelDrivenTelemetry(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeModelDrivenTelemetry

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""

    shutdown_timeout_ms: Annotated[
        Optional[float], pydantic.Field(alias="shutdownTimeoutMs")
    ] = None
    r"""Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000."""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "metadata",
                "maxActiveCxn",
                "shutdownTimeoutMs",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeOpenTelemetry(str, Enum):
    OPEN_TELEMETRY = "open_telemetry"


class CreateInputSystemByPackProtocol(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select whether to leverage gRPC or HTTP for OpenTelemetry"""

    # gRPC
    GRPC = "grpc"
    # HTTP
    HTTP = "http"


class CreateInputSystemByPackOTLPVersion(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The version of OTLP Protobuf definitions to use when interpreting received data"""

    # 0.10.0
    ZERO_DOT_10_DOT_0 = "0.10.0"
    # 1.3.1
    ONE_DOT_3_DOT_1 = "1.3.1"


class CreateInputSystemByPackInputOpenTelemetryTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeOpenTelemetry
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[Any]
    capture_headers: NotRequired[Any]
    activity_log_sample_rate: NotRequired[Any]
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.)."""
    enable_health_check: NotRequired[bool]
    r"""Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist."""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    protocol: NotRequired[CreateInputSystemByPackProtocol]
    r"""Select whether to leverage gRPC or HTTP for OpenTelemetry"""
    extract_spans: NotRequired[bool]
    r"""Enable to extract each incoming span to a separate event"""
    extract_metrics: NotRequired[bool]
    r"""Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point"""
    otlp_version: NotRequired[CreateInputSystemByPackOTLPVersion]
    r"""The version of OTLP Protobuf definitions to use when interpreting received data"""
    auth_type: NotRequired[AuthenticationTypeOptions]
    r"""OpenTelemetry authentication type"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""
    description: NotRequired[str]
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    r"""Bearer token to include in the authorization header"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    extract_logs: NotRequired[bool]
    r"""Enable to extract each incoming log record to a separate event"""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputOpenTelemetry(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeOpenTelemetry

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[Any], pydantic.Field(alias="enableProxyHeader")
    ] = None

    capture_headers: Annotated[
        Optional[Any], pydantic.Field(alias="captureHeaders")
    ] = None

    activity_log_sample_rate: Annotated[
        Optional[Any], pydantic.Field(alias="activityLogSampleRate")
    ] = None

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist."""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    protocol: Optional[CreateInputSystemByPackProtocol] = None
    r"""Select whether to leverage gRPC or HTTP for OpenTelemetry"""

    extract_spans: Annotated[Optional[bool], pydantic.Field(alias="extractSpans")] = (
        None
    )
    r"""Enable to extract each incoming span to a separate event"""

    extract_metrics: Annotated[
        Optional[bool], pydantic.Field(alias="extractMetrics")
    ] = None
    r"""Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point"""

    otlp_version: Annotated[
        Optional[CreateInputSystemByPackOTLPVersion],
        pydantic.Field(alias="otlpVersion"),
    ] = None
    r"""The version of OTLP Protobuf definitions to use when interpreting received data"""

    auth_type: Annotated[
        Optional[AuthenticationTypeOptions], pydantic.Field(alias="authType")
    ] = None
    r"""OpenTelemetry authentication type"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""

    description: Optional[str] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None
    r"""Bearer token to include in the authorization header"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    extract_logs: Annotated[Optional[bool], pydantic.Field(alias="extractLogs")] = None
    r"""Enable to extract each incoming log record to a separate event"""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @field_serializer("protocol")
    def serialize_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackProtocol(value)
            except ValueError:
                return value
        return value

    @field_serializer("otlp_version")
    def serialize_otlp_version(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackOTLPVersion(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationTypeOptions(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "protocol",
                "extractSpans",
                "extractMetrics",
                "otlpVersion",
                "authType",
                "metadata",
                "maxActiveCxn",
                "description",
                "username",
                "password",
                "token",
                "credentialsSecret",
                "textSecret",
                "extractLogs",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeSnmp(str, Enum):
    SNMP = "snmp"


class CreateInputSystemByPackPrivacyProtocol(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # DES
    DES = "des"
    # AES128
    AES = "aes"
    # AES256b (Blumenthal)
    AES256B = "aes256b"
    # AES256r (Reeder)
    AES256R = "aes256r"


class CreateInputSystemByPackV3UserTypedDict(TypedDict):
    name: str
    auth_protocol: NotRequired[AuthenticationProtocolOptionsV3User]
    auth_key: NotRequired[str]
    priv_protocol: NotRequired[CreateInputSystemByPackPrivacyProtocol]
    priv_key: NotRequired[str]


class CreateInputSystemByPackV3User(BaseModel):
    name: str

    auth_protocol: Annotated[
        Optional[AuthenticationProtocolOptionsV3User],
        pydantic.Field(alias="authProtocol"),
    ] = None

    auth_key: Annotated[Optional[str], pydantic.Field(alias="authKey")] = None

    priv_protocol: Annotated[
        Optional[CreateInputSystemByPackPrivacyProtocol],
        pydantic.Field(alias="privProtocol"),
    ] = None

    priv_key: Annotated[Optional[str], pydantic.Field(alias="privKey")] = None

    @field_serializer("auth_protocol")
    def serialize_auth_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationProtocolOptionsV3User(value)
            except ValueError:
                return value
        return value

    @field_serializer("priv_protocol")
    def serialize_priv_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackPrivacyProtocol(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["authProtocol", "authKey", "privProtocol", "privKey"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackSNMPv3AuthenticationTypedDict(TypedDict):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: bool
    allow_unmatched_trap: NotRequired[bool]
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""
    v3_users: NotRequired[List[CreateInputSystemByPackV3UserTypedDict]]
    r"""User credentials for receiving v3 traps"""


class CreateInputSystemByPackSNMPv3Authentication(BaseModel):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: Annotated[bool, pydantic.Field(alias="v3AuthEnabled")]

    allow_unmatched_trap: Annotated[
        Optional[bool], pydantic.Field(alias="allowUnmatchedTrap")
    ] = None
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""

    v3_users: Annotated[
        Optional[List[CreateInputSystemByPackV3User]], pydantic.Field(alias="v3Users")
    ] = None
    r"""User credentials for receiving v3 traps"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["allowUnmatchedTrap", "v3Users"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputSnmpTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeSnmp
    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    port: float
    r"""UDP port to receive SNMP traps on. Defaults to 162."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    snmp_v3_auth: NotRequired[CreateInputSystemByPackSNMPv3AuthenticationTypedDict]
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    varbinds_with_types: NotRequired[bool]
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""
    best_effort_parsing: NotRequired[bool]
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputSnmp(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeSnmp

    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    port: float
    r"""UDP port to receive SNMP traps on. Defaults to 162."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    snmp_v3_auth: Annotated[
        Optional[CreateInputSystemByPackSNMPv3Authentication],
        pydantic.Field(alias="snmpV3Auth"),
    ] = None
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = None
    r"""Maximum number of events to buffer when downstream is blocking."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to send data"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    varbinds_with_types: Annotated[
        Optional[bool], pydantic.Field(alias="varbindsWithTypes")
    ] = None
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""

    best_effort_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="bestEffortParsing")
    ] = None
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "snmpV3Auth",
                "maxBufferSize",
                "ipWhitelistRegex",
                "metadata",
                "udpSocketRxBufSize",
                "varbindsWithTypes",
                "bestEffortParsing",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeS3Inventory(str, Enum):
    S3_INVENTORY = "s3_inventory"


class CreateInputSystemByPackInputS3InventoryTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeS3Inventory
    queue_name: str
    r"""The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    file_filter: NotRequired[str]
    r"""Regex matching file names to download and process. Defaults to: .*"""
    aws_account_id: NotRequired[str]
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    region: NotRequired[str]
    r"""AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region."""
    endpoint: NotRequired[str]
    r"""S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptionsS3CollectorConf]
    r"""Signature version to use for signing S3 requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    max_messages: NotRequired[float]
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""
    visibility_timeout: NotRequired[float]
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""
    num_receivers: NotRequired[float]
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""
    socket_timeout: NotRequired[float]
    r"""Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure."""
    skip_on_error: NotRequired[bool]
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""
    include_sqs_metadata: NotRequired[bool]
    r"""Attach SQS notification metadata to a __sqsMetadata field on each event"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access Amazon S3"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    enable_sqs_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials when accessing Amazon SQS"""
    preprocess: NotRequired[PreprocessTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    parquet_chunk_size_mb: NotRequired[float]
    r"""Maximum file size for each Parquet chunk"""
    parquet_chunk_download_timeout: NotRequired[float]
    r"""The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified."""
    checkpointing: NotRequired[CheckpointingTypeTypedDict]
    poll_timeout: NotRequired[float]
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""
    checksum_suffix: NotRequired[str]
    r"""Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to \"checksum\" """
    max_manifest_size_kb: NotRequired[int]
    r"""Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096."""
    validate_inventory_files: NotRequired[bool]
    r"""If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false"""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    tag_after_processing: NotRequired[TagAfterProcessingOptions]
    processed_tag_key: NotRequired[str]
    r"""The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""
    processed_tag_value: NotRequired[str]
    r"""The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""
    template_queue_name: NotRequired[str]
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""
    template_aws_account_id: NotRequired[str]
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""


class CreateInputSystemByPackInputS3Inventory(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeS3Inventory

    queue_name: Annotated[str, pydantic.Field(alias="queueName")]
    r"""The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    file_filter: Annotated[Optional[str], pydantic.Field(alias="fileFilter")] = None
    r"""Regex matching file names to download and process. Defaults to: .*"""

    aws_account_id: Annotated[Optional[str], pydantic.Field(alias="awsAccountId")] = (
        None
    )
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    region: Optional[str] = None
    r"""AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region."""

    endpoint: Optional[str] = None
    r"""S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptionsS3CollectorConf],
        pydantic.Field(alias="signatureVersion"),
    ] = None
    r"""Signature version to use for signing S3 requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    max_messages: Annotated[Optional[float], pydantic.Field(alias="maxMessages")] = None
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""

    visibility_timeout: Annotated[
        Optional[float], pydantic.Field(alias="visibilityTimeout")
    ] = None
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""

    num_receivers: Annotated[Optional[float], pydantic.Field(alias="numReceivers")] = (
        None
    )
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure."""

    skip_on_error: Annotated[Optional[bool], pydantic.Field(alias="skipOnError")] = None
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""

    include_sqs_metadata: Annotated[
        Optional[bool], pydantic.Field(alias="includeSqsMetadata")
    ] = None
    r"""Attach SQS notification metadata to a __sqsMetadata field on each event"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access Amazon S3"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    enable_sqs_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableSQSAssumeRole")
    ] = None
    r"""Use Assume Role credentials when accessing Amazon SQS"""

    preprocess: Optional[PreprocessType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    parquet_chunk_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="parquetChunkSizeMB")
    ] = None
    r"""Maximum file size for each Parquet chunk"""

    parquet_chunk_download_timeout: Annotated[
        Optional[float], pydantic.Field(alias="parquetChunkDownloadTimeout")
    ] = None
    r"""The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified."""

    checkpointing: Optional[CheckpointingType] = None

    poll_timeout: Annotated[Optional[float], pydantic.Field(alias="pollTimeout")] = None
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""

    checksum_suffix: Annotated[
        Optional[str], pydantic.Field(alias="checksumSuffix")
    ] = None
    r"""Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to \"checksum\" """

    max_manifest_size_kb: Annotated[
        Optional[int], pydantic.Field(alias="maxManifestSizeKB")
    ] = None
    r"""Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096."""

    validate_inventory_files: Annotated[
        Optional[bool], pydantic.Field(alias="validateInventoryFiles")
    ] = None
    r"""If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false"""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    tag_after_processing: Annotated[
        Optional[TagAfterProcessingOptions], pydantic.Field(alias="tagAfterProcessing")
    ] = None

    processed_tag_key: Annotated[
        Optional[str], pydantic.Field(alias="processedTagKey")
    ] = None
    r"""The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""

    processed_tag_value: Annotated[
        Optional[str], pydantic.Field(alias="processedTagValue")
    ] = None
    r"""The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""

    template_queue_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_queueName")
    ] = None
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""

    template_aws_account_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsAccountId")
    ] = None
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("tag_after_processing")
    def serialize_tag_after_processing(self, value):
        if isinstance(value, str):
            try:
                return models.TagAfterProcessingOptions(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "fileFilter",
                "awsAccountId",
                "awsAuthenticationMethod",
                "awsSecretKey",
                "region",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "breakerRulesets",
                "staleChannelFlushMs",
                "maxMessages",
                "visibilityTimeout",
                "numReceivers",
                "socketTimeout",
                "skipOnError",
                "includeSqsMetadata",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "enableSQSAssumeRole",
                "preprocess",
                "metadata",
                "parquetChunkSizeMB",
                "parquetChunkDownloadTimeout",
                "checkpointing",
                "pollTimeout",
                "checksumSuffix",
                "maxManifestSizeKB",
                "validateInventoryFiles",
                "description",
                "awsApiKey",
                "awsSecret",
                "tagAfterProcessing",
                "processedTagKey",
                "processedTagValue",
                "__template_queueName",
                "__template_awsAccountId",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
                "__template_awsApiKey",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeS3(str, Enum):
    S3 = "s3"


class CreateInputSystemByPackInputS3TypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeS3
    queue_name: str
    r"""The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    file_filter: NotRequired[str]
    r"""Regex matching file names to download and process. Defaults to: .*"""
    aws_account_id: NotRequired[str]
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    region: NotRequired[str]
    r"""AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region."""
    endpoint: NotRequired[str]
    r"""S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptionsS3CollectorConf]
    r"""Signature version to use for signing S3 requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    max_messages: NotRequired[float]
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""
    visibility_timeout: NotRequired[float]
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""
    num_receivers: NotRequired[float]
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""
    socket_timeout: NotRequired[float]
    r"""Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure."""
    skip_on_error: NotRequired[bool]
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""
    include_sqs_metadata: NotRequired[bool]
    r"""Attach SQS notification metadata to a __sqsMetadata field on each event"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access Amazon S3"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    enable_sqs_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials when accessing Amazon SQS"""
    preprocess: NotRequired[PreprocessTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    parquet_chunk_size_mb: NotRequired[float]
    r"""Maximum file size for each Parquet chunk"""
    parquet_chunk_download_timeout: NotRequired[float]
    r"""The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified."""
    checkpointing: NotRequired[CheckpointingTypeTypedDict]
    poll_timeout: NotRequired[float]
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""
    encoding: NotRequired[str]
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""
    tag_after_processing: NotRequired[bool]
    r"""Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    processed_tag_key: NotRequired[str]
    r"""The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""
    processed_tag_value: NotRequired[str]
    r"""The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""
    template_queue_name: NotRequired[str]
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""
    template_aws_account_id: NotRequired[str]
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""


class CreateInputSystemByPackInputS3(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeS3

    queue_name: Annotated[str, pydantic.Field(alias="queueName")]
    r"""The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    file_filter: Annotated[Optional[str], pydantic.Field(alias="fileFilter")] = None
    r"""Regex matching file names to download and process. Defaults to: .*"""

    aws_account_id: Annotated[Optional[str], pydantic.Field(alias="awsAccountId")] = (
        None
    )
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    region: Optional[str] = None
    r"""AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region."""

    endpoint: Optional[str] = None
    r"""S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptionsS3CollectorConf],
        pydantic.Field(alias="signatureVersion"),
    ] = None
    r"""Signature version to use for signing S3 requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    max_messages: Annotated[Optional[float], pydantic.Field(alias="maxMessages")] = None
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""

    visibility_timeout: Annotated[
        Optional[float], pydantic.Field(alias="visibilityTimeout")
    ] = None
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""

    num_receivers: Annotated[Optional[float], pydantic.Field(alias="numReceivers")] = (
        None
    )
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure."""

    skip_on_error: Annotated[Optional[bool], pydantic.Field(alias="skipOnError")] = None
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""

    include_sqs_metadata: Annotated[
        Optional[bool], pydantic.Field(alias="includeSqsMetadata")
    ] = None
    r"""Attach SQS notification metadata to a __sqsMetadata field on each event"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access Amazon S3"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    enable_sqs_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableSQSAssumeRole")
    ] = None
    r"""Use Assume Role credentials when accessing Amazon SQS"""

    preprocess: Optional[PreprocessType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    parquet_chunk_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="parquetChunkSizeMB")
    ] = None
    r"""Maximum file size for each Parquet chunk"""

    parquet_chunk_download_timeout: Annotated[
        Optional[float], pydantic.Field(alias="parquetChunkDownloadTimeout")
    ] = None
    r"""The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified."""

    checkpointing: Optional[CheckpointingType] = None

    poll_timeout: Annotated[Optional[float], pydantic.Field(alias="pollTimeout")] = None
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""

    encoding: Optional[str] = None
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""

    tag_after_processing: Annotated[
        Optional[bool], pydantic.Field(alias="tagAfterProcessing")
    ] = None
    r"""Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    processed_tag_key: Annotated[
        Optional[str], pydantic.Field(alias="processedTagKey")
    ] = None
    r"""The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""

    processed_tag_value: Annotated[
        Optional[str], pydantic.Field(alias="processedTagValue")
    ] = None
    r"""The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""

    template_queue_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_queueName")
    ] = None
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""

    template_aws_account_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsAccountId")
    ] = None
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "fileFilter",
                "awsAccountId",
                "awsAuthenticationMethod",
                "awsSecretKey",
                "region",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "breakerRulesets",
                "staleChannelFlushMs",
                "maxMessages",
                "visibilityTimeout",
                "numReceivers",
                "socketTimeout",
                "skipOnError",
                "includeSqsMetadata",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "enableSQSAssumeRole",
                "preprocess",
                "metadata",
                "parquetChunkSizeMB",
                "parquetChunkDownloadTimeout",
                "checkpointing",
                "pollTimeout",
                "encoding",
                "tagAfterProcessing",
                "description",
                "awsApiKey",
                "awsSecret",
                "processedTagKey",
                "processedTagValue",
                "__template_queueName",
                "__template_awsAccountId",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
                "__template_awsApiKey",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeMetrics(str, Enum):
    METRICS = "metrics"


class CreateInputSystemByPackInputMetricsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeMetrics
    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    udp_port: NotRequired[float]
    r"""Enter UDP port number to listen on. Not required if listening on TCP."""
    tcp_port: NotRequired[float]
    r"""Enter TCP port number to listen on. Not required if listening on UDP."""
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking. Only applies to UDP."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    enable_proxy_header: NotRequired[bool]
    r"""Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2"""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_udp_port: NotRequired[str]
    r"""Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime."""
    template_tcp_port: NotRequired[str]
    r"""Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime."""


class CreateInputSystemByPackInputMetrics(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeMetrics

    host: str
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    udp_port: Annotated[Optional[float], pydantic.Field(alias="udpPort")] = None
    r"""Enter UDP port number to listen on. Not required if listening on TCP."""

    tcp_port: Annotated[Optional[float], pydantic.Field(alias="tcpPort")] = None
    r"""Enter TCP port number to listen on. Not required if listening on UDP."""

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = None
    r"""Maximum number of events to buffer when downstream is blocking. Only applies to UDP."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to send data"""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2"""

    tls: Optional[TLSSettingsServerSideType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_udp_port: Annotated[
        Optional[str], pydantic.Field(alias="__template_udpPort")
    ] = None
    r"""Binds 'udpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'udpPort' at runtime."""

    template_tcp_port: Annotated[
        Optional[str], pydantic.Field(alias="__template_tcpPort")
    ] = None
    r"""Binds 'tcpPort' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tcpPort' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "udpPort",
                "tcpPort",
                "maxBufferSize",
                "ipWhitelistRegex",
                "enableProxyHeader",
                "tls",
                "metadata",
                "udpSocketRxBufSize",
                "description",
                "__template_host",
                "__template_udpPort",
                "__template_tcpPort",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeCriblmetrics(str, Enum):
    CRIBLMETRICS = "criblmetrics"


class CreateInputSystemByPackInputCriblmetricsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeCriblmetrics
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    prefix: NotRequired[str]
    r"""A prefix that is applied to the metrics provided by Cribl Stream"""
    full_fidelity: NotRequired[bool]
    r"""Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]


class CreateInputSystemByPackInputCriblmetrics(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeCriblmetrics

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    prefix: Optional[str] = None
    r"""A prefix that is applied to the metrics provided by Cribl Stream"""

    full_fidelity: Annotated[Optional[bool], pydantic.Field(alias="fullFidelity")] = (
        None
    )
    r"""Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "prefix",
                "fullFidelity",
                "metadata",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeKinesis(str, Enum):
    KINESIS = "kinesis"


class CreateInputSystemByPackShardIteratorStart(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Location at which to start reading a shard for the first time"""

    # Earliest record
    TRIM_HORIZON = "TRIM_HORIZON"
    # Latest record
    LATEST = "LATEST"


class CreateInputSystemByPackRecordDataFormat(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of data inside the Kinesis Stream records. Gzip compression is automatically detected."""

    # Cribl
    CRIBL = "cribl"
    # Newline JSON
    NDJSON = "ndjson"
    # Cloudwatch Logs
    CLOUDWATCH = "cloudwatch"
    # Event per line
    LINE = "line"


class CreateInputSystemByPackShardLoadBalancing(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes"""

    # Consistent Hashing
    CONSISTENT_HASHING = "ConsistentHashing"
    # Round Robin
    ROUND_ROBIN = "RoundRobin"


class CreateInputSystemByPackInputKinesisTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeKinesis
    stream_name: str
    r"""Kinesis Data Stream to read data from"""
    region: str
    r"""Region where the Kinesis stream is located"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    service_interval: NotRequired[float]
    r"""Time interval in minutes between consecutive service calls"""
    shard_expr: NotRequired[str]
    r"""A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed."""
    shard_iterator_type: NotRequired[CreateInputSystemByPackShardIteratorStart]
    r"""Location at which to start reading a shard for the first time"""
    payload_format: NotRequired[CreateInputSystemByPackRecordDataFormat]
    r"""Format of data inside the Kinesis Stream records. Gzip compression is automatically detected."""
    get_records_limit: NotRequired[float]
    r"""Maximum number of records per getRecords call"""
    get_records_limit_total: NotRequired[float]
    r"""Maximum number of records, across all shards, to pull down at once per Worker Process"""
    load_balancing_algorithm: NotRequired[CreateInputSystemByPackShardLoadBalancing]
    r"""The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes"""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    endpoint: NotRequired[str]
    r"""Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptions2]
    r"""Signature version to use for signing Kinesis stream requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access Kinesis stream"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    verify_kpl_check_sums: NotRequired[bool]
    r"""Verify Kinesis Producer Library (KPL) event checksums"""
    avoid_duplicates: NotRequired[bool]
    r"""When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    template_stream_name: NotRequired[str]
    r"""Binds 'streamName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'streamName' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""


class CreateInputSystemByPackInputKinesis(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeKinesis

    stream_name: Annotated[str, pydantic.Field(alias="streamName")]
    r"""Kinesis Data Stream to read data from"""

    region: str
    r"""Region where the Kinesis stream is located"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    service_interval: Annotated[
        Optional[float], pydantic.Field(alias="serviceInterval")
    ] = None
    r"""Time interval in minutes between consecutive service calls"""

    shard_expr: Annotated[Optional[str], pydantic.Field(alias="shardExpr")] = None
    r"""A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed."""

    shard_iterator_type: Annotated[
        Optional[CreateInputSystemByPackShardIteratorStart],
        pydantic.Field(alias="shardIteratorType"),
    ] = None
    r"""Location at which to start reading a shard for the first time"""

    payload_format: Annotated[
        Optional[CreateInputSystemByPackRecordDataFormat],
        pydantic.Field(alias="payloadFormat"),
    ] = None
    r"""Format of data inside the Kinesis Stream records. Gzip compression is automatically detected."""

    get_records_limit: Annotated[
        Optional[float], pydantic.Field(alias="getRecordsLimit")
    ] = None
    r"""Maximum number of records per getRecords call"""

    get_records_limit_total: Annotated[
        Optional[float], pydantic.Field(alias="getRecordsLimitTotal")
    ] = None
    r"""Maximum number of records, across all shards, to pull down at once per Worker Process"""

    load_balancing_algorithm: Annotated[
        Optional[CreateInputSystemByPackShardLoadBalancing],
        pydantic.Field(alias="loadBalancingAlgorithm"),
    ] = None
    r"""The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes"""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    endpoint: Optional[str] = None
    r"""Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptions2], pydantic.Field(alias="signatureVersion")
    ] = None
    r"""Signature version to use for signing Kinesis stream requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access Kinesis stream"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    verify_kpl_check_sums: Annotated[
        Optional[bool], pydantic.Field(alias="verifyKPLCheckSums")
    ] = None
    r"""Verify Kinesis Producer Library (KPL) event checksums"""

    avoid_duplicates: Annotated[
        Optional[bool], pydantic.Field(alias="avoidDuplicates")
    ] = None
    r"""When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    template_stream_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_streamName")
    ] = None
    r"""Binds 'streamName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'streamName' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    @field_serializer("shard_iterator_type")
    def serialize_shard_iterator_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackShardIteratorStart(value)
            except ValueError:
                return value
        return value

    @field_serializer("payload_format")
    def serialize_payload_format(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackRecordDataFormat(value)
            except ValueError:
                return value
        return value

    @field_serializer("load_balancing_algorithm")
    def serialize_load_balancing_algorithm(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackShardLoadBalancing(value)
            except ValueError:
                return value
        return value

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions2(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "serviceInterval",
                "shardExpr",
                "shardIteratorType",
                "payloadFormat",
                "getRecordsLimit",
                "getRecordsLimitTotal",
                "loadBalancingAlgorithm",
                "awsAuthenticationMethod",
                "awsSecretKey",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "verifyKPLCheckSums",
                "avoidDuplicates",
                "metadata",
                "description",
                "awsApiKey",
                "awsSecret",
                "__template_streamName",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
                "__template_awsApiKey",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeHTTPRaw(str, Enum):
    HTTP_RAW = "http_raw"


class CreateInputSystemByPackInputHTTPRawTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeHTTPRaw
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[List[str]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    allowed_paths: NotRequired[List[str]]
    r"""List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all."""
    allowed_methods: NotRequired[List[str]]
    r"""List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all."""
    auth_tokens_ext: NotRequired[List[ItemsTypeAuthTokensExtTypedDict]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputHTTPRaw(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeHTTPRaw

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[Optional[List[str]], pydantic.Field(alias="authTokens")] = (
        None
    )
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    allowed_paths: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedPaths")
    ] = None
    r"""List of URI paths accepted by this input, wildcards are supported, e.g /api/v*/hook. Defaults to allow all."""

    allowed_methods: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedMethods")
    ] = None
    r"""List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all."""

    auth_tokens_ext: Annotated[
        Optional[List[ItemsTypeAuthTokensExt]], pydantic.Field(alias="authTokensExt")
    ] = None
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "breakerRulesets",
                "staleChannelFlushMs",
                "metadata",
                "allowedPaths",
                "allowedMethods",
                "authTokensExt",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeDatagen(str, Enum):
    DATAGEN = "datagen"


class CreateInputSystemByPackSampleTypedDict(TypedDict):
    sample: str
    events_per_sec: float
    r"""Maximum number of events to generate per second per Worker Node. Defaults to 10."""


class CreateInputSystemByPackSample(BaseModel):
    sample: str

    events_per_sec: Annotated[float, pydantic.Field(alias="eventsPerSec")]
    r"""Maximum number of events to generate per second per Worker Node. Defaults to 10."""


class CreateInputSystemByPackInputDatagenTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeDatagen
    samples: List[CreateInputSystemByPackSampleTypedDict]
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]


class CreateInputSystemByPackInputDatagen(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeDatagen

    samples: List[CreateInputSystemByPackSample]

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "metadata",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeDatadogAgent(str, Enum):
    DATADOG_AGENT = "datadog_agent"


class CreateInputSystemByPackProxyModeDatadogAgentTypedDict(TypedDict):
    enabled: bool
    r"""Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid."""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""


class CreateInputSystemByPackProxyModeDatadogAgent(BaseModel):
    enabled: bool
    r"""Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid."""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["rejectUnauthorized"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputDatadogAgentTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeDatadogAgent
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    extract_metrics: NotRequired[bool]
    r"""Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default)."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    proxy_mode: NotRequired[CreateInputSystemByPackProxyModeDatadogAgentTypedDict]
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputDatadogAgent(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeDatadogAgent

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    extract_metrics: Annotated[
        Optional[bool], pydantic.Field(alias="extractMetrics")
    ] = None
    r"""Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default)."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    proxy_mode: Annotated[
        Optional[CreateInputSystemByPackProxyModeDatadogAgent],
        pydantic.Field(alias="proxyMode"),
    ] = None

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "extractMetrics",
                "metadata",
                "proxyMode",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeCrowdstrike(str, Enum):
    CROWDSTRIKE = "crowdstrike"


class CreateInputSystemByPackInputCrowdstrikeTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeCrowdstrike
    queue_name: str
    r"""The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    file_filter: NotRequired[str]
    r"""Regex matching file names to download and process. Defaults to: .*"""
    aws_account_id: NotRequired[str]
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    region: NotRequired[str]
    r"""AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region."""
    endpoint: NotRequired[str]
    r"""S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptionsS3CollectorConf]
    r"""Signature version to use for signing S3 requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    max_messages: NotRequired[float]
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""
    visibility_timeout: NotRequired[float]
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""
    num_receivers: NotRequired[float]
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""
    socket_timeout: NotRequired[float]
    r"""Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure."""
    skip_on_error: NotRequired[bool]
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""
    include_sqs_metadata: NotRequired[bool]
    r"""Attach SQS notification metadata to a __sqsMetadata field on each event"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access Amazon S3"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    enable_sqs_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials when accessing Amazon SQS"""
    preprocess: NotRequired[PreprocessTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    checkpointing: NotRequired[CheckpointingTypeTypedDict]
    poll_timeout: NotRequired[float]
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""
    encoding: NotRequired[str]
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    tag_after_processing: NotRequired[TagAfterProcessingOptions]
    processed_tag_key: NotRequired[str]
    r"""The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""
    processed_tag_value: NotRequired[str]
    r"""The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""
    template_queue_name: NotRequired[str]
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""
    template_aws_account_id: NotRequired[str]
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""


class CreateInputSystemByPackInputCrowdstrike(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeCrowdstrike

    queue_name: Annotated[str, pydantic.Field(alias="queueName")]
    r"""The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    file_filter: Annotated[Optional[str], pydantic.Field(alias="fileFilter")] = None
    r"""Regex matching file names to download and process. Defaults to: .*"""

    aws_account_id: Annotated[Optional[str], pydantic.Field(alias="awsAccountId")] = (
        None
    )
    r"""SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account."""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    region: Optional[str] = None
    r"""AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region."""

    endpoint: Optional[str] = None
    r"""S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptionsS3CollectorConf],
        pydantic.Field(alias="signatureVersion"),
    ] = None
    r"""Signature version to use for signing S3 requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    max_messages: Annotated[Optional[float], pydantic.Field(alias="maxMessages")] = None
    r"""The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10."""

    visibility_timeout: Annotated[
        Optional[float], pydantic.Field(alias="visibilityTimeout")
    ] = None
    r"""After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours)."""

    num_receivers: Annotated[Optional[float], pydantic.Field(alias="numReceivers")] = (
        None
    )
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure."""

    skip_on_error: Annotated[Optional[bool], pydantic.Field(alias="skipOnError")] = None
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""

    include_sqs_metadata: Annotated[
        Optional[bool], pydantic.Field(alias="includeSqsMetadata")
    ] = None
    r"""Attach SQS notification metadata to a __sqsMetadata field on each event"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access Amazon S3"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    enable_sqs_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableSQSAssumeRole")
    ] = None
    r"""Use Assume Role credentials when accessing Amazon SQS"""

    preprocess: Optional[PreprocessType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    checkpointing: Optional[CheckpointingType] = None

    poll_timeout: Annotated[Optional[float], pydantic.Field(alias="pollTimeout")] = None
    r"""How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts."""

    encoding: Optional[str] = None
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    tag_after_processing: Annotated[
        Optional[TagAfterProcessingOptions], pydantic.Field(alias="tagAfterProcessing")
    ] = None

    processed_tag_key: Annotated[
        Optional[str], pydantic.Field(alias="processedTagKey")
    ] = None
    r"""The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""

    processed_tag_value: Annotated[
        Optional[str], pydantic.Field(alias="processedTagValue")
    ] = None
    r"""The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation."""

    template_queue_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_queueName")
    ] = None
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""

    template_aws_account_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsAccountId")
    ] = None
    r"""Binds 'awsAccountId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsAccountId' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("tag_after_processing")
    def serialize_tag_after_processing(self, value):
        if isinstance(value, str):
            try:
                return models.TagAfterProcessingOptions(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "fileFilter",
                "awsAccountId",
                "awsAuthenticationMethod",
                "awsSecretKey",
                "region",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "breakerRulesets",
                "staleChannelFlushMs",
                "maxMessages",
                "visibilityTimeout",
                "numReceivers",
                "socketTimeout",
                "skipOnError",
                "includeSqsMetadata",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "enableSQSAssumeRole",
                "preprocess",
                "metadata",
                "checkpointing",
                "pollTimeout",
                "encoding",
                "description",
                "awsApiKey",
                "awsSecret",
                "tagAfterProcessing",
                "processedTagKey",
                "processedTagValue",
                "__template_queueName",
                "__template_awsAccountId",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
                "__template_awsApiKey",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeWindowsMetrics(str, Enum):
    WINDOWS_METRICS = "windows_metrics"


class CreateInputSystemByPackSystemModeWindowsMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of details for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackSystemWindowsMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackSystemModeWindowsMetrics]
    r"""Select the level of details for system metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all system information"""


class CreateInputSystemByPackSystemWindowsMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackSystemModeWindowsMetrics] = None
    r"""Select the level of details for system metrics"""

    detail: Optional[bool] = None
    r"""Generate metrics for all system information"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackSystemModeWindowsMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "detail"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackCPUModeWindowsMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of details for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackCPUWindowsMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackCPUModeWindowsMetrics]
    r"""Select the level of details for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class CreateInputSystemByPackCPUWindowsMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackCPUModeWindowsMetrics] = None
    r"""Select the level of details for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = None
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = None
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = None
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackCPUModeWindowsMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "perCpu", "detail", "time"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackMemoryModeWindowsMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of details for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackMemoryWindowsMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackMemoryModeWindowsMetrics]
    r"""Select the level of details for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class CreateInputSystemByPackMemoryWindowsMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackMemoryModeWindowsMetrics] = None
    r"""Select the level of details for memory metrics"""

    detail: Optional[bool] = None
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackMemoryModeWindowsMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "detail"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackNetworkModeWindowsMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of details for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackNetworkWindowsMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackNetworkModeWindowsMetrics]
    r"""Select the level of details for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class CreateInputSystemByPackNetworkWindowsMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackNetworkModeWindowsMetrics] = None
    r"""Select the level of details for network metrics"""

    detail: Optional[bool] = None
    r"""Generate full network metrics"""

    protocols: Optional[bool] = None
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        None
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackNetworkModeWindowsMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["mode", "detail", "protocols", "devices", "perInterface"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackDiskModeWindowsMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of details for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackDiskWindowsMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackDiskModeWindowsMetrics]
    r"""Select the level of details for disk metrics"""
    per_volume: NotRequired[bool]
    r"""Generate separate metrics for each volume"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    volumes: NotRequired[List[str]]
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""


class CreateInputSystemByPackDiskWindowsMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackDiskModeWindowsMetrics] = None
    r"""Select the level of details for disk metrics"""

    per_volume: Annotated[Optional[bool], pydantic.Field(alias="perVolume")] = None
    r"""Generate separate metrics for each volume"""

    detail: Optional[bool] = None
    r"""Generate full disk metrics"""

    volumes: Optional[List[str]] = None
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackDiskModeWindowsMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "perVolume", "detail", "volumes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackCustomWindowsMetricsTypedDict(TypedDict):
    system: NotRequired[CreateInputSystemByPackSystemWindowsMetricsTypedDict]
    cpu: NotRequired[CreateInputSystemByPackCPUWindowsMetricsTypedDict]
    memory: NotRequired[CreateInputSystemByPackMemoryWindowsMetricsTypedDict]
    network: NotRequired[CreateInputSystemByPackNetworkWindowsMetricsTypedDict]
    disk: NotRequired[CreateInputSystemByPackDiskWindowsMetricsTypedDict]


class CreateInputSystemByPackCustomWindowsMetrics(BaseModel):
    system: Optional[CreateInputSystemByPackSystemWindowsMetrics] = None

    cpu: Optional[CreateInputSystemByPackCPUWindowsMetrics] = None

    memory: Optional[CreateInputSystemByPackMemoryWindowsMetrics] = None

    network: Optional[CreateInputSystemByPackNetworkWindowsMetrics] = None

    disk: Optional[CreateInputSystemByPackDiskWindowsMetrics] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["system", "cpu", "memory", "network", "disk"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackHostWindowsMetricsTypedDict(TypedDict):
    mode: NotRequired[ModeOptionsHost]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[CreateInputSystemByPackCustomWindowsMetricsTypedDict]


class CreateInputSystemByPackHostWindowsMetrics(BaseModel):
    mode: Optional[ModeOptionsHost] = None
    r"""Select level of detail for host metrics"""

    custom: Optional[CreateInputSystemByPackCustomWindowsMetrics] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.ModeOptionsHost(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "custom"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackPersistenceWindowsMetricsTypedDict(TypedDict):
    enable: NotRequired[bool]
    r"""Spool metrics to disk for Cribl Edge and Search"""
    time_window: NotRequired[str]
    r"""Time span for each file bucket"""
    max_data_size: NotRequired[str]
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""
    max_data_time: NotRequired[str]
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""
    compress: NotRequired[DataCompressionFormatOptionsPersistence]
    dest_path: NotRequired[str]
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics"""


class CreateInputSystemByPackPersistenceWindowsMetrics(BaseModel):
    enable: Optional[bool] = None
    r"""Spool metrics to disk for Cribl Edge and Search"""

    time_window: Annotated[Optional[str], pydantic.Field(alias="timeWindow")] = None
    r"""Time span for each file bucket"""

    max_data_size: Annotated[Optional[str], pydantic.Field(alias="maxDataSize")] = None
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""

    max_data_time: Annotated[Optional[str], pydantic.Field(alias="maxDataTime")] = None
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""

    compress: Optional[DataCompressionFormatOptionsPersistence] = None

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics"""

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.DataCompressionFormatOptionsPersistence(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enable",
                "timeWindow",
                "maxDataSize",
                "maxDataTime",
                "compress",
                "destPath",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputWindowsMetricsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeWindowsMetrics
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[CreateInputSystemByPackHostWindowsMetricsTypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[CreateInputSystemByPackPersistenceWindowsMetricsTypedDict]
    disable_native_module: NotRequired[bool]
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""
    description: NotRequired[str]


class CreateInputSystemByPackInputWindowsMetrics(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeWindowsMetrics

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = None
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[CreateInputSystemByPackHostWindowsMetrics] = None

    process: Optional[ProcessType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[CreateInputSystemByPackPersistenceWindowsMetrics] = None

    disable_native_module: Annotated[
        Optional[bool], pydantic.Field(alias="disableNativeModule")
    ] = None
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "interval",
                "host",
                "process",
                "metadata",
                "persistence",
                "disableNativeModule",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeKubeEvents(str, Enum):
    KUBE_EVENTS = "kube_events"


class CreateInputSystemByPackInputKubeEventsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeKubeEvents
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    rules: NotRequired[List[ItemsTypeRulesTypedDict]]
    r"""Filtering on event fields"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]


class CreateInputSystemByPackInputKubeEvents(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeKubeEvents

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    rules: Optional[List[ItemsTypeRules]] = None
    r"""Filtering on event fields"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "rules",
                "metadata",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeKubeLogs(str, Enum):
    KUBE_LOGS = "kube_logs"


class CreateInputSystemByPackRuleKubeLogsTypedDict(TypedDict):
    filter_: str
    r"""JavaScript expression applied to Pod objects. Return 'true' to include it."""
    description: NotRequired[str]
    r"""Optional description of this rule's purpose"""


class CreateInputSystemByPackRuleKubeLogs(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""JavaScript expression applied to Pod objects. Return 'true' to include it."""

    description: Optional[str] = None
    r"""Optional description of this rule's purpose"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["description"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputKubeLogsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeKubeLogs
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between checks for new containers. Default is 15 secs."""
    rules: NotRequired[List[CreateInputSystemByPackRuleKubeLogsTypedDict]]
    r"""Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true."""
    timestamps: NotRequired[bool]
    r"""For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[DiskSpoolingTypeTypedDict]
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    enable_load_balancing: NotRequired[bool]
    r"""Load balance traffic across all Worker Processes"""
    description: NotRequired[str]


class CreateInputSystemByPackInputKubeLogs(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeKubeLogs

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = None
    r"""Time, in seconds, between checks for new containers. Default is 15 secs."""

    rules: Optional[List[CreateInputSystemByPackRuleKubeLogs]] = None
    r"""Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true."""

    timestamps: Optional[bool] = None
    r"""For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[DiskSpoolingType] = None

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    enable_load_balancing: Annotated[
        Optional[bool], pydantic.Field(alias="enableLoadBalancing")
    ] = None
    r"""Load balance traffic across all Worker Processes"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "interval",
                "rules",
                "timestamps",
                "metadata",
                "persistence",
                "breakerRulesets",
                "staleChannelFlushMs",
                "enableLoadBalancing",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeKubeMetrics(str, Enum):
    KUBE_METRICS = "kube_metrics"


class CreateInputSystemByPackPersistenceKubeMetricsTypedDict(TypedDict):
    enable: NotRequired[bool]
    r"""Spool metrics on disk for Cribl Search"""
    time_window: NotRequired[str]
    r"""Time span for each file bucket"""
    max_data_size: NotRequired[str]
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""
    max_data_time: NotRequired[str]
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""
    compress: NotRequired[DataCompressionFormatOptionsPersistence]
    dest_path: NotRequired[str]
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>"""


class CreateInputSystemByPackPersistenceKubeMetrics(BaseModel):
    enable: Optional[bool] = None
    r"""Spool metrics on disk for Cribl Search"""

    time_window: Annotated[Optional[str], pydantic.Field(alias="timeWindow")] = None
    r"""Time span for each file bucket"""

    max_data_size: Annotated[Optional[str], pydantic.Field(alias="maxDataSize")] = None
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""

    max_data_time: Annotated[Optional[str], pydantic.Field(alias="maxDataTime")] = None
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""

    compress: Optional[DataCompressionFormatOptionsPersistence] = None

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>"""

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.DataCompressionFormatOptionsPersistence(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enable",
                "timeWindow",
                "maxDataSize",
                "maxDataTime",
                "compress",
                "destPath",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputKubeMetricsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeKubeMetrics
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metrics collections. Default is 15 secs."""
    rules: NotRequired[List[ItemsTypeRulesTypedDict]]
    r"""Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[CreateInputSystemByPackPersistenceKubeMetricsTypedDict]
    description: NotRequired[str]


class CreateInputSystemByPackInputKubeMetrics(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeKubeMetrics

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = None
    r"""Time, in seconds, between consecutive metrics collections. Default is 15 secs."""

    rules: Optional[List[ItemsTypeRules]] = None
    r"""Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[CreateInputSystemByPackPersistenceKubeMetrics] = None

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "interval",
                "rules",
                "metadata",
                "persistence",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeSystemState(str, Enum):
    SYSTEM_STATE = "system_state"


class CreateInputSystemByPackHostsFileTypedDict(TypedDict):
    r"""Creates events based on entries collected from the hosts file"""

    enable: NotRequired[bool]


class CreateInputSystemByPackHostsFile(BaseModel):
    r"""Creates events based on entries collected from the hosts file"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInterfacesTypedDict(TypedDict):
    r"""Creates events for each of the hosts network interfaces"""

    enable: NotRequired[bool]


class CreateInputSystemByPackInterfaces(BaseModel):
    r"""Creates events for each of the hosts network interfaces"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackDisksAndFileSystemsTypedDict(TypedDict):
    r"""Creates events for physical disks, partitions, and file systems"""

    enable: NotRequired[bool]


class CreateInputSystemByPackDisksAndFileSystems(BaseModel):
    r"""Creates events for physical disks, partitions, and file systems"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackHostInfoTypedDict(TypedDict):
    r"""Creates events based on the host systems current state"""

    enable: NotRequired[bool]


class CreateInputSystemByPackHostInfo(BaseModel):
    r"""Creates events based on the host systems current state"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackRoutesTypedDict(TypedDict):
    r"""Creates events based on entries collected from the hosts network routes"""

    enable: NotRequired[bool]


class CreateInputSystemByPackRoutes(BaseModel):
    r"""Creates events based on entries collected from the hosts network routes"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackDNSTypedDict(TypedDict):
    r"""Creates events for DNS resolvers and search entries"""

    enable: NotRequired[bool]


class CreateInputSystemByPackDNS(BaseModel):
    r"""Creates events for DNS resolvers and search entries"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackUsersAndGroupsTypedDict(TypedDict):
    r"""Creates events for local users and groups"""

    enable: NotRequired[bool]


class CreateInputSystemByPackUsersAndGroups(BaseModel):
    r"""Creates events for local users and groups"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackFirewallTypedDict(TypedDict):
    r"""Creates events for Firewall rules entries"""

    enable: NotRequired[bool]


class CreateInputSystemByPackFirewall(BaseModel):
    r"""Creates events for Firewall rules entries"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackServicesTypedDict(TypedDict):
    r"""Creates events from the list of services"""

    enable: NotRequired[bool]


class CreateInputSystemByPackServices(BaseModel):
    r"""Creates events from the list of services"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackListeningPortsTypedDict(TypedDict):
    r"""Creates events from list of listening ports"""

    enable: NotRequired[bool]


class CreateInputSystemByPackListeningPorts(BaseModel):
    r"""Creates events from list of listening ports"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackLoggedInUsersTypedDict(TypedDict):
    r"""Creates events from list of logged-in users"""

    enable: NotRequired[bool]


class CreateInputSystemByPackLoggedInUsers(BaseModel):
    r"""Creates events from list of logged-in users"""

    enable: Optional[bool] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enable"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackCollectorsTypedDict(TypedDict):
    hostsfile: NotRequired[CreateInputSystemByPackHostsFileTypedDict]
    r"""Creates events based on entries collected from the hosts file"""
    interfaces: NotRequired[CreateInputSystemByPackInterfacesTypedDict]
    r"""Creates events for each of the hosts network interfaces"""
    disk: NotRequired[CreateInputSystemByPackDisksAndFileSystemsTypedDict]
    r"""Creates events for physical disks, partitions, and file systems"""
    metadata: NotRequired[CreateInputSystemByPackHostInfoTypedDict]
    r"""Creates events based on the host systems current state"""
    routes: NotRequired[CreateInputSystemByPackRoutesTypedDict]
    r"""Creates events based on entries collected from the hosts network routes"""
    dns: NotRequired[CreateInputSystemByPackDNSTypedDict]
    r"""Creates events for DNS resolvers and search entries"""
    user: NotRequired[CreateInputSystemByPackUsersAndGroupsTypedDict]
    r"""Creates events for local users and groups"""
    firewall: NotRequired[CreateInputSystemByPackFirewallTypedDict]
    r"""Creates events for Firewall rules entries"""
    services: NotRequired[CreateInputSystemByPackServicesTypedDict]
    r"""Creates events from the list of services"""
    ports: NotRequired[CreateInputSystemByPackListeningPortsTypedDict]
    r"""Creates events from list of listening ports"""
    login_users: NotRequired[CreateInputSystemByPackLoggedInUsersTypedDict]
    r"""Creates events from list of logged-in users"""


class CreateInputSystemByPackCollectors(BaseModel):
    hostsfile: Optional[CreateInputSystemByPackHostsFile] = None
    r"""Creates events based on entries collected from the hosts file"""

    interfaces: Optional[CreateInputSystemByPackInterfaces] = None
    r"""Creates events for each of the hosts network interfaces"""

    disk: Optional[CreateInputSystemByPackDisksAndFileSystems] = None
    r"""Creates events for physical disks, partitions, and file systems"""

    metadata: Optional[CreateInputSystemByPackHostInfo] = None
    r"""Creates events based on the host systems current state"""

    routes: Optional[CreateInputSystemByPackRoutes] = None
    r"""Creates events based on entries collected from the hosts network routes"""

    dns: Optional[CreateInputSystemByPackDNS] = None
    r"""Creates events for DNS resolvers and search entries"""

    user: Optional[CreateInputSystemByPackUsersAndGroups] = None
    r"""Creates events for local users and groups"""

    firewall: Optional[CreateInputSystemByPackFirewall] = None
    r"""Creates events for Firewall rules entries"""

    services: Optional[CreateInputSystemByPackServices] = None
    r"""Creates events from the list of services"""

    ports: Optional[CreateInputSystemByPackListeningPorts] = None
    r"""Creates events from list of listening ports"""

    login_users: Annotated[
        Optional[CreateInputSystemByPackLoggedInUsers],
        pydantic.Field(alias="loginUsers"),
    ] = None
    r"""Creates events from list of logged-in users"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "hostsfile",
                "interfaces",
                "disk",
                "metadata",
                "routes",
                "dns",
                "user",
                "firewall",
                "services",
                "ports",
                "loginUsers",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackPersistenceSystemStateTypedDict(TypedDict):
    enable: NotRequired[bool]
    r"""Spool metrics to disk for Cribl Edge and Search"""
    time_window: NotRequired[str]
    r"""Time span for each file bucket"""
    max_data_size: NotRequired[str]
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""
    max_data_time: NotRequired[str]
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""
    compress: NotRequired[DataCompressionFormatOptionsPersistence]
    dest_path: NotRequired[str]
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state"""


class CreateInputSystemByPackPersistenceSystemState(BaseModel):
    enable: Optional[bool] = None
    r"""Spool metrics to disk for Cribl Edge and Search"""

    time_window: Annotated[Optional[str], pydantic.Field(alias="timeWindow")] = None
    r"""Time span for each file bucket"""

    max_data_size: Annotated[Optional[str], pydantic.Field(alias="maxDataSize")] = None
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""

    max_data_time: Annotated[Optional[str], pydantic.Field(alias="maxDataTime")] = None
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""

    compress: Optional[DataCompressionFormatOptionsPersistence] = None

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state"""

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.DataCompressionFormatOptionsPersistence(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enable",
                "timeWindow",
                "maxDataSize",
                "maxDataTime",
                "compress",
                "destPath",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputSystemStateTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeSystemState
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes)."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    collectors: NotRequired[CreateInputSystemByPackCollectorsTypedDict]
    persistence: NotRequired[CreateInputSystemByPackPersistenceSystemStateTypedDict]
    disable_native_module: NotRequired[bool]
    r"""Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)"""
    disable_native_last_log_module: NotRequired[bool]
    r"""Enable only to collect LastLog data via legacy implementation. This option will be removed in a future release. Please contact Support before enabling. [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)"""
    description: NotRequired[str]


class CreateInputSystemByPackInputSystemState(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeSystemState

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = None
    r"""Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes)."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    collectors: Optional[CreateInputSystemByPackCollectors] = None

    persistence: Optional[CreateInputSystemByPackPersistenceSystemState] = None

    disable_native_module: Annotated[
        Optional[bool], pydantic.Field(alias="disableNativeModule")
    ] = None
    r"""Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)"""

    disable_native_last_log_module: Annotated[
        Optional[bool], pydantic.Field(alias="disableNativeLastLogModule")
    ] = None
    r"""Enable only to collect LastLog data via legacy implementation. This option will be removed in a future release. Please contact Support before enabling. [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "interval",
                "metadata",
                "collectors",
                "persistence",
                "disableNativeModule",
                "disableNativeLastLogModule",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeSystemMetrics(str, Enum):
    SYSTEM_METRICS = "system_metrics"


class CreateInputSystemByPackSystemModeSystemMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of detail for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackSystemSystemMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackSystemModeSystemMetrics]
    r"""Select the level of detail for system metrics"""
    processes: NotRequired[bool]
    r"""Generate metrics for the numbers of processes in various states"""


class CreateInputSystemByPackSystemSystemMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackSystemModeSystemMetrics] = None
    r"""Select the level of detail for system metrics"""

    processes: Optional[bool] = None
    r"""Generate metrics for the numbers of processes in various states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackSystemModeSystemMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "processes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackCPUModeSystemMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of detail for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackCPUSystemMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackCPUModeSystemMetrics]
    r"""Select the level of detail for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class CreateInputSystemByPackCPUSystemMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackCPUModeSystemMetrics] = None
    r"""Select the level of detail for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = None
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = None
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = None
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackCPUModeSystemMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "perCpu", "detail", "time"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackMemoryModeSystemMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of detail for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackMemorySystemMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackMemoryModeSystemMetrics]
    r"""Select the level of detail for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class CreateInputSystemByPackMemorySystemMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackMemoryModeSystemMetrics] = None
    r"""Select the level of detail for memory metrics"""

    detail: Optional[bool] = None
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackMemoryModeSystemMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "detail"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackNetworkModeSystemMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of detail for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackNetworkSystemMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackNetworkModeSystemMetrics]
    r"""Select the level of detail for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class CreateInputSystemByPackNetworkSystemMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackNetworkModeSystemMetrics] = None
    r"""Select the level of detail for network metrics"""

    detail: Optional[bool] = None
    r"""Generate full network metrics"""

    protocols: Optional[bool] = None
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        None
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackNetworkModeSystemMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["mode", "detail", "protocols", "devices", "perInterface"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackDiskModeSystemMetrics(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select the level of detail for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackDiskSystemMetricsTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackDiskModeSystemMetrics]
    r"""Select the level of detail for disk metrics"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    inodes: NotRequired[bool]
    r"""Generate filesystem inode metrics"""
    devices: NotRequired[List[str]]
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""
    mountpoints: NotRequired[List[str]]
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""
    fstypes: NotRequired[List[str]]
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""


class CreateInputSystemByPackDiskSystemMetrics(BaseModel):
    mode: Optional[CreateInputSystemByPackDiskModeSystemMetrics] = None
    r"""Select the level of detail for disk metrics"""

    detail: Optional[bool] = None
    r"""Generate full disk metrics"""

    inodes: Optional[bool] = None
    r"""Generate filesystem inode metrics"""

    devices: Optional[List[str]] = None
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""

    mountpoints: Optional[List[str]] = None
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""

    fstypes: Optional[List[str]] = None
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = None
    r"""Generate separate metrics for each device"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackDiskModeSystemMetrics(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "mode",
                "detail",
                "inodes",
                "devices",
                "mountpoints",
                "fstypes",
                "perDevice",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackCustomSystemMetricsTypedDict(TypedDict):
    system: NotRequired[CreateInputSystemByPackSystemSystemMetricsTypedDict]
    cpu: NotRequired[CreateInputSystemByPackCPUSystemMetricsTypedDict]
    memory: NotRequired[CreateInputSystemByPackMemorySystemMetricsTypedDict]
    network: NotRequired[CreateInputSystemByPackNetworkSystemMetricsTypedDict]
    disk: NotRequired[CreateInputSystemByPackDiskSystemMetricsTypedDict]


class CreateInputSystemByPackCustomSystemMetrics(BaseModel):
    system: Optional[CreateInputSystemByPackSystemSystemMetrics] = None

    cpu: Optional[CreateInputSystemByPackCPUSystemMetrics] = None

    memory: Optional[CreateInputSystemByPackMemorySystemMetrics] = None

    network: Optional[CreateInputSystemByPackNetworkSystemMetrics] = None

    disk: Optional[CreateInputSystemByPackDiskSystemMetrics] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["system", "cpu", "memory", "network", "disk"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackHostSystemMetricsTypedDict(TypedDict):
    mode: NotRequired[ModeOptionsHost]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[CreateInputSystemByPackCustomSystemMetricsTypedDict]


class CreateInputSystemByPackHostSystemMetrics(BaseModel):
    mode: Optional[ModeOptionsHost] = None
    r"""Select level of detail for host metrics"""

    custom: Optional[CreateInputSystemByPackCustomSystemMetrics] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.ModeOptionsHost(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["mode", "custom"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackContainerMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for container metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class CreateInputSystemByPackFilterSystemMetricsTypedDict(TypedDict):
    expr: str


class CreateInputSystemByPackFilterSystemMetrics(BaseModel):
    expr: str


class CreateInputSystemByPackContainerTypedDict(TypedDict):
    mode: NotRequired[CreateInputSystemByPackContainerMode]
    r"""Select the level of detail for container metrics"""
    docker_socket: NotRequired[List[str]]
    r"""Full paths for Docker's UNIX-domain socket"""
    docker_timeout: NotRequired[float]
    r"""Timeout, in seconds, for the Docker API"""
    filters: NotRequired[List[CreateInputSystemByPackFilterSystemMetricsTypedDict]]
    r"""Containers matching any of these will be included. All are included if no filters are added."""
    all_containers: NotRequired[bool]
    r"""Include stopped and paused containers"""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""
    detail: NotRequired[bool]
    r"""Generate full container metrics"""


class CreateInputSystemByPackContainer(BaseModel):
    mode: Optional[CreateInputSystemByPackContainerMode] = None
    r"""Select the level of detail for container metrics"""

    docker_socket: Annotated[
        Optional[List[str]], pydantic.Field(alias="dockerSocket")
    ] = None
    r"""Full paths for Docker's UNIX-domain socket"""

    docker_timeout: Annotated[
        Optional[float], pydantic.Field(alias="dockerTimeout")
    ] = None
    r"""Timeout, in seconds, for the Docker API"""

    filters: Optional[List[CreateInputSystemByPackFilterSystemMetrics]] = None
    r"""Containers matching any of these will be included. All are included if no filters are added."""

    all_containers: Annotated[Optional[bool], pydantic.Field(alias="allContainers")] = (
        None
    )
    r"""Include stopped and paused containers"""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = None
    r"""Generate separate metrics for each device"""

    detail: Optional[bool] = None
    r"""Generate full container metrics"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackContainerMode(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "mode",
                "dockerSocket",
                "dockerTimeout",
                "filters",
                "allContainers",
                "perDevice",
                "detail",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackPersistenceSystemMetricsTypedDict(TypedDict):
    enable: NotRequired[bool]
    r"""Spool metrics to disk for Cribl Edge and Search"""
    time_window: NotRequired[str]
    r"""Time span for each file bucket"""
    max_data_size: NotRequired[str]
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""
    max_data_time: NotRequired[str]
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""
    compress: NotRequired[DataCompressionFormatOptionsPersistence]
    dest_path: NotRequired[str]
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics"""


class CreateInputSystemByPackPersistenceSystemMetrics(BaseModel):
    enable: Optional[bool] = None
    r"""Spool metrics to disk for Cribl Edge and Search"""

    time_window: Annotated[Optional[str], pydantic.Field(alias="timeWindow")] = None
    r"""Time span for each file bucket"""

    max_data_size: Annotated[Optional[str], pydantic.Field(alias="maxDataSize")] = None
    r"""Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted."""

    max_data_time: Annotated[Optional[str], pydantic.Field(alias="maxDataTime")] = None
    r"""Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted."""

    compress: Optional[DataCompressionFormatOptionsPersistence] = None

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics"""

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.DataCompressionFormatOptionsPersistence(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enable",
                "timeWindow",
                "maxDataSize",
                "maxDataTime",
                "compress",
                "destPath",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputSystemMetricsTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeSystemMetrics
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[CreateInputSystemByPackHostSystemMetricsTypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    container: NotRequired[CreateInputSystemByPackContainerTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[CreateInputSystemByPackPersistenceSystemMetricsTypedDict]
    description: NotRequired[str]


class CreateInputSystemByPackInputSystemMetrics(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeSystemMetrics

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = None
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[CreateInputSystemByPackHostSystemMetrics] = None

    process: Optional[ProcessType] = None

    container: Optional[CreateInputSystemByPackContainer] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[CreateInputSystemByPackPersistenceSystemMetrics] = None

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "interval",
                "host",
                "process",
                "container",
                "metadata",
                "persistence",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeTcpjson(str, Enum):
    TCPJSON = "tcpjson"


class CreateInputSystemByPackInputTcpjsonTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeTcpjson
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to establish a connection"""
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""
    socket_idle_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""
    socket_ending_max_wait: NotRequired[float]
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""
    socket_max_lifespan: NotRequired[float]
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""
    enable_proxy_header: NotRequired[bool]
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    enable_load_balancing: NotRequired[bool]
    r"""Load balance traffic across all Worker Processes"""
    auth_type: NotRequired[AuthenticationMethodOptionsAuthTokensItems]
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""
    description: NotRequired[str]
    auth_token: NotRequired[str]
    r"""Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputTcpjson(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeTcpjson

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to establish a connection"""

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""

    socket_idle_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketIdleTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""

    socket_ending_max_wait: Annotated[
        Optional[float], pydantic.Field(alias="socketEndingMaxWait")
    ] = None
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""

    socket_max_lifespan: Annotated[
        Optional[float], pydantic.Field(alias="socketMaxLifespan")
    ] = None
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    enable_load_balancing: Annotated[
        Optional[bool], pydantic.Field(alias="enableLoadBalancing")
    ] = None
    r"""Load balance traffic across all Worker Processes"""

    auth_type: Annotated[
        Optional[AuthenticationMethodOptionsAuthTokensItems],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""

    description: Optional[str] = None

    auth_token: Annotated[Optional[str], pydantic.Field(alias="authToken")] = None
    r"""Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsAuthTokensItems(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "ipWhitelistRegex",
                "maxActiveCxn",
                "socketIdleTimeout",
                "socketEndingMaxWait",
                "socketMaxLifespan",
                "enableProxyHeader",
                "metadata",
                "enableLoadBalancing",
                "authType",
                "description",
                "authToken",
                "textSecret",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeCriblLakeHTTP(str, Enum):
    CRIBL_LAKE_HTTP = "cribl_lake_http"


class CreateInputSystemByPackSplunkHecMetadataTypedDict(TypedDict):
    enabled: NotRequired[bool]
    default_dataset: NotRequired[str]
    allowed_indexes_at_token: NotRequired[List[str]]


class CreateInputSystemByPackSplunkHecMetadata(BaseModel):
    enabled: Optional[bool] = None

    default_dataset: Annotated[
        Optional[str], pydantic.Field(alias="defaultDataset")
    ] = None

    allowed_indexes_at_token: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedIndexesAtToken")
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled", "defaultDataset", "allowedIndexesAtToken"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackElasticsearchMetadataTypedDict(TypedDict):
    enabled: NotRequired[bool]
    default_dataset: NotRequired[str]


class CreateInputSystemByPackElasticsearchMetadata(BaseModel):
    enabled: Optional[bool] = None

    default_dataset: Annotated[
        Optional[str], pydantic.Field(alias="defaultDataset")
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled", "defaultDataset"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackAuthTokensExtTypedDict(TypedDict):
    token: str
    description: NotRequired[str]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events referencing this token"""
    splunk_hec_metadata: NotRequired[CreateInputSystemByPackSplunkHecMetadataTypedDict]
    elasticsearch_metadata: NotRequired[
        CreateInputSystemByPackElasticsearchMetadataTypedDict
    ]


class CreateInputSystemByPackAuthTokensExt(BaseModel):
    token: str

    description: Optional[str] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events referencing this token"""

    splunk_hec_metadata: Annotated[
        Optional[CreateInputSystemByPackSplunkHecMetadata],
        pydantic.Field(alias="splunkHecMetadata"),
    ] = None

    elasticsearch_metadata: Annotated[
        Optional[CreateInputSystemByPackElasticsearchMetadata],
        pydantic.Field(alias="elasticsearchMetadata"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["description", "metadata", "splunkHecMetadata", "elasticsearchMetadata"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputCriblLakeHTTPTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeCriblLakeHTTP
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[List[str]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    cribl_api: NotRequired[str]
    r"""Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable."""
    elastic_api: NotRequired[str]
    r"""Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable."""
    splunk_hec_api: NotRequired[str]
    r"""Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable."""
    splunk_hec_acks: NotRequired[bool]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    auth_tokens_ext: NotRequired[List[CreateInputSystemByPackAuthTokensExtTypedDict]]
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""
    template_splunk_hec_api: NotRequired[str]
    r"""Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime."""


class CreateInputSystemByPackInputCriblLakeHTTP(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeCriblLakeHTTP

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[Optional[List[str]], pydantic.Field(alias="authTokens")] = (
        None
    )
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    cribl_api: Annotated[Optional[str], pydantic.Field(alias="criblAPI")] = None
    r"""Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable."""

    elastic_api: Annotated[Optional[str], pydantic.Field(alias="elasticAPI")] = None
    r"""Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable."""

    splunk_hec_api: Annotated[Optional[str], pydantic.Field(alias="splunkHecAPI")] = (
        None
    )
    r"""Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable."""

    splunk_hec_acks: Annotated[
        Optional[bool], pydantic.Field(alias="splunkHecAcks")
    ] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    auth_tokens_ext: Annotated[
        Optional[List[CreateInputSystemByPackAuthTokensExt]],
        pydantic.Field(alias="authTokensExt"),
    ] = None

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    template_splunk_hec_api: Annotated[
        Optional[str], pydantic.Field(alias="__template_splunkHecAPI")
    ] = None
    r"""Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "criblAPI",
                "elasticAPI",
                "splunkHecAPI",
                "splunkHecAcks",
                "metadata",
                "authTokensExt",
                "description",
                "__template_host",
                "__template_port",
                "__template_splunkHecAPI",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeCriblHTTP(str, Enum):
    CRIBL_HTTP = "cribl_http"


class CreateInputSystemByPackInputCriblHTTPTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeCriblHTTP
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[List[ItemsTypeAuthTokensTypedDict]]
    r"""Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputCriblHTTP(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeCriblHTTP

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[
        Optional[List[ItemsTypeAuthTokens]], pydantic.Field(alias="authTokens")
    ] = None
    r"""Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "metadata",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeCriblTCP(str, Enum):
    CRIBL_TCP = "cribl_tcp"


class CreateInputSystemByPackInputCriblTCPTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeCriblTCP
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""
    socket_idle_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""
    socket_ending_max_wait: NotRequired[float]
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""
    socket_max_lifespan: NotRequired[float]
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""
    enable_proxy_header: NotRequired[bool]
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    enable_load_balancing: NotRequired[bool]
    r"""Load balance traffic across all Worker Processes"""
    auth_tokens: NotRequired[List[ItemsTypeAuthTokensTypedDict]]
    r"""Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments."""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputCriblTCP(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeCriblTCP

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""

    socket_idle_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketIdleTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""

    socket_ending_max_wait: Annotated[
        Optional[float], pydantic.Field(alias="socketEndingMaxWait")
    ] = None
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""

    socket_max_lifespan: Annotated[
        Optional[float], pydantic.Field(alias="socketMaxLifespan")
    ] = None
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    enable_load_balancing: Annotated[
        Optional[bool], pydantic.Field(alias="enableLoadBalancing")
    ] = None
    r"""Load balance traffic across all Worker Processes"""

    auth_tokens: Annotated[
        Optional[List[ItemsTypeAuthTokens]], pydantic.Field(alias="authTokens")
    ] = None
    r"""Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments."""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "maxActiveCxn",
                "socketIdleTimeout",
                "socketEndingMaxWait",
                "socketMaxLifespan",
                "enableProxyHeader",
                "metadata",
                "enableLoadBalancing",
                "authTokens",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeCribl(str, Enum):
    CRIBL = "cribl"


class CreateInputSystemByPackInputCriblTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeCribl
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    filter_: NotRequired[str]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]


class CreateInputSystemByPackInputCribl(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeCribl

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    filter_: Annotated[Optional[str], pydantic.Field(alias="filter")] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "filter",
                "metadata",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeGooglePubsub(str, Enum):
    GOOGLE_PUBSUB = "google_pubsub"


class CreateInputSystemByPackInputGooglePubsubTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeGooglePubsub
    topic_name: str
    r"""ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered."""
    subscription_name: str
    r"""ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    monitor_subscription: NotRequired[bool]
    r"""Use when the subscription is not created by this Source and topic is not known"""
    create_topic: NotRequired[bool]
    r"""Create topic if it does not exist"""
    create_subscription: NotRequired[bool]
    r"""Create subscription if it does not exist"""
    region: NotRequired[str]
    r"""Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy."""
    google_auth_method: NotRequired[GoogleAuthenticationMethodOptions]
    r"""Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials."""
    service_account_credentials: NotRequired[str]
    r"""Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right."""
    secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    max_backlog: NotRequired[float]
    r"""If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events"""
    concurrency: NotRequired[float]
    r"""How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5."""
    request_timeout: NotRequired[float]
    r"""Pull request timeout, in milliseconds"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    ordered_delivery: NotRequired[bool]
    r"""Receive events in the order they were added to the queue. The process sending events must have ordering enabled."""
    template_topic_name: NotRequired[str]
    r"""Binds 'topicName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'topicName' at runtime."""
    template_subscription_name: NotRequired[str]
    r"""Binds 'subscriptionName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'subscriptionName' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""


class CreateInputSystemByPackInputGooglePubsub(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeGooglePubsub

    topic_name: Annotated[str, pydantic.Field(alias="topicName")]
    r"""ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered."""

    subscription_name: Annotated[str, pydantic.Field(alias="subscriptionName")]
    r"""ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    monitor_subscription: Annotated[
        Optional[bool], pydantic.Field(alias="monitorSubscription")
    ] = None
    r"""Use when the subscription is not created by this Source and topic is not known"""

    create_topic: Annotated[Optional[bool], pydantic.Field(alias="createTopic")] = None
    r"""Create topic if it does not exist"""

    create_subscription: Annotated[
        Optional[bool], pydantic.Field(alias="createSubscription")
    ] = None
    r"""Create subscription if it does not exist"""

    region: Optional[str] = None
    r"""Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy."""

    google_auth_method: Annotated[
        Optional[GoogleAuthenticationMethodOptions],
        pydantic.Field(alias="googleAuthMethod"),
    ] = None
    r"""Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right."""

    secret: Optional[str] = None
    r"""Select or create a stored text secret"""

    max_backlog: Annotated[Optional[float], pydantic.Field(alias="maxBacklog")] = None
    r"""If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events"""

    concurrency: Optional[float] = None
    r"""How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""Pull request timeout, in milliseconds"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    ordered_delivery: Annotated[
        Optional[bool], pydantic.Field(alias="orderedDelivery")
    ] = None
    r"""Receive events in the order they were added to the queue. The process sending events must have ordering enabled."""

    template_topic_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_topicName")
    ] = None
    r"""Binds 'topicName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'topicName' at runtime."""

    template_subscription_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_subscriptionName")
    ] = None
    r"""Binds 'subscriptionName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'subscriptionName' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    @field_serializer("google_auth_method")
    def serialize_google_auth_method(self, value):
        if isinstance(value, str):
            try:
                return models.GoogleAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "monitorSubscription",
                "createTopic",
                "createSubscription",
                "region",
                "googleAuthMethod",
                "serviceAccountCredentials",
                "secret",
                "maxBacklog",
                "concurrency",
                "requestTimeout",
                "metadata",
                "description",
                "orderedDelivery",
                "__template_topicName",
                "__template_subscriptionName",
                "__template_region",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeFirehose(str, Enum):
    FIREHOSE = "firehose"


class CreateInputSystemByPackInputFirehoseTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeFirehose
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[List[str]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputFirehose(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeFirehose

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[Optional[List[str]], pydantic.Field(alias="authTokens")] = (
        None
    )
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "metadata",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputExecType(str, Enum):
    EXEC = "exec"


class CreateInputSystemByPackScheduleType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select a schedule type; either an interval (in seconds) or a cron-style schedule."""

    INTERVAL = "interval"
    CRON_SCHEDULE = "cronSchedule"


class CreateInputSystemByPackInputExecTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackInputExecType
    command: str
    r"""Command to execute; supports Bourne shell (or CMD on Windows) syntax"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    retries: NotRequired[float]
    r"""Maximum number of retry attempts in the event that the command fails"""
    schedule_type: NotRequired[CreateInputSystemByPackScheduleType]
    r"""Select a schedule type; either an interval (in seconds) or a cron-style schedule."""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    interval: NotRequired[float]
    r"""Interval between command executions in seconds."""
    cron_schedule: NotRequired[str]
    r"""Cron schedule to execute the command on."""


class CreateInputSystemByPackInputExec(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackInputExecType

    command: str
    r"""Command to execute; supports Bourne shell (or CMD on Windows) syntax"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    retries: Optional[float] = None
    r"""Maximum number of retry attempts in the event that the command fails"""

    schedule_type: Annotated[
        Optional[CreateInputSystemByPackScheduleType],
        pydantic.Field(alias="scheduleType"),
    ] = None
    r"""Select a schedule type; either an interval (in seconds) or a cron-style schedule."""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    interval: Optional[float] = None
    r"""Interval between command executions in seconds."""

    cron_schedule: Annotated[Optional[str], pydantic.Field(alias="cronSchedule")] = None
    r"""Cron schedule to execute the command on."""

    @field_serializer("schedule_type")
    def serialize_schedule_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackScheduleType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "retries",
                "scheduleType",
                "breakerRulesets",
                "staleChannelFlushMs",
                "metadata",
                "description",
                "interval",
                "cronSchedule",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeEventhub(str, Enum):
    EVENTHUB = "eventhub"


class CreateInputSystemByPackInputEventhubTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeEventhub
    brokers: List[str]
    r"""List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies."""
    topics: List[str]
    r"""The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    group_id: NotRequired[str]
    r"""The consumer group this instance belongs to. Default is 'Cribl'."""
    from_beginning: NotRequired[bool]
    r"""Start reading from earliest available data; relevant only during initial subscription"""
    connection_timeout: NotRequired[float]
    r"""Maximum time to wait for a connection to complete successfully"""
    request_timeout: NotRequired[float]
    r"""Maximum time to wait for Kafka to respond to a request"""
    max_retries: NotRequired[float]
    r"""If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data"""
    max_back_off: NotRequired[float]
    r"""The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds)."""
    initial_backoff: NotRequired[float]
    r"""Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes)."""
    backoff_rate: NotRequired[float]
    r"""Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details."""
    authentication_timeout: NotRequired[float]
    r"""Maximum time to wait for Kafka to respond to an authentication request"""
    reauthentication_threshold: NotRequired[float]
    r"""Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire."""
    sasl: NotRequired[AuthenticationType1TypedDict]
    r"""Authentication parameters to use when connecting to brokers. Using TLS is highly recommended."""
    tls: NotRequired[TLSSettingsClientSideTypeTypedDict]
    session_timeout: NotRequired[float]
    r"""Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
    If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
    Value must be lower than rebalanceTimeout.
    See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
    """
    rebalance_timeout: NotRequired[float]
    r"""Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
    If the timeout is exceeded, the coordinator broker will remove the worker from the group.
    See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
    """
    heartbeat_interval: NotRequired[float]
    r"""Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
    Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
    See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
    """
    auto_commit_interval: NotRequired[float]
    r"""How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""
    auto_commit_threshold: NotRequired[float]
    r"""How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""
    max_bytes_per_partition: NotRequired[float]
    r"""Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB)."""
    max_bytes: NotRequired[float]
    r"""Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB)."""
    max_socket_errors: NotRequired[float]
    r"""Maximum number of network errors before the consumer re-creates a socket"""
    minimize_duplicates: NotRequired[bool]
    r"""Minimize duplicate events by starting only one consumer for each topic partition"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]


class CreateInputSystemByPackInputEventhub(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeEventhub

    brokers: List[str]
    r"""List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies."""

    topics: List[str]
    r"""The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    group_id: Annotated[Optional[str], pydantic.Field(alias="groupId")] = None
    r"""The consumer group this instance belongs to. Default is 'Cribl'."""

    from_beginning: Annotated[Optional[bool], pydantic.Field(alias="fromBeginning")] = (
        None
    )
    r"""Start reading from earliest available data; relevant only during initial subscription"""

    connection_timeout: Annotated[
        Optional[float], pydantic.Field(alias="connectionTimeout")
    ] = None
    r"""Maximum time to wait for a connection to complete successfully"""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""Maximum time to wait for Kafka to respond to a request"""

    max_retries: Annotated[Optional[float], pydantic.Field(alias="maxRetries")] = None
    r"""If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data"""

    max_back_off: Annotated[Optional[float], pydantic.Field(alias="maxBackOff")] = None
    r"""The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds)."""

    initial_backoff: Annotated[
        Optional[float], pydantic.Field(alias="initialBackoff")
    ] = None
    r"""Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes)."""

    backoff_rate: Annotated[Optional[float], pydantic.Field(alias="backoffRate")] = None
    r"""Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details."""

    authentication_timeout: Annotated[
        Optional[float], pydantic.Field(alias="authenticationTimeout")
    ] = None
    r"""Maximum time to wait for Kafka to respond to an authentication request"""

    reauthentication_threshold: Annotated[
        Optional[float], pydantic.Field(alias="reauthenticationThreshold")
    ] = None
    r"""Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire."""

    sasl: Optional[AuthenticationType1] = None
    r"""Authentication parameters to use when connecting to brokers. Using TLS is highly recommended."""

    tls: Optional[TLSSettingsClientSideType] = None

    session_timeout: Annotated[
        Optional[float], pydantic.Field(alias="sessionTimeout")
    ] = None
    r"""Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
    If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
    Value must be lower than rebalanceTimeout.
    See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
    """

    rebalance_timeout: Annotated[
        Optional[float], pydantic.Field(alias="rebalanceTimeout")
    ] = None
    r"""Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
    If the timeout is exceeded, the coordinator broker will remove the worker from the group.
    See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
    """

    heartbeat_interval: Annotated[
        Optional[float], pydantic.Field(alias="heartbeatInterval")
    ] = None
    r"""Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
    Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
    See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
    """

    auto_commit_interval: Annotated[
        Optional[float], pydantic.Field(alias="autoCommitInterval")
    ] = None
    r"""How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""

    auto_commit_threshold: Annotated[
        Optional[float], pydantic.Field(alias="autoCommitThreshold")
    ] = None
    r"""How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""

    max_bytes_per_partition: Annotated[
        Optional[float], pydantic.Field(alias="maxBytesPerPartition")
    ] = None
    r"""Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB)."""

    max_bytes: Annotated[Optional[float], pydantic.Field(alias="maxBytes")] = None
    r"""Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB)."""

    max_socket_errors: Annotated[
        Optional[float], pydantic.Field(alias="maxSocketErrors")
    ] = None
    r"""Maximum number of network errors before the consumer re-creates a socket"""

    minimize_duplicates: Annotated[
        Optional[bool], pydantic.Field(alias="minimizeDuplicates")
    ] = None
    r"""Minimize duplicate events by starting only one consumer for each topic partition"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "groupId",
                "fromBeginning",
                "connectionTimeout",
                "requestTimeout",
                "maxRetries",
                "maxBackOff",
                "initialBackoff",
                "backoffRate",
                "authenticationTimeout",
                "reauthenticationThreshold",
                "sasl",
                "tls",
                "sessionTimeout",
                "rebalanceTimeout",
                "heartbeatInterval",
                "autoCommitInterval",
                "autoCommitThreshold",
                "maxBytesPerPartition",
                "maxBytes",
                "maxSocketErrors",
                "minimizeDuplicates",
                "metadata",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeOffice365MsgTrace(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class CreateInputSystemByPackLogLevelOffice365MsgTrace(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CreateInputSystemByPackCertOptionsTypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CreateInputSystemByPackCertOptions(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["certificateName", "passphrase"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputOffice365MsgTraceTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeOffice365MsgTrace
    url: str
    r"""URL to use when retrieving report data."""
    interval: float
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    auth_type: NotRequired[CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace]
    r"""Select authentication method."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[CreateInputSystemByPackLogLevelOffice365MsgTrace]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesType1TypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    tenant_id: NotRequired[str]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: NotRequired[str]
    r"""client_id to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[SubscriptionPlanOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    cert_options: NotRequired[CreateInputSystemByPackCertOptionsTypedDict]
    template_url: NotRequired[str]
    r"""Binds 'url' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'url' at runtime."""
    template_tenant_id: NotRequired[str]
    r"""Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime."""
    template_client_id: NotRequired[str]
    r"""Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime."""
    template_resource: NotRequired[str]
    r"""Binds 'resource' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'resource' at runtime."""


class CreateInputSystemByPackInputOffice365MsgTrace(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeOffice365MsgTrace

    url: str
    r"""URL to use when retrieving report data."""

    interval: float
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disables time filtering of events when a date range is specified."""

    auth_type: Annotated[
        Optional[CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Select authentication method."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = None
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = None
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Optional[CreateInputSystemByPackLogLevelOffice365MsgTrace],
        pydantic.Field(alias="logLevel"),
    ] = None
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = None
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = None
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = None
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = None
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = None
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType1], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""client_id to pass in the OAuth request parameter."""

    resource: Optional[str] = None
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Optional[SubscriptionPlanOptions], pydantic.Field(alias="planType")
    ] = None
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    cert_options: Annotated[
        Optional[CreateInputSystemByPackCertOptions],
        pydantic.Field(alias="certOptions"),
    ] = None

    template_url: Annotated[Optional[str], pydantic.Field(alias="__template_url")] = (
        None
    )
    r"""Binds 'url' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'url' at runtime."""

    template_tenant_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_tenantId")
    ] = None
    r"""Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime."""

    template_client_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_clientId")
    ] = None
    r"""Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime."""

    template_resource: Annotated[
        Optional[str], pydantic.Field(alias="__template_resource")
    ] = None
    r"""Binds 'resource' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'resource' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return (
                    models.CreateInputSystemByPackAuthenticationMethodOffice365MsgTrace(
                        value
                    )
                )
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackLogLevelOffice365MsgTrace(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.SubscriptionPlanOptions(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "startDate",
                "endDate",
                "timeout",
                "disableTimeFilter",
                "authType",
                "rescheduleDroppedTasks",
                "maxTaskReschedule",
                "logLevel",
                "jobTimeout",
                "keepAliveTime",
                "maxMissedKeepAlives",
                "ttl",
                "ignoreGroupJobsLimit",
                "metadata",
                "retryRules",
                "description",
                "username",
                "password",
                "credentialsSecret",
                "clientSecret",
                "tenantId",
                "clientId",
                "resource",
                "planType",
                "textSecret",
                "certOptions",
                "__template_url",
                "__template_tenantId",
                "__template_clientId",
                "__template_resource",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeOffice365Service(str, Enum):
    OFFICE365_SERVICE = "office365_service"


class CreateInputSystemByPackContentConfigOffice365ServiceTypedDict(TypedDict):
    content_type: NotRequired[str]
    r"""Office 365 Services API Content Type"""
    description: NotRequired[str]
    r"""If interval type is minutes the value entered must evenly divisible by 60 or save will fail"""
    interval: NotRequired[float]
    log_level: NotRequired[LogLevelOptionsContentConfigItems]
    r"""Collector runtime Log Level"""
    enabled: NotRequired[bool]


class CreateInputSystemByPackContentConfigOffice365Service(BaseModel):
    content_type: Annotated[Optional[str], pydantic.Field(alias="contentType")] = None
    r"""Office 365 Services API Content Type"""

    description: Optional[str] = None
    r"""If interval type is minutes the value entered must evenly divisible by 60 or save will fail"""

    interval: Optional[float] = None

    log_level: Annotated[
        Optional[LogLevelOptionsContentConfigItems], pydantic.Field(alias="logLevel")
    ] = None
    r"""Collector runtime Log Level"""

    enabled: Optional[bool] = None

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.LogLevelOptionsContentConfigItems(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["contentType", "description", "interval", "logLevel", "enabled"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputOffice365ServiceTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeOffice365Service
    tenant_id: str
    r"""Office 365 Azure Tenant ID"""
    app_id: str
    r"""Office 365 Azure Application ID"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    plan_type: NotRequired[SubscriptionPlanOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    content_config: NotRequired[
        List[CreateInputSystemByPackContentConfigOffice365ServiceTypedDict]
    ]
    r"""Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule."""
    retry_rules: NotRequired[RetryRulesType1TypedDict]
    auth_type: NotRequired[AuthenticationMethodOptions1]
    r"""Enter client secret directly, or select a stored secret"""
    description: NotRequired[str]
    client_secret: NotRequired[str]
    r"""Office 365 Azure client secret"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_tenant_id: NotRequired[str]
    r"""Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime."""
    template_app_id: NotRequired[str]
    r"""Binds 'appId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'appId' at runtime."""
    template_client_secret: NotRequired[str]
    r"""Binds 'clientSecret' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientSecret' at runtime."""


class CreateInputSystemByPackInputOffice365Service(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeOffice365Service

    tenant_id: Annotated[str, pydantic.Field(alias="tenantId")]
    r"""Office 365 Azure Tenant ID"""

    app_id: Annotated[str, pydantic.Field(alias="appId")]
    r"""Office 365 Azure Application ID"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    plan_type: Annotated[
        Optional[SubscriptionPlanOptions], pydantic.Field(alias="planType")
    ] = None
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = None
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = None
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = None
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = None
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = None
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    content_config: Annotated[
        Optional[List[CreateInputSystemByPackContentConfigOffice365Service]],
        pydantic.Field(alias="contentConfig"),
    ] = None
    r"""Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule."""

    retry_rules: Annotated[
        Optional[RetryRulesType1], pydantic.Field(alias="retryRules")
    ] = None

    auth_type: Annotated[
        Optional[AuthenticationMethodOptions1], pydantic.Field(alias="authType")
    ] = None
    r"""Enter client secret directly, or select a stored secret"""

    description: Optional[str] = None

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""Office 365 Azure client secret"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_tenant_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_tenantId")
    ] = None
    r"""Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime."""

    template_app_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_appId")
    ] = None
    r"""Binds 'appId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'appId' at runtime."""

    template_client_secret: Annotated[
        Optional[str], pydantic.Field(alias="__template_clientSecret")
    ] = None
    r"""Binds 'clientSecret' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientSecret' at runtime."""

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.SubscriptionPlanOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptions1(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "planType",
                "timeout",
                "keepAliveTime",
                "jobTimeout",
                "maxMissedKeepAlives",
                "ttl",
                "ignoreGroupJobsLimit",
                "metadata",
                "contentConfig",
                "retryRules",
                "authType",
                "description",
                "clientSecret",
                "textSecret",
                "__template_tenantId",
                "__template_appId",
                "__template_clientSecret",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeOffice365Mgmt(str, Enum):
    OFFICE365_MGMT = "office365_mgmt"


class CreateInputSystemByPackContentConfigOffice365MgmtTypedDict(TypedDict):
    content_type: NotRequired[str]
    r"""Office 365 Management Activity API Content Type"""
    description: NotRequired[str]
    r"""If interval type is minutes the value entered must evenly divisible by 60 or save will fail"""
    interval: NotRequired[float]
    log_level: NotRequired[LogLevelOptionsContentConfigItems]
    r"""Collector runtime Log Level"""
    enabled: NotRequired[bool]


class CreateInputSystemByPackContentConfigOffice365Mgmt(BaseModel):
    content_type: Annotated[Optional[str], pydantic.Field(alias="contentType")] = None
    r"""Office 365 Management Activity API Content Type"""

    description: Optional[str] = None
    r"""If interval type is minutes the value entered must evenly divisible by 60 or save will fail"""

    interval: Optional[float] = None

    log_level: Annotated[
        Optional[LogLevelOptionsContentConfigItems], pydantic.Field(alias="logLevel")
    ] = None
    r"""Collector runtime Log Level"""

    enabled: Optional[bool] = None

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.LogLevelOptionsContentConfigItems(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["contentType", "description", "interval", "logLevel", "enabled"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputOffice365MgmtTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeOffice365Mgmt
    plan_type: SubscriptionPlanOptions
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    tenant_id: str
    r"""Office 365 Azure Tenant ID"""
    app_id: str
    r"""Office 365 Azure Application ID"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    publisher_identifier: NotRequired[str]
    r"""Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)"""
    content_config: NotRequired[
        List[CreateInputSystemByPackContentConfigOffice365MgmtTypedDict]
    ]
    r"""Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule."""
    ingestion_lag: NotRequired[float]
    r"""Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval."""
    retry_rules: NotRequired[RetryRulesType1TypedDict]
    auth_type: NotRequired[AuthenticationMethodOptions1]
    r"""Enter client secret directly, or select a stored secret"""
    description: NotRequired[str]
    client_secret: NotRequired[str]
    r"""Office 365 Azure client secret"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_tenant_id: NotRequired[str]
    r"""Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime."""
    template_app_id: NotRequired[str]
    r"""Binds 'appId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'appId' at runtime."""
    template_publisher_identifier: NotRequired[str]
    r"""Binds 'publisherIdentifier' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'publisherIdentifier' at runtime."""
    template_client_secret: NotRequired[str]
    r"""Binds 'clientSecret' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientSecret' at runtime."""


class CreateInputSystemByPackInputOffice365Mgmt(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeOffice365Mgmt

    plan_type: Annotated[SubscriptionPlanOptions, pydantic.Field(alias="planType")]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    tenant_id: Annotated[str, pydantic.Field(alias="tenantId")]
    r"""Office 365 Azure Tenant ID"""

    app_id: Annotated[str, pydantic.Field(alias="appId")]
    r"""Office 365 Azure Application ID"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = None
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = None
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = None
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = None
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = None
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    publisher_identifier: Annotated[
        Optional[str], pydantic.Field(alias="publisherIdentifier")
    ] = None
    r"""Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)"""

    content_config: Annotated[
        Optional[List[CreateInputSystemByPackContentConfigOffice365Mgmt]],
        pydantic.Field(alias="contentConfig"),
    ] = None
    r"""Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: */${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule."""

    ingestion_lag: Annotated[Optional[float], pydantic.Field(alias="ingestionLag")] = (
        None
    )
    r"""Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval."""

    retry_rules: Annotated[
        Optional[RetryRulesType1], pydantic.Field(alias="retryRules")
    ] = None

    auth_type: Annotated[
        Optional[AuthenticationMethodOptions1], pydantic.Field(alias="authType")
    ] = None
    r"""Enter client secret directly, or select a stored secret"""

    description: Optional[str] = None

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""Office 365 Azure client secret"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_tenant_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_tenantId")
    ] = None
    r"""Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime."""

    template_app_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_appId")
    ] = None
    r"""Binds 'appId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'appId' at runtime."""

    template_publisher_identifier: Annotated[
        Optional[str], pydantic.Field(alias="__template_publisherIdentifier")
    ] = None
    r"""Binds 'publisherIdentifier' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'publisherIdentifier' at runtime."""

    template_client_secret: Annotated[
        Optional[str], pydantic.Field(alias="__template_clientSecret")
    ] = None
    r"""Binds 'clientSecret' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientSecret' at runtime."""

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.SubscriptionPlanOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptions1(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "timeout",
                "keepAliveTime",
                "jobTimeout",
                "maxMissedKeepAlives",
                "ttl",
                "ignoreGroupJobsLimit",
                "metadata",
                "publisherIdentifier",
                "contentConfig",
                "ingestionLag",
                "retryRules",
                "authType",
                "description",
                "clientSecret",
                "textSecret",
                "__template_tenantId",
                "__template_appId",
                "__template_publisherIdentifier",
                "__template_clientSecret",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeEdgePrometheus(str, Enum):
    EDGE_PROMETHEUS = "edge_prometheus"


class CreateInputSystemByPackDiscoveryTypeEdgePrometheus(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Target discovery mechanism. Use static to manually enter a list of targets."""

    # Static
    STATIC = "static"
    # DNS
    DNS = "dns"
    # AWS EC2
    EC2 = "ec2"
    # Kubernetes Node
    K8S_NODE = "k8s-node"
    # Kubernetes Pods
    K8S_PODS = "k8s-pods"


class CreateInputSystemByPackAuthenticationMethodEdgePrometheus(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Enter credentials directly, or select a stored secret"""

    MANUAL = "manual"
    SECRET = "secret"
    KUBERNETES = "kubernetes"


class CreateInputSystemByPackTargetTypedDict(TypedDict):
    host: str
    r"""Name of host from which to pull metrics."""
    protocol: NotRequired[ProtocolOptionsTargetsItems]
    r"""Protocol to use when collecting metrics"""
    port: NotRequired[float]
    r"""The port number in the metrics URL for discovered targets."""
    path: NotRequired[str]
    r"""Path to use when collecting metrics from discovered targets"""


class CreateInputSystemByPackTarget(BaseModel):
    host: str
    r"""Name of host from which to pull metrics."""

    protocol: Optional[ProtocolOptionsTargetsItems] = None
    r"""Protocol to use when collecting metrics"""

    port: Optional[float] = None
    r"""The port number in the metrics URL for discovered targets."""

    path: Optional[str] = None
    r"""Path to use when collecting metrics from discovered targets"""

    @field_serializer("protocol")
    def serialize_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.ProtocolOptionsTargetsItems(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["protocol", "port", "path"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackPodFilterTypedDict(TypedDict):
    filter_: str
    r"""JavaScript expression applied to pods objects. Return 'true' to include it."""
    description: NotRequired[str]
    r"""Optional description of this rule's purpose"""


class CreateInputSystemByPackPodFilter(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""JavaScript expression applied to pods objects. Return 'true' to include it."""

    description: Optional[str] = None
    r"""Optional description of this rule's purpose"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["description"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputEdgePrometheusTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeEdgePrometheus
    discovery_type: CreateInputSystemByPackDiscoveryTypeEdgePrometheus
    r"""Target discovery mechanism. Use static to manually enter a list of targets."""
    interval: float
    r"""How often in seconds to scrape targets for metrics."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    dimension_list: NotRequired[List[str]]
    r"""Other dimensions to include in events"""
    timeout: NotRequired[float]
    r"""Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable"""
    persistence: NotRequired[DiskSpoolingTypeTypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    auth_type: NotRequired[CreateInputSystemByPackAuthenticationMethodEdgePrometheus]
    r"""Enter credentials directly, or select a stored secret"""
    description: NotRequired[str]
    targets: NotRequired[List[CreateInputSystemByPackTargetTypedDict]]
    record_type: NotRequired[RecordTypeOptions]
    r"""DNS record type to resolve"""
    scrape_port: NotRequired[float]
    r"""The port number in the metrics URL for discovered targets."""
    name_list: NotRequired[List[str]]
    r"""List of DNS names to resolve"""
    scrape_protocol: NotRequired[ProtocolOptionsTargetsItems]
    r"""Protocol to use when collecting metrics"""
    scrape_path: NotRequired[str]
    r"""Path to use when collecting metrics from discovered targets"""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    use_public_ip: NotRequired[bool]
    r"""Use public IP address for discovered targets. Disable to use the private IP address."""
    search_filter: NotRequired[List[ItemsTypeSearchFilterTypedDict]]
    r"""Filter to apply when searching for EC2 instances"""
    aws_secret_key: NotRequired[str]
    region: NotRequired[str]
    r"""Region where the EC2 is located"""
    endpoint: NotRequired[str]
    r"""EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptions1]
    r"""Signature version to use for signing EC2 requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access EC2"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    scrape_protocol_expr: NotRequired[str]
    r"""Protocol to use when collecting metrics"""
    scrape_port_expr: NotRequired[str]
    r"""The port number in the metrics URL for discovered targets."""
    scrape_path_expr: NotRequired[str]
    r"""Path to use when collecting metrics from discovered targets"""
    pod_filter: NotRequired[List[CreateInputSystemByPackPodFilterTypedDict]]
    r"""Add rules to decide which pods to discover for metrics.
    Pods are searched if no rules are given or of all the rules'
    expressions evaluate to true.

    """
    username: NotRequired[str]
    r"""Username for Prometheus Basic authentication"""
    password: NotRequired[str]
    r"""Password for Prometheus Basic authentication"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""


class CreateInputSystemByPackInputEdgePrometheus(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeEdgePrometheus

    discovery_type: Annotated[
        CreateInputSystemByPackDiscoveryTypeEdgePrometheus,
        pydantic.Field(alias="discoveryType"),
    ]
    r"""Target discovery mechanism. Use static to manually enter a list of targets."""

    interval: float
    r"""How often in seconds to scrape targets for metrics."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    dimension_list: Annotated[
        Optional[List[str]], pydantic.Field(alias="dimensionList")
    ] = None
    r"""Other dimensions to include in events"""

    timeout: Optional[float] = None
    r"""Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable"""

    persistence: Optional[DiskSpoolingType] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    auth_type: Annotated[
        Optional[CreateInputSystemByPackAuthenticationMethodEdgePrometheus],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Enter credentials directly, or select a stored secret"""

    description: Optional[str] = None

    targets: Optional[List[CreateInputSystemByPackTarget]] = None

    record_type: Annotated[
        Optional[RecordTypeOptions], pydantic.Field(alias="recordType")
    ] = None
    r"""DNS record type to resolve"""

    scrape_port: Annotated[Optional[float], pydantic.Field(alias="scrapePort")] = None
    r"""The port number in the metrics URL for discovered targets."""

    name_list: Annotated[Optional[List[str]], pydantic.Field(alias="nameList")] = None
    r"""List of DNS names to resolve"""

    scrape_protocol: Annotated[
        Optional[ProtocolOptionsTargetsItems], pydantic.Field(alias="scrapeProtocol")
    ] = None
    r"""Protocol to use when collecting metrics"""

    scrape_path: Annotated[Optional[str], pydantic.Field(alias="scrapePath")] = None
    r"""Path to use when collecting metrics from discovered targets"""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    use_public_ip: Annotated[Optional[bool], pydantic.Field(alias="usePublicIp")] = None
    r"""Use public IP address for discovered targets. Disable to use the private IP address."""

    search_filter: Annotated[
        Optional[List[ItemsTypeSearchFilter]], pydantic.Field(alias="searchFilter")
    ] = None
    r"""Filter to apply when searching for EC2 instances"""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    region: Optional[str] = None
    r"""Region where the EC2 is located"""

    endpoint: Optional[str] = None
    r"""EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptions1], pydantic.Field(alias="signatureVersion")
    ] = None
    r"""Signature version to use for signing EC2 requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access EC2"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    scrape_protocol_expr: Annotated[
        Optional[str], pydantic.Field(alias="scrapeProtocolExpr")
    ] = None
    r"""Protocol to use when collecting metrics"""

    scrape_port_expr: Annotated[
        Optional[str], pydantic.Field(alias="scrapePortExpr")
    ] = None
    r"""The port number in the metrics URL for discovered targets."""

    scrape_path_expr: Annotated[
        Optional[str], pydantic.Field(alias="scrapePathExpr")
    ] = None
    r"""Path to use when collecting metrics from discovered targets"""

    pod_filter: Annotated[
        Optional[List[CreateInputSystemByPackPodFilter]],
        pydantic.Field(alias="podFilter"),
    ] = None
    r"""Add rules to decide which pods to discover for metrics.
    Pods are searched if no rules are given or of all the rules'
    expressions evaluate to true.

    """

    username: Optional[str] = None
    r"""Username for Prometheus Basic authentication"""

    password: Optional[str] = None
    r"""Password for Prometheus Basic authentication"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    @field_serializer("discovery_type")
    def serialize_discovery_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackDiscoveryTypeEdgePrometheus(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackAuthenticationMethodEdgePrometheus(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("record_type")
    def serialize_record_type(self, value):
        if isinstance(value, str):
            try:
                return models.RecordTypeOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("scrape_protocol")
    def serialize_scrape_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.ProtocolOptionsTargetsItems(value)
            except ValueError:
                return value
        return value

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions1(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "dimensionList",
                "timeout",
                "persistence",
                "metadata",
                "authType",
                "description",
                "targets",
                "recordType",
                "scrapePort",
                "nameList",
                "scrapeProtocol",
                "scrapePath",
                "awsAuthenticationMethod",
                "awsApiKey",
                "awsSecret",
                "usePublicIp",
                "searchFilter",
                "awsSecretKey",
                "region",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "scrapeProtocolExpr",
                "scrapePortExpr",
                "scrapePathExpr",
                "podFilter",
                "username",
                "password",
                "credentialsSecret",
                "__template_awsApiKey",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypePrometheus(str, Enum):
    PROMETHEUS = "prometheus"


class CreateInputSystemByPackDiscoveryTypePrometheus(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Target discovery mechanism. Use static to manually enter a list of targets."""

    # Static
    STATIC = "static"
    # DNS
    DNS = "dns"
    # AWS EC2
    EC2 = "ec2"


class CreateInputSystemByPackLogLevelPrometheus(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Collector runtime log level"""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"


class CreateInputSystemByPackMetricsProtocol(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Protocol to use when collecting metrics"""

    HTTP = "http"
    HTTPS = "https"


class CreateInputSystemByPackInputPrometheusTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypePrometheus
    interval: float
    r"""How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter."""
    log_level: CreateInputSystemByPackLogLevelPrometheus
    r"""Collector runtime log level"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    dimension_list: NotRequired[List[str]]
    r"""Other dimensions to include in events"""
    discovery_type: NotRequired[CreateInputSystemByPackDiscoveryTypePrometheus]
    r"""Target discovery mechanism. Use static to manually enter a list of targets."""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    timeout: NotRequired[float]
    r"""Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout"""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    auth_type: NotRequired[AuthenticationMethodOptionsSasl]
    r"""Enter credentials directly, or select a stored secret"""
    description: NotRequired[str]
    target_list: NotRequired[List[str]]
    r"""List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'."""
    record_type: NotRequired[RecordTypeOptions]
    r"""DNS record type to resolve"""
    scrape_port: NotRequired[float]
    r"""The port number in the metrics URL for discovered targets"""
    name_list: NotRequired[List[str]]
    r"""List of DNS names to resolve"""
    scrape_protocol: NotRequired[CreateInputSystemByPackMetricsProtocol]
    r"""Protocol to use when collecting metrics"""
    scrape_path: NotRequired[str]
    r"""Path to use when collecting metrics from discovered targets"""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    use_public_ip: NotRequired[bool]
    r"""Use public IP address for discovered targets. Disable to use the private IP address."""
    search_filter: NotRequired[List[ItemsTypeSearchFilterTypedDict]]
    r"""Filter to apply when searching for EC2 instances"""
    aws_secret_key: NotRequired[str]
    region: NotRequired[str]
    r"""Region where the EC2 is located"""
    endpoint: NotRequired[str]
    r"""EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptions1]
    r"""Signature version to use for signing EC2 requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access EC2"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    username: NotRequired[str]
    r"""Username for Prometheus Basic authentication"""
    password: NotRequired[str]
    r"""Password for Prometheus Basic authentication"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    template_log_level: NotRequired[str]
    r"""Binds 'logLevel' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'logLevel' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""


class CreateInputSystemByPackInputPrometheus(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypePrometheus

    interval: float
    r"""How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter."""

    log_level: Annotated[
        CreateInputSystemByPackLogLevelPrometheus, pydantic.Field(alias="logLevel")
    ]
    r"""Collector runtime log level"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    dimension_list: Annotated[
        Optional[List[str]], pydantic.Field(alias="dimensionList")
    ] = None
    r"""Other dimensions to include in events"""

    discovery_type: Annotated[
        Optional[CreateInputSystemByPackDiscoveryTypePrometheus],
        pydantic.Field(alias="discoveryType"),
    ] = None
    r"""Target discovery mechanism. Use static to manually enter a list of targets."""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    timeout: Optional[float] = None
    r"""Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout"""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = None
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = None
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = None
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = None
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = None
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    auth_type: Annotated[
        Optional[AuthenticationMethodOptionsSasl], pydantic.Field(alias="authType")
    ] = None
    r"""Enter credentials directly, or select a stored secret"""

    description: Optional[str] = None

    target_list: Annotated[Optional[List[str]], pydantic.Field(alias="targetList")] = (
        None
    )
    r"""List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'."""

    record_type: Annotated[
        Optional[RecordTypeOptions], pydantic.Field(alias="recordType")
    ] = None
    r"""DNS record type to resolve"""

    scrape_port: Annotated[Optional[float], pydantic.Field(alias="scrapePort")] = None
    r"""The port number in the metrics URL for discovered targets"""

    name_list: Annotated[Optional[List[str]], pydantic.Field(alias="nameList")] = None
    r"""List of DNS names to resolve"""

    scrape_protocol: Annotated[
        Optional[CreateInputSystemByPackMetricsProtocol],
        pydantic.Field(alias="scrapeProtocol"),
    ] = None
    r"""Protocol to use when collecting metrics"""

    scrape_path: Annotated[Optional[str], pydantic.Field(alias="scrapePath")] = None
    r"""Path to use when collecting metrics from discovered targets"""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    use_public_ip: Annotated[Optional[bool], pydantic.Field(alias="usePublicIp")] = None
    r"""Use public IP address for discovered targets. Disable to use the private IP address."""

    search_filter: Annotated[
        Optional[List[ItemsTypeSearchFilter]], pydantic.Field(alias="searchFilter")
    ] = None
    r"""Filter to apply when searching for EC2 instances"""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    region: Optional[str] = None
    r"""Region where the EC2 is located"""

    endpoint: Optional[str] = None
    r"""EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptions1], pydantic.Field(alias="signatureVersion")
    ] = None
    r"""Signature version to use for signing EC2 requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access EC2"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    username: Optional[str] = None
    r"""Username for Prometheus Basic authentication"""

    password: Optional[str] = None
    r"""Password for Prometheus Basic authentication"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    template_log_level: Annotated[
        Optional[str], pydantic.Field(alias="__template_logLevel")
    ] = None
    r"""Binds 'logLevel' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'logLevel' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    @field_serializer("discovery_type")
    def serialize_discovery_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackDiscoveryTypePrometheus(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackLogLevelPrometheus(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsSasl(value)
            except ValueError:
                return value
        return value

    @field_serializer("record_type")
    def serialize_record_type(self, value):
        if isinstance(value, str):
            try:
                return models.RecordTypeOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("scrape_protocol")
    def serialize_scrape_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackMetricsProtocol(value)
            except ValueError:
                return value
        return value

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions1(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "dimensionList",
                "discoveryType",
                "rejectUnauthorized",
                "timeout",
                "keepAliveTime",
                "jobTimeout",
                "maxMissedKeepAlives",
                "ttl",
                "ignoreGroupJobsLimit",
                "metadata",
                "authType",
                "description",
                "targetList",
                "recordType",
                "scrapePort",
                "nameList",
                "scrapeProtocol",
                "scrapePath",
                "awsAuthenticationMethod",
                "awsApiKey",
                "awsSecret",
                "usePublicIp",
                "searchFilter",
                "awsSecretKey",
                "region",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "username",
                "password",
                "credentialsSecret",
                "__template_logLevel",
                "__template_awsApiKey",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypePrometheusRw(str, Enum):
    PROMETHEUS_RW = "prometheus_rw"


class CreateInputSystemByPackInputPrometheusRwTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypePrometheusRw
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    prometheus_api: str
    r"""Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    auth_type: NotRequired[AuthenticationTypeOptionsPrometheusAuth]
    r"""Remote Write authentication type"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    r"""Bearer token to include in the authorization header"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""
    template_prometheus_api: NotRequired[str]
    r"""Binds 'prometheusAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'prometheusAPI' at runtime."""


class CreateInputSystemByPackInputPrometheusRw(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypePrometheusRw

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    prometheus_api: Annotated[str, pydantic.Field(alias="prometheusAPI")]
    r"""Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    auth_type: Annotated[
        Optional[AuthenticationTypeOptionsPrometheusAuth],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Remote Write authentication type"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None
    r"""Bearer token to include in the authorization header"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    template_prometheus_api: Annotated[
        Optional[str], pydantic.Field(alias="__template_prometheusAPI")
    ] = None
    r"""Binds 'prometheusAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'prometheusAPI' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationTypeOptionsPrometheusAuth(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "authType",
                "metadata",
                "description",
                "username",
                "password",
                "token",
                "credentialsSecret",
                "textSecret",
                "__template_host",
                "__template_port",
                "__template_prometheusAPI",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeLoki(str, Enum):
    LOKI = "loki"


class CreateInputSystemByPackInputLokiTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeLoki
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    loki_api: str
    r"""Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    auth_type: NotRequired[AuthenticationTypeOptionsLokiAuth]
    r"""Loki logs authentication type"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    r"""Bearer token to include in the authorization header"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputLoki(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeLoki

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    loki_api: Annotated[str, pydantic.Field(alias="lokiAPI")]
    r"""Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    auth_type: Annotated[
        Optional[AuthenticationTypeOptionsLokiAuth], pydantic.Field(alias="authType")
    ] = None
    r"""Loki logs authentication type"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None
    r"""Bearer token to include in the authorization header"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationTypeOptionsLokiAuth(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "authType",
                "metadata",
                "description",
                "username",
                "password",
                "token",
                "credentialsSecret",
                "textSecret",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputGrafanaType2(str, Enum):
    GRAFANA = "grafana"


class CreateInputSystemByPackPrometheusAuth2TypedDict(TypedDict):
    auth_type: NotRequired[AuthenticationTypeOptionsPrometheusAuth]
    r"""Remote Write authentication type"""
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    r"""Bearer token to include in the authorization header"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""


class CreateInputSystemByPackPrometheusAuth2(BaseModel):
    auth_type: Annotated[
        Optional[AuthenticationTypeOptionsPrometheusAuth],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Remote Write authentication type"""

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None
    r"""Bearer token to include in the authorization header"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationTypeOptionsPrometheusAuth(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "username",
                "password",
                "token",
                "credentialsSecret",
                "textSecret",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackLokiAuth2TypedDict(TypedDict):
    auth_type: NotRequired[AuthenticationTypeOptionsLokiAuth]
    r"""Loki logs authentication type"""
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    r"""Bearer token to include in the authorization header"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""


class CreateInputSystemByPackLokiAuth2(BaseModel):
    auth_type: Annotated[
        Optional[AuthenticationTypeOptionsLokiAuth], pydantic.Field(alias="authType")
    ] = None
    r"""Loki logs authentication type"""

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None
    r"""Bearer token to include in the authorization header"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationTypeOptionsLokiAuth(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "username",
                "password",
                "token",
                "credentialsSecret",
                "textSecret",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputGrafanaGrafana2TypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackInputGrafanaType2
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    loki_api: str
    r"""Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    prometheus_api: NotRequired[str]
    r"""Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured."""
    prometheus_auth: NotRequired[CreateInputSystemByPackPrometheusAuth2TypedDict]
    loki_auth: NotRequired[CreateInputSystemByPackLokiAuth2TypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputGrafanaGrafana2(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackInputGrafanaType2

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    loki_api: Annotated[str, pydantic.Field(alias="lokiAPI")]
    r"""Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    prometheus_api: Annotated[Optional[str], pydantic.Field(alias="prometheusAPI")] = (
        None
    )
    r"""Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured."""

    prometheus_auth: Annotated[
        Optional[CreateInputSystemByPackPrometheusAuth2],
        pydantic.Field(alias="prometheusAuth"),
    ] = None

    loki_auth: Annotated[
        Optional[CreateInputSystemByPackLokiAuth2], pydantic.Field(alias="lokiAuth")
    ] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "prometheusAPI",
                "prometheusAuth",
                "lokiAuth",
                "metadata",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputGrafanaType1(str, Enum):
    GRAFANA = "grafana"


class CreateInputSystemByPackPrometheusAuth1TypedDict(TypedDict):
    auth_type: NotRequired[AuthenticationTypeOptionsPrometheusAuth]
    r"""Remote Write authentication type"""
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    r"""Bearer token to include in the authorization header"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""


class CreateInputSystemByPackPrometheusAuth1(BaseModel):
    auth_type: Annotated[
        Optional[AuthenticationTypeOptionsPrometheusAuth],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Remote Write authentication type"""

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None
    r"""Bearer token to include in the authorization header"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationTypeOptionsPrometheusAuth(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "username",
                "password",
                "token",
                "credentialsSecret",
                "textSecret",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackLokiAuth1TypedDict(TypedDict):
    auth_type: NotRequired[AuthenticationTypeOptionsLokiAuth]
    r"""Loki logs authentication type"""
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    r"""Bearer token to include in the authorization header"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""


class CreateInputSystemByPackLokiAuth1(BaseModel):
    auth_type: Annotated[
        Optional[AuthenticationTypeOptionsLokiAuth], pydantic.Field(alias="authType")
    ] = None
    r"""Loki logs authentication type"""

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None
    r"""Bearer token to include in the authorization header"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationTypeOptionsLokiAuth(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "username",
                "password",
                "token",
                "credentialsSecret",
                "textSecret",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputGrafanaGrafana1TypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackInputGrafanaType1
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    prometheus_api: str
    r"""Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    loki_api: NotRequired[str]
    r"""Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured."""
    prometheus_auth: NotRequired[CreateInputSystemByPackPrometheusAuth1TypedDict]
    loki_auth: NotRequired[CreateInputSystemByPackLokiAuth1TypedDict]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputGrafanaGrafana1(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackInputGrafanaType1

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    prometheus_api: Annotated[str, pydantic.Field(alias="prometheusAPI")]
    r"""Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    loki_api: Annotated[Optional[str], pydantic.Field(alias="lokiAPI")] = None
    r"""Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured."""

    prometheus_auth: Annotated[
        Optional[CreateInputSystemByPackPrometheusAuth1],
        pydantic.Field(alias="prometheusAuth"),
    ] = None

    loki_auth: Annotated[
        Optional[CreateInputSystemByPackLokiAuth1], pydantic.Field(alias="lokiAuth")
    ] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "lokiAPI",
                "prometheusAuth",
                "lokiAuth",
                "metadata",
                "description",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateInputSystemByPackInputGrafanaUnionTypedDict = TypeAliasType(
    "CreateInputSystemByPackInputGrafanaUnionTypedDict",
    Union[
        CreateInputSystemByPackInputGrafanaGrafana1TypedDict,
        CreateInputSystemByPackInputGrafanaGrafana2TypedDict,
    ],
)


CreateInputSystemByPackInputGrafanaUnion = TypeAliasType(
    "CreateInputSystemByPackInputGrafanaUnion",
    Union[
        CreateInputSystemByPackInputGrafanaGrafana1,
        CreateInputSystemByPackInputGrafanaGrafana2,
    ],
)


class CreateInputSystemByPackTypeConfluentCloud(str, Enum):
    CONFLUENT_CLOUD = "confluent_cloud"


class CreateInputSystemByPackInputConfluentCloudTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeConfluentCloud
    brokers: List[str]
    r"""List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092"""
    topics: List[str]
    r"""Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsClientSideTypeKafkaSchemaRegistryTypedDict]
    group_id: NotRequired[str]
    r"""The consumer group to which this instance belongs. Defaults to 'Cribl'."""
    from_beginning: NotRequired[bool]
    r"""Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message"""
    kafka_schema_registry: NotRequired[KafkaSchemaRegistryAuthenticationTypeTypedDict]
    connection_timeout: NotRequired[float]
    r"""Maximum time to wait for a connection to complete successfully"""
    request_timeout: NotRequired[float]
    r"""Maximum time to wait for Kafka to respond to a request"""
    max_retries: NotRequired[float]
    r"""If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data"""
    max_back_off: NotRequired[float]
    r"""The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds)."""
    initial_backoff: NotRequired[float]
    r"""Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes)."""
    backoff_rate: NotRequired[float]
    r"""Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details."""
    authentication_timeout: NotRequired[float]
    r"""Maximum time to wait for Kafka to respond to an authentication request"""
    reauthentication_threshold: NotRequired[float]
    r"""Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire."""
    sasl: NotRequired[AuthenticationTypeTypedDict]
    r"""Authentication parameters to use when connecting to brokers. Using TLS is highly recommended."""
    session_timeout: NotRequired[float]
    r"""
    Timeout used to detect client failures when using Kafka's group-management facilities.
    If the client sends no heartbeats to the broker before the timeout expires,
    the broker will remove the client from the group and initiate a rebalance.
    Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
    """
    rebalance_timeout: NotRequired[float]
    r"""Maximum allowed time for each worker to join the group after a rebalance begins.
    If the timeout is exceeded, the coordinator broker will remove the worker from the group.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
    """
    heartbeat_interval: NotRequired[float]
    r"""Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
    Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
    """
    auto_commit_interval: NotRequired[float]
    r"""How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""
    auto_commit_threshold: NotRequired[float]
    r"""How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""
    max_bytes_per_partition: NotRequired[float]
    r"""Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB)."""
    max_bytes: NotRequired[float]
    r"""Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB)."""
    max_socket_errors: NotRequired[float]
    r"""Maximum number of network errors before the consumer re-creates a socket"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]


class CreateInputSystemByPackInputConfluentCloud(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeConfluentCloud

    brokers: List[str]
    r"""List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092"""

    topics: List[str]
    r"""Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsClientSideTypeKafkaSchemaRegistry] = None

    group_id: Annotated[Optional[str], pydantic.Field(alias="groupId")] = None
    r"""The consumer group to which this instance belongs. Defaults to 'Cribl'."""

    from_beginning: Annotated[Optional[bool], pydantic.Field(alias="fromBeginning")] = (
        None
    )
    r"""Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message"""

    kafka_schema_registry: Annotated[
        Optional[KafkaSchemaRegistryAuthenticationType],
        pydantic.Field(alias="kafkaSchemaRegistry"),
    ] = None

    connection_timeout: Annotated[
        Optional[float], pydantic.Field(alias="connectionTimeout")
    ] = None
    r"""Maximum time to wait for a connection to complete successfully"""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""Maximum time to wait for Kafka to respond to a request"""

    max_retries: Annotated[Optional[float], pydantic.Field(alias="maxRetries")] = None
    r"""If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data"""

    max_back_off: Annotated[Optional[float], pydantic.Field(alias="maxBackOff")] = None
    r"""The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds)."""

    initial_backoff: Annotated[
        Optional[float], pydantic.Field(alias="initialBackoff")
    ] = None
    r"""Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes)."""

    backoff_rate: Annotated[Optional[float], pydantic.Field(alias="backoffRate")] = None
    r"""Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details."""

    authentication_timeout: Annotated[
        Optional[float], pydantic.Field(alias="authenticationTimeout")
    ] = None
    r"""Maximum time to wait for Kafka to respond to an authentication request"""

    reauthentication_threshold: Annotated[
        Optional[float], pydantic.Field(alias="reauthenticationThreshold")
    ] = None
    r"""Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire."""

    sasl: Optional[AuthenticationType] = None
    r"""Authentication parameters to use when connecting to brokers. Using TLS is highly recommended."""

    session_timeout: Annotated[
        Optional[float], pydantic.Field(alias="sessionTimeout")
    ] = None
    r"""
    Timeout used to detect client failures when using Kafka's group-management facilities.
    If the client sends no heartbeats to the broker before the timeout expires,
    the broker will remove the client from the group and initiate a rebalance.
    Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
    """

    rebalance_timeout: Annotated[
        Optional[float], pydantic.Field(alias="rebalanceTimeout")
    ] = None
    r"""Maximum allowed time for each worker to join the group after a rebalance begins.
    If the timeout is exceeded, the coordinator broker will remove the worker from the group.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
    """

    heartbeat_interval: Annotated[
        Optional[float], pydantic.Field(alias="heartbeatInterval")
    ] = None
    r"""Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
    Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
    """

    auto_commit_interval: Annotated[
        Optional[float], pydantic.Field(alias="autoCommitInterval")
    ] = None
    r"""How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""

    auto_commit_threshold: Annotated[
        Optional[float], pydantic.Field(alias="autoCommitThreshold")
    ] = None
    r"""How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""

    max_bytes_per_partition: Annotated[
        Optional[float], pydantic.Field(alias="maxBytesPerPartition")
    ] = None
    r"""Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB)."""

    max_bytes: Annotated[Optional[float], pydantic.Field(alias="maxBytes")] = None
    r"""Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB)."""

    max_socket_errors: Annotated[
        Optional[float], pydantic.Field(alias="maxSocketErrors")
    ] = None
    r"""Maximum number of network errors before the consumer re-creates a socket"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "groupId",
                "fromBeginning",
                "kafkaSchemaRegistry",
                "connectionTimeout",
                "requestTimeout",
                "maxRetries",
                "maxBackOff",
                "initialBackoff",
                "backoffRate",
                "authenticationTimeout",
                "reauthenticationThreshold",
                "sasl",
                "sessionTimeout",
                "rebalanceTimeout",
                "heartbeatInterval",
                "autoCommitInterval",
                "autoCommitThreshold",
                "maxBytesPerPartition",
                "maxBytes",
                "maxSocketErrors",
                "metadata",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeElastic(str, Enum):
    ELASTIC = "elastic"


class CreateInputSystemByPackAuthenticationTypeElastic(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    CREDENTIALS_SECRET = "credentialsSecret"
    # Auth Tokens
    AUTH_TOKENS = "authTokens"


class CreateInputSystemByPackAPIVersion(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The API version to use for communicating with the server"""

    # 6.8.4
    SIX_DOT_8_DOT_4 = "6.8.4"
    # 8.3.2
    EIGHT_DOT_3_DOT_2 = "8.3.2"
    # Custom
    CUSTOM = "custom"


class CreateInputSystemByPackAuthenticationMethodElastic(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Enter credentials directly, or select a stored secret"""

    NONE = "none"
    MANUAL = "manual"
    SECRET = "secret"


class CreateInputSystemByPackProxyModeElasticTypedDict(TypedDict):
    enabled: bool
    r"""Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details."""
    auth_type: NotRequired[CreateInputSystemByPackAuthenticationMethodElastic]
    r"""Enter credentials directly, or select a stored secret"""
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    url: NotRequired[str]
    r"""URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    remove_headers: NotRequired[List[str]]
    r"""List of headers to remove from the request to proxy"""
    timeout_sec: NotRequired[float]
    r"""Amount of time, in seconds, to wait for a proxy request to complete before canceling it"""
    template_url: NotRequired[str]
    r"""Binds 'url' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'url' at runtime."""


class CreateInputSystemByPackProxyModeElastic(BaseModel):
    enabled: bool
    r"""Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details."""

    auth_type: Annotated[
        Optional[CreateInputSystemByPackAuthenticationMethodElastic],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Enter credentials directly, or select a stored secret"""

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    url: Optional[str] = None
    r"""URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    remove_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="removeHeaders")
    ] = None
    r"""List of headers to remove from the request to proxy"""

    timeout_sec: Annotated[Optional[float], pydantic.Field(alias="timeoutSec")] = None
    r"""Amount of time, in seconds, to wait for a proxy request to complete before canceling it"""

    template_url: Annotated[Optional[str], pydantic.Field(alias="__template_url")] = (
        None
    )
    r"""Binds 'url' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'url' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackAuthenticationMethodElastic(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "username",
                "password",
                "credentialsSecret",
                "url",
                "rejectUnauthorized",
                "removeHeaders",
                "timeoutSec",
                "__template_url",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputElasticTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeElastic
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    elastic_api: str
    r"""Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    auth_type: NotRequired[CreateInputSystemByPackAuthenticationTypeElastic]
    api_version: NotRequired[CreateInputSystemByPackAPIVersion]
    r"""The API version to use for communicating with the server"""
    extra_http_headers: NotRequired[List[ItemsTypeExtraHTTPHeadersTypedDict]]
    r"""Headers to add to all events"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    proxy_mode: NotRequired[CreateInputSystemByPackProxyModeElasticTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    auth_tokens: NotRequired[List[str]]
    r"""Bearer tokens to include in the authorization header"""
    custom_api_version: NotRequired[str]
    r"""Custom version information to respond to requests"""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputElastic(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeElastic

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    elastic_api: Annotated[str, pydantic.Field(alias="elasticAPI")]
    r"""Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    auth_type: Annotated[
        Optional[CreateInputSystemByPackAuthenticationTypeElastic],
        pydantic.Field(alias="authType"),
    ] = None

    api_version: Annotated[
        Optional[CreateInputSystemByPackAPIVersion], pydantic.Field(alias="apiVersion")
    ] = None
    r"""The API version to use for communicating with the server"""

    extra_http_headers: Annotated[
        Optional[List[ItemsTypeExtraHTTPHeaders]],
        pydantic.Field(alias="extraHttpHeaders"),
    ] = None
    r"""Headers to add to all events"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    proxy_mode: Annotated[
        Optional[CreateInputSystemByPackProxyModeElastic],
        pydantic.Field(alias="proxyMode"),
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    auth_tokens: Annotated[Optional[List[str]], pydantic.Field(alias="authTokens")] = (
        None
    )
    r"""Bearer tokens to include in the authorization header"""

    custom_api_version: Annotated[
        Optional[str], pydantic.Field(alias="customAPIVersion")
    ] = None
    r"""Custom version information to respond to requests"""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackAuthenticationTypeElastic(value)
            except ValueError:
                return value
        return value

    @field_serializer("api_version")
    def serialize_api_version(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackAPIVersion(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "authType",
                "apiVersion",
                "extraHttpHeaders",
                "metadata",
                "proxyMode",
                "description",
                "username",
                "password",
                "credentialsSecret",
                "authTokens",
                "customAPIVersion",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeAzureBlob(str, Enum):
    AZURE_BLOB = "azure_blob"


class CreateInputSystemByPackInputAzureBlobTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeAzureBlob
    queue_name: str
    r"""The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    file_filter: NotRequired[str]
    r"""Regex matching file names to download and process. Defaults to: .*"""
    visibility_timeout: NotRequired[float]
    r"""The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request."""
    num_receivers: NotRequired[float]
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""
    max_messages: NotRequired[float]
    r"""The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32."""
    service_period_secs: NotRequired[float]
    r"""The duration (in seconds) which pollers should be validated and restarted if exited"""
    skip_on_error: NotRequired[bool]
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    parquet_chunk_size_mb: NotRequired[float]
    r"""Maximum file size for each Parquet chunk"""
    parquet_chunk_download_timeout: NotRequired[float]
    r"""The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified."""
    auth_type: NotRequired[AuthenticationMethodOptions]
    description: NotRequired[str]
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeAzureBlobAuthTypeClientCertTypedDict]
    template_queue_name: NotRequired[str]
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""
    template_connection_string: NotRequired[str]
    r"""Binds 'connectionString' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'connectionString' at runtime."""
    template_tenant_id: NotRequired[str]
    r"""Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime."""
    template_client_id: NotRequired[str]
    r"""Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime."""


class CreateInputSystemByPackInputAzureBlob(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeAzureBlob

    queue_name: Annotated[str, pydantic.Field(alias="queueName")]
    r"""The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    file_filter: Annotated[Optional[str], pydantic.Field(alias="fileFilter")] = None
    r"""Regex matching file names to download and process. Defaults to: .*"""

    visibility_timeout: Annotated[
        Optional[float], pydantic.Field(alias="visibilityTimeout")
    ] = None
    r"""The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request."""

    num_receivers: Annotated[Optional[float], pydantic.Field(alias="numReceivers")] = (
        None
    )
    r"""How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead."""

    max_messages: Annotated[Optional[float], pydantic.Field(alias="maxMessages")] = None
    r"""The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32."""

    service_period_secs: Annotated[
        Optional[float], pydantic.Field(alias="servicePeriodSecs")
    ] = None
    r"""The duration (in seconds) which pollers should be validated and restarted if exited"""

    skip_on_error: Annotated[Optional[bool], pydantic.Field(alias="skipOnError")] = None
    r"""Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    parquet_chunk_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="parquetChunkSizeMB")
    ] = None
    r"""Maximum file size for each Parquet chunk"""

    parquet_chunk_download_timeout: Annotated[
        Optional[float], pydantic.Field(alias="parquetChunkDownloadTimeout")
    ] = None
    r"""The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified."""

    auth_type: Annotated[
        Optional[AuthenticationMethodOptions], pydantic.Field(alias="authType")
    ] = None

    description: Optional[str] = None

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateTypeAzureBlobAuthTypeClientCert] = None

    template_queue_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_queueName")
    ] = None
    r"""Binds 'queueName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'queueName' at runtime."""

    template_connection_string: Annotated[
        Optional[str], pydantic.Field(alias="__template_connectionString")
    ] = None
    r"""Binds 'connectionString' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'connectionString' at runtime."""

    template_tenant_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_tenantId")
    ] = None
    r"""Binds 'tenantId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'tenantId' at runtime."""

    template_client_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_clientId")
    ] = None
    r"""Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "fileFilter",
                "visibilityTimeout",
                "numReceivers",
                "maxMessages",
                "servicePeriodSecs",
                "skipOnError",
                "metadata",
                "breakerRulesets",
                "staleChannelFlushMs",
                "parquetChunkSizeMB",
                "parquetChunkDownloadTimeout",
                "authType",
                "description",
                "connectionString",
                "textSecret",
                "storageAccountName",
                "tenantId",
                "clientId",
                "azureCloud",
                "endpointSuffix",
                "clientTextSecret",
                "certificate",
                "__template_queueName",
                "__template_connectionString",
                "__template_tenantId",
                "__template_clientId",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeSplunkHec(str, Enum):
    SPLUNK_HEC = "splunk_hec"


class CreateInputSystemByPackAuthTokenSplunkHecTypedDict(TypedDict):
    token: str
    r"""Shared secret to be provided by any client (Authorization: <token>)"""
    auth_type: NotRequired[AuthenticationMethodOptionsAuthTokensItems]
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""
    token_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    enabled: NotRequired[bool]
    description: NotRequired[str]
    r"""Optional token description"""
    allowed_indexes_at_token: NotRequired[List[str]]
    r"""Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events referencing this token"""


class CreateInputSystemByPackAuthTokenSplunkHec(BaseModel):
    token: str
    r"""Shared secret to be provided by any client (Authorization: <token>)"""

    auth_type: Annotated[
        Optional[AuthenticationMethodOptionsAuthTokensItems],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate"""

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored text secret"""

    enabled: Optional[bool] = None

    description: Optional[str] = None
    r"""Optional token description"""

    allowed_indexes_at_token: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedIndexesAtToken")
    ] = None
    r"""Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events referencing this token"""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsAuthTokensItems(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "tokenSecret",
                "enabled",
                "description",
                "allowedIndexesAtToken",
                "metadata",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackInputSplunkHecTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeSplunkHec
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    splunk_hec_api: str
    r"""Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[List[CreateInputSystemByPackAuthTokenSplunkHecTypedDict]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[Any]
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info."""
    allowed_indexes: NotRequired[List[str]]
    r"""List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level."""
    splunk_hec_acks: NotRequired[bool]
    r"""Enable Splunk HEC acknowledgements"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    use_fwd_timezone: NotRequired[bool]
    r"""Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event"""
    drop_control_fields: NotRequired[bool]
    r"""Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`."""
    extract_metrics: NotRequired[bool]
    r"""Extract and process Splunk-generated metrics as Cribl metrics"""
    access_control_allow_origin: NotRequired[List[str]]
    r"""Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards."""
    access_control_allow_headers: NotRequired[List[str]]
    r"""Optionally, list HTTP headers that @{product} will send to allowed origins as \"Access-Control-Allow-Headers\" in a CORS preflight response. Use \"*\" to allow all headers."""
    emit_token_metrics: NotRequired[bool]
    r"""Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics"""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""
    template_splunk_hec_api: NotRequired[str]
    r"""Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime."""


class CreateInputSystemByPackInputSplunkHec(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeSplunkHec

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    splunk_hec_api: Annotated[str, pydantic.Field(alias="splunkHecAPI")]
    r"""Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[
        Optional[List[CreateInputSystemByPackAuthTokenSplunkHec]],
        pydantic.Field(alias="authTokens"),
    ] = None
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[Any], pydantic.Field(alias="enableHealthCheck")
    ] = None

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info."""

    allowed_indexes: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedIndexes")
    ] = None
    r"""List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level."""

    splunk_hec_acks: Annotated[
        Optional[bool], pydantic.Field(alias="splunkHecAcks")
    ] = None
    r"""Enable Splunk HEC acknowledgements"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    use_fwd_timezone: Annotated[
        Optional[bool], pydantic.Field(alias="useFwdTimezone")
    ] = None
    r"""Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event"""

    drop_control_fields: Annotated[
        Optional[bool], pydantic.Field(alias="dropControlFields")
    ] = None
    r"""Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`."""

    extract_metrics: Annotated[
        Optional[bool], pydantic.Field(alias="extractMetrics")
    ] = None
    r"""Extract and process Splunk-generated metrics as Cribl metrics"""

    access_control_allow_origin: Annotated[
        Optional[List[str]], pydantic.Field(alias="accessControlAllowOrigin")
    ] = None
    r"""Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards."""

    access_control_allow_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="accessControlAllowHeaders")
    ] = None
    r"""Optionally, list HTTP headers that @{product} will send to allowed origins as \"Access-Control-Allow-Headers\" in a CORS preflight response. Use \"*\" to allow all headers."""

    emit_token_metrics: Annotated[
        Optional[bool], pydantic.Field(alias="emitTokenMetrics")
    ] = None
    r"""Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics"""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    template_splunk_hec_api: Annotated[
        Optional[str], pydantic.Field(alias="__template_splunkHecAPI")
    ] = None
    r"""Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "metadata",
                "allowedIndexes",
                "splunkHecAcks",
                "breakerRulesets",
                "staleChannelFlushMs",
                "useFwdTimezone",
                "dropControlFields",
                "extractMetrics",
                "accessControlAllowOrigin",
                "accessControlAllowHeaders",
                "emitTokenMetrics",
                "description",
                "__template_host",
                "__template_port",
                "__template_splunkHecAPI",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeSplunkSearch(str, Enum):
    SPLUNK_SEARCH = "splunk_search"


class CreateInputSystemByPackEndpointParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings."""


class CreateInputSystemByPackEndpointParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings."""


class CreateInputSystemByPackEndpointHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings."""


class CreateInputSystemByPackEndpointHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (e.g.,`${earliest}`). Ifa constant, use single quotes (e.g.,'earliest'). Valueswithout delimiters (e.g.,earliest) are evaluated as strings."""


class CreateInputSystemByPackLogLevelSplunkSearch(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Collector runtime log level (verbosity)"""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"


class CreateInputSystemByPackAuthenticationTypeSplunkSearch(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Splunk Search authentication type"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    CREDENTIALS_SECRET = "credentialsSecret"
    # Token
    TOKEN = "token"
    # Token (text secret)
    TEXT_SECRET = "textSecret"


class CreateInputSystemByPackInputSplunkSearchTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeSplunkSearch
    search_head: str
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    search: str
    r"""Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    cron_schedule: str
    r"""A cron schedule on which to run this job"""
    endpoint: str
    r"""REST API used to create a search"""
    output_mode: OutputModeOptionsSplunkCollectorConf
    r"""Format of the returned output"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint_params: NotRequired[List[CreateInputSystemByPackEndpointParamTypedDict]]
    r"""Optional request parameters to send to the endpoint"""
    endpoint_headers: NotRequired[List[CreateInputSystemByPackEndpointHeaderTypedDict]]
    r"""Optional request headers to send to the endpoint"""
    log_level: NotRequired[CreateInputSystemByPackLogLevelSplunkSearch]
    r"""Collector runtime log level (verbosity)"""
    request_timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    encoding: NotRequired[str]
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    auth_type: NotRequired[CreateInputSystemByPackAuthenticationTypeSplunkSearch]
    r"""Splunk Search authentication type"""
    description: NotRequired[str]
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    r"""Bearer token to include in the authorization header"""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""


class CreateInputSystemByPackInputSplunkSearch(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeSplunkSearch

    search_head: Annotated[str, pydantic.Field(alias="searchHead")]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    search: str
    r"""Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    cron_schedule: Annotated[str, pydantic.Field(alias="cronSchedule")]
    r"""A cron schedule on which to run this job"""

    endpoint: str
    r"""REST API used to create a search"""

    output_mode: Annotated[
        OutputModeOptionsSplunkCollectorConf, pydantic.Field(alias="outputMode")
    ]
    r"""Format of the returned output"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint_params: Annotated[
        Optional[List[CreateInputSystemByPackEndpointParam]],
        pydantic.Field(alias="endpointParams"),
    ] = None
    r"""Optional request parameters to send to the endpoint"""

    endpoint_headers: Annotated[
        Optional[List[CreateInputSystemByPackEndpointHeader]],
        pydantic.Field(alias="endpointHeaders"),
    ] = None
    r"""Optional request headers to send to the endpoint"""

    log_level: Annotated[
        Optional[CreateInputSystemByPackLogLevelSplunkSearch],
        pydantic.Field(alias="logLevel"),
    ] = None
    r"""Collector runtime log level (verbosity)"""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    encoding: Optional[str] = None
    r"""Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = None
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = None
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = None
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = None
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = None
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    auth_type: Annotated[
        Optional[CreateInputSystemByPackAuthenticationTypeSplunkSearch],
        pydantic.Field(alias="authType"),
    ] = None
    r"""Splunk Search authentication type"""

    description: Optional[str] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None
    r"""Bearer token to include in the authorization header"""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptionsSplunkCollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackLogLevelSplunkSearch(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackAuthenticationTypeSplunkSearch(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "earliest",
                "latest",
                "endpointParams",
                "endpointHeaders",
                "logLevel",
                "requestTimeout",
                "useRoundRobinDns",
                "rejectUnauthorized",
                "encoding",
                "keepAliveTime",
                "jobTimeout",
                "maxMissedKeepAlives",
                "ttl",
                "ignoreGroupJobsLimit",
                "metadata",
                "retryRules",
                "breakerRulesets",
                "staleChannelFlushMs",
                "authType",
                "description",
                "username",
                "password",
                "token",
                "credentialsSecret",
                "textSecret",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeSplunk(str, Enum):
    SPLUNK = "splunk"


class CreateInputSystemByPackAuthTokenSplunkTypedDict(TypedDict):
    token: str
    r"""Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted."""
    description: NotRequired[str]


class CreateInputSystemByPackAuthTokenSplunk(BaseModel):
    token: str
    r"""Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted."""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["description"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackMaxS2SVersion(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The highest S2S protocol version to advertise during handshake"""

    # v3
    V3 = "v3"
    # v4
    V4 = "v4"


class CreateInputSystemByPackCompression(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections."""

    # Disabled
    DISABLED = "disabled"
    # Automatic
    AUTO = "auto"
    # Always
    ALWAYS = "always"


class CreateInputSystemByPackInputSplunkTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeSplunk
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to establish a connection"""
    max_active_cxn: NotRequired[float]
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""
    socket_idle_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""
    socket_ending_max_wait: NotRequired[float]
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""
    socket_max_lifespan: NotRequired[float]
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""
    enable_proxy_header: NotRequired[bool]
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    auth_tokens: NotRequired[List[CreateInputSystemByPackAuthTokenSplunkTypedDict]]
    r"""Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted."""
    max_s2_sversion: NotRequired[CreateInputSystemByPackMaxS2SVersion]
    r"""The highest S2S protocol version to advertise during handshake"""
    description: NotRequired[str]
    use_fwd_timezone: NotRequired[bool]
    r"""Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event"""
    drop_control_fields: NotRequired[bool]
    r"""Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`."""
    extract_metrics: NotRequired[bool]
    r"""Extract and process Splunk-generated metrics as Cribl metrics"""
    compress: NotRequired[CreateInputSystemByPackCompression]
    r"""Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections."""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class CreateInputSystemByPackInputSplunk(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeSplunk

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    tls: Optional[TLSSettingsServerSideType] = None

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = None
    r"""Regex matching IP addresses that are allowed to establish a connection"""

    max_active_cxn: Annotated[Optional[float], pydantic.Field(alias="maxActiveCxn")] = (
        None
    )
    r"""Maximum number of active connections allowed per Worker Process. Use 0 for unlimited."""

    socket_idle_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketIdleTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring."""

    socket_ending_max_wait: Annotated[
        Optional[float], pydantic.Field(alias="socketEndingMaxWait")
    ] = None
    r"""How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring."""

    socket_max_lifespan: Annotated[
        Optional[float], pydantic.Field(alias="socketMaxLifespan")
    ] = None
    r"""The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Enable if the connection is proxied by a device that supports proxy protocol v1 or v2"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    auth_tokens: Annotated[
        Optional[List[CreateInputSystemByPackAuthTokenSplunk]],
        pydantic.Field(alias="authTokens"),
    ] = None
    r"""Shared secrets to be provided by any Splunk forwarder. Ifempty, unauthorized access is permitted."""

    max_s2_sversion: Annotated[
        Optional[CreateInputSystemByPackMaxS2SVersion],
        pydantic.Field(alias="maxS2Sversion"),
    ] = None
    r"""The highest S2S protocol version to advertise during handshake"""

    description: Optional[str] = None

    use_fwd_timezone: Annotated[
        Optional[bool], pydantic.Field(alias="useFwdTimezone")
    ] = None
    r"""Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event"""

    drop_control_fields: Annotated[
        Optional[bool], pydantic.Field(alias="dropControlFields")
    ] = None
    r"""Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`."""

    extract_metrics: Annotated[
        Optional[bool], pydantic.Field(alias="extractMetrics")
    ] = None
    r"""Extract and process Splunk-generated metrics as Cribl metrics"""

    compress: Optional[CreateInputSystemByPackCompression] = None
    r"""Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections."""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @field_serializer("max_s2_sversion")
    def serialize_max_s2_sversion(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackMaxS2SVersion(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.CreateInputSystemByPackCompression(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "tls",
                "ipWhitelistRegex",
                "maxActiveCxn",
                "socketIdleTimeout",
                "socketEndingMaxWait",
                "socketMaxLifespan",
                "enableProxyHeader",
                "metadata",
                "breakerRulesets",
                "staleChannelFlushMs",
                "authTokens",
                "maxS2Sversion",
                "description",
                "useFwdTimezone",
                "dropControlFields",
                "extractMetrics",
                "compress",
                "__template_host",
                "__template_port",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeHTTP(str, Enum):
    HTTP = "http"


class CreateInputSystemByPackInputHTTPTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeHTTP
    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""
    port: float
    r"""Port to listen on"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_tokens: NotRequired[List[str]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    tls: NotRequired[TLSSettingsServerSideTypeTypedDict]
    max_active_req: NotRequired[float]
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""
    max_requests_per_socket: NotRequired[int]
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""
    enable_proxy_header: NotRequired[bool]
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""
    capture_headers: NotRequired[bool]
    r"""Add request headers to events, in the __headers field"""
    activity_log_sample_rate: NotRequired[float]
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""
    request_timeout: NotRequired[float]
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""
    socket_timeout: NotRequired[float]
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""
    keep_alive_timeout: NotRequired[float]
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""
    enable_health_check: NotRequired[bool]
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""
    ip_allowlist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""
    ip_denylist_regex: NotRequired[str]
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""
    cribl_api: NotRequired[str]
    r"""Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable."""
    elastic_api: NotRequired[str]
    r"""Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable."""
    splunk_hec_api: NotRequired[str]
    r"""Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable."""
    splunk_hec_acks: NotRequired[bool]
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    auth_tokens_ext: NotRequired[List[ItemsTypeAuthTokensExtTypedDict]]
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""
    description: NotRequired[str]
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""
    template_splunk_hec_api: NotRequired[str]
    r"""Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime."""


class CreateInputSystemByPackInputHTTP(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeHTTP

    host: str
    r"""Address to bind on. Defaults to 0.0.0.0 (all addresses)."""

    port: float
    r"""Port to listen on"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_tokens: Annotated[Optional[List[str]], pydantic.Field(alias="authTokens")] = (
        None
    )
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    tls: Optional[TLSSettingsServerSideType] = None

    max_active_req: Annotated[Optional[float], pydantic.Field(alias="maxActiveReq")] = (
        None
    )
    r"""Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput."""

    max_requests_per_socket: Annotated[
        Optional[int], pydantic.Field(alias="maxRequestsPerSocket")
    ] = None
    r"""Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited)."""

    enable_proxy_header: Annotated[
        Optional[bool], pydantic.Field(alias="enableProxyHeader")
    ] = None
    r"""Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction."""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Add request headers to events, in the __headers field"""

    activity_log_sample_rate: Annotated[
        Optional[float], pydantic.Field(alias="activityLogSampleRate")
    ] = None
    r"""How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""How long to wait for an incoming request to complete before aborting it. Use 0 to disable."""

    socket_timeout: Annotated[
        Optional[float], pydantic.Field(alias="socketTimeout")
    ] = None
    r"""How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0."""

    keep_alive_timeout: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTimeout")
    ] = None
    r"""After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes)."""

    enable_health_check: Annotated[
        Optional[bool], pydantic.Field(alias="enableHealthCheck")
    ] = None
    r"""Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy"""

    ip_allowlist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipAllowlistRegex")
    ] = None
    r"""Messages from matched IP addresses will be processed, unless also matched by the denylist"""

    ip_denylist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipDenylistRegex")
    ] = None
    r"""Messages from matched IP addresses will be ignored. This takes precedence over the allowlist."""

    cribl_api: Annotated[Optional[str], pydantic.Field(alias="criblAPI")] = None
    r"""Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable."""

    elastic_api: Annotated[Optional[str], pydantic.Field(alias="elasticAPI")] = None
    r"""Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable."""

    splunk_hec_api: Annotated[Optional[str], pydantic.Field(alias="splunkHecAPI")] = (
        None
    )
    r"""Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable."""

    splunk_hec_acks: Annotated[
        Optional[bool], pydantic.Field(alias="splunkHecAcks")
    ] = None

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    auth_tokens_ext: Annotated[
        Optional[List[ItemsTypeAuthTokensExt]], pydantic.Field(alias="authTokensExt")
    ] = None
    r"""Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted."""

    description: Optional[str] = None

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    template_splunk_hec_api: Annotated[
        Optional[str], pydantic.Field(alias="__template_splunkHecAPI")
    ] = None
    r"""Binds 'splunkHecAPI' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'splunkHecAPI' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authTokens",
                "tls",
                "maxActiveReq",
                "maxRequestsPerSocket",
                "enableProxyHeader",
                "captureHeaders",
                "activityLogSampleRate",
                "requestTimeout",
                "socketTimeout",
                "keepAliveTimeout",
                "enableHealthCheck",
                "ipAllowlistRegex",
                "ipDenylistRegex",
                "criblAPI",
                "elasticAPI",
                "splunkHecAPI",
                "splunkHecAcks",
                "metadata",
                "authTokensExt",
                "description",
                "__template_host",
                "__template_port",
                "__template_splunkHecAPI",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeMsk(str, Enum):
    MSK = "msk"


class CreateInputSystemByPackInputMskTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeMsk
    brokers: List[str]
    r"""Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092)."""
    topics: List[str]
    r"""Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only."""
    aws_authentication_method: AuthenticationMethodOptionsS3CollectorConf
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    region: str
    r"""Region where the MSK cluster is located"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    group_id: NotRequired[str]
    r"""The consumer group to which this instance belongs. Defaults to 'Cribl'."""
    from_beginning: NotRequired[bool]
    r"""Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message"""
    session_timeout: NotRequired[float]
    r"""
    Timeout used to detect client failures when using Kafka's group-management facilities.
    If the client sends no heartbeats to the broker before the timeout expires,
    the broker will remove the client from the group and initiate a rebalance.
    Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
    """
    rebalance_timeout: NotRequired[float]
    r"""Maximum allowed time for each worker to join the group after a rebalance begins.
    If the timeout is exceeded, the coordinator broker will remove the worker from the group.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
    """
    heartbeat_interval: NotRequired[float]
    r"""Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
    Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
    """
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    kafka_schema_registry: NotRequired[KafkaSchemaRegistryAuthenticationTypeTypedDict]
    connection_timeout: NotRequired[float]
    r"""Maximum time to wait for a connection to complete successfully"""
    request_timeout: NotRequired[float]
    r"""Maximum time to wait for Kafka to respond to a request"""
    max_retries: NotRequired[float]
    r"""If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data"""
    max_back_off: NotRequired[float]
    r"""The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds)."""
    initial_backoff: NotRequired[float]
    r"""Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes)."""
    backoff_rate: NotRequired[float]
    r"""Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details."""
    authentication_timeout: NotRequired[float]
    r"""Maximum time to wait for Kafka to respond to an authentication request"""
    reauthentication_threshold: NotRequired[float]
    r"""Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire."""
    aws_secret_key: NotRequired[str]
    endpoint: NotRequired[str]
    r"""MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access MSK"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    tls: NotRequired[TLSSettingsClientSideTypeKafkaSchemaRegistryTypedDict]
    auto_commit_interval: NotRequired[float]
    r"""How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""
    auto_commit_threshold: NotRequired[float]
    r"""How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""
    max_bytes_per_partition: NotRequired[float]
    r"""Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB)."""
    max_bytes: NotRequired[float]
    r"""Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB)."""
    max_socket_errors: NotRequired[float]
    r"""Maximum number of network errors before the consumer re-creates a socket"""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""


class CreateInputSystemByPackInputMsk(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeMsk

    brokers: List[str]
    r"""Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092)."""

    topics: List[str]
    r"""Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only."""

    aws_authentication_method: Annotated[
        AuthenticationMethodOptionsS3CollectorConf,
        pydantic.Field(alias="awsAuthenticationMethod"),
    ]
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    region: str
    r"""Region where the MSK cluster is located"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    group_id: Annotated[Optional[str], pydantic.Field(alias="groupId")] = None
    r"""The consumer group to which this instance belongs. Defaults to 'Cribl'."""

    from_beginning: Annotated[Optional[bool], pydantic.Field(alias="fromBeginning")] = (
        None
    )
    r"""Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message"""

    session_timeout: Annotated[
        Optional[float], pydantic.Field(alias="sessionTimeout")
    ] = None
    r"""
    Timeout used to detect client failures when using Kafka's group-management facilities.
    If the client sends no heartbeats to the broker before the timeout expires,
    the broker will remove the client from the group and initiate a rebalance.
    Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
    """

    rebalance_timeout: Annotated[
        Optional[float], pydantic.Field(alias="rebalanceTimeout")
    ] = None
    r"""Maximum allowed time for each worker to join the group after a rebalance begins.
    If the timeout is exceeded, the coordinator broker will remove the worker from the group.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
    """

    heartbeat_interval: Annotated[
        Optional[float], pydantic.Field(alias="heartbeatInterval")
    ] = None
    r"""Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
    Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
    """

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    kafka_schema_registry: Annotated[
        Optional[KafkaSchemaRegistryAuthenticationType],
        pydantic.Field(alias="kafkaSchemaRegistry"),
    ] = None

    connection_timeout: Annotated[
        Optional[float], pydantic.Field(alias="connectionTimeout")
    ] = None
    r"""Maximum time to wait for a connection to complete successfully"""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""Maximum time to wait for Kafka to respond to a request"""

    max_retries: Annotated[Optional[float], pydantic.Field(alias="maxRetries")] = None
    r"""If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data"""

    max_back_off: Annotated[Optional[float], pydantic.Field(alias="maxBackOff")] = None
    r"""The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds)."""

    initial_backoff: Annotated[
        Optional[float], pydantic.Field(alias="initialBackoff")
    ] = None
    r"""Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes)."""

    backoff_rate: Annotated[Optional[float], pydantic.Field(alias="backoffRate")] = None
    r"""Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details."""

    authentication_timeout: Annotated[
        Optional[float], pydantic.Field(alias="authenticationTimeout")
    ] = None
    r"""Maximum time to wait for Kafka to respond to an authentication request"""

    reauthentication_threshold: Annotated[
        Optional[float], pydantic.Field(alias="reauthenticationThreshold")
    ] = None
    r"""Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    endpoint: Optional[str] = None
    r"""MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptions], pydantic.Field(alias="signatureVersion")
    ] = None
    r"""Signature version to use for signing MSK cluster requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access MSK"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    tls: Optional[TLSSettingsClientSideTypeKafkaSchemaRegistry] = None

    auto_commit_interval: Annotated[
        Optional[float], pydantic.Field(alias="autoCommitInterval")
    ] = None
    r"""How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""

    auto_commit_threshold: Annotated[
        Optional[float], pydantic.Field(alias="autoCommitThreshold")
    ] = None
    r"""How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""

    max_bytes_per_partition: Annotated[
        Optional[float], pydantic.Field(alias="maxBytesPerPartition")
    ] = None
    r"""Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB)."""

    max_bytes: Annotated[Optional[float], pydantic.Field(alias="maxBytes")] = None
    r"""Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB)."""

    max_socket_errors: Annotated[
        Optional[float], pydantic.Field(alias="maxSocketErrors")
    ] = None
    r"""Maximum number of network errors before the consumer re-creates a socket"""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "groupId",
                "fromBeginning",
                "sessionTimeout",
                "rebalanceTimeout",
                "heartbeatInterval",
                "metadata",
                "kafkaSchemaRegistry",
                "connectionTimeout",
                "requestTimeout",
                "maxRetries",
                "maxBackOff",
                "initialBackoff",
                "backoffRate",
                "authenticationTimeout",
                "reauthenticationThreshold",
                "awsSecretKey",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "tls",
                "autoCommitInterval",
                "autoCommitThreshold",
                "maxBytesPerPartition",
                "maxBytes",
                "maxSocketErrors",
                "description",
                "awsApiKey",
                "awsSecret",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
                "__template_awsApiKey",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeKafka(str, Enum):
    KAFKA = "kafka"


class CreateInputSystemByPackInputKafkaTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeKafka
    brokers: List[str]
    r"""Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092)."""
    topics: List[str]
    r"""Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only."""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    group_id: NotRequired[str]
    r"""The consumer group to which this instance belongs. Defaults to 'Cribl'."""
    from_beginning: NotRequired[bool]
    r"""Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message"""
    kafka_schema_registry: NotRequired[KafkaSchemaRegistryAuthenticationTypeTypedDict]
    connection_timeout: NotRequired[float]
    r"""Maximum time to wait for a connection to complete successfully"""
    request_timeout: NotRequired[float]
    r"""Maximum time to wait for Kafka to respond to a request"""
    max_retries: NotRequired[float]
    r"""If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data"""
    max_back_off: NotRequired[float]
    r"""The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds)."""
    initial_backoff: NotRequired[float]
    r"""Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes)."""
    backoff_rate: NotRequired[float]
    r"""Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details."""
    authentication_timeout: NotRequired[float]
    r"""Maximum time to wait for Kafka to respond to an authentication request"""
    reauthentication_threshold: NotRequired[float]
    r"""Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire."""
    sasl: NotRequired[AuthenticationTypeTypedDict]
    r"""Authentication parameters to use when connecting to brokers. Using TLS is highly recommended."""
    tls: NotRequired[TLSSettingsClientSideTypeKafkaSchemaRegistryTypedDict]
    session_timeout: NotRequired[float]
    r"""
    Timeout used to detect client failures when using Kafka's group-management facilities.
    If the client sends no heartbeats to the broker before the timeout expires,
    the broker will remove the client from the group and initiate a rebalance.
    Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
    """
    rebalance_timeout: NotRequired[float]
    r"""Maximum allowed time for each worker to join the group after a rebalance begins.
    If the timeout is exceeded, the coordinator broker will remove the worker from the group.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
    """
    heartbeat_interval: NotRequired[float]
    r"""Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
    Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
    """
    auto_commit_interval: NotRequired[float]
    r"""How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""
    auto_commit_threshold: NotRequired[float]
    r"""How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""
    max_bytes_per_partition: NotRequired[float]
    r"""Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB)."""
    max_bytes: NotRequired[float]
    r"""Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB)."""
    max_socket_errors: NotRequired[float]
    r"""Maximum number of network errors before the consumer re-creates a socket"""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]


class CreateInputSystemByPackInputKafka(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeKafka

    brokers: List[str]
    r"""Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092)."""

    topics: List[str]
    r"""Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only."""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    group_id: Annotated[Optional[str], pydantic.Field(alias="groupId")] = None
    r"""The consumer group to which this instance belongs. Defaults to 'Cribl'."""

    from_beginning: Annotated[Optional[bool], pydantic.Field(alias="fromBeginning")] = (
        None
    )
    r"""Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message"""

    kafka_schema_registry: Annotated[
        Optional[KafkaSchemaRegistryAuthenticationType],
        pydantic.Field(alias="kafkaSchemaRegistry"),
    ] = None

    connection_timeout: Annotated[
        Optional[float], pydantic.Field(alias="connectionTimeout")
    ] = None
    r"""Maximum time to wait for a connection to complete successfully"""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""Maximum time to wait for Kafka to respond to a request"""

    max_retries: Annotated[Optional[float], pydantic.Field(alias="maxRetries")] = None
    r"""If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data"""

    max_back_off: Annotated[Optional[float], pydantic.Field(alias="maxBackOff")] = None
    r"""The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds)."""

    initial_backoff: Annotated[
        Optional[float], pydantic.Field(alias="initialBackoff")
    ] = None
    r"""Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes)."""

    backoff_rate: Annotated[Optional[float], pydantic.Field(alias="backoffRate")] = None
    r"""Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details."""

    authentication_timeout: Annotated[
        Optional[float], pydantic.Field(alias="authenticationTimeout")
    ] = None
    r"""Maximum time to wait for Kafka to respond to an authentication request"""

    reauthentication_threshold: Annotated[
        Optional[float], pydantic.Field(alias="reauthenticationThreshold")
    ] = None
    r"""Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire."""

    sasl: Optional[AuthenticationType] = None
    r"""Authentication parameters to use when connecting to brokers. Using TLS is highly recommended."""

    tls: Optional[TLSSettingsClientSideTypeKafkaSchemaRegistry] = None

    session_timeout: Annotated[
        Optional[float], pydantic.Field(alias="sessionTimeout")
    ] = None
    r"""
    Timeout used to detect client failures when using Kafka's group-management facilities.
    If the client sends no heartbeats to the broker before the timeout expires,
    the broker will remove the client from the group and initiate a rebalance.
    Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
    """

    rebalance_timeout: Annotated[
        Optional[float], pydantic.Field(alias="rebalanceTimeout")
    ] = None
    r"""Maximum allowed time for each worker to join the group after a rebalance begins.
    If the timeout is exceeded, the coordinator broker will remove the worker from the group.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
    """

    heartbeat_interval: Annotated[
        Optional[float], pydantic.Field(alias="heartbeatInterval")
    ] = None
    r"""Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
    Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
    See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
    """

    auto_commit_interval: Annotated[
        Optional[float], pydantic.Field(alias="autoCommitInterval")
    ] = None
    r"""How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""

    auto_commit_threshold: Annotated[
        Optional[float], pydantic.Field(alias="autoCommitThreshold")
    ] = None
    r"""How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch."""

    max_bytes_per_partition: Annotated[
        Optional[float], pydantic.Field(alias="maxBytesPerPartition")
    ] = None
    r"""Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB)."""

    max_bytes: Annotated[Optional[float], pydantic.Field(alias="maxBytes")] = None
    r"""Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB)."""

    max_socket_errors: Annotated[
        Optional[float], pydantic.Field(alias="maxSocketErrors")
    ] = None
    r"""Maximum number of network errors before the consumer re-creates a socket"""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "groupId",
                "fromBeginning",
                "kafkaSchemaRegistry",
                "connectionTimeout",
                "requestTimeout",
                "maxRetries",
                "maxBackOff",
                "initialBackoff",
                "backoffRate",
                "authenticationTimeout",
                "reauthenticationThreshold",
                "sasl",
                "tls",
                "sessionTimeout",
                "rebalanceTimeout",
                "heartbeatInterval",
                "autoCommitInterval",
                "autoCommitThreshold",
                "maxBytesPerPartition",
                "maxBytes",
                "maxSocketErrors",
                "metadata",
                "description",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateInputSystemByPackTypeCollection(str, Enum):
    COLLECTION = "collection"


class CreateInputSystemByPackInputCollectionTypedDict(TypedDict):
    id: str
    r"""Unique ID for this input"""
    type: CreateInputSystemByPackTypeCollection
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process results"""
    send_to_routes: NotRequired[bool]
    r"""Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    breaker_rulesets: NotRequired[List[str]]
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""
    stale_channel_flush_ms: NotRequired[float]
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""
    preprocess: NotRequired[PreprocessTypeTypedDict]
    throttle_rate_per_sec: NotRequired[str]
    r"""Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    output: NotRequired[str]
    r"""Destination to send results to"""


class CreateInputSystemByPackInputCollection(BaseModel):
    id: str
    r"""Unique ID for this input"""

    type: CreateInputSystemByPackTypeCollection

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process results"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    breaker_rulesets: Annotated[
        Optional[List[str]], pydantic.Field(alias="breakerRulesets")
    ] = None
    r"""A list of event-breaking rulesets that will be applied, in order, to the input data stream"""

    stale_channel_flush_ms: Annotated[
        Optional[float], pydantic.Field(alias="staleChannelFlushMs")
    ] = None
    r"""How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines"""

    preprocess: Optional[PreprocessType] = None

    throttle_rate_per_sec: Annotated[
        Optional[str], pydantic.Field(alias="throttleRatePerSec")
    ] = None
    r"""Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    output: Optional[str] = None
    r"""Destination to send results to"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "breakerRulesets",
                "staleChannelFlushMs",
                "preprocess",
                "throttleRatePerSec",
                "metadata",
                "output",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateInputSystemByPackRequestBodyTypedDict = TypeAliasType(
    "CreateInputSystemByPackRequestBodyTypedDict",
    Union[
        CreateInputSystemByPackInputDatagenTypedDict,
        CreateInputSystemByPackInputCriblTypedDict,
        CreateInputSystemByPackInputKubeEventsTypedDict,
        CreateInputSystemByPackInputCriblmetricsTypedDict,
        CreateInputSystemByPackInputKubeMetricsTypedDict,
        CreateInputSystemByPackInputCollectionTypedDict,
        CreateInputSystemByPackInputSystemStateTypedDict,
        CreateInputSystemByPackInputWindowsMetricsTypedDict,
        CreateInputSystemByPackInputSystemMetricsTypedDict,
        CreateInputSystemByPackInputJournalFilesTypedDict,
        CreateInputSystemByPackInputExecTypedDict,
        CreateInputSystemByPackInputKubeLogsTypedDict,
        CreateInputSystemByPackInputModelDrivenTelemetryTypedDict,
        CreateInputSystemByPackInputRawUDPTypedDict,
        CreateInputSystemByPackInputWinEventLogsTypedDict,
        CreateInputSystemByPackInputSnmpTypedDict,
        CreateInputSystemByPackInputMetricsTypedDict,
        CreateInputSystemByPackInputCriblTCPTypedDict,
        CreateInputSystemByPackInputNetflowTypedDict,
        CreateInputSystemByPackInputTcpjsonTypedDict,
        CreateInputSystemByPackInputGooglePubsubTypedDict,
        CreateInputSystemByPackInputFirehoseTypedDict,
        CreateInputSystemByPackInputWizTypedDict,
        CreateInputSystemByPackInputOffice365ServiceTypedDict,
        CreateInputSystemByPackInputCriblHTTPTypedDict,
        CreateInputSystemByPackInputTCPTypedDict,
        CreateInputSystemByPackInputDatadogAgentTypedDict,
        CreateInputSystemByPackInputFileTypedDict,
        CreateInputSystemByPackInputSplunkTypedDict,
        CreateInputSystemByPackInputOffice365MgmtTypedDict,
        CreateInputSystemByPackInputAppscopeTypedDict,
        CreateInputSystemByPackInputWefTypedDict,
        CreateInputSystemByPackInputWizWebhookTypedDict,
        CreateInputSystemByPackInputHTTPRawTypedDict,
        CreateInputSystemByPackInputKafkaTypedDict,
        CreateInputSystemByPackInputHTTPTypedDict,
        CreateInputSystemByPackInputEventhubTypedDict,
        CreateInputSystemByPackInputCriblLakeHTTPTypedDict,
        CreateInputSystemByPackInputConfluentCloudTypedDict,
        CreateInputSystemByPackInputLokiTypedDict,
        CreateInputSystemByPackInputPrometheusRwTypedDict,
        CreateInputSystemByPackInputCloudflareHecTypedDict,
        CreateInputSystemByPackInputZscalerHecTypedDict,
        CreateInputSystemByPackInputAzureBlobTypedDict,
        CreateInputSystemByPackInputElasticTypedDict,
        CreateInputSystemByPackInputSplunkSearchTypedDict,
        CreateInputSystemByPackInputOpenTelemetryTypedDict,
        CreateInputSystemByPackInputSqsTypedDict,
        CreateInputSystemByPackInputKinesisTypedDict,
        CreateInputSystemByPackInputSplunkHecTypedDict,
        CreateInputSystemByPackInputOffice365MsgTraceTypedDict,
        CreateInputSystemByPackInputEdgePrometheusTypedDict,
        CreateInputSystemByPackInputCrowdstrikeTypedDict,
        CreateInputSystemByPackInputMskTypedDict,
        CreateInputSystemByPackInputS3TypedDict,
        CreateInputSystemByPackInputPrometheusTypedDict,
        CreateInputSystemByPackInputSecurityLakeTypedDict,
        CreateInputSystemByPackInputS3InventoryTypedDict,
        CreateInputSystemByPackInputSyslogUnionTypedDict,
        CreateInputSystemByPackInputGrafanaUnionTypedDict,
    ],
)
r"""Input object"""


CreateInputSystemByPackRequestBody = Annotated[
    Union[
        Annotated[CreateInputSystemByPackInputCollection, Tag("collection")],
        Annotated[CreateInputSystemByPackInputKafka, Tag("kafka")],
        Annotated[CreateInputSystemByPackInputMsk, Tag("msk")],
        Annotated[CreateInputSystemByPackInputHTTP, Tag("http")],
        Annotated[CreateInputSystemByPackInputSplunk, Tag("splunk")],
        Annotated[CreateInputSystemByPackInputSplunkSearch, Tag("splunk_search")],
        Annotated[CreateInputSystemByPackInputSplunkHec, Tag("splunk_hec")],
        Annotated[CreateInputSystemByPackInputAzureBlob, Tag("azure_blob")],
        Annotated[CreateInputSystemByPackInputElastic, Tag("elastic")],
        Annotated[CreateInputSystemByPackInputConfluentCloud, Tag("confluent_cloud")],
        Annotated[CreateInputSystemByPackInputGrafanaUnion, Tag("grafana")],
        Annotated[CreateInputSystemByPackInputLoki, Tag("loki")],
        Annotated[CreateInputSystemByPackInputPrometheusRw, Tag("prometheus_rw")],
        Annotated[CreateInputSystemByPackInputPrometheus, Tag("prometheus")],
        Annotated[CreateInputSystemByPackInputEdgePrometheus, Tag("edge_prometheus")],
        Annotated[CreateInputSystemByPackInputOffice365Mgmt, Tag("office365_mgmt")],
        Annotated[
            CreateInputSystemByPackInputOffice365Service, Tag("office365_service")
        ],
        Annotated[
            CreateInputSystemByPackInputOffice365MsgTrace, Tag("office365_msg_trace")
        ],
        Annotated[CreateInputSystemByPackInputEventhub, Tag("eventhub")],
        Annotated[CreateInputSystemByPackInputExec, Tag("exec")],
        Annotated[CreateInputSystemByPackInputFirehose, Tag("firehose")],
        Annotated[CreateInputSystemByPackInputGooglePubsub, Tag("google_pubsub")],
        Annotated[CreateInputSystemByPackInputCribl, Tag("cribl")],
        Annotated[CreateInputSystemByPackInputCriblTCP, Tag("cribl_tcp")],
        Annotated[CreateInputSystemByPackInputCriblHTTP, Tag("cribl_http")],
        Annotated[CreateInputSystemByPackInputCriblLakeHTTP, Tag("cribl_lake_http")],
        Annotated[CreateInputSystemByPackInputTcpjson, Tag("tcpjson")],
        Annotated[CreateInputSystemByPackInputSystemMetrics, Tag("system_metrics")],
        Annotated[CreateInputSystemByPackInputSystemState, Tag("system_state")],
        Annotated[CreateInputSystemByPackInputKubeMetrics, Tag("kube_metrics")],
        Annotated[CreateInputSystemByPackInputKubeLogs, Tag("kube_logs")],
        Annotated[CreateInputSystemByPackInputKubeEvents, Tag("kube_events")],
        Annotated[CreateInputSystemByPackInputWindowsMetrics, Tag("windows_metrics")],
        Annotated[CreateInputSystemByPackInputCrowdstrike, Tag("crowdstrike")],
        Annotated[CreateInputSystemByPackInputDatadogAgent, Tag("datadog_agent")],
        Annotated[CreateInputSystemByPackInputDatagen, Tag("datagen")],
        Annotated[CreateInputSystemByPackInputHTTPRaw, Tag("http_raw")],
        Annotated[CreateInputSystemByPackInputKinesis, Tag("kinesis")],
        Annotated[CreateInputSystemByPackInputCriblmetrics, Tag("criblmetrics")],
        Annotated[CreateInputSystemByPackInputMetrics, Tag("metrics")],
        Annotated[CreateInputSystemByPackInputS3, Tag("s3")],
        Annotated[CreateInputSystemByPackInputS3Inventory, Tag("s3_inventory")],
        Annotated[CreateInputSystemByPackInputSnmp, Tag("snmp")],
        Annotated[CreateInputSystemByPackInputOpenTelemetry, Tag("open_telemetry")],
        Annotated[
            CreateInputSystemByPackInputModelDrivenTelemetry,
            Tag("model_driven_telemetry"),
        ],
        Annotated[CreateInputSystemByPackInputSqs, Tag("sqs")],
        Annotated[CreateInputSystemByPackInputSyslogUnion, Tag("syslog")],
        Annotated[CreateInputSystemByPackInputFile, Tag("file")],
        Annotated[CreateInputSystemByPackInputTCP, Tag("tcp")],
        Annotated[CreateInputSystemByPackInputAppscope, Tag("appscope")],
        Annotated[CreateInputSystemByPackInputWef, Tag("wef")],
        Annotated[CreateInputSystemByPackInputWinEventLogs, Tag("win_event_logs")],
        Annotated[CreateInputSystemByPackInputRawUDP, Tag("raw_udp")],
        Annotated[CreateInputSystemByPackInputJournalFiles, Tag("journal_files")],
        Annotated[CreateInputSystemByPackInputWiz, Tag("wiz")],
        Annotated[CreateInputSystemByPackInputWizWebhook, Tag("wiz_webhook")],
        Annotated[CreateInputSystemByPackInputNetflow, Tag("netflow")],
        Annotated[CreateInputSystemByPackInputSecurityLake, Tag("security_lake")],
        Annotated[CreateInputSystemByPackInputZscalerHec, Tag("zscaler_hec")],
        Annotated[CreateInputSystemByPackInputCloudflareHec, Tag("cloudflare_hec")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]
r"""Input object"""


class CreateInputSystemByPackRequestTypedDict(TypedDict):
    pack: str
    r"""The <code>id</code> of the Pack to create."""
    request_body: CreateInputSystemByPackRequestBodyTypedDict
    r"""Input object"""


class CreateInputSystemByPackRequest(BaseModel):
    pack: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The <code>id</code> of the Pack to create."""

    request_body: Annotated[
        CreateInputSystemByPackRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]
    r"""Input object"""
