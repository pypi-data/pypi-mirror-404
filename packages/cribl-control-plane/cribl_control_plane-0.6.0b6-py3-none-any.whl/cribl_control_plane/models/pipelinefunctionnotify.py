"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class PipelineFunctionNotifyID(str, Enum):
    r"""Function ID"""

    NOTIFY = "notify"


class TriggerType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of the trigger condition. custom applies a kusto expression over the results, and results count applies a comparison over results count"""

    # Where
    CUSTOM = "custom"
    # Count of Results
    RESULTS_COUNT = "resultsCount"


class CountComparator(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Operation to be applied over the results count"""

    # greater than
    GREATER_THAN_ = ">"
    # less than
    LESS_THAN_ = "<"
    # equals
    EQUAL_EQUAL_EQUAL_ = "==="
    # not equal to
    NOT_EQUAL_EQUAL_ = "!=="
    # greater than or equal to
    GREATER_THAN_EQUAL_ = ">="
    # less than or equal to
    LESS_THAN_EQUAL_ = "<="


class NotifyConfigurationTypedDict(TypedDict):
    group: str
    r"""Group the notification belongs to"""
    notification_id: str
    r"""Workspace within the deployment to send the search results to."""
    search_id: str
    r"""Id of the search this function is running on."""
    saved_query_id: str
    r"""Id of the saved query"""
    search_url: str
    r"""Url of the search results"""
    auth_token: str
    r"""Auth token for sending notification messages"""
    messages_endpoint: str
    r"""System messages api endpoint"""
    trigger: NotRequired[str]
    r"""Js expression that filters events, a greater than 'Trigger Count' events will trigger the notification"""
    trigger_type: NotRequired[TriggerType]
    r"""Type of the trigger condition. custom applies a kusto expression over the results, and results count applies a comparison over results count"""
    trigger_comparator: NotRequired[CountComparator]
    r"""Operation to be applied over the results count"""
    trigger_count: NotRequired[float]
    r"""How many results that match trigger the condition"""
    results_limit: NotRequired[float]
    r"""Number of results to include in the notification event"""
    message: NotRequired[str]
    r"""Message content template, available fields: searchId, resultSet, savedQueryId, notificationId, searchResultsUrl"""
    tenant_id: NotRequired[str]
    r"""Current tenant id"""


class NotifyConfiguration(BaseModel):
    group: str
    r"""Group the notification belongs to"""

    notification_id: Annotated[str, pydantic.Field(alias="notificationId")]
    r"""Workspace within the deployment to send the search results to."""

    search_id: Annotated[str, pydantic.Field(alias="searchId")]
    r"""Id of the search this function is running on."""

    saved_query_id: Annotated[str, pydantic.Field(alias="savedQueryId")]
    r"""Id of the saved query"""

    search_url: Annotated[str, pydantic.Field(alias="searchUrl")]
    r"""Url of the search results"""

    auth_token: Annotated[str, pydantic.Field(alias="authToken")]
    r"""Auth token for sending notification messages"""

    messages_endpoint: Annotated[str, pydantic.Field(alias="messagesEndpoint")]
    r"""System messages api endpoint"""

    trigger: Optional[str] = None
    r"""Js expression that filters events, a greater than 'Trigger Count' events will trigger the notification"""

    trigger_type: Annotated[
        Optional[TriggerType], pydantic.Field(alias="triggerType")
    ] = None
    r"""Type of the trigger condition. custom applies a kusto expression over the results, and results count applies a comparison over results count"""

    trigger_comparator: Annotated[
        Optional[CountComparator], pydantic.Field(alias="triggerComparator")
    ] = None
    r"""Operation to be applied over the results count"""

    trigger_count: Annotated[Optional[float], pydantic.Field(alias="triggerCount")] = (
        None
    )
    r"""How many results that match trigger the condition"""

    results_limit: Annotated[Optional[float], pydantic.Field(alias="resultsLimit")] = (
        None
    )
    r"""Number of results to include in the notification event"""

    message: Optional[str] = None
    r"""Message content template, available fields: searchId, resultSet, savedQueryId, notificationId, searchResultsUrl"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Current tenant id"""

    @field_serializer("trigger_type")
    def serialize_trigger_type(self, value):
        if isinstance(value, str):
            try:
                return models.TriggerType(value)
            except ValueError:
                return value
        return value

    @field_serializer("trigger_comparator")
    def serialize_trigger_comparator(self, value):
        if isinstance(value, str):
            try:
                return models.CountComparator(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "trigger",
                "triggerType",
                "triggerComparator",
                "triggerCount",
                "resultsLimit",
                "message",
                "tenantId",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PipelineFunctionNotifyTypedDict(TypedDict):
    id: PipelineFunctionNotifyID
    r"""Function ID"""
    conf: NotifyConfigurationTypedDict
    filter_: NotRequired[str]
    r"""Filter that selects data to be fed through this Function"""
    description: NotRequired[str]
    r"""Simple description of this step"""
    disabled: NotRequired[bool]
    r"""If true, data will not be pushed through this function"""
    final: NotRequired[bool]
    r"""If enabled, stops the results of this Function from being passed to the downstream Functions"""
    group_id: NotRequired[str]
    r"""Group ID"""


class PipelineFunctionNotify(BaseModel):
    id: PipelineFunctionNotifyID
    r"""Function ID"""

    conf: NotifyConfiguration

    filter_: Annotated[Optional[str], pydantic.Field(alias="filter")] = None
    r"""Filter that selects data to be fed through this Function"""

    description: Optional[str] = None
    r"""Simple description of this step"""

    disabled: Optional[bool] = None
    r"""If true, data will not be pushed through this function"""

    final: Optional[bool] = None
    r"""If enabled, stops the results of this Function from being passed to the downstream Functions"""

    group_id: Annotated[Optional[str], pydantic.Field(alias="groupId")] = None
    r"""Group ID"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["filter", "description", "disabled", "final", "groupId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
