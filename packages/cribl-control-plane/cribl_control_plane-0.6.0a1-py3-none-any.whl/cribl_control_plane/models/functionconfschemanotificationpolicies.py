"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .itemstypepoliciesitemstemplatetargetpairs import (
    ItemsTypePoliciesItemsTemplateTargetPairs,
    ItemsTypePoliciesItemsTemplateTargetPairsTypedDict,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class Operator(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Comparison operator"""

    EQUAL = "="
    NOT_EQUAL = "!="
    REGEX_MATCH = "=~"
    REGEX_NOT_MATCH = "!~"


ValueTypedDict = TypeAliasType("ValueTypedDict", Union[str, float, bool])
r"""Value to compare against (string, number, boolean)"""


Value = TypeAliasType("Value", Union[str, float, bool])
r"""Value to compare against (string, number, boolean)"""


class ConditionTypedDict(TypedDict):
    key: str
    r"""Event field name to match against"""
    operator: Operator
    r"""Comparison operator"""
    value: ValueTypedDict
    r"""Value to compare against (string, number, boolean)"""


class Condition(BaseModel):
    key: str
    r"""Event field name to match against"""

    operator: Operator
    r"""Comparison operator"""

    value: Value
    r"""Value to compare against (string, number, boolean)"""

    @field_serializer("operator")
    def serialize_operator(self, value):
        if isinstance(value, str):
            try:
                return models.Operator(value)
            except ValueError:
                return value
        return value


class PolicyTypedDict(TypedDict):
    id: str
    r"""Unique identifier for this policy"""
    template_target_pairs: List[ItemsTypePoliciesItemsTemplateTargetPairsTypedDict]
    r"""List of targets to route to and the templates to use"""
    order: float
    r"""Evaluation order of this policy (lower numbers evaluated first)"""
    disabled: NotRequired[bool]
    r"""If true, this policy will be skipped during evaluation"""
    wait_to_group: NotRequired[float]
    r"""Time to wait (in minutes) to group similar alerts before sending"""
    group_by_labels: NotRequired[List[str]]
    r"""Event fields to use for grouping"""
    conditions: NotRequired[List[List[ConditionTypedDict]]]
    r"""List of conditions. If ANY condition matches (OR), the policy applies. Each condition is a list of tags that must ALL match (AND)."""
    final: NotRequired[bool]
    r"""If true, stop evaluating further policies after this one matches"""


class Policy(BaseModel):
    id: str
    r"""Unique identifier for this policy"""

    template_target_pairs: Annotated[
        List[ItemsTypePoliciesItemsTemplateTargetPairs],
        pydantic.Field(alias="templateTargetPairs"),
    ]
    r"""List of targets to route to and the templates to use"""

    order: float
    r"""Evaluation order of this policy (lower numbers evaluated first)"""

    disabled: Optional[bool] = None
    r"""If true, this policy will be skipped during evaluation"""

    wait_to_group: Annotated[Optional[float], pydantic.Field(alias="waitToGroup")] = (
        None
    )
    r"""Time to wait (in minutes) to group similar alerts before sending"""

    group_by_labels: Annotated[
        Optional[List[str]], pydantic.Field(alias="groupByLabels")
    ] = None
    r"""Event fields to use for grouping"""

    conditions: Optional[List[List[Condition]]] = None
    r"""List of conditions. If ANY condition matches (OR), the policy applies. Each condition is a list of tags that must ALL match (AND)."""

    final: Optional[bool] = None
    r"""If true, stop evaluating further policies after this one matches"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["disabled", "waitToGroup", "groupByLabels", "conditions", "final"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FunctionConfSchemaNotificationPoliciesTypedDict(TypedDict):
    policies: NotRequired[List[PolicyTypedDict]]
    r"""List of notification routing policies evaluated in order"""


class FunctionConfSchemaNotificationPolicies(BaseModel):
    policies: Optional[List[Policy]] = None
    r"""List of notification routing policies evaluated in order"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["policies"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
