"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

import hashlib
import httpx
import threading
import time
from .types import (
    SDKInitHook,
    BeforeRequestContext,
    BeforeRequestHook,
    AfterErrorContext,
    AfterErrorHook,
    HookContext,
)
from typing import Any, ClassVar, Dict, List, Tuple, Union, Optional
from urllib.parse import urlparse, urljoin
from cribl_control_plane.httpclient import HttpClient
from cribl_control_plane.sdkconfiguration import SDKConfiguration


class Credentials:
    client_id: str
    client_secret: str
    token_url: str
    scopes: Optional[List[str]]
    additional_properties: Dict[str, str]

    def __init__(
        self,
        client_id: str,
        client_secret: str,
        token_url: str,
        scopes: Optional[List[str]],
        additional_properties: Optional[Dict[str, str]] = None,
    ):
        self.client_id = client_id
        self.client_secret = client_secret
        self.token_url = token_url
        self.scopes = scopes
        self.additional_properties = additional_properties or {}


class Session:
    credentials: Credentials
    token: str
    scopes: List[str]
    expires_at: Optional[int] = None

    def __init__(
        self,
        credentials: Credentials,
        token: str,
        scopes: List[str],
        expires_at: Optional[int] = None,
    ):
        self.credentials = credentials
        self.token = token
        self.scopes = scopes
        self.expires_at = expires_at


class ClientCredentialsHook(SDKInitHook, BeforeRequestHook, AfterErrorHook):
    client: HttpClient
    _global_lock: ClassVar[threading.Lock] = threading.Lock()
    _client_locks: ClassVar[Dict[str, threading.Lock]] = {}
    _sessions: ClassVar[Dict[str, Dict[str, Session]]] = {}

    @classmethod
    def _get_client_lock(cls, client_key: str) -> threading.Lock:
        """Get or create a lock for a specific client key (thread-safe)."""
        with cls._global_lock:
            if client_key not in cls._client_locks:
                cls._client_locks[client_key] = threading.Lock()
            return cls._client_locks[client_key]

    def sdk_init(self, config: SDKConfiguration) -> SDKConfiguration:
        if config.client is None:
            raise Exception("Client is required")

        self.client = config.client
        return config

    def before_request(
        self, hook_ctx: BeforeRequestContext, request: httpx.Request
    ) -> httpx.Request:
        if self.is_hook_disabled(hook_ctx):
            return request

        credentials = self.get_credentials(hook_ctx)
        if credentials is None:
            return request

        session_key = self.get_session_key(
            credentials.client_id, credentials.client_secret
        )

        scopes = self.get_required_scopes(credentials, hook_ctx)
        session = self.get_existing_session(session_key, scopes)

        if session is None:
            # Create new session
            session = self.do_token_request(
                hook_ctx,
                credentials,
                scopes,
            )

            self._store_session(session_key, scopes, session)

        request.headers["Authorization"] = f"Bearer {session.token}"

        return request

    def after_error(
        self,
        hook_ctx: AfterErrorContext,
        response: Optional[httpx.Response],
        error: Optional[Exception],
    ) -> Union[Tuple[Optional[httpx.Response], Optional[Exception]], Exception]:
        if self.is_hook_disabled(hook_ctx):
            return (response, error)

        # We don't want to refresh the token if the error is not related to the token
        if error is not None:
            return (response, error)

        credentials = self.get_credentials(hook_ctx)
        if credentials is None:
            return (response, error)

        if response is not None and response.status_code == 401:
            session_key = self.get_session_key(
                credentials.client_id, credentials.client_secret
            )
            scopes = self.get_required_scopes(credentials, hook_ctx)
            scope_key = self.get_scope_key(scopes)
            self.remove_session(session_key, scope_key)

        return (response, error)

    def is_hook_disabled(self, hook_ctx: HookContext) -> bool:
        return hook_ctx.oauth2_scopes is None

    def get_credentials(self, hook_ctx: HookContext) -> Optional[Credentials]:
        source = hook_ctx.security_source

        if source is None:
            return None

        security = source() if callable(source) else source

        return self.get_credentials_global(security)

    def get_credentials_global(self, security: Any) -> Optional[Credentials]:
        if security is None or security.client_oauth is None:
            return None

        # Extract additional properties from security object
        additional_properties = {}
        for key, value in dict(security.client_oauth).items():
            if key not in ["client_id", "client_secret", "token_url", "scopes"]:
                additional_properties[key] = value

        return Credentials(
            client_id=security.client_oauth.client_id,
            client_secret=security.client_oauth.client_secret,
            token_url=security.client_oauth.token_url,
            scopes=None,
            additional_properties=additional_properties,
        )

    def do_token_request(
        self, hook_ctx: HookContext, credentials: Credentials, scopes: List[str]
    ) -> Session:
        payload = {
            "grant_type": "client_credentials",
            "client_id": credentials.client_id,
            "client_secret": credentials.client_secret,
        }

        if len(scopes) > 0:
            payload["scope"] = " ".join(scopes)

        # Add additional properties to payload
        for key, value in credentials.additional_properties.items():
            payload[key] = value

        token_url = credentials.token_url
        if not bool(urlparse(credentials.token_url).netloc):
            token_url = urljoin(hook_ctx.base_url, credentials.token_url)
        response = self.client.send(
            self.client.build_request(method="POST", url=token_url, data=payload)
        )

        if response.status_code < 200 or response.status_code >= 300:
            raise Exception(
                f"Unexpected status code {response.status_code} from token endpoint"
            )

        response_data = response.json()

        if response_data.get("token_type", "").lower() != "bearer":
            raise Exception("Unexpected token type from token endpoint")

        expires_at = None
        if "expires_in" in response_data:
            expires_at = int(time.time()) + response_data.get("expires_in")

        return Session(
            credentials=credentials,
            token=response_data.get("access_token"),
            scopes=scopes,
            expires_at=expires_at,
        )

    def get_session_key(self, client_id: str, client_secret: str) -> str:
        """Generate a consistent session key for the given client ID and secret."""
        return hashlib.md5(f"{client_id}:{client_secret}".encode()).hexdigest()

    def get_required_scopes(
        self, credentials: Credentials, hook_ctx: HookContext
    ) -> List[str]:
        """Return the list of scopes that need to be requested."""
        if credentials.scopes is not None:
            return credentials.scopes
        return hook_ctx.oauth2_scopes or []

    def get_scope_key(self, scopes: List[str]) -> str:
        """Generate a consistent scope key for the given scopes."""
        if not scopes:
            return ""

        sorted_scopes = sorted(scopes)
        return "&".join(sorted_scopes)

    def _store_session(
        self, client_key: str, scopes: List[str], session: Session
    ) -> None:
        """Store a session in the cache (thread-safe with per-client locking)."""
        scope_key = self.get_scope_key(scopes)
        lock = self._get_client_lock(client_key)
        with lock:
            if client_key not in self._sessions:
                self._sessions[client_key] = {}
            self._sessions[client_key][scope_key] = session

    def remove_session(self, client_key: str, scope_key: str) -> None:
        """Remove a session and clean up empty client session maps (thread-safe with per-client locking)."""
        lock = self._get_client_lock(client_key)
        with lock:
            if client_key in self._sessions and scope_key in self._sessions[client_key]:
                del self._sessions[client_key][scope_key]

                # Clean up empty client sessions
                if not self._sessions[client_key]:
                    del self._sessions[client_key]

    def get_existing_session(
        self, client_key: str, required_scopes: List[str]
    ) -> Optional[Session]:
        """Find the best session for the required scopes (thread-safe with per-client locking)."""
        scope_key = self.get_scope_key(required_scopes)
        expired_keys: List[str] = []
        result: Optional[Session] = None

        lock = self._get_client_lock(client_key)
        with lock:
            if client_key not in self._sessions:
                return None

            client_sessions = self._sessions[client_key]

            # Check for exact scope match first
            if scope_key in client_sessions:
                exact_match = client_sessions[scope_key]
                if self.has_token_expired(exact_match.expires_at):
                    expired_keys.append(scope_key)
                else:
                    result = exact_match

            # If no exact match, look for a superset match
            if result is None:
                for key, session in client_sessions.items():
                    if self.has_token_expired(session.expires_at):
                        expired_keys.append(key)
                    elif result is None and self.has_required_scopes(
                        session.scopes, required_scopes
                    ):
                        result = session

            # Clean up expired sessions (safe: we collected keys first, not iterating while modifying)
            for key in expired_keys:
                if key in client_sessions:
                    del client_sessions[key]

            # Clean up empty client sessions
            if client_key in self._sessions and not self._sessions[client_key]:
                del self._sessions[client_key]

        return result

    def has_required_scopes(
        self, scopes: List[str], required_scopes: List[str]
    ) -> bool:
        """Check if all required scopes are present in the given scopes."""
        return all(scope in scopes for scope in required_scopes)

    def has_token_expired(self, expires_at: Optional[int]) -> bool:
        """
        Check if the token has expired.
        If no expires_in field was returned by the authorization server, the token is considered to never expire.
        A 60-second buffer is applied to refresh tokens before they actually expire.
        """
        return expires_at is not None and time.time() + 60 >= expires_at
