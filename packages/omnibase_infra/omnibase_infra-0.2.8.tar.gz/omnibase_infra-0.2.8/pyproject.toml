[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
name = "omnibase_infra"
version = "0.2.8"
description = "ONEX Infrastructure - Service integration and database infrastructure tools"
authors = ["OmniNode Team <team@omninode.ai>"]
license = "MIT"
readme = "README.md"
packages = [{include = "omnibase_infra", from = "src"}]

[tool.poetry.scripts]
omni-infra = "omnibase_infra.cli.commands:cli"
onex-runtime = "omnibase_infra.runtime.kernel:main"
emit-daemon = "omnibase_infra.runtime.emit_daemon.cli:main"

[tool.poetry.dependencies]
python = "^3.12"

# ============================================================================
# ONEX Internal Dependencies (omnibase-core, omnibase-spi)
# ============================================================================
# Semantic versioning (^X.Y.Z) is appropriate for these packages because:
# - We control the release process and CI/CD validates compatibility
# - Breaking changes are communicated through semver major versions
# - Internal packages are co-developed with this codebase
#
# RELEASE STATUS: These packages are published to PyPI and version-pinned.
# - omnibase-core: https://pypi.org/project/omnibase-core/
# - omnibase-spi: https://pypi.org/project/omnibase-spi/
#
# PRE-RELEASE NOTE: If you need features from unreleased versions during
# development, use git dependencies (comment out PyPI version):
#   omnibase-core = { git = "https://github.com/org/omnibase_core.git", rev = "SHA" }
# Remember to switch back to PyPI versions before merging to main.
#
# omnibase-core v0.9.11: Version bump
omnibase-core = "^0.9.11"
# omnibase-spi v0.6.4: Version bump
omnibase-spi = "^0.6.4"

# ============================================================================
# External Dependency Security Guidance
# ============================================================================
# CURRENT STATE: All dependencies below are PyPI-sourced (no git dependencies).
#
# PyPI Dependencies (current - all deps below):
# - Version pinning (^X.Y.Z) is acceptable for trusted packages when:
#   1. Package is from established maintainers (PyPA, major OSS projects)
#   2. poetry.lock captures exact resolved versions for reproducibility
# - To update: 1) Review changelog for security fixes, 2) Update version, 3) Run tests
# - See docs/decisions/adr-cryptography-upgrade-46.md for upgrade rationale examples
#
# Git Dependencies (FUTURE guidance - not currently used):
# - If git-sourced external deps are added in the future, prefer commit SHAs over tags:
#   - SHAs are immutable; tags can be force-pushed
#   - SHAs provide audit trail and tamper-evidence

# Core dependencies
pydantic = "^2.11.7"
fastapi = "^0.120.1"
uvicorn = "^0.32.0"
pyyaml = "^6.0.2"
aiohttp = "^3.9.0"

# Database dependencies (for PostgreSQL connection manager)
asyncpg = "^0.29.0"
psycopg2-binary = "^2.9.10"

# Service integration dependencies (for the actual tools we're migrating)
python-consul = "^1.1.0"  # For Consul adapter tools
redis = "^6.0.0"  # For Redis/Valkey integration (redis-py 6.x required by omnibase_core)
aiokafka = "^0.11.0"  # For Kafka tools (async Python client)
confluent-kafka = "^2.12.0"  # For Kafka integration (C-based high-performance client)
hvac = "^2.1.0"  # For Vault adapter tools

# Vector and graph database dependencies (for Qdrant and Memgraph handlers)
qdrant-client = "^1.12.0"  # Vector database client for semantic search
neo4j = "^5.15.0"  # Bolt/Cypher client for Memgraph graph database

# CLI Dependencies
click = "^8.1.0"
rich = "^13.7.0"

# System utilities
# cryptography: Transitive dependency (via omnibase_core -> paramiko/pyopenssl).
# Explicitly declared here to enforce minimum version for security compliance.
# Constraint: ^46.0.3 means >=46.0.3, <47.0.0 (Poetry caret notation).
# Security: CVE-2024-26130 (42.0.4), CVE-2024-12797 (44.0.1) - both addressed by 46.x.
# See docs/decisions/adr-cryptography-upgrade-46.md for full rationale.
cryptography = "^46.0.3"
jinja2 = "^3.1.6"
aiofiles = "^23.2.1"
dependency-injector = "^4.48.1"  # Enhanced dependency injection

# Tracing and observability dependencies
sqlparse = "^0.4.4"  # For secure SQL query sanitization in tracing
structlog = "^23.2.0"  # Structured logging
prometheus-client = "^0.19.0"  # Metrics collection
opentelemetry-api = "^1.27.0"  # OpenTelemetry API
opentelemetry-sdk = "^1.27.0"  # OpenTelemetry SDK
opentelemetry-exporter-otlp = "^1.27.0"  # OTLP exporter
opentelemetry-instrumentation = "^0.48b0"  # Base instrumentation
opentelemetry-instrumentation-fastapi = "^0.48b0"  # FastAPI tracing
opentelemetry-instrumentation-asyncpg = "^0.48b0"  # AsyncPG tracing
opentelemetry-instrumentation-aiohttp-client = "^0.48b0"  # AIOHTTP tracing
opentelemetry-instrumentation-kafka-python = "^0.48b0"  # Kafka tracing
opentelemetry-instrumentation-redis = "^0.48b0"  # Redis tracing

# MCP (Model Context Protocol) integration
mcp = "^1.25.0"  # Anthropic MCP SDK for streamable HTTP transport

# Additional infrastructure dependencies
httpx = "^0.28.1"  # Modern HTTP client (>=0.27.1 required by MCP SDK)
tenacity = "^9.0.0"  # Retry and resilience patterns
circuitbreaker = "^2.0.0"  # Circuit breaker pattern
slowapi = "^0.1.9"  # Rate limiting
pydantic-settings = "^2.2.1"  # Settings management
jsonschema = "^4.20.0"  # JSON schema validation

[tool.poetry.group.dev.dependencies]
pytest = "^8.4.0"
pytest-asyncio = "^0.25.0"
pytest-mock = "^3.11.0"
pytest-cov = "^6.0.0"
pytest-xdist = "^3.5.0"  # Parallel test execution
pytest-timeout = "^2.3.0"  # Test timeout support
mypy = "^1.13.0"
ruff = "^0.14.7"  # Ruff handles both formatting and linting (replaces black + isort)
types-pyyaml = "^6.0.12.20250822"
pre-commit = "^4.3.0"

# Test infrastructure dependencies
locust = "^2.31.8"  # Load testing framework for postgres adapter tests
testcontainers = "^4.9.0"  # Integration testing with real database containers
kafka-python = "^2.0.2"  # Kafka client for integration testing
pytest-httpserver = "^1.1.0"  # Local mock HTTP server for integration tests

# Additional type stubs for better mypy coverage
types-aiofiles = "^23.2.0.20240403"
types-requests = "^2.32.0.20250914"
hypothesis = "^6.148.7"
pytest-split = "^0.10.0"

[tool.ruff]
target-version = "py312"
line-length = 88
exclude = [
    "**/archived/**",
    "**/archive/**",
    "**/__pycache__/**",
    "**/site-packages/**",
]

[tool.ruff.format]
# Use black-compatible formatting (ruff format is a drop-in replacement for black)
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
line-ending = "auto"

[tool.ruff.lint]
# Matches omnibase_core settings for consistency across ONEX ecosystem
select = ["E", "F", "W", "C90", "I", "N", "UP", "YTT", "S", "BLE", "FBT", "B", "A", "COM", "C4", "DTZ", "T10", "EM", "EXE", "ISC", "ICN", "G", "INP", "PIE", "T20", "PT", "Q", "RSE", "RET", "SLF", "SIM", "TID", "TCH", "ARG", "PTH", "ERA", "PD", "PGH", "PL", "TRY", "NPY", "RUF"]
ignore = [
    # Type annotation style rules
    # Note: ONEX prefers X | None syntax (PEP 604). This ignore allows legacy Union[X,Y]
    # if introduced, but codebase is already compliant. Can be removed to enforce strict PEP 604.
    "UP007",     # Union[X, Y] -> X | Y (allow legacy Union syntax if present)
    "S101",      # Allow assert statements in tests
    "E501",      # Line too long (technical debt - will fix incrementally)
    "BLE001",    # Blind exception catching (technical debt)
    "E402",      # Module level import not at top (technical debt)
    "TC001",     # Type checking imports (technical debt)
    "TC002",     # Third-party imports in TYPE_CHECKING (Pydantic needs runtime access)
    "TC003",     # Type checking imports (technical debt)
    "PLR0911",   # Too many returns (technical debt)
    "PLR0912",   # Too many branches (technical debt)
    "PLR0913",   # Too many arguments (technical debt)
    "PLR0915",   # Too many statements (technical debt)
    "PLR2004",   # Magic values (technical debt)
    "FBT001",    # Boolean positional args (technical debt)
    "FBT002",    # Boolean default args (technical debt)
    "EM101",     # Exception string literal (technical debt)
    "EM102",     # Exception f-string literal (technical debt)
    "TRY003",    # Long exception messages (technical debt)
    "TRY004",    # Exception type preference (technical debt)
    "TRY300",    # Consider else block (technical debt)
    "DTZ005",    # datetime.now() without tz (technical debt)
    "B008",      # Function call in defaults (technical debt)
    "ARG003",    # Unused class method argument (technical debt)
    "ERA001",    # Commented out code (technical debt)
    "SIM102",    # Nested if statements (technical debt)
    "B007",      # Unused loop variable (technical debt)
    "PT018",     # Assertion breakdown (technical debt)
    "EXE001",    # Shebang without executable (technical debt)
    "B904",      # raise from (will fix incrementally)
    "RET505",    # Unnecessary elif (will fix incrementally)
    "COM812",    # Trailing commas (will fix incrementally)
    "C901",      # Function complexity (architectural - not fixable easily)
    "E721",      # Type comparisons (technical debt)
    "N806",      # Variable naming (technical debt)
    "TRY203",    # Redundant exception handler (technical debt)
    "RUF003",    # Comment formatting (technical debt)
    "SIM117",    # Nested with statements (technical debt)
    "SIM105",    # contextlib.suppress (technical debt)
    "PTH123",    # Path.open() (technical debt)
    "PT017",     # pytest.raises in except (technical debt)
    "F841",      # Unused variable (technical debt)
    "ARG002",    # Unused method argument (technical debt)
    "T201",      # Print statements (technical debt)
    "FBT003",    # Boolean positional value in call (technical debt)
    "N802",      # Invalid function name (technical debt)
    "S603",      # Subprocess without shell (technical debt)
    "S607",      # Start process with partial path (technical debt)
    "PT011",     # Pytest raises too broad (technical debt)
    "SLF001",    # Private member access (technical debt)
    "DTZ001",    # Call datetime without tzinfo (technical debt)
    "ARG001",    # Unused function argument (technical debt)
    "G004",      # Logging f-string (technical debt)
    "INP001",    # Implicit namespace package (technical debt)
    "TRY301",    # Raise within try (technical debt)
    "RUF022",    # Unsorted dunder all (technical debt)
    "SIM103",    # Needless bool (technical debt)
    # SECURITY IGNORES - Reviewed and justified for infrastructure code:
    "S301",      # Pickle usage - Allowed for internal serialization of validator state only
                 # NOT used for untrusted data. All external data uses JSON/YAML.
    "S311",      # Random usage - Allowed for test data generation and non-cryptographic IDs only
                 # Cryptographic operations use secrets module (not ignored).
    "S324",      # Hashlib - Allowed for non-cryptographic checksums (MD5/SHA1) for caching only
                 # Cryptographic hashing uses SHA256+ (cryptography library).
    "S105",      # Hardcoded strings - Allowed for test fixtures and example configurations only
                 # Production secrets managed via Vault adapter (encrypted at rest).
    "B019",      # Cached instance method (technical debt)
    "PLW2901",   # Redefined loop name (technical debt)
    "B011",      # Assert false (technical debt)
    "PT015",     # Pytest assert always false (technical debt)
    "RUF005",    # Collection literal concatenation (technical debt)
    "S110",      # Try except pass (technical debt)
    "S112",      # Try except continue (technical debt)
    "SIM108",    # If else block instead of if exp (technical debt)
    "F401",      # Unused import (technical debt)
    "PLR1714",   # Repeated equality comparison (technical debt)
    "RUF012",    # Mutable class default (technical debt)
    "TRY401",    # Verbose log message (technical debt)
    "B017",      # Assert raises exception (technical debt)
    "A001",      # Builtin variable shadowing (technical debt)
    "PT012",     # Pytest raises with multiple statements (technical debt)
    "RET503",    # Implicit return (technical debt)
    "RET504",    # Unnecessary assign (technical debt)
    "SIM101",    # Duplicate isinstance call (technical debt)
    "SIM110",    # Reimplemented builtin (technical debt)
    "ARG005",    # Unused lambda argument (technical debt)
    "E711",      # None comparison (technical debt)
    "E722",      # Bare except (technical debt)
    "PLR1722",   # Sys exit alias (technical debt)
    "ISC001",    # Implicit string concatenation (conflicts with formatter)
    "PLC0415",   # Import not at top-level (intentional lazy imports in tests)
]

[tool.ruff.lint.isort]
# Ensure consistent import sorting between local and CI
# All omnibase packages are first-party to avoid blank lines between them
known-first-party = ["omnibase_infra", "omnibase_core", "omnibase_spi", "tests"]
# Force combine as imports for consistency
force-single-line = false
# Split imports from same package
split-on-trailing-comma = true

[tool.pytest.ini_options]
pythonpath = ["src"]
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
asyncio_mode = "auto"
# pytest-asyncio 0.25+ requires explicit fixture loop scope configuration.
# Set to "function" (default) to make configuration explicit and avoid deprecation warnings.
# Test modules using session/module-scoped async fixtures must override via pytestmark:
#   pytestmark = [pytest.mark.asyncio(loop_scope="session")]
# See: tests/conftest.py for detailed documentation on loop_scope configuration.
asyncio_default_fixture_loop_scope = "function"
markers = [
    "unit: Unit tests that test individual components in isolation",
    "integration: Integration tests that test multiple components together",
    "slow: Tests that take a long time to run (>1s)",
    "chaos: Chaos engineering tests for fault injection and resilience validation",
    "replay: Event replay and recovery tests",
    "smoke: Quick smoke tests for basic functionality",
    "performance: Performance and benchmark tests",
    "benchmark: Benchmark tests for performance measurement",
    "infrastructure: Infrastructure-specific tests",
    "validation: Validation framework tests",
    "consul: Tests requiring real Consul instance (CONSUL_HTTP_ADDR)",
    "database: marks tests that require database connection",
    "postgres: Tests requiring real PostgreSQL instance (POSTGRES_DSN)",
    "kafka: Tests requiring real Kafka instance (KAFKA_BOOTSTRAP_SERVERS)",
    "e2e: End-to-end tests requiring full infrastructure (Kafka + Consul + PostgreSQL)",
    "runtime: Tests requiring the ONEX runtime container to be running",
    "serial: Tests that must run serially (not in parallel with pytest-xdist) due to resource intensity",
    "heavy: Heavy integration tests requiring real infrastructure (Kafka, PostgreSQL, HTTP servers). Skipped by default, run with RUN_HEAVY_TESTS=1",
    "real_mcp: Tests using real MCP SDK server and client (requires available port)",
    "mcp_protocol: Mock-based MCP JSON-RPC protocol tests (not real SDK integration)",
]
addopts = [
    "--strict-markers",
    "--strict-config",
    "-ra",
    "--tb=short",
]

[tool.mypy]
plugins = ["pydantic.mypy"]
python_version = "3.12"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
mypy_path = "src"
namespace_packages = true
explicit_package_bases = true
# NOTE: omnibase_core 0.9.0 now includes py.typed marker file
# TODO: Remove ignore_missing_imports once omnibase_spi also adds py.typed
# Current workaround: ignore_missing_imports = true (global)
# Target state: Per-module overrides only (see [[tool.mypy.overrides]] below)
ignore_missing_imports = true

[[tool.mypy.overrides]]
module = ["omnibase_spi.*"]
ignore_missing_imports = true

[tool.pydantic-mypy]
init_forbid_extra = true
init_typed = false
warn_required_dynamic_aliases = true
warn_untyped_fields = true

[tool.coverage.run]
source = ["src/omnibase_infra"]
omit = [
    "*/tests/*",
    "*/archived/*",
    "*/archive/*",
    "*/__pycache__/*",
    "*/site-packages/*"
]
branch = true
parallel = true

[tool.coverage.report]
precision = 2
show_missing = true
skip_covered = false
fail_under = 60
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if TYPE_CHECKING:",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if typing.TYPE_CHECKING:",
    "@abstractmethod",
    "@abc.abstractmethod"
]
