"""Beautiful visualizations for categorical land cover data: static (matplotlib) and interactive (plotly)."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_charts.ipynb.

# %% auto #0
__all__ = ['DEFAULT_PALETTE', 'prepare_chart_data', 'get_class_colors', 'plot_class_distribution', 'plot_class_area_stacked',
           'plot_class_distribution_interactive', 'plot_class_area_stacked_interactive', 'plot_extraction',
           'plot_aggregated', 'plot_aggregated_interactive']

# %% ../nbs/03_charts.ipynb #cell-3
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
from typing import Optional, Union
from .layers import CategoricalLayer

# %% ../nbs/03_charts.ipynb #cell-5
# Default color palette for categorical data (colorblind-friendly)
# Based on ColorBrewer qualitative palettes
DEFAULT_PALETTE = [
    '#1b9e77',  # teal
    '#d95f02',  # orange
    '#7570b3',  # purple
    '#e7298a',  # pink
    '#66a61e',  # green
    '#e6ab02',  # gold
    '#a6761d',  # brown
    '#666666',  # gray
    '#8dd3c7',  # light teal
    '#bebada',  # light purple
    '#fb8072',  # salmon
    '#80b1d3',  # light blue
    '#fdb462',  # light orange
    '#b3de69',  # lime
    '#fccde5',  # light pink
    '#bc80bd',  # mauve
]

# %% ../nbs/03_charts.ipynb #cell-7
def prepare_chart_data(
    df: pd.DataFrame,
    value_col: str = 'area_ha',
    as_percentage: bool = False
) -> pd.DataFrame:
    """Pivot extraction data for charting.
    
    Args:
        df: DataFrame from extract_categorical with columns:
            site_id, year, class_value, count, area_ha, class_name
        value_col: Column to use for values ('area_ha' or 'count')
        as_percentage: If True, convert to percentages per year
        
    Returns:
        Pivoted DataFrame with years as index, classes as columns
    """
    # Use class_name if available, otherwise create from class_value
    df = df.copy()
    if df['class_name'].isna().all():
        df['class_label'] = 'class_' + df['class_value'].astype(str)
    else:
        df['class_label'] = df['class_name'].fillna('class_' + df['class_value'].astype(str))
    
    # Pivot to wide format
    pivot = df.pivot_table(
        index='year',
        columns='class_label',
        values=value_col,
        aggfunc='sum'
    ).fillna(0)
    
    if as_percentage:
        pivot = pivot.div(pivot.sum(axis=1), axis=0) * 100
    
    return pivot

# %% ../nbs/03_charts.ipynb #cell-8
def get_class_colors(
    classes: list[str],
    custom_colors: Optional[dict[str, str]] = None,
    layer: Optional['CategoricalLayer'] = None
) -> dict[str, str]:
    """Get colors for each class, using layer palette, custom, or defaults.
    
    Priority order:
    1. custom_colors (if provided)
    2. layer.palette (if layer provided and has palette)
    3. DEFAULT_PALETTE cycle
    
    Args:
        classes: List of class names
        custom_colors: Optional dict mapping class names to hex colors
        layer: Optional CategoricalLayer with palette attribute
        
    Returns:
        Dict mapping class names to colors
    """
    colors = custom_colors or {}
    
    # Build reverse lookup from class name to color via layer palette
    layer_colors = {}
    if layer is not None and layer.palette is not None and layer.class_map is not None:
        for class_val, color in layer.palette.items():
            class_name = layer.class_map.get(class_val)
            if class_name:
                layer_colors[class_name] = color
    
    result = {}
    fallback_idx = 0
    
    for cls in classes:
        if cls in colors:
            result[cls] = colors[cls]
        elif cls in layer_colors:
            result[cls] = layer_colors[cls]
        else:
            # Cycle through default palette
            result[cls] = DEFAULT_PALETTE[fallback_idx % len(DEFAULT_PALETTE)]
            fallback_idx += 1
    
    return result

# %% ../nbs/03_charts.ipynb #cell-10
def plot_class_distribution(
    df: pd.DataFrame,
    title: str = 'Class Distribution Over Time (%)',
    colors: Optional[dict[str, str]] = None,
    layer: Optional['CategoricalLayer'] = None,
    figsize: tuple[int, int] = (12, 6),
    marker: str = 'o',
    linewidth: float = 2,
    markersize: float = 6,
    grid: bool = True,
    legend_loc: str = 'center left',
    legend_bbox: tuple[float, float] = (1.02, 0.5)
) -> tuple[plt.Figure, plt.Axes]:
    """Create a line chart showing class distribution percentages over time.
    
    Args:
        df: DataFrame from extract_categorical
        title: Chart title
        colors: Optional dict mapping class names to hex colors
        layer: Optional CategoricalLayer to extract colors from palette
        figsize: Figure size (width, height)
        marker: Marker style for data points
        linewidth: Width of lines
        markersize: Size of markers
        grid: Whether to show grid
        legend_loc: Legend location
        legend_bbox: Legend bbox_to_anchor
        
    Returns:
        Tuple of (figure, axes)
    """
    # Prepare data as percentages
    pivot = prepare_chart_data(df, as_percentage=True)
    class_colors = get_class_colors(pivot.columns.tolist(), colors, layer)
    
    fig, ax = plt.subplots(figsize=figsize)
    
    for cls in pivot.columns:
        ax.plot(
            pivot.index,
            pivot[cls],
            marker=marker,
            linewidth=linewidth,
            markersize=markersize,
            color=class_colors[cls],
            label=cls
        )
    
    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_xlabel('Year', fontsize=12)
    ax.set_ylabel('Percentage (%)', fontsize=12)
    ax.set_ylim(0, 100)
    
    # Format x-axis to show years without comma separators
    ax.xaxis.set_major_formatter(mtick.FormatStrFormatter('%d'))
    
    if grid:
        ax.grid(True, linestyle='-', alpha=0.3)
    
    ax.legend(loc=legend_loc, bbox_to_anchor=legend_bbox)
    
    plt.tight_layout()
    return fig, ax

# %% ../nbs/03_charts.ipynb #cell-11
def plot_class_area_stacked(
    df: pd.DataFrame,
    title: str = 'Area by Class Over Time (hectares)',
    colors: Optional[dict[str, str]] = None,
    layer: Optional['CategoricalLayer'] = None,
    figsize: tuple[int, int] = (12, 6),
    bar_width: float = 0.7,
    grid: bool = True,
    legend_loc: str = 'center left',
    legend_bbox: tuple[float, float] = (1.02, 0.5)
) -> tuple[plt.Figure, plt.Axes]:
    """Create a stacked bar chart showing area by class over time.
    
    Args:
        df: DataFrame from extract_categorical
        title: Chart title
        colors: Optional dict mapping class names to hex colors
        layer: Optional CategoricalLayer to extract colors from palette
        figsize: Figure size (width, height)
        bar_width: Width of bars
        grid: Whether to show grid
        legend_loc: Legend location
        legend_bbox: Legend bbox_to_anchor
        
    Returns:
        Tuple of (figure, axes)
    """
    # Prepare data as absolute areas
    pivot = prepare_chart_data(df, value_col='area_ha', as_percentage=False)
    class_colors = get_class_colors(pivot.columns.tolist(), colors, layer)
    
    fig, ax = plt.subplots(figsize=figsize)
    
    # Create stacked bars
    bottom = pd.Series(0, index=pivot.index)
    
    # Reverse order so "Other" is at bottom, vegetation classes stack up
    for cls in reversed(pivot.columns.tolist()):
        ax.bar(
            pivot.index,
            pivot[cls],
            bottom=bottom,
            width=bar_width,
            color=class_colors[cls],
            label=cls,
            edgecolor='white',
            linewidth=0.5
        )
        bottom += pivot[cls]
    
    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_xlabel('Year', fontsize=12)
    ax.set_ylabel('Area (ha)', fontsize=12)
    
    # Format x-axis to show years without comma separators
    ax.xaxis.set_major_formatter(mtick.FormatStrFormatter('%d'))
    
    if grid:
        ax.grid(True, linestyle='-', alpha=0.3, axis='y')
        ax.set_axisbelow(True)
    
    # Reverse legend order to match visual stacking
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles[::-1], labels[::-1], loc=legend_loc, bbox_to_anchor=legend_bbox)
    
    plt.tight_layout()
    return fig, ax

# %% ../nbs/03_charts.ipynb #cell-13
try:
    import plotly.graph_objects as go
    import plotly.express as px
    HAS_PLOTLY = True
except ImportError:
    HAS_PLOTLY = False

# %% ../nbs/03_charts.ipynb #cell-14
def plot_class_distribution_interactive(
    df: pd.DataFrame,
    title: str = 'Class Distribution Over Time (%)',
    colors: Optional[dict[str, str]] = None,
    layer: Optional['CategoricalLayer'] = None,
    height: int = 500,
    width: Optional[int] = None,
    line_width: float = 2,
    marker_size: float = 8
) -> 'go.Figure':
    """Create an interactive line chart showing class distribution percentages.
    
    Args:
        df: DataFrame from extract_categorical
        title: Chart title
        colors: Optional dict mapping class names to hex colors
        layer: Optional CategoricalLayer to extract colors from palette
        height: Chart height in pixels
        width: Chart width in pixels (None for auto)
        line_width: Width of lines
        marker_size: Size of markers
        
    Returns:
        Plotly Figure object
    """
    if not HAS_PLOTLY:
        raise ImportError("plotly is required for interactive charts. Install with: pip install plotly")
    
    pivot = prepare_chart_data(df, as_percentage=True)
    class_colors = get_class_colors(pivot.columns.tolist(), colors, layer)
    
    fig = go.Figure()
    
    for cls in pivot.columns:
        fig.add_trace(go.Scatter(
            x=pivot.index,
            y=pivot[cls],
            mode='lines+markers',
            name=cls,
            line=dict(color=class_colors[cls], width=line_width),
            marker=dict(size=marker_size),
            hovertemplate=f'{cls}<br>Year: %{{x}}<br>Percentage: %{{y:.1f}}%<extra></extra>'
        ))
    
    fig.update_layout(
        title=dict(text=title, font=dict(size=16)),
        xaxis=dict(
            title='Year',
            tickformat='d',
            gridcolor='rgba(128, 128, 128, 0.2)'
        ),
        yaxis=dict(
            title='Percentage (%)',
            range=[0, 100],
            gridcolor='rgba(128, 128, 128, 0.2)'
        ),
        height=height,
        width=width,
        plot_bgcolor='white',
        hovermode='x unified',
        legend=dict(
            yanchor='middle',
            y=0.5,
            xanchor='left',
            x=1.02
        )
    )
    
    return fig

# %% ../nbs/03_charts.ipynb #cell-15
def plot_class_area_stacked_interactive(
    df: pd.DataFrame,
    title: str = 'Area by Class Over Time (hectares)',
    colors: Optional[dict[str, str]] = None,
    layer: Optional['CategoricalLayer'] = None,
    height: int = 500,
    width: Optional[int] = None
) -> 'go.Figure':
    """Create an interactive stacked bar chart showing area by class.
    
    Args:
        df: DataFrame from extract_categorical
        title: Chart title
        colors: Optional dict mapping class names to hex colors
        layer: Optional CategoricalLayer to extract colors from palette
        height: Chart height in pixels
        width: Chart width in pixels (None for auto)
        
    Returns:
        Plotly Figure object
    """
    if not HAS_PLOTLY:
        raise ImportError("plotly is required for interactive charts. Install with: pip install plotly")
    
    pivot = prepare_chart_data(df, value_col='area_ha', as_percentage=False)
    class_colors = get_class_colors(pivot.columns.tolist(), colors, layer)
    
    fig = go.Figure()
    
    # Add bars in reverse order for proper stacking visual
    for cls in reversed(pivot.columns.tolist()):
        fig.add_trace(go.Bar(
            x=pivot.index,
            y=pivot[cls],
            name=cls,
            marker_color=class_colors[cls],
            hovertemplate=f'{cls}<br>Year: %{{x}}<br>Area: %{{y:.2f}} ha<extra></extra>'
        ))
    
    fig.update_layout(
        title=dict(text=title, font=dict(size=16)),
        xaxis=dict(
            title='Year',
            tickformat='d',
            gridcolor='rgba(128, 128, 128, 0.2)'
        ),
        yaxis=dict(
            title='Area (ha)',
            gridcolor='rgba(128, 128, 128, 0.2)'
        ),
        barmode='stack',
        height=height,
        width=width,
        plot_bgcolor='white',
        legend=dict(
            yanchor='middle',
            y=0.5,
            xanchor='left',
            x=1.02,
            traceorder='reversed'
        )
    )
    
    return fig

# %% ../nbs/03_charts.ipynb #cell-17
def plot_extraction(
    df: pd.DataFrame,
    chart_type: str = 'distribution',
    interactive: bool = False,
    layer: Optional['CategoricalLayer'] = None,
    **kwargs
):
    """Universal plotting function for extraction results.
    
    Args:
        df: DataFrame from extract_categorical
        chart_type: 'distribution' (line %) or 'area' (stacked bar)
        interactive: If True, use plotly; if False, use matplotlib
        layer: Optional CategoricalLayer to extract colors from palette
        **kwargs: Additional arguments passed to the underlying plot function
        
    Returns:
        Figure object (matplotlib or plotly)
    """
    if chart_type == 'distribution':
        if interactive:
            return plot_class_distribution_interactive(df, layer=layer, **kwargs)
        else:
            return plot_class_distribution(df, layer=layer, **kwargs)
    elif chart_type == 'area':
        if interactive:
            return plot_class_area_stacked_interactive(df, layer=layer, **kwargs)
        else:
            return plot_class_area_stacked(df, layer=layer, **kwargs)
    else:
        raise ValueError(f"Unknown chart_type: {chart_type}. Use 'distribution' or 'area'.")

# %% ../nbs/03_charts.ipynb #0fcusete8lnp
def plot_aggregated(
    df: pd.DataFrame,
    aggregates: dict[str, list[str]],
    title: str = 'Aggregated Class Distribution',
    colors: Optional[dict[str, str]] = None,
    layer: Optional['CategoricalLayer'] = None,
    show_components: bool = True,
    vlines: Optional[dict[int, str]] = None,
    vline_color: str = '#666666',
    figsize: tuple[int, int] = (12, 6),
    linewidth: float = 2,
    marker: str = 'o',
    markersize: float = 6,
    grid: bool = True,
    legend_loc: str = 'center left',
    legend_bbox: tuple[float, float] = (1.02, 0.5)
) -> tuple[plt.Figure, plt.Axes]:
    """Plot aggregated classes with components shown as dashed lines.
    
    Args:
        df: DataFrame from extract_categorical
        aggregates: Dict mapping aggregate name to list of component class names.
                   Example: {'total_restoration': ['Secondary Vegetation', 'Secondary Veg Regrowth']}
        title: Chart title
        colors: Optional dict mapping class/aggregate names to hex colors
        layer: Optional CategoricalLayer to extract colors from palette
        show_components: If True, show component classes as dashed lines
        vlines: Optional dict mapping years to labels for vertical reference lines.
               Example: {2012: 'Restoration Start'}
        vline_color: Color for vertical lines (default gray)
        figsize: Figure size (width, height)
        linewidth: Width of lines
        marker: Marker style
        markersize: Size of markers
        grid: Whether to show grid
        legend_loc: Legend location
        legend_bbox: Legend bbox_to_anchor
        
    Returns:
        Tuple of (figure, axes)
    """
    pivot = prepare_chart_data(df, as_percentage=True)
    
    # Collect all class names we need colors for
    all_names = []
    for agg_name, components in aggregates.items():
        all_names.append(agg_name)
        if show_components:
            all_names.extend(components)
    
    class_colors = get_class_colors(all_names, colors, layer)
    
    fig, ax = plt.subplots(figsize=figsize)
    
    for agg_name, components in aggregates.items():
        # Compute aggregate (sum of components)
        agg_values = pivot[components].sum(axis=1)
        
        # Plot aggregate as solid line
        ax.plot(
            pivot.index,
            agg_values,
            marker=marker,
            linewidth=linewidth,
            markersize=markersize,
            color=class_colors[agg_name],
            label=agg_name,
            linestyle='-'
        )
        
        # Plot components as dashed lines
        if show_components:
            for comp in components:
                if comp in pivot.columns:
                    ax.plot(
                        pivot.index,
                        pivot[comp],
                        marker=marker,
                        linewidth=linewidth * 0.7,
                        markersize=markersize * 0.8,
                        color=class_colors[comp],
                        label=comp,
                        linestyle=':'
                    )
    
    # Add vertical reference lines
    if vlines:
        for year, label in vlines.items():
            ax.axvline(x=year, color=vline_color, linestyle='--', linewidth=1.5, alpha=0.7)
            # Add label at top of chart
            ax.text(year, 98, f' {label}', fontsize=9, color=vline_color,
                   ha='left', va='top', rotation=0)
    
    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_xlabel('Year', fontsize=12)
    ax.set_ylabel('Percentage (%)', fontsize=12)
    ax.set_ylim(0, 100)
    
    ax.xaxis.set_major_formatter(mtick.FormatStrFormatter('%d'))
    
    if grid:
        ax.grid(True, linestyle='-', alpha=0.3)
    
    ax.legend(loc=legend_loc, bbox_to_anchor=legend_bbox)
    
    plt.tight_layout()
    return fig, ax

# %% ../nbs/03_charts.ipynb #3z508k1oakz
def plot_aggregated_interactive(
    df: pd.DataFrame,
    aggregates: dict[str, list[str]],
    title: str = 'Aggregated Class Distribution',
    colors: Optional[dict[str, str]] = None,
    layer: Optional['CategoricalLayer'] = None,
    show_components: bool = True,
    vlines: Optional[dict[int, str]] = None,
    vline_color: str = '#666666',
    height: int = 500,
    width: Optional[int] = None,
    line_width: float = 2,
    marker_size: float = 8
) -> 'go.Figure':
    """Create an interactive aggregated class chart with plotly.
    
    Args:
        df: DataFrame from extract_categorical
        aggregates: Dict mapping aggregate name to list of component class names.
        title: Chart title
        colors: Optional dict mapping class/aggregate names to hex colors
        layer: Optional CategoricalLayer to extract colors from palette
        show_components: If True, show component classes as dashed lines
        vlines: Optional dict mapping years to labels for vertical reference lines.
               Example: {2012: 'Restoration Start'}
        vline_color: Color for vertical lines (default gray)
        height: Chart height in pixels
        width: Chart width in pixels (None for auto)
        line_width: Width of lines
        marker_size: Size of markers
        
    Returns:
        Plotly Figure object
    """
    if not HAS_PLOTLY:
        raise ImportError("plotly is required for interactive charts. Install with: pip install plotly")
    
    pivot = prepare_chart_data(df, as_percentage=True)
    
    # Collect all class names we need colors for
    all_names = []
    for agg_name, components in aggregates.items():
        all_names.append(agg_name)
        if show_components:
            all_names.extend(components)
    
    class_colors = get_class_colors(all_names, colors, layer)
    
    fig = go.Figure()
    
    for agg_name, components in aggregates.items():
        # Compute aggregate
        agg_values = pivot[components].sum(axis=1)
        
        # Plot aggregate as solid line
        fig.add_trace(go.Scatter(
            x=pivot.index,
            y=agg_values,
            mode='lines+markers',
            name=agg_name,
            line=dict(color=class_colors[agg_name], width=line_width, dash='solid'),
            marker=dict(size=marker_size),
            hovertemplate=f'{agg_name}<br>Year: %{{x}}<br>Percentage: %{{y:.1f}}%<extra></extra>'
        ))
        
        # Plot components as dashed lines
        if show_components:
            for comp in components:
                if comp in pivot.columns:
                    fig.add_trace(go.Scatter(
                        x=pivot.index,
                        y=pivot[comp],
                        mode='lines+markers',
                        name=comp,
                        line=dict(color=class_colors[comp], width=line_width * 0.7, dash='dot'),
                        marker=dict(size=marker_size * 0.8),
                        hovertemplate=f'{comp}<br>Year: %{{x}}<br>Percentage: %{{y:.1f}}%<extra></extra>'
                    ))
    
    # Add vertical reference lines
    if vlines:
        for year, label in vlines.items():
            fig.add_vline(
                x=year,
                line=dict(color=vline_color, width=1.5, dash='dash'),
                opacity=0.7
            )
            fig.add_annotation(
                x=year,
                y=98,
                text=label,
                showarrow=False,
                font=dict(size=10, color=vline_color),
                xanchor='left',
                yanchor='top'
            )
    
    fig.update_layout(
        title=dict(text=title, font=dict(size=16)),
        xaxis=dict(
            title='Year',
            tickformat='d',
            gridcolor='rgba(128, 128, 128, 0.2)'
        ),
        yaxis=dict(
            title='Percentage (%)',
            range=[0, 100],
            gridcolor='rgba(128, 128, 128, 0.2)'
        ),
        height=height,
        width=width,
        plot_bgcolor='white',
        hovermode='x unified',
        legend=dict(
            yanchor='middle',
            y=0.5,
            xanchor='left',
            x=1.02
        )
    )
    
    return fig
