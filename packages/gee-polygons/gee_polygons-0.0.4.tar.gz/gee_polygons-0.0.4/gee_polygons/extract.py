"""The extraction engine: `extract_categorical` and `extract_continuous` for pulling stats from any raster."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_extract.ipynb.

# %% auto #0
__all__ = []

# %% ../nbs/02_extract.ipynb #de7099e5
import ee
import geemap
import pandas as pd
from fastcore.basics import patch
from typing import Optional, Literal

from .layers import CategoricalLayer, ContinuousLayer
from .site import Site

# %% ../nbs/02_extract.ipynb #fe8333e4
@patch
def extract_categorical(
    self: Site,
    layer: CategoricalLayer,
    years: list[int],
    max_pixels: int = int(1e9)
) -> pd.DataFrame:
    """Extract per-year pixel counts and areas from a categorical raster.
    
    Supports two temporal modes:
    - 'band': Each year is a band in a single Image (e.g., MapBiomas)
    - 'collection': An ImageCollection filtered by date (e.g., Dynamic World)
    
    Args:
        layer: A CategoricalLayer describing the data source
        years: List of years to extract
        max_pixels: Maximum pixels for reduction (default 1e9)
        
    Returns:
        A tidy DataFrame with columns:
        - site_id: Site identifier
        - year: Year of observation
        - class_value: Integer class value
        - count: Pixel count
        - area_ha: Area in hectares
        - class_name: Human-readable name (if available in layer)
    """
    records = []
    
    for year in years:
        if layer.temporal_mode == 'band':
            # MapBiomas style: select band from single image
            img = ee.Image(layer.asset_id)
            band = layer.band_name(year)
            classified = img.select(band)
            band_name = band
        else:
            # Dynamic World style: filter collection and reduce
            collection = (
                ee.ImageCollection(layer.asset_id)
                .filterDate(f'{year}-01-01', f'{year}-12-31')
                .filterBounds(self.geometry)
                .select(layer.band)
            )
            # Use mode (most frequent class) to aggregate across time
            classified = collection.reduce(ee.Reducer.mode())
            band_name = f'{layer.band}_mode'
        
        stats = classified.reduceRegion(
            reducer=ee.Reducer.frequencyHistogram(),
            geometry=self.geometry,
            scale=layer.scale,
            maxPixels=max_pixels
        )
        
        hist = ee.Dictionary(stats.get(band_name))
        
        # Build a feature to batch the getInfo call
        records.append(
            ee.Feature(None, {
                'year': year,
                'histogram': hist
            })
        )
    
    # Single getInfo call for all years
    fc = ee.FeatureCollection(records).getInfo()
    
    # Convert to tidy rows
    rows = []
    for f in fc['features']:
        year = f['properties']['year']
        hist = f['properties']['histogram']
        
        if hist is None:
            continue
            
        for cls_str, count in hist.items():
            cls = int(float(cls_str))  # Handle potential float strings
            rows.append({
                'site_id': self.site_id,
                'year': year,
                'class_value': cls,
                'count': count,
                'area_ha': count * (layer.scale ** 2) / 10_000,
                'class_name': layer.class_name(cls)
            })
    
    return pd.DataFrame(rows)

# %% ../nbs/02_extract.ipynb #b0fe8c09
@patch
def show_layer(
    self: Site,
    layer: CategoricalLayer,
    years: list[int],
    zoom: int = 14,
    basemap: str = 'SATELLITE',
    site_color: str = 'blue',
    buffer_m: Optional[float] = None
) -> geemap.Map:
    """Display a categorical layer for multiple years with the site overlaid.
    
    Supports both temporal modes:
    - 'band': Shows each year's band from a single Image
    - 'collection': Shows mode-reduced composite per year
    
    Args:
        layer: A CategoricalLayer to visualize
        years: List of years to add as layers
        zoom: Initial zoom level (default 14)
        basemap: Basemap type (default 'SATELLITE')
        site_color: Color for site boundary (default 'blue')
        buffer_m: Optional buffer around site for clipping display
        
    Returns:
        A geemap.Map with yearly classification layers
    """
    m = geemap.Map()
    m.add_basemap(basemap)
    m.center_object(self.geometry, zoom)
    
    # Determine clip geometry
    clip_geom = self.buffer(buffer_m) if buffer_m else self.geometry
    
    # Build visualization params from palette
    if layer.palette:
        classes = sorted(layer.palette.keys())
        colors = [layer.palette[c] for c in classes]
        vis_params = {
            'min': min(classes),
            'max': max(classes),
            'palette': colors
        }
    else:
        vis_params = {'min': 0, 'max': 10}
    
    # Add each year as a layer (most recent visible by default)
    for i, year in enumerate(years):
        if layer.temporal_mode == 'band':
            # MapBiomas style
            img = ee.Image(layer.asset_id)
            band = layer.band_name(year)
            classified = img.select(band).clip(clip_geom)
        else:
            # Dynamic World style
            collection = (
                ee.ImageCollection(layer.asset_id)
                .filterDate(f'{year}-01-01', f'{year}-12-31')
                .filterBounds(self.geometry)
                .select(layer.band)
            )
            classified = collection.reduce(ee.Reducer.mode()).clip(clip_geom)
        
        shown = (i == len(years) - 1)
        m.add_layer(classified, vis_params, f'{year}', shown=shown)
    
    # Add site boundary on top
    site_style = {'color': site_color, 'fillColor': '#00000000', 'width': 2}
    m.add_layer(self.geometry, site_style, f'Site {self.site_id}')
    
    return m

# %% ../nbs/02_extract.ipynb #d6fdbbe2
@patch
def extract_continuous(
    self: Site,
    layer: ContinuousLayer,
    start_date: str,
    end_date: str,
    reducer: Literal['mean', 'median', 'min', 'max'] = 'mean',
    frequency: Literal['all', 'monthly', 'yearly'] = 'all',
    max_pixels: int = int(1e9)
) -> pd.DataFrame:
    """Extract continuous raster statistics over time for a site.
    
    Completely dataset-agnostic. All preprocessing (cloud masking, index
    computation, scaling) is handled by the layer's `preprocess` function.
    
    Args:
        layer: ContinuousLayer with bands to extract and optional preprocess
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)
        reducer: Spatial aggregation ('mean', 'median', 'min', 'max')
        frequency: Temporal output ('all', 'monthly', 'yearly')
        max_pixels: Maximum pixels for reduction
        
    Returns:
        DataFrame with columns: site_id, date/year/month, and one column per band
    """
    reducer_fn = getattr(ee.Reducer, reducer)()
    
    # Load collection
    collection = (
        ee.ImageCollection(layer.collection_id)
        .filterDate(start_date, end_date)
        .filterBounds(self.geometry)
    )
    
    # Apply preprocessing if defined (cloud masking, index computation, etc.)
    if layer.preprocess is not None:
        collection = collection.map(layer.preprocess)
    
    # Select the requested bands
    collection = collection.select(layer.bands)
    
    if frequency == 'all':
        return _extract_continuous_all(self, collection, layer, reducer_fn, max_pixels)
    elif frequency == 'yearly':
        return _extract_continuous_yearly(self, collection, layer, reducer_fn, start_date, end_date, max_pixels)
    elif frequency == 'monthly':
        return _extract_continuous_monthly(self, collection, layer, reducer_fn, start_date, end_date, max_pixels)
    else:
        raise ValueError(f"Unknown frequency: {frequency}")

# %% ../nbs/02_extract.ipynb #012c5bba
def _extract_continuous_all(site, collection, layer, reducer_fn, max_pixels):
    """Extract one row per image in the collection."""
    bands = layer.bands
    
    def reduce_image(img):
        stats = img.reduceRegion(
            reducer=reducer_fn,
            geometry=site.geometry,
            scale=layer.scale,
            maxPixels=max_pixels
        )
        props = {'date': img.date().format('YYYY-MM-dd')}
        for band in bands:
            props[band] = stats.get(band)
        return ee.Feature(None, props)
    
    fc = ee.FeatureCollection(collection.map(reduce_image)).getInfo()
    
    rows = []
    for f in fc['features']:
        props = f['properties']
        # Skip if all band values are None
        if all(props.get(b) is None for b in bands):
            continue
        row = {'site_id': site.site_id, 'date': props['date']}
        for band in bands:
            row[band] = props.get(band)
        rows.append(row)
    
    return pd.DataFrame(rows)

# %% ../nbs/02_extract.ipynb #923968e6
def _extract_continuous_yearly(site, collection, layer, reducer_fn, start_date, end_date, max_pixels):
    """Aggregate by year: temporal median, then spatial reduce."""
    start_year = int(start_date[:4])
    end_year = int(end_date[:4])
    bands = layer.bands
    
    records = []
    for year in range(start_year, end_year + 1):
        yearly = collection.filterDate(f'{year}-01-01', f'{year}-12-31')
        composite = yearly.median()
        
        stats = composite.reduceRegion(
            reducer=reducer_fn,
            geometry=site.geometry,
            scale=layer.scale,
            maxPixels=max_pixels
        )
        
        props = {'year': year}
        for band in bands:
            props[band] = stats.get(band)
        records.append(ee.Feature(None, props))
    
    fc = ee.FeatureCollection(records).getInfo()
    
    rows = []
    for f in fc['features']:
        props = f['properties']
        if all(props.get(b) is None for b in bands):
            continue
        row = {'site_id': site.site_id, 'year': props['year']}
        for band in bands:
            row[band] = props.get(band)
        rows.append(row)
    
    return pd.DataFrame(rows)

# %% ../nbs/02_extract.ipynb #7c8c9ca8
def _extract_continuous_monthly(site, collection, layer, reducer_fn, start_date, end_date, max_pixels):
    """Aggregate by month: temporal median, then spatial reduce."""
    import datetime
    
    start = datetime.date.fromisoformat(start_date)
    end = datetime.date.fromisoformat(end_date)
    bands = layer.bands
    
    records = []
    current = start.replace(day=1)
    
    while current <= end:
        year, month = current.year, current.month
        if month == 12:
            next_month = datetime.date(year + 1, 1, 1)
        else:
            next_month = datetime.date(year, month + 1, 1)
        
        monthly = collection.filterDate(current.isoformat(), next_month.isoformat())
        composite = monthly.median()
        
        stats = composite.reduceRegion(
            reducer=reducer_fn,
            geometry=site.geometry,
            scale=layer.scale,
            maxPixels=max_pixels
        )
        
        props = {'year': year, 'month': month}
        for band in bands:
            props[band] = stats.get(band)
        records.append(ee.Feature(None, props))
        
        current = next_month
    
    fc = ee.FeatureCollection(records).getInfo()
    
    rows = []
    for f in fc['features']:
        props = f['properties']
        if all(props.get(b) is None for b in bands):
            continue
        row = {'site_id': site.site_id, 'year': props['year'], 'month': props['month']}
        for band in bands:
            row[band] = props.get(band)
        rows.append(row)
    
    return pd.DataFrame(rows)
