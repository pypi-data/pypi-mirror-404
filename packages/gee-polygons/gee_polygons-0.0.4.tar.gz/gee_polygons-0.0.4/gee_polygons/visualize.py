"""Generic spatial visualization: render any ee.Image, export PNGs, GIFs, and timestrips."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_visualize.ipynb.

# %% auto #0
__all__ = ['NDVI_VIS', 'EVI_VIS', 'VisParams', 'render_thumbnail', 'add_label', 'render_image', 'get_vis_params_from_layer',
           'get_image_for_layer', 'render_site_layer', 'export_frames_as_gif', 'export_frames_as_strip',
           'export_layer_gif', 'export_layer_timestrip']

# %% ../nbs/04_visualize.ipynb #cell-3
import ee
from PIL import Image, ImageDraw, ImageFont
from pathlib import Path
from typing import Optional, Union, Literal, Callable
from dataclasses import dataclass
import io

from .layers import CategoricalLayer, ContinuousLayer
from .site import Site

# %% ../nbs/04_visualize.ipynb #cell-5
@dataclass
class VisParams:
    """Visualization parameters for rendering layers.
    
    Examples:
        # For single-band continuous data (NDVI, temperature)
        VisParams(min=-0.2, max=0.8, palette=['red', 'yellow', 'green'])
        
        # For RGB composites
        VisParams(min=0, max=0.3, bands=['B4', 'B3', 'B2'], gamma=1.4)
        
        # For categorical data
        VisParams(min=0, max=7, palette=['#111', '#ccc', '#0f0', ...])
    """
    min: Optional[float] = None
    max: Optional[float] = None
    palette: Optional[list[str]] = None
    bands: Optional[list[str]] = None
    gamma: Optional[float] = None
    
    def to_dict(self) -> dict:
        """Convert to GEE visualization params dict."""
        d = {}
        if self.min is not None:
            d['min'] = self.min
        if self.max is not None:
            d['max'] = self.max
        if self.palette is not None:
            d['palette'] = self.palette
        if self.bands is not None:
            d['bands'] = self.bands
        if self.gamma is not None:
            d['gamma'] = self.gamma
        return d

# %% ../nbs/04_visualize.ipynb #cell-6
# Common visualization presets
NDVI_VIS = VisParams(
    min=-0.2, max=0.8,
    palette=['#d73027', '#f46d43', '#fdae61', '#fee08b', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850']
)

EVI_VIS = VisParams(
    min=0, max=0.6,
    palette=['#d73027', '#f46d43', '#fdae61', '#fee08b', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850']
)

# %% ../nbs/04_visualize.ipynb #cell-8
def render_thumbnail(
    image: ee.Image,
    region: ee.Geometry,
    vis_params: dict,
    dimensions: int = 512,
    format: str = 'png'
) -> bytes:
    """Render an ee.Image to thumbnail bytes.
    
    Args:
        image: The image to render
        region: Region to render
        vis_params: Visualization parameters dict
        dimensions: Max dimension in pixels
        format: Image format ('png' or 'jpg')
        
    Returns:
        Image bytes
    """
    url = image.getThumbURL({
        'region': region,
        'dimensions': dimensions,
        'format': format,
        **vis_params
    })
    
    import urllib.request
    with urllib.request.urlopen(url) as response:
        return response.read()

# %% ../nbs/04_visualize.ipynb #cell-9
def add_label(
    img: Image.Image,
    label: str,
    position: Literal['top-left', 'top-right', 'bottom-left', 'bottom-right'] = 'bottom-left',
    font_size: int = 16,
    text_color: str = 'white',
    bg_color: str = 'black',
    padding: int = 5
) -> Image.Image:
    """Add a text label to an image."""
    img = img.copy()
    draw = ImageDraw.Draw(img)
    
    try:
        font = ImageFont.truetype("/System/Library/Fonts/Helvetica.ttc", font_size)
    except:
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", font_size)
        except:
            font = ImageFont.load_default()
    
    bbox = draw.textbbox((0, 0), label, font=font)
    text_width = bbox[2] - bbox[0]
    text_height = bbox[3] - bbox[1]
    
    x = padding if 'left' in position else img.width - text_width - padding * 2
    y = padding if 'top' in position else img.height - text_height - padding * 2
    
    if bg_color:
        draw.rectangle(
            [x - padding, y - padding, x + text_width + padding, y + text_height + padding],
            fill=bg_color
        )
    
    draw.text((x, y), label, fill=text_color, font=font)
    return img

# %% ../nbs/04_visualize.ipynb #cell-10
def _parse_color(color: str) -> tuple[int, int, int]:
    """Parse hex color to RGB tuple."""
    if color.startswith('#'):
        return (
            int(color[1:3], 16),
            int(color[3:5], 16),
            int(color[5:7], 16)
        )
    return (255, 255, 255)


def _to_pil(thumb_bytes: bytes) -> Image.Image:
    """Convert thumbnail bytes to RGB PIL Image."""
    img = Image.open(io.BytesIO(thumb_bytes))
    if img.mode == 'RGBA':
        background = Image.new('RGB', img.size, (0, 0, 0))
        background.paste(img, mask=img.split()[3])
        return background
    elif img.mode != 'RGB':
        return img.convert('RGB')
    return img

# %% ../nbs/04_visualize.ipynb #cell-12
def render_image(
    image: ee.Image,
    region: ee.Geometry,
    vis_params: Union[VisParams, dict],
    dimensions: int = 512,
    boundary: Optional[ee.Geometry] = None,
    boundary_color: str = '#FFFFFF',
    boundary_width: int = 2,
    label: Optional[str] = None,
    label_position: str = 'bottom-left'
) -> Image.Image:
    """Render any ee.Image to a PIL Image.
    
    This is the core generic rendering function. It works with any ee.Image
    from any source (Sentinel, MODIS, Landsat, custom computations, etc.).
    
    Args:
        image: Any ee.Image to visualize
        region: Region to render (usually site.geometry.buffer(n).bounds())
        vis_params: Visualization parameters (VisParams or dict)
        dimensions: Image size in pixels
        boundary: Optional geometry to overlay as boundary line
        boundary_color: Color for boundary line
        boundary_width: Width of boundary line
        label: Optional text label
        label_position: Position for label
        
    Returns:
        PIL Image
        
    Example:
        # Get any ee.Image from any source
        image = ee.Image('USGS/SRTMGL1_003')  # elevation
        
        # Render it
        pil_img = render_image(
            image=image,
            region=site.geometry.buffer(1000).bounds(),
            vis_params={'min': 0, 'max': 3000, 'palette': ['green', 'yellow', 'brown']},
            boundary=site.geometry,
            label='Elevation'
        )
    """
    vis_dict = vis_params.to_dict() if isinstance(vis_params, VisParams) else vis_params
    
    if boundary is not None:
        # Create boundary overlay
        boundary_img = ee.Image().paint(
            featureCollection=ee.FeatureCollection([ee.Feature(boundary)]),
            color=1,
            width=boundary_width
        )
        
        # Visualize base image
        vis_img = image.visualize(**vis_dict)
        
        # Blend boundary
        r, g, b = _parse_color(boundary_color)
        boundary_vis = boundary_img.visualize(palette=[f'{r:02x}{g:02x}{b:02x}'])
        combined = vis_img.blend(boundary_vis.updateMask(boundary_img))
        
        thumb_bytes = render_thumbnail(combined, region, {}, dimensions)
    else:
        thumb_bytes = render_thumbnail(image, region, vis_dict, dimensions)
    
    pil_img = _to_pil(thumb_bytes)
    
    if label:
        pil_img = add_label(pil_img, label, position=label_position)
    
    return pil_img

# %% ../nbs/04_visualize.ipynb #cell-14
def get_vis_params_from_layer(layer: 'CategoricalLayer') -> dict:
    """Extract visualization params from a CategoricalLayer's palette."""
    if layer.palette is None:
        return {'min': 0, 'max': 10}
    
    classes = sorted(layer.palette.keys())
    colors = [layer.palette[c] for c in classes]
    return {
        'min': min(classes),
        'max': max(classes),
        'palette': colors
    }


def get_image_for_layer(
    layer: Union['CategoricalLayer', 'ContinuousLayer'],
    geometry: ee.Geometry,
    year: Optional[int] = None,
    date_range: Optional[tuple[str, str]] = None,
    reducer: str = 'median'
) -> ee.Image:
    """Get an ee.Image from a CategoricalLayer or ContinuousLayer."""
    from gee_polygons.layers import CategoricalLayer, ContinuousLayer
    
    if isinstance(layer, CategoricalLayer):
        if layer.temporal_mode == 'band':
            img = ee.Image(layer.asset_id)
            band = layer.band_name(year)
            return img.select(band)
        else:
            start = date_range[0] if date_range else f'{year}-01-01'
            end = date_range[1] if date_range else f'{year}-12-31'
            collection = (
                ee.ImageCollection(layer.asset_id)
                .filterDate(start, end)
                .filterBounds(geometry)
                .select(layer.band)
            )
            return collection.reduce(ee.Reducer.mode())
    
    elif isinstance(layer, ContinuousLayer):
        start = date_range[0] if date_range else f'{year}-01-01'
        end = date_range[1] if date_range else f'{year}-12-31'
        
        collection = (
            ee.ImageCollection(layer.collection_id)
            .filterDate(start, end)
            .filterBounds(geometry)
        )
        
        if layer.preprocess is not None:
            collection = collection.map(layer.preprocess)
        
        collection = collection.select(layer.bands)
        reducer_fn = getattr(collection, reducer)
        return reducer_fn()
    
    else:
        raise ValueError(f"Unknown layer type: {type(layer)}")

# %% ../nbs/04_visualize.ipynb #cell-15
def render_site_layer(
    site: 'Site',
    layer: Union['CategoricalLayer', 'ContinuousLayer'],
    year: Optional[int] = None,
    date_range: Optional[tuple[str, str]] = None,
    vis_params: Optional[Union[VisParams, dict]] = None,
    buffer_m: float = 500,
    dimensions: int = 512,
    show_boundary: bool = True,
    boundary_color: str = '#FFFFFF',
    boundary_width: int = 2,
    label: Optional[str] = None,
    label_position: str = 'bottom-left'
) -> Image.Image:
    """Render a CategoricalLayer or ContinuousLayer for a site.
    
    This is a convenience wrapper around render_image() for Layer objects.
    """
    from gee_polygons.layers import CategoricalLayer
    
    # Get the image
    image = get_image_for_layer(layer, site.geometry, year, date_range)
    
    # Determine vis params
    if vis_params is None:
        if isinstance(layer, CategoricalLayer):
            vis_params = get_vis_params_from_layer(layer)
        else:
            vis_params = {'min': 0, 'max': 1}
    
    # Render
    return render_image(
        image=image,
        region=site.geometry.buffer(buffer_m).bounds(),
        vis_params=vis_params,
        dimensions=dimensions,
        boundary=site.geometry if show_boundary else None,
        boundary_color=boundary_color,
        boundary_width=boundary_width,
        label=label,
        label_position=label_position
    )

# %% ../nbs/04_visualize.ipynb #cell-17
def export_frames_as_gif(
    frames: list[Image.Image],
    output_path: Union[str, Path],
    duration_ms: int = 500,
    loop: bool = True
) -> Path:
    """Export a list of PIL Images as animated GIF.
    
    Args:
        frames: List of PIL Images
        output_path: Output file path
        duration_ms: Frame duration in milliseconds
        loop: Whether to loop
        
    Returns:
        Path to saved file
    """
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    frames[0].save(
        output_path,
        save_all=True,
        append_images=frames[1:],
        duration=duration_ms,
        loop=0 if loop else 1
    )
    return output_path


def export_frames_as_strip(
    frames: list[Image.Image],
    output_path: Union[str, Path],
    orientation: Literal['horizontal', 'vertical'] = 'horizontal',
    spacing: int = 2,
    background_color: str = '#000000'
) -> Path:
    """Export a list of PIL Images as a strip (side by side).
    
    Args:
        frames: List of PIL Images (should be same size)
        output_path: Output file path
        orientation: 'horizontal' or 'vertical'
        spacing: Pixels between tiles
        background_color: Background color
        
    Returns:
        Path to saved file
    """
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Use first frame size as reference
    tile_w, tile_h = frames[0].size
    n = len(frames)
    
    if orientation == 'horizontal':
        width = n * tile_w + (n - 1) * spacing
        height = tile_h
    else:
        width = tile_w
        height = n * tile_h + (n - 1) * spacing
    
    bg_rgb = _parse_color(background_color)
    output = Image.new('RGB', (width, height), bg_rgb)
    
    for i, frame in enumerate(frames):
        if orientation == 'horizontal':
            x, y = i * (tile_w + spacing), 0
        else:
            x, y = 0, i * (tile_h + spacing)
        
        # Resize if needed
        if frame.size != (tile_w, tile_h):
            frame = frame.resize((tile_w, tile_h), Image.Resampling.LANCZOS)
        
        output.paste(frame, (x, y))
    
    output.save(output_path, 'PNG')
    return output_path

# %% ../nbs/04_visualize.ipynb #cell-19
def export_layer_gif(
    site: 'Site',
    layer: Union['CategoricalLayer', 'ContinuousLayer'],
    output_path: Union[str, Path],
    years: list[int],
    vis_params: Optional[Union[VisParams, dict]] = None,
    buffer_m: float = 500,
    dimensions: int = 512,
    show_boundary: bool = True,
    boundary_color: str = '#FFFFFF',
    duration_ms: int = 500,
    add_labels: bool = True
) -> Path:
    """Export a Layer time series as animated GIF."""
    frames = []
    for year in years:
        label = str(year) if add_labels else None
        frame = render_site_layer(
            site=site, layer=layer, year=year,
            vis_params=vis_params, buffer_m=buffer_m,
            dimensions=dimensions, show_boundary=show_boundary,
            boundary_color=boundary_color, label=label
        )
        frames.append(frame)
    
    return export_frames_as_gif(frames, output_path, duration_ms)


def export_layer_timestrip(
    site: 'Site',
    layer: Union['CategoricalLayer', 'ContinuousLayer'],
    output_path: Union[str, Path],
    years: list[int],
    vis_params: Optional[Union[VisParams, dict]] = None,
    buffer_m: float = 500,
    tile_size: int = 256,
    show_boundary: bool = True,
    boundary_color: str = '#FFFFFF',
    add_labels: bool = True,
    orientation: Literal['horizontal', 'vertical'] = 'horizontal',
    spacing: int = 2
) -> Path:
    """Export a Layer time series as timestrip."""
    frames = []
    for year in years:
        label = str(year) if add_labels else None
        frame = render_site_layer(
            site=site, layer=layer, year=year,
            vis_params=vis_params, buffer_m=buffer_m,
            dimensions=tile_size, show_boundary=show_boundary,
            boundary_color=boundary_color, label=label
        )
        frames.append(frame)
    
    return export_frames_as_strip(frames, output_path, orientation, spacing)
