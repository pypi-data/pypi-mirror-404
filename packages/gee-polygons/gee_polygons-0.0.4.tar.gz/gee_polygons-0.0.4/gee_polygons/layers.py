"""Pure configuration objects for describing raster layers â€” categorical and continuous."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_layers.ipynb.

# %% auto #0
__all__ = ['CategoricalLayer', 'ContinuousLayer']

# %% ../nbs/00_layers.ipynb #cdbdefbd
from dataclasses import dataclass, field
from typing import Optional, Dict, Literal, List, Callable, Any

# %% ../nbs/00_layers.ipynb #dc6b4fc0
@dataclass
class CategoricalLayer:
    """A descriptor for a categorical raster layer.
    
    Supports two temporal modes:
    - 'band': Each year is a band in a single Image (e.g., MapBiomas)
    - 'collection': An ImageCollection filtered by date (e.g., Dynamic World)
    
    Attributes:
        asset_id: GEE asset path
        temporal_mode: How time is encoded - 'band' or 'collection'
        band_pattern: For 'band' mode - pattern with {} for year (e.g., 'classification_{}')
        band: For 'collection' mode - the band name to select (e.g., 'label')
        scale: Pixel resolution in meters (default 30)
        class_map: Optional mapping of class values to names
        palette: Optional mapping of class values to hex colors
    """
    asset_id: str
    temporal_mode: Literal['band', 'collection'] = 'band'
    
    # For band-per-year mode (MapBiomas)
    band_pattern: Optional[str] = None
    
    # For collection mode (Dynamic World)
    band: Optional[str] = None
    
    scale: int = 30
    class_map: Optional[Dict[int, str]] = None
    palette: Optional[Dict[int, str]] = None
    
    def band_name(self, year: int) -> str:
        """Get the band name for a specific year (band mode only)."""
        if self.temporal_mode != 'band':
            raise ValueError("band_name() only valid for temporal_mode='band'")
        if self.band_pattern is None:
            raise ValueError("band_pattern required for temporal_mode='band'")
        return self.band_pattern.format(year)
    
    def class_name(self, class_value: int) -> Optional[str]:
        """Get the human-readable name for a class value."""
        if self.class_map is None:
            return None
        return self.class_map.get(class_value)
    
    def class_color(self, class_value: int) -> Optional[str]:
        """Get the hex color for a class value."""
        if self.palette is None:
            return None
        return self.palette.get(class_value)

# %% ../nbs/00_layers.ipynb #5072e090
@dataclass
class ContinuousLayer:
    """A descriptor for a continuous raster time series.
    
    Used for floating-point data like vegetation indices, temperature,
    or any continuous signal that varies over time.
    
    Attributes:
        collection_id: GEE ImageCollection ID
        bands: List of band names to extract (output columns in DataFrame)
        scale: Pixel resolution in meters (default 10)
        preprocess: Optional function (ee.Image -> ee.Image) for preprocessing.
                   Use this for cloud masking, scaling, computing derived indices.
                   Must return an image containing all bands listed in `bands`.
    
    Example:
        # Simple - extract existing band
        ContinuousLayer(collection_id='...', bands=['B4'])
        
        # With preprocessing - compute NDVI
        ContinuousLayer(
            collection_id='COPERNICUS/S2_SR_HARMONIZED',
            bands=['NDVI', 'EVI'],
            preprocess=compute_s2_indices  # defined in datasets/sentinel2.py
        )
    """
    collection_id: str
    bands: List[str]
    scale: int = 10
    preprocess: Optional[Callable[[Any], Any]] = None  # ee.Image -> ee.Image
