"""Core abstractions for polygon-first GEE analysis: the `Site` class."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% ../nbs/00_core.ipynb #97a573b6
from __future__ import annotations
import json
from pathlib import Path
from datetime import datetime
from typing import Optional, Union

import ee
import geemap
from pyproj import Transformer

# %% auto #0
__all__ = ['Site', 'load_sites']

# %% ../nbs/00_core.ipynb #b7c99261
class Site:
    """A polygon with temporal context for GEE analysis.
    
    The Site class wraps an ee.Feature with convenient accessors for
    common properties like start_year and area, plus helper methods
    for temporal analysis.
    """
    
    def __init__(self, 
                 feature: ee.Feature,
                 start_year: Optional[int] = None,
                 site_id: Optional[str] = None):
        """Create a Site from an ee.Feature.
        
        Args:
            feature: An ee.Feature with polygon geometry
            start_year: Override start year (otherwise reads from feature properties)
            site_id: Override site ID (otherwise reads from 'rid' property)
        """
        self._feature = feature
        self._start_year = start_year
        self._site_id = site_id
    
    @property
    def feature(self) -> ee.Feature:
        """The underlying ee.Feature."""
        return self._feature
    
    @property
    def geometry(self) -> ee.Geometry:
        """The site's geometry."""
        return self._feature.geometry()
    
    @property
    def start_year(self) -> int:
        """The year this site's monitoring/restoration began."""
        if self._start_year is not None:
            return self._start_year
        # Try to get from feature properties
        return int(self._feature.get('start_year').getInfo())
    
    @property
    def site_id(self) -> str:
        """Unique identifier for this site."""
        if self._site_id is not None:
            return self._site_id
        return str(self._feature.get('rid').getInfo())
    
    @property
    def area_ha(self) -> float:
        """Site area in hectares."""
        return float(self._feature.get('area_ha').getInfo())
    
    @property 
    def properties(self) -> dict:
        """All feature properties as a dictionary."""
        return self._feature.getInfo()['properties']
    
    def buffer(self, distance_m: float) -> ee.Geometry:
        """Buffer the site geometry by a distance in meters.
        
        Args:
            distance_m: Buffer distance in meters
            
        Returns:
            Buffered ee.Geometry
        """
        return self.geometry.buffer(distance_m)
    
    def years(self, end_year: Optional[int] = None) -> list[int]:
        """Generate list of years from start_year to end_year.
        
        Args:
            end_year: End year (defaults to current year)
            
        Returns:
            List of years for time-series analysis
        """
        if end_year is None:
            end_year = datetime.now().year
        return list(range(self.start_year, end_year + 1))
    
    def __repr__(self) -> str:
        return f"Site(id={self.site_id}, start_year={self.start_year})"
    
    @classmethod
    def from_geojson(cls, 
                     feature_dict: dict,
                     source_crs: str = 'EPSG:4326') -> Site:
        """Create a Site from a GeoJSON feature dictionary.
        
        Args:
            feature_dict: A GeoJSON Feature dict with geometry and properties
            source_crs: The CRS of the input coordinates (default WGS84)
            
        Returns:
            A Site instance
        """
        geom = feature_dict['geometry']
        props = feature_dict.get('properties', {})
        
        # Reproject coordinates if not WGS84
        if source_crs != 'EPSG:4326':
            geom = _reproject_geometry(geom, source_crs, 'EPSG:4326')
        
        # Create ee.Geometry based on type
        geom_type = geom['type']
        coords = geom['coordinates']
        
        if geom_type == 'Polygon':
            ee_geom = ee.Geometry.Polygon(coords)
        elif geom_type == 'MultiPolygon':
            ee_geom = ee.Geometry.MultiPolygon(coords)
        elif geom_type == 'Point':
            ee_geom = ee.Geometry.Point(coords)
        else:
            raise ValueError(f"Unsupported geometry type: {geom_type}")
        
        # Create ee.Feature with properties
        ee_feature = ee.Feature(ee_geom, props)
        
        return cls(ee_feature)

# %% ../nbs/00_core.ipynb #401231a0
def _reproject_geometry(geom: dict, 
                        source_crs: str, 
                        target_crs: str) -> dict:
    """Reproject a GeoJSON geometry from source to target CRS.
    
    Args:
        geom: GeoJSON geometry dict
        source_crs: Source CRS (e.g., 'EPSG:5880')
        target_crs: Target CRS (e.g., 'EPSG:4326')
        
    Returns:
        Reprojected geometry dict
    """
    transformer = Transformer.from_crs(source_crs, target_crs, always_xy=True)
    
    def transform_coords(coords):
        """Recursively transform coordinates."""
        if isinstance(coords[0], (int, float)):
            # This is a coordinate pair (or triple with Z)
            x, y = transformer.transform(coords[0], coords[1])
            if len(coords) > 2:
                return [x, y, coords[2]]  # Preserve Z if present
            return [x, y]
        else:
            # This is a list of coordinates/rings
            return [transform_coords(c) for c in coords]
    
    return {
        'type': geom['type'],
        'coordinates': transform_coords(geom['coordinates'])
    }

# %% ../nbs/00_core.ipynb #4bd64369
def load_sites(path: Union[str, Path], 
               source_crs: Optional[str] = None) -> list[Site]:
    """Load sites from a GeoJSON file.
    
    Args:
        path: Path to GeoJSON file
        source_crs: Override source CRS (auto-detected from file if present)
        
    Returns:
        List of Site objects
    """
    path = Path(path)
    
    with open(path) as f:
        data = json.load(f)
    
    # Try to detect CRS from file
    if source_crs is None:
        source_crs = _detect_crs(data)
    
    features = data.get('features', [data])  # Handle single feature or collection
    
    return [Site.from_geojson(f, source_crs=source_crs) for f in features]


def _detect_crs(geojson_data: dict) -> str:
    """Detect CRS from GeoJSON data, defaulting to WGS84."""
    crs_info = geojson_data.get('crs', {})
    crs_props = crs_info.get('properties', {})
    crs_name = crs_props.get('name', '')
    
    # Parse common CRS formats
    if 'EPSG' in crs_name:
        # Extract EPSG code from URN or direct format
        # e.g., "urn:ogc:def:crs:EPSG::5880" -> "EPSG:5880"
        parts = crs_name.split(':')
        for i, part in enumerate(parts):
            if part == 'EPSG' and i + 1 < len(parts):
                code = parts[-1]  # Get the last part (the actual code)
                if code:  # Handle double colon case
                    return f'EPSG:{code}'
    
    # Default to WGS84
    return 'EPSG:4326'
