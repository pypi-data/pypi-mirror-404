/**
 * Project configuration
 * This file is auto-generated by pipecat-cli
 */

export const AVAILABLE_TRANSPORTS = [
{%- for transport in transports %}
  '{{ transport.value }}',
{%- endfor %}
];

export const DEFAULT_TRANSPORT = '{{ transports[0].value }}';

const botStartUrl =
  import.meta.env.VITE_BOT_START_URL || 'http://localhost:7860/start';
const botStartPublicApiKey = import.meta.env.VITE_BOT_START_PUBLIC_API_KEY;

if (!import.meta.env.VITE_BOT_START_URL) {
  console.warn(
    'VITE_BOT_START_URL not configured, using default: http://localhost:7860/start'
  );
}

const dailyConfig = {
  endpoint: botStartUrl,
  requestData: {
    createDailyRoom: true,
    dailyRoomProperties: { start_video_off: true },
    transport: "daily",
  },
};

if (botStartPublicApiKey) {
  dailyConfig.headers = new Headers({
    Authorization: `Bearer ${botStartPublicApiKey}`,
  });
}

const smallWebRTCConfig = {
  endpoint: botStartUrl,
  requestData: {
    createDailyRoom: false,
    enableDefaultIceServers: true,
    transport: "webrtc",
  },
};

if (botStartPublicApiKey) {
  smallWebRTCConfig.headers = new Headers({
    Authorization: `Bearer ${botStartPublicApiKey}`,
  });
}

export const TRANSPORT_CONFIG = {
  daily: dailyConfig,
  smallwebrtc: smallWebRTCConfig,
};

/**
 * Create a transport instance based on the transport type
 * Uses dynamic imports to only load the required transport library
 */
export async function createTransport(transportType) {
  switch (transportType) {
{% for transport in transports -%}
{%- if transport.value == 'daily' %}
    case 'daily': {
      const { DailyTransport } = await import('@pipecat-ai/daily-transport');
      return new DailyTransport();
    }
{% elif transport.value == 'smallwebrtc' %}
    case 'smallwebrtc': {
      const { SmallWebRTCTransport } = await import('@pipecat-ai/small-webrtc-transport');
      return new SmallWebRTCTransport();
    }
{% endif -%}
{%- endfor %}
    default:
      throw new Error(`Unsupported transport type: ${transportType}`);
  }
}
