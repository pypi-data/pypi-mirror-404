# Issue #12: 非同期処理・リトライチュートリアル追加

## 概要
非同期処理やリトライ機能のチュートリアルがない。

## 問題点
- 実際の運用シナリオでは非同期処理が必要になることが多い
- ネットワークエラー等に対するリトライ処理は一般的な要件
- これらの機能の使い方が分からない

## 依存関係
- Issue #01-05: コンテキスト変数アーキテクチャ（先行）

**注意**: 本issueのコード例はIssue #01-05の新形式（Context受け取り）に準拠する。

## 提案される解決策
非同期処理とリトライ機能のチュートリアルを追加する。

### 追加するセクション案

```markdown
## Step 6: 非同期処理とリトライ

### 非同期ノードの作成
```python
from railway import node
from railway.core.context import Context
import aiohttp

@node
async def fetch_api_data(ctx: Context) -> None:
    """外部APIからデータを取得する非同期ノード"""
    url = ctx.get_param("api_url")

    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            data = await response.json()

    ctx["fetch_api_data"] = {"data": data, "status": response.status}
```

### 非同期パイプラインの実行
```python
from railway import Context, async_pipeline

ctx = Context(entry_point="api_fetch")
ctx.set_param("api_url", "https://api.example.com/data")

await async_pipeline(ctx, fetch_api_data, process_data, save_result)

print(ctx["save_result"])
```

### リトライ機能
```python
from railway import node, Retry
from railway.core.context import Context
import requests

@node
@Retry(max_attempts=3, delay=1.0, backoff=2.0)
def unreliable_api_call(ctx: Context) -> None:
    """リトライ機能付きのAPIコール"""
    data = ctx["prepare_request"]["payload"]

    response = requests.post("https://api.example.com", json=data)
    response.raise_for_status()

    ctx["unreliable_api_call"] = {"response": response.json()}
```

### リトライオプション
| オプション | 説明 | デフォルト |
|-----------|------|-----------|
| `max_attempts` | 最大試行回数 | 3 |
| `delay` | 初回リトライまでの待機時間（秒） | 1.0 |
| `backoff` | 待機時間の倍率 | 2.0 |
| `exceptions` | リトライ対象の例外 | (Exception,) |

### 完全な使用例
```python
from railway import Context, async_pipeline, node, Retry

@node
async def fetch_data(ctx: Context) -> None:
    user_id = ctx.get_param("user_id")
    # 非同期でデータ取得
    ctx["fetch_data"] = await get_user_async(user_id)

@node
@Retry(max_attempts=3)
def save_to_db(ctx: Context) -> None:
    data = ctx["fetch_data"]
    # リトライ付きでDB保存
    ctx["save_to_db"] = {"saved": save(data)}

# 実行
ctx = Context(entry_point="data_sync")
ctx.set_param("user_id", 1)
await async_pipeline(ctx, fetch_data, save_to_db)
```
```

## 優先度
中〜高

## 関連ファイル
- `TUTORIAL.md`
- 非同期処理・リトライ機能の実装ファイル

## 参考情報
ユーザーレビューより:
> 非同期処理やリトライ機能のチュートリアルがない
