# Issue #05: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½

## æ¦‚è¦

`railway update` å®Ÿè¡Œå‰ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆã¨ã€å•é¡Œç™ºç”Ÿæ™‚ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ç¾çŠ¶

ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ä»•çµ„ã¿ãŒãªã„ãŸã‚ã€ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—æ™‚ã®ãƒªã‚«ãƒãƒªãƒ¼ãŒå›°é›£ã€‚

## ç›®æ¨™

```bash
# è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
$ railway update
ğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ: .railway/backups/0.8.0_20260123_103000/
...

# ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
$ railway rollback
åˆ©ç”¨å¯èƒ½ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—:
  [1] 0.8.0_20260123_103000 (2æ™‚é–“å‰)
  [2] 0.7.0_20260120_090000 (3æ—¥å‰)

ã©ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«æˆ»ã—ã¾ã™ã‹? [1]: 1
âœ… ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Œäº†

# ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§
$ railway backup list
  0.8.0_20260123_103000  2æ™‚é–“å‰   15KB
  0.7.0_20260120_090000  3æ—¥å‰     12KB

# ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‰Šé™¤
$ railway backup clean --keep 3
ğŸ—‘ï¸  2ä»¶ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸ
```

## è¨­è¨ˆ

### ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ§‹é€ 

```
my_project/
â””â”€â”€ .railway/
    â””â”€â”€ backups/
        â””â”€â”€ 0.8.0_20260123_103000/
            â”œâ”€â”€ manifest.yaml       # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ¡ã‚¿æƒ…å ±
            â”œâ”€â”€ TUTORIAL.md
            â”œâ”€â”€ pyproject.toml
            â”œâ”€â”€ .gitignore
            â””â”€â”€ config/
                â””â”€â”€ development.yaml
```

### manifest.yaml

```yaml
backup:
  version: "0.8.0"
  created_at: "2026-01-23T10:30:00+09:00"
  reason: "Before update to 0.9.0"

files:
  - path: "TUTORIAL.md"
    checksum: "sha256:abc123..."
  - path: "pyproject.toml"
    checksum: "sha256:def456..."
  - path: "config/development.yaml"
    checksum: "sha256:ghi789..."
```

### ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡

| å¯¾è±¡ | ç†ç”± |
|------|------|
| `.railway/project.yaml` | ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã®å¾©å…ƒ |
| `TUTORIAL.md` | è‡ªå‹•ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ« |
| `pyproject.toml` | ä¾å­˜é–¢ä¿‚ |
| `.gitignore` | ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯è¨­å®š |
| `config/*.yaml` | è¨­å®šãƒ•ã‚¡ã‚¤ãƒ« |

**é™¤å¤–å¯¾è±¡:**
- `src/nodes/*` - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰ï¼ˆæ›´æ–°å¯¾è±¡å¤–ï¼‰
- `tests/*` - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰
- `.venv/` - ä»®æƒ³ç’°å¢ƒ
- `__pycache__/` - ã‚­ãƒ£ãƒƒã‚·ãƒ¥

## è¨­è¨ˆåŸå‰‡

### é–¢æ•°å‹ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ æº–æ‹ 

1. **ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ±**: frozen dataclass ã§è¡¨ç¾
2. **ç´”ç²‹é–¢æ•°ã«ã‚ˆã‚‹ãƒ‡ãƒ¼ã‚¿å¤‰æ›**: ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆç”Ÿæˆ/ãƒ‘ãƒ¼ã‚¹ã¯ç´”ç²‹é–¢æ•°
3. **IOæ“ä½œã®åˆ†é›¢**: ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã¯å°‚ç”¨é–¢æ•°ã§æ˜ç¤ºçš„ã«åˆ†é›¢
4. **Resultå‹ãƒ‘ã‚¿ãƒ¼ãƒ³**: æ“ä½œçµæœã‚’æ˜ç¤ºçš„ã«è¡¨ç¾

## å®Ÿè£…

### 1. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‹å®šç¾©ï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼‰

```python
# railway/migrations/backup_types.py
"""ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‹å®šç¾©ã€‚

é–¢æ•°å‹ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ :
- å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿å‹ã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ« (frozen=True)
- å¤‰æ›é–¢æ•°ã¯ç´”ç²‹é–¢æ•°
"""
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional, Sequence


@dataclass(frozen=True)
class BackupFile:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼‰ã€‚"""
    path: str
    checksum: str
    size_bytes: int


@dataclass(frozen=True)
class BackupManifest:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼‰ã€‚"""
    version: str
    created_at: datetime
    reason: str
    files: tuple[BackupFile, ...]

    @property
    def total_size(self) -> int:
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®åˆè¨ˆã‚µã‚¤ã‚ºã€‚"""
        return sum(f.size_bytes for f in self.files)

    @property
    def file_count(self) -> int:
        """ãƒ•ã‚¡ã‚¤ãƒ«æ•°ã€‚"""
        return len(self.files)


@dataclass(frozen=True)
class BackupInfo:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ±ï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼‰ã€‚"""
    manifest: BackupManifest
    path: Path

    @property
    def version(self) -> str:
        return self.manifest.version

    @property
    def created_at(self) -> datetime:
        return self.manifest.created_at

    @property
    def reason(self) -> str:
        return self.manifest.reason

    @property
    def size_bytes(self) -> int:
        return self.manifest.total_size

    @property
    def name(self) -> str:
        return self.path.name


@dataclass(frozen=True)
class BackupResult:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ“ä½œçµæœï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼‰ã€‚"""
    success: bool
    backup: Optional[BackupInfo] = None
    error: Optional[str] = None


@dataclass(frozen=True)
class RestoreResult:
    """å¾©å…ƒæ“ä½œçµæœï¼ˆã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ï¼‰ã€‚"""
    success: bool
    restored_files: tuple[str, ...] = field(default_factory=tuple)
    error: Optional[str] = None
```

### 2. ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆæ“ä½œï¼ˆç´”ç²‹é–¢æ•°ï¼‰

```python
# railway/migrations/backup_manifest.py
"""ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆæ“ä½œã€‚

é–¢æ•°å‹ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ :
- ãƒ‘ãƒ¼ã‚¹/ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã¯ç´”ç²‹é–¢æ•°
- IOæ“ä½œã¯åˆ¥ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§åˆ†é›¢
"""
from datetime import datetime
from typing import Any, Mapping, Optional, Sequence

import yaml

from railway.migrations.backup_types import BackupFile, BackupManifest


def parse_manifest(yaml_content: str) -> BackupManifest:
    """YAMLæ–‡å­—åˆ—ã‹ã‚‰ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹ã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚

    Args:
        yaml_content: YAMLå½¢å¼ã®æ–‡å­—åˆ—

    Returns:
        ãƒ‘ãƒ¼ã‚¹ã•ã‚ŒãŸBackupManifest

    Raises:
        ValueError: ãƒ‘ãƒ¼ã‚¹å¤±æ•—æ™‚
    """
    data = yaml.safe_load(yaml_content)
    return _dict_to_manifest(data)


def serialize_manifest(manifest: BackupManifest) -> str:
    """ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã‚’YAMLæ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚

    Args:
        manifest: ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯¾è±¡

    Returns:
        YAMLå½¢å¼ã®æ–‡å­—åˆ—
    """
    data = _manifest_to_dict(manifest)
    return yaml.dump(data, default_flow_style=False, allow_unicode=True)


def _dict_to_manifest(data: Mapping[str, Any]) -> BackupManifest:
    """è¾æ›¸ã‹ã‚‰ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚"""
    backup_data = data["backup"]
    files_data = data.get("files", [])

    files = tuple(
        BackupFile(
            path=f["path"],
            checksum=f["checksum"],
            size_bytes=f.get("size_bytes", 0),
        )
        for f in files_data
    )

    return BackupManifest(
        version=backup_data["version"],
        created_at=datetime.fromisoformat(backup_data["created_at"]),
        reason=backup_data["reason"],
        files=files,
    )


def _manifest_to_dict(manifest: BackupManifest) -> dict[str, Any]:
    """ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã‚’è¾æ›¸ã«å¤‰æ›ã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚"""
    return {
        "backup": {
            "version": manifest.version,
            "created_at": manifest.created_at.isoformat(),
            "reason": manifest.reason,
        },
        "files": [
            {
                "path": f.path,
                "checksum": f.checksum,
                "size_bytes": f.size_bytes,
            }
            for f in manifest.files
        ],
    }


def create_manifest(
    version: str,
    reason: str,
    files: Sequence[BackupFile],
    now: Optional[datetime] = None,
) -> BackupManifest:
    """æ–°è¦ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚

    Args:
        version: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³
        reason: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç†ç”±
        files: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆ
        now: ç¾åœ¨æ™‚åˆ»ï¼ˆãƒ†ã‚¹ãƒˆç”¨ã«ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰

    Returns:
        æ–°è¦BackupManifest
    """
    return BackupManifest(
        version=version,
        created_at=now or datetime.now().astimezone(),
        reason=reason,
        files=tuple(files),
    )
```

### 3. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ“ä½œï¼ˆIOåˆ†é›¢ï¼‰

```python
# railway/migrations/backup.py
"""ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ“ä½œã€‚

é–¢æ•°å‹ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ :
- ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆç”Ÿæˆï¼‰ã¨ IOï¼ˆãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œï¼‰ã‚’åˆ†é›¢
- çµæœã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãª Result å‹ã§è¿”ã™
"""
import hashlib
import shutil
from datetime import datetime
from pathlib import Path
from typing import Sequence

from railway.migrations.backup_types import (
    BackupFile,
    BackupInfo,
    BackupResult,
    RestoreResult,
)
from railway.migrations.backup_manifest import (
    create_manifest,
    parse_manifest,
    serialize_manifest,
)


# ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå®šæ•°ï¼‰
BACKUP_PATTERNS: tuple[str, ...] = (
    ".railway/project.yaml",
    "TUTORIAL.md",
    "pyproject.toml",
    ".gitignore",
    "config/*.yaml",
)


def compute_checksum(content: bytes) -> str:
    """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒã‚§ãƒƒã‚¯ã‚µãƒ ã‚’è¨ˆç®—ã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚

    Args:
        content: ãƒã‚§ãƒƒã‚¯ã‚µãƒ å¯¾è±¡ã®ãƒã‚¤ãƒˆåˆ—

    Returns:
        "sha256:..." å½¢å¼ã®ãƒã‚§ãƒƒã‚¯ã‚µãƒ 
    """
    sha256 = hashlib.sha256(content)
    return f"sha256:{sha256.hexdigest()}"


def generate_backup_name(version: str, timestamp: datetime) -> str:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åã‚’ç”Ÿæˆã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚

    Args:
        version: ãƒãƒ¼ã‚¸ãƒ§ãƒ³
        timestamp: ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—

    Returns:
        "{version}_{YYYYMMDD_HHMMSS}" å½¢å¼ã®åå‰
    """
    return f"{version}_{timestamp.strftime('%Y%m%d_%H%M%S')}"


def collect_backup_files(
    project_path: Path,
    patterns: Sequence[str] = BACKUP_PATTERNS,
) -> list[tuple[Path, BackupFile]]:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åé›†ã™ã‚‹ã€‚

    Args:
        project_path: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹
        patterns: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³

    Returns:
        (ã‚½ãƒ¼ã‚¹ãƒ‘ã‚¹, BackupFile) ã®ãƒªã‚¹ãƒˆ
    """
    files = []

    for pattern in patterns:
        for src in project_path.glob(pattern):
            if src.is_file():
                try:
                    content = src.read_bytes()
                    rel_path = src.relative_to(project_path)
                    files.append((
                        src,
                        BackupFile(
                            path=str(rel_path),
                            checksum=compute_checksum(content),
                            size_bytes=len(content),
                        ),
                    ))
                except (OSError, PermissionError):
                    continue

    return files


def create_backup(
    project_path: Path,
    version: str,
    reason: str = "Manual backup",
) -> BackupResult:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆã™ã‚‹ã€‚

    Args:
        project_path: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹
        version: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³
        reason: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç†ç”±

    Returns:
        BackupResult with success status
    """
    try:
        now = datetime.now().astimezone()
        backup_name = generate_backup_name(version, now)
        backup_path = project_path / ".railway" / "backups" / backup_name

        # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        backup_path.mkdir(parents=True, exist_ok=True)

        # ãƒ•ã‚¡ã‚¤ãƒ«åé›†ã¨ã‚³ãƒ”ãƒ¼
        file_infos = collect_backup_files(project_path)
        backup_files: list[BackupFile] = []

        for src, file_info in file_infos:
            dst = backup_path / file_info.path
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)
            backup_files.append(file_info)

        # ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆä½œæˆ
        manifest = create_manifest(version, reason, backup_files, now)
        manifest_content = serialize_manifest(manifest)

        manifest_path = backup_path / "manifest.yaml"
        manifest_path.write_text(manifest_content, encoding="utf-8")

        return BackupResult(
            success=True,
            backup=BackupInfo(manifest=manifest, path=backup_path),
        )

    except Exception as e:
        return BackupResult(success=False, error=str(e))


def list_backups(project_path: Path) -> list[BackupInfo]:
    """åˆ©ç”¨å¯èƒ½ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä¸€è¦§å–å¾—ã™ã‚‹ã€‚

    Args:
        project_path: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹

    Returns:
        ä½œæˆæ—¥æ™‚ã®é™é †ã§ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸBackupInfoã®ãƒªã‚¹ãƒˆ
    """
    backup_dir = project_path / ".railway" / "backups"
    backups: list[BackupInfo] = []

    if not backup_dir.exists():
        return backups

    for backup_path in backup_dir.iterdir():
        manifest_path = backup_path / "manifest.yaml"
        if manifest_path.exists():
            try:
                content = manifest_path.read_text(encoding="utf-8")
                manifest = parse_manifest(content)
                backups.append(BackupInfo(manifest=manifest, path=backup_path))
            except Exception:
                continue

    # ä½œæˆæ—¥æ™‚ã®é™é †ã§ã‚½ãƒ¼ãƒˆ
    backups.sort(key=lambda b: b.created_at, reverse=True)
    return backups


def restore_backup(project_path: Path, backup: BackupInfo) -> RestoreResult:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã™ã‚‹ã€‚

    Args:
        project_path: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹
        backup: å¾©å…ƒã™ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—

    Returns:
        RestoreResult with success status
    """
    try:
        restored: list[str] = []

        for file_info in backup.manifest.files:
            src = backup.path / file_info.path
            dst = project_path / file_info.path

            if src.exists():
                dst.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(src, dst)
                restored.append(file_info.path)

        return RestoreResult(
            success=True,
            restored_files=tuple(restored),
        )

    except Exception as e:
        return RestoreResult(success=False, error=str(e))


def clean_backups(project_path: Path, keep: int = 5) -> tuple[int, list[str]]:
    """å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã™ã‚‹ã€‚

    Args:
        project_path: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹
        keep: ä¿æŒã™ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°

    Returns:
        (å‰Šé™¤æ•°, å‰Šé™¤ã•ã‚ŒãŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åã®ãƒªã‚¹ãƒˆ)
    """
    backups = list_backups(project_path)
    to_remove = backups[keep:]
    removed_names: list[str] = []

    for backup in to_remove:
        try:
            shutil.rmtree(backup.path)
            removed_names.append(backup.name)
        except Exception:
            continue

    return len(removed_names), removed_names
```

### 4. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—CLI

```python
# railway/cli/backup.py
"""ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç†ã‚³ãƒãƒ³ãƒ‰ã€‚

é–¢æ•°å‹ãƒ‘ãƒ©ãƒ€ã‚¤ãƒ :
- ã‚³ãƒãƒ³ãƒ‰ã¯IO/UIã®çµ±åˆå±¤
- ãƒ­ã‚¸ãƒƒã‚¯ã¯ backup ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åˆ†é›¢
"""
import typer
from datetime import datetime

from railway.core.project_discovery import find_project_root
from railway.migrations.backup import (
    list_backups,
    restore_backup,
    clean_backups,
)

app = typer.Typer(help="ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç†")


def format_age(dt: datetime) -> str:
    """æ—¥æ™‚ã‚’ã€Œã€œå‰ã€å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚"""
    delta = datetime.now().astimezone() - dt
    seconds = delta.total_seconds()

    if seconds < 60:
        return "ãŸã£ãŸä»Š"
    elif seconds < 3600:
        return f"{int(seconds / 60)}åˆ†å‰"
    elif seconds < 86400:
        return f"{int(seconds / 3600)}æ™‚é–“å‰"
    else:
        return f"{int(seconds / 86400)}æ—¥å‰"


def format_size(size_bytes: int) -> str:
    """ãƒã‚¤ãƒˆæ•°ã‚’äººé–“ãŒèª­ã¿ã‚„ã™ã„å½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã™ã‚‹ç´”ç²‹é–¢æ•°ã€‚"""
    if size_bytes < 1024:
        return f"{size_bytes}B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f}KB"
    else:
        return f"{size_bytes / (1024 * 1024):.1f}MB"


@app.command("list")
def list_cmd():
    """åˆ©ç”¨å¯èƒ½ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä¸€è¦§è¡¨ç¤ºã€‚"""
    project_path = find_project_root()
    if project_path is None:
        typer.echo("âŒ Railwayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", err=True)
        raise typer.Exit(1)

    backups = list_backups(project_path)

    if not backups:
        typer.echo("ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒã‚ã‚Šã¾ã›ã‚“")
        return

    typer.echo("\nåˆ©ç”¨å¯èƒ½ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—:\n")
    for i, backup in enumerate(backups, 1):
        age = format_age(backup.created_at)
        size = format_size(backup.size_bytes)
        typer.echo(f"  [{i}] {backup.name}  {age}  {size}")


@app.command("restore")
def restore_cmd(
    name: str = typer.Argument(None, help="ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åï¼ˆçœç•¥æ™‚ã¯é¸æŠï¼‰"),
):
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã€‚"""
    project_path = find_project_root()
    if project_path is None:
        typer.echo("âŒ Railwayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", err=True)
        raise typer.Exit(1)

    backups = list_backups(project_path)

    if not backups:
        typer.echo("ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒã‚ã‚Šã¾ã›ã‚“", err=True)
        raise typer.Exit(1)

    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—é¸æŠ
    if name:
        backup = next((b for b in backups if b.name == name), None)
        if backup is None:
            typer.echo(f"ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ— '{name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", err=True)
            raise typer.Exit(1)
    else:
        typer.echo("\nåˆ©ç”¨å¯èƒ½ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—:\n")
        for i, b in enumerate(backups, 1):
            typer.echo(f"  [{i}] {b.name} ({format_age(b.created_at)})")

        choice = typer.prompt("\nã©ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«æˆ»ã—ã¾ã™ã‹?", default="1")
        try:
            idx = int(choice) - 1
            backup = backups[idx]
        except (ValueError, IndexError):
            typer.echo("ç„¡åŠ¹ãªé¸æŠã§ã™", err=True)
            raise typer.Exit(1)

    # ç¢ºèª
    if not typer.confirm(f"\n{backup.name} ã«æˆ»ã—ã¾ã™ã‹?"):
        typer.echo("ä¸­æ­¢ã—ã¾ã—ãŸ")
        return

    # å¾©å…ƒå®Ÿè¡Œ
    result = restore_backup(project_path, backup)

    if result.success:
        typer.echo(f"\nâœ… ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Œäº†: {backup.version}")
        typer.echo(f"   å¾©å…ƒãƒ•ã‚¡ã‚¤ãƒ«æ•°: {len(result.restored_files)}")
    else:
        typer.echo(f"âŒ å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸ: {result.error}", err=True)
        raise typer.Exit(1)


@app.command("clean")
def clean_cmd(
    keep: int = typer.Option(5, "--keep", "-k", help="ä¿æŒã™ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°"),
):
    """å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã€‚"""
    project_path = find_project_root()
    if project_path is None:
        typer.echo("âŒ Railwayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“", err=True)
        raise typer.Exit(1)

    removed_count, removed_names = clean_backups(project_path, keep=keep)

    if removed_count > 0:
        typer.echo(f"ğŸ—‘ï¸  {removed_count}ä»¶ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸ")
    else:
        typer.echo("å‰Šé™¤å¯¾è±¡ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ã‚ã‚Šã¾ã›ã‚“")
```

## ãƒ†ã‚¹ãƒˆï¼ˆTDD: Red â†’ Green â†’ Refactorï¼‰

### ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ

```
tests/unit/migrations/
â”œâ”€â”€ test_backup_types.py
â”œâ”€â”€ test_backup_manifest.py
â””â”€â”€ test_backup.py
```

### Red Phase: ãƒ†ã‚¹ãƒˆã‚’å…ˆã«æ›¸ã

```python
# tests/unit/migrations/test_backup.py
"""ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆã€‚

TDD Red Phase: ã¾ãšãƒ†ã‚¹ãƒˆã‚’æ›¸ãã€å¤±æ•—ã‚’ç¢ºèªã™ã‚‹ã€‚
"""
from datetime import datetime, timezone
from pathlib import Path

import pytest

from railway.migrations.backup_types import (
    BackupFile,
    BackupManifest,
    BackupInfo,
)
from railway.migrations.backup_manifest import (
    create_manifest,
    parse_manifest,
    serialize_manifest,
)
from railway.migrations.backup import (
    compute_checksum,
    generate_backup_name,
    collect_backup_files,
    create_backup,
    list_backups,
    restore_backup,
    clean_backups,
)


class TestBackupTypesImmutability:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‹ã®ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«æ€§ãƒ†ã‚¹ãƒˆã€‚"""

    def test_backup_file_is_frozen(self):
        """BackupFileã¯å¤‰æ›´ä¸å¯ã€‚"""
        bf = BackupFile(path="test.txt", checksum="sha256:abc", size_bytes=100)

        with pytest.raises(Exception):
            bf.path = "other.txt"

    def test_backup_manifest_is_frozen(self):
        """BackupManifestã¯å¤‰æ›´ä¸å¯ã€‚"""
        manifest = create_manifest("0.9.0", "test", [])

        with pytest.raises(Exception):
            manifest.version = "1.0.0"


class TestPureFunctions:
    """ç´”ç²‹é–¢æ•°ã®ãƒ†ã‚¹ãƒˆã€‚"""

    def test_compute_checksum_is_deterministic(self):
        """åŒã˜å…¥åŠ›ã«ã¯åŒã˜ãƒã‚§ãƒƒã‚¯ã‚µãƒ ã€‚"""
        content = b"Hello, World!"

        checksum1 = compute_checksum(content)
        checksum2 = compute_checksum(content)

        assert checksum1 == checksum2
        assert checksum1.startswith("sha256:")

    def test_compute_checksum_different_for_different_content(self):
        """ç•°ãªã‚‹å…¥åŠ›ã«ã¯ç•°ãªã‚‹ãƒã‚§ãƒƒã‚¯ã‚µãƒ ã€‚"""
        checksum1 = compute_checksum(b"Hello")
        checksum2 = compute_checksum(b"World")

        assert checksum1 != checksum2

    def test_generate_backup_name_format(self):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€‚"""
        dt = datetime(2026, 1, 23, 10, 30, 0, tzinfo=timezone.utc)

        name = generate_backup_name("0.9.0", dt)

        assert name == "0.9.0_20260123_103000"

    def test_manifest_roundtrip(self):
        """ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºâ†’ãƒ‘ãƒ¼ã‚¹ã§å¾©å…ƒã§ãã‚‹ã€‚"""
        original = create_manifest(
            version="0.9.0",
            reason="Test backup",
            files=[
                BackupFile(path="test.txt", checksum="sha256:abc", size_bytes=100),
            ],
        )

        yaml_str = serialize_manifest(original)
        restored = parse_manifest(yaml_str)

        assert restored.version == original.version
        assert restored.reason == original.reason
        assert len(restored.files) == len(original.files)


class TestBackupOperations:
    """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ“ä½œã®ãƒ†ã‚¹ãƒˆã€‚"""

    def test_collect_backup_files(self, tmp_path: Path):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åé›†ã™ã‚‹ã€‚"""
        # ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        (tmp_path / "TUTORIAL.md").write_text("Tutorial")
        (tmp_path / "pyproject.toml").write_text("[project]")
        (tmp_path / "src").mkdir()
        (tmp_path / "src" / "user_code.py").write_text("# User code")

        files = collect_backup_files(tmp_path)

        # TUTORIAL.md ã¨ pyproject.toml ã¯åé›†ã•ã‚Œã‚‹
        paths = [f[1].path for f in files]
        assert "TUTORIAL.md" in paths
        assert "pyproject.toml" in paths
        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰ã¯å«ã¾ã‚Œãªã„
        assert "src/user_code.py" not in paths

    def test_create_backup_success(self, tmp_path: Path):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆãŒæˆåŠŸã™ã‚‹ã€‚"""
        # ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        (tmp_path / "TUTORIAL.md").write_text("Tutorial content")

        result = create_backup(tmp_path, "0.9.0", "Test backup")

        assert result.success
        assert result.backup is not None
        assert result.backup.path.exists()
        assert (result.backup.path / "manifest.yaml").exists()
        assert (result.backup.path / "TUTORIAL.md").exists()

    def test_list_backups_returns_sorted(self, tmp_path: Path):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒä½œæˆæ—¥æ™‚é™é †ã§ã‚½ãƒ¼ãƒˆã•ã‚Œã‚‹ã€‚"""
        # è¤‡æ•°ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
        create_backup(tmp_path, "0.7.0", "First")
        create_backup(tmp_path, "0.8.0", "Second")
        create_backup(tmp_path, "0.9.0", "Third")

        backups = list_backups(tmp_path)

        assert len(backups) == 3
        # æœ€æ–°ãŒæœ€åˆ
        assert backups[0].version == "0.9.0"
        assert backups[2].version == "0.7.0"

    def test_restore_backup(self, tmp_path: Path):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã§ãã‚‹ã€‚"""
        # ã‚ªãƒªã‚¸ãƒŠãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        tutorial = tmp_path / "TUTORIAL.md"
        tutorial.write_text("Original content")

        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
        result = create_backup(tmp_path, "0.9.0", "Before change")
        backup = result.backup

        # ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´
        tutorial.write_text("Modified content")
        assert tutorial.read_text() == "Modified content"

        # å¾©å…ƒ
        restore_result = restore_backup(tmp_path, backup)

        assert restore_result.success
        assert tutorial.read_text() == "Original content"

    def test_clean_backups_keeps_recent(self, tmp_path: Path):
        """æŒ‡å®šæ•°ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä¿æŒã™ã‚‹ã€‚"""
        # 5å€‹ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
        for i in range(5):
            create_backup(tmp_path, f"0.{i}.0", f"Backup {i}")

        removed_count, _ = clean_backups(tmp_path, keep=2)

        assert removed_count == 3
        assert len(list_backups(tmp_path)) == 2


class TestBackupResultTypes:
    """çµæœå‹ã®ãƒ†ã‚¹ãƒˆã€‚"""

    def test_backup_result_is_immutable(self, tmp_path: Path):
        """BackupResultã¯å¤‰æ›´ä¸å¯ã€‚"""
        result = create_backup(tmp_path, "0.9.0", "Test")

        with pytest.raises(Exception):
            result.success = False

    def test_restore_result_is_immutable(self, tmp_path: Path):
        """RestoreResultã¯å¤‰æ›´ä¸å¯ã€‚"""
        create_backup(tmp_path, "0.9.0", "Test")
        backups = list_backups(tmp_path)
        result = restore_backup(tmp_path, backups[0])

        with pytest.raises(Exception):
            result.success = False
```

### Green Phase: æœ€å°é™ã®å®Ÿè£…

ä¸Šè¨˜ã€Œå®Ÿè£…ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã—ã€ãƒ†ã‚¹ãƒˆã‚’é€šã™ã€‚

### Refactor Phase: æ”¹å–„

1. å·®åˆ†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®æ¤œè¨
2. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ¤œè¨¼æ©Ÿèƒ½ï¼ˆãƒã‚§ãƒƒã‚¯ã‚µãƒ ç…§åˆï¼‰
3. åœ§ç¸®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¿½åŠ 

## ä¾å­˜é–¢ä¿‚

- #03 railway update ã‚³ãƒãƒ³ãƒ‰åŸºæœ¬å®Ÿè£…

## å„ªå…ˆåº¦

**ä¸­** - å®‰å…¨ãªãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«å¿…è¦
