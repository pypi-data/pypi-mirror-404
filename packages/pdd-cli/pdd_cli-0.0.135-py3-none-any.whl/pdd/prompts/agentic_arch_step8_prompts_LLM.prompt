<pdd-reason>Generates prompt files for all modules defined in architecture.json, placing them in the correct directories based on .pddrc configuration.</pdd-reason>
<pdd-interface>
{{
  "type": "module",
  "module": {{
    "functions": [
      {{"name": "generate_prompts", "signature": "(architecture_json: str, pddrc_content: str)", "returns": "str (list of generated prompt files)"}}
    ]
  }}
}}
</pdd-interface>
<pdd-dependency>agentic_arch_step7_pddrc_LLM.prompt</pdd-dependency>
% You are an expert prompt writer for PDD (Prompt-Driven Development). Your task is to generate prompt files for all modules defined in architecture.json.

% Context

You are working on step 8 of the agentic architecture workflow. Step 6 generated architecture.json, Step 7 generated .pddrc. Now generate the actual prompt files.

% Inputs

- GitHub Issue URL: {issue_url}
- Repository: {repo_owner}/{repo_name}
- Issue Number: {issue_number}

% Architecture
<architecture_json>
{step6_output}
</architecture_json>

% PDD Configuration
<pddrc>
{pddrc_content}
</pddrc>

% Prompt Generation Template

<prompt_template>
---
name: generic/generate_prompt
description: Generate a module prompt (.prompt) for any stack (backend, frontend, CLI, jobs) using project docs and context
version: 1.0.0
tags: [template, prompt, generic]
language: prompt
output: prompts/${MODULE}_${LANG_OR_FRAMEWORK}.prompt
variables:
  MODULE:
    required: true
    type: string
    description: Module/component basename to generate a prompt for.
    examples: [orders, auth, users]
  LANG_OR_FRAMEWORK:
    required: false
    type: string
    description: Target language or framework suffix used in prompt naming (matches your stack conventions).
    examples: [Python, TypeScriptReact, Go, Java, Ruby]
    default: Python
  LAYER:
    required: false
    type: string
    description: System layer or interface type for context.
    examples: [backend, frontend, api, graphql, cli, job, message, config, module, component, page]
  PRD_FILE:
    required: false
    type: path
    description: Product requirements document providing overall context.
    example_paths: [PRD.md, docs/product/prd.md]
  API_DOC_FILE:
    required: false
    type: path
    description: API documentation describing endpoints and conventions.
    example_paths: [docs/api-documentation.md, docs/api.md]
  DB_SCHEMA_FILE:
    required: false
    type: path
    description: Database schema or ERD for backend data models.
    example_paths: [context/database-schema.md, docs/db/schema.md]
  BACKEND_FILES_CSV:
    required: false
    type: path
    description: CSV listing backend Python files/modules (for context/reference).
    example_paths: [prompts/backend/python_architecture.csv]
  IO_DEPENDENCIES_CSV:
    required: false
    type: path
    description: CSV of function inputs/outputs and dependencies for backend modules.
    example_paths: [prompts/backend/io_dependencies.csv]
  ARCHITECTURE_FILE:
    required: true
    type: path
    description: Architecture JSON (from architecture/architecture_json) to drive module scope, dependencies, and interface.
    example_paths: [architecture.json]
  TECH_STACK_FILE:
    required: false
    type: path
    description: Tech stack overview (languages, frameworks, infrastructure, tools) for shaping conventions.
    example_paths: [docs/tech_stack.md, docs/architecture/stack.md]
  CODE_GENERATOR_PROMPT:
    required: false
    type: path
    description: Reference code generator prompt to mirror style and expectations.
    example_paths: [prompts/code_generator_python.prompt, prompts/code_generator_main_python.prompt]
  EXISTING_PROMPTS:
    required: false
    type: list
    description: Existing prompt files to use as reference (comma/newline-separated).
    example_paths: [prompts/orders_python.prompt, prompts/auth_python.prompt]
  DEP_EXAMPLE_EXT:
    required: false
    type: string
    description: File extension for dependency examples (for non-Python stacks).
    examples: [py, ts, tsx, go, java]
    default: py
  PDDRC_FILE:
    required: false
    type: path
    description: Project .pddrc configuration file that defines example_output_path and other path conventions.
    example_paths: [.pddrc]
    default: .pddrc
usage:
  generate:
    - name: Minimal (architecture only)
      command: pdd generate --template generic/generate_prompt -e MODULE=orders -e LANG_OR_FRAMEWORK=Python -e ARCHITECTURE_FILE=architecture.json --output 'prompts/${MODULE}_${LANG_OR_FRAMEWORK}.prompt'
    - name: With project docs
      command: pdd generate --template generic/generate_prompt -e MODULE=orders -e LANG_OR_FRAMEWORK=Python -e ARCHITECTURE_FILE=architecture.json -e PRD_FILE=docs/PRD.md -e API_DOC_FILE=docs/api-documentation.md -e DB_SCHEMA_FILE=context/database-schema.md --output 'prompts/${MODULE}_${LANG_OR_FRAMEWORK}.prompt'
    - name: With CSVs and references (backend/Python)
      command: pdd generate --template generic/generate_prompt -e MODULE=orders -e LANG_OR_FRAMEWORK=Python -e ARCHITECTURE_FILE=architecture.json -e PRD_FILE=docs/PRD.md -e API_DOC_FILE=docs/api-documentation.md -e DB_SCHEMA_FILE=context/database-schema.md -e BACKEND_FILES_CSV=prompts/backend/python_architecture.csv -e IO_DEPENDENCIES_CSV=prompts/backend/io_dependencies.csv -e CODE_GENERATOR_PROMPT=prompts/code_generator_python.prompt --output 'prompts/${MODULE}_${LANG_OR_FRAMEWORK}.prompt'
    - name: Frontend (TypeScriptReact) variant
      command: pdd generate --template generic/generate_prompt -e MODULE=profile_page -e LANG_OR_FRAMEWORK=TypeScriptReact -e LAYER=frontend -e ARCHITECTURE_FILE=architecture.json -e PRD_FILE=docs/PRD.md --output 'prompts/${MODULE}_${LANG_OR_FRAMEWORK}.prompt'
    - name: From architecture.json
      command: pdd generate --template generic/generate_prompt -e MODULE=orders_api -e LANG_OR_FRAMEWORK=Python -e LAYER=api -e ARCHITECTURE_FILE=architecture.json --output 'prompts/${MODULE}_${LANG_OR_FRAMEWORK}.prompt'

discover:
  enabled: false
  max_per_pattern: 5
  max_total: 10
---

% You are an expert prompt writer and software architect for PDD. Your goal is to write a high-quality prompt that will generate the code for the ${MODULE} module/component. The prompt you create will be used to produce a detailed implementation specification in a file named ${MODULE}_${LANG_OR_FRAMEWORK}.prompt, suitable for the specified stack and layer.

IMPORTANT: Your reply MUST begin with `<prompt>` on the very first line and end with `</prompt>` on the final line. Do not include any text, whitespace, or code fences outside this block.

% Project context (architecture required, others optional):
<prd>[File not found: ${PRD_FILE}]</prd>
<api>[File not found: ${API_DOC_FILE}]</api>
<database>[File not found: ${DB_SCHEMA_FILE}]</database>
<backend_files_csv>[File not found: ${BACKEND_FILES_CSV}]</backend_files_csv>
<io_dependencies_csv>[File not found: ${IO_DEPENDENCIES_CSV}]</io_dependencies_csv>
<architecture>[File not found: ${ARCHITECTURE_FILE}]</architecture>
<tech_stack>[File not found: ${TECH_STACK_FILE}]</tech_stack>
<generate_code_cli_example>[File not found: ${CODE_GENERATOR_PROMPT}]</generate_code_cli_example>
<pddrc>[File not found: ${PDDRC_FILE}]</pddrc>

% Existing prompt references (optional):
<existing_backend_prompts>[File not found: ${EXISTING_PROMPTS}]</existing_backend_prompts>

% Do the following:
- Explain concisely what you are going to do (create a prompt for the ${MODULE} module/component for the specified layer and stack).
- Analyze any difficulties this prompt might encounter for ${MODULE} (e.g., data modeling, API or UI contracts, transactions, idempotency, auth, state management, error handling) and briefly state mitigation strategies tailored to the given LAYER and LANG_OR_FRAMEWORK.
- Use the ARCHITECTURE_FILE to identify the item that corresponds to this prompt by matching `filename` to `${MODULE}_${LANG_OR_FRAMEWORK}.prompt` (or best match by basename and layer). Use that item’s `reason`, `description`, `dependencies`, `interface`, and `tags` to shape the sections below.
- Then create the prompt content for ${MODULE} inside XML tags named prompt, ensuring conventions fit the stack and layer.
- Ensure the final response consists solely of the `<prompt>...</prompt>` block; nothing else (including whitespace) may appear before `<prompt>` or after `</prompt>`.

% The prompt you generate must follow this structure:
1) First paragraph: describe the role and responsibility of the ${MODULE} module/component within the system (consider the LAYER if provided).
2) A "Requirements" section with numbered points covering functionality, contracts, error handling, validation, logging, performance, and security.
3) A "Dependencies" section using XML include tags for each dependency (see format below).
4) An "Instructions" section with precise implementation guidance (clarify inputs/outputs, function/class responsibilities, edge cases, and testing notes).
5) A clear "Deliverable" section describing the expected code artifacts and entry points.

% Dependencies format and conventions:
- Read the `example_output_path` from the PDDRC_FILE (`.pddrc`) to determine where example files are located. This path is defined under each context's `defaults.example_output_path` setting.
- Represent each dependency using an XML tag with the dependency name, and put the file path inside an <include> tag. Use the example_output_path from .pddrc, e.g. if .pddrc says `example_output_path: "examples/shared/"`:
  <orders_service>
    <include>examples/shared/orders_service_example.${DEP_EXAMPLE_EXT}</include>
  </orders_service>
- Prefer real example files available in the provided context (use <include-many> when listing multiple). If examples are not provided, use the example_output_path from .pddrc with the pattern [example_output_path]/[dependency_name]_example.${DEP_EXAMPLE_EXT}.
- Include all necessary dependencies for the module/component (based on the provided context and references).
- The ARCHITECTURE_FILE lists `dependencies` referencing other prompt filenames. Convert each dependency prompt filename into a sensible dependency name (strip language suffix and `_prompt`), and map to context files with the `${DEP_EXAMPLE_EXT}` extension if present; otherwise, list the prompt filename explicitly in a "Prompt Dependencies" subsection.
- If the matched architecture entry has a `context_urls` array, emit a `<web>` tag for each URL in the Dependencies section. Derive the XML tag name from the `purpose` field (lowercased, non-alphanumeric characters replaced with underscores). Example:
  ```
  <fastapi_routing_patterns>
    <web>https://fastapi.tiangolo.com/tutorial/first-steps/</web>
  </fastapi_routing_patterns>
  ```

% Architecture awareness (ARCHITECTURE_FILE is required):
- Align the "Requirements" and "Instructions" with the selected item’s `interface.type` (e.g., page, component, module, api, graphql, cli, job, message, config).
- For `api`, outline endpoints (method, path, auth) consistent with the architecture description; for `page`/`component`, describe route/props/data sources; for `job`, include trigger and retry policy; for `config`, list keys and sources.

% Style and quality requirements:
- The generated prompt must be detailed enough to yield production-ready code.
- Match the style and patterns of existing *_${LANG_OR_FRAMEWORK}.prompt files when present.
- Do not invent technologies or files; rely on the included context. If assumptions are necessary, state them explicitly and conservatively.

% Output contract:
- Start the output with `<prompt>` on its own line and end with `</prompt>` on its own line.
- Do not emit any characters (including whitespace, markdown fences, or commentary) outside the `<prompt>...</prompt>` block.
- Within the tags, include the sections described above as plain text.
- OUTPUT FORMAT (authoritative – copy/paste and replace the bracketed placeholders, keeping every literal token):
  ```text
  <prompt>
  [ROLE_PARAGRAPH]
  Requirements
  1. [REQ_ITEM_1]
  2. [REQ_ITEM_2]
  Dependencies
  <[DEPENDENCY_TAG_1]>
    <include>[DEPENDENCY_INCLUDE_1]</include>
  </[DEPENDENCY_TAG_1]>
  [OPTIONAL_ADDITIONAL_DEPENDENCY_TAGS]
  Prompt Dependencies:
  [PROMPT_DEPENDENCIES_SECTION]
  Instructions
  - [INSTRUCTION_1]
  - [INSTRUCTION_2]
  Deliverable
  - [DELIVERABLE_1]
  - [DELIVERABLE_2]
  Implementation assumptions (explicit)
  - [ASSUMPTION_1]
  - [ASSUMPTION_2]
  Please produce production-ready prompt content that will generate the module consistent with the above.
  </prompt>
  ```
  Replace each `[PLACEHOLDER]` with concrete content while preserving the surrounding structure and literal `<prompt>` / `<include>` tags.

</prompt_template>

% Key Rules

1. **Prompt file location:**
   - All prompts go FLAT in `prompts/` directory
   - Filename comes DIRECTLY from architecture.json `filename` field
   - Example: `prompts/home_page_TypeScriptReact.prompt`

2. **Prompt content structure:**
   ```
   [Role paragraph - module's responsibility]

   Requirements
   1. [Functional requirement]
   2. [Interface requirement]
   ...

   Dependencies
   <dependency_name>
     <include>examples/BASENAME_example.EXT</include>
   </dependency_name>

   Instructions
   - [Implementation guidance]
   - [Edge cases]

   Deliverable
   - [Expected artifacts]
   ```

3. **Use architecture.json fields:**
   - `reason` → understand why module exists
   - `description` → architectural details
   - `interface` → module contract
   - `dependencies` → what to include

% Output Requirements

1. **Create prompts/ directory:** `mkdir -p prompts`

2. **Write each prompt file** to `prompts/{filename}`

3. **Post summary to GitHub**

4. **Report files:** `FILES_CREATED: prompts/home_page_TypeScriptReact.prompt, ...`

% ============================================================================
% VERIFIED WORKING EXAMPLE - FOLLOW THIS PATTERN EXACTLY
% ============================================================================

This example shows the correct prompt file structure and naming.

<verified_working_example>
% Complete Working Example: Next.js Task Notes Application
% This is a verified, working example that passes pdd sync validation.
% Use this as a reference when generating architecture.json and .pddrc for Next.js projects.

% ============================================================================
% PROJECT OVERVIEW
% ============================================================================

A Next.js 14 App Router project with:
- Prisma for database (PostgreSQL)
- TypeScript throughout
- App Router pages and API routes
- React components

% ============================================================================
% ARCHITECTURE.JSON (VERIFIED WORKING)
% ============================================================================

```json
[
  {
    "reason": "Prisma schema defines the database structure for tasks and categories with proper relationships",
    "description": "Database schema using Prisma ORM with Task and Category models. Tasks have title, content, status, priority, and belong to a category.",
    "dependencies": [],
    "priority": 1,
    "filename": "prisma_schema_Prisma.prompt",
    "filepath": "prisma/schema.prisma",
    "tags": ["database", "prisma", "schema"],
    "interface": {
      "type": "config",
      "config": {
        "keys": [
          {"name": "DATABASE_URL", "type": "string", "required": true, "source": "env"}
        ]
      }
    }
  },
  {
    "reason": "Prisma client singleton for database connections across the application",
    "description": "TypeScript module exporting a singleton Prisma client instance. Handles connection pooling and prevents multiple instances in development.",
    "dependencies": ["prisma_schema_Prisma.prompt"],
    "priority": 2,
    "filename": "prisma_client_TypeScript.prompt",
    "filepath": "lib/prisma.ts",
    "tags": ["database", "prisma", "client"],
    "interface": {
      "type": "module",
      "module": {
        "functions": [
          {"name": "prisma", "signature": "export const prisma: PrismaClient", "returns": "PrismaClient instance"}
        ]
      }
    }
  },
  {
    "reason": "Shared TypeScript types for tasks and categories used across frontend and API",
    "description": "Type definitions for Task, Category, TaskStatus, and TaskPriority. Includes request/response types for API operations.",
    "dependencies": [],
    "priority": 3,
    "filename": "types_TypeScript.prompt",
    "filepath": "lib/types.ts",
    "tags": ["types", "shared"],
    "interface": {
      "type": "module",
      "module": {
        "functions": [
          {"name": "Task", "signature": "interface Task", "returns": "Task type"},
          {"name": "Category", "signature": "interface Category", "returns": "Category type"}
        ]
      }
    }
  },
  {
    "reason": "Root layout provides the app shell with navigation and global providers",
    "description": "Next.js App Router root layout with global styles, metadata, navigation sidebar, and React Query provider.",
    "dependencies": ["types_TypeScript.prompt"],
    "priority": 4,
    "filename": "root_layout_TypeScriptReact.prompt",
    "filepath": "app/layout.tsx",
    "tags": ["frontend", "layout", "nextjs"],
    "interface": {
      "type": "page",
      "page": {
        "route": "/",
        "params": [],
        "dataSources": []
      }
    }
  },
  {
    "reason": "Home page displays dashboard with task summary and quick actions",
    "description": "Main landing page showing task statistics, recent tasks, and quick action buttons. Server component with parallel data fetching.",
    "dependencies": ["types_TypeScript.prompt", "api_tasks_route_TypeScript.prompt"],
    "priority": 5,
    "filename": "home_page_TypeScriptReact.prompt",
    "filepath": "app/page.tsx",
    "tags": ["frontend", "page", "nextjs"],
    "interface": {
      "type": "page",
      "page": {
        "route": "/",
        "params": [],
        "dataSources": [
          {"kind": "api", "source": "/api/tasks", "method": "GET"}
        ]
      }
    }
  },
  {
    "reason": "Tasks list page with filtering, sorting, and pagination",
    "description": "Page displaying all tasks with category filter, status filter, priority sort, and pagination.",
    "dependencies": ["types_TypeScript.prompt", "api_tasks_route_TypeScript.prompt", "task_card_component_TypeScriptReact.prompt"],
    "priority": 6,
    "filename": "tasks_page_TypeScriptReact.prompt",
    "filepath": "app/tasks/page.tsx",
    "tags": ["frontend", "page", "nextjs"],
    "interface": {
      "type": "page",
      "page": {
        "route": "/tasks",
        "params": [
          {"name": "category", "type": "string"},
          {"name": "status", "type": "string"},
          {"name": "page", "type": "number"}
        ],
        "dataSources": [
          {"kind": "api", "source": "/api/tasks", "method": "GET"}
        ]
      }
    }
  },
  {
    "reason": "Task detail page with full content view and edit capabilities",
    "description": "Dynamic route page displaying single task details with inline editing and status updates.",
    "dependencies": ["types_TypeScript.prompt", "api_tasks_id_route_TypeScript.prompt"],
    "priority": 7,
    "filename": "task_detail_page_TypeScriptReact.prompt",
    "filepath": "app/tasks/[id]/page.tsx",
    "tags": ["frontend", "page", "nextjs", "dynamic"],
    "interface": {
      "type": "page",
      "page": {
        "route": "/tasks/[id]",
        "params": [
          {"name": "id", "type": "string"}
        ],
        "dataSources": [
          {{"kind": "api", "source": "/api/tasks/{{id}}", "method": "GET"}}
        ]
      }
    }
  },
  {
    "reason": "Categories page for managing task categories",
    "description": "Page for viewing and managing categories with task counts and color picker.",
    "dependencies": ["types_TypeScript.prompt", "api_categories_route_TypeScript.prompt"],
    "priority": 8,
    "filename": "categories_page_TypeScriptReact.prompt",
    "filepath": "app/categories/page.tsx",
    "tags": ["frontend", "page", "nextjs"],
    "interface": {
      "type": "page",
      "page": {
        "route": "/categories",
        "params": [],
        "dataSources": [
          {"kind": "api", "source": "/api/categories", "method": "GET"}
        ]
      }
    }
  },
  {
    "reason": "Reusable task card component for displaying task preview",
    "description": "Client component rendering task preview card with title, status badge, priority indicator, and category tag.",
    "dependencies": ["types_TypeScript.prompt"],
    "priority": 9,
    "filename": "task_card_component_TypeScriptReact.prompt",
    "filepath": "components/TaskCard.tsx",
    "tags": ["frontend", "component", "ui"],
    "interface": {
      "type": "component",
      "component": {
        "props": [
          {"name": "task", "type": "Task", "required": true},
          {"name": "onStatusChange", "type": "(status: TaskStatus) => void", "required": false}
        ],
        "emits": ["statusChange", "click"]
      }
    }
  },
  {
    "reason": "Task form component for creating and editing tasks",
    "description": "Form component with controlled inputs for task title, content, category, priority, and due date.",
    "dependencies": ["types_TypeScript.prompt"],
    "priority": 10,
    "filename": "task_form_component_TypeScriptReact.prompt",
    "filepath": "components/TaskForm.tsx",
    "tags": ["frontend", "component", "form"],
    "interface": {
      "type": "component",
      "component": {
        "props": [
          {"name": "initialData", "type": "Partial<Task>", "required": false},
          {"name": "categories", "type": "Category[]", "required": true},
          {"name": "onSubmit", "type": "(data: CreateTaskInput) => Promise<void>", "required": true}
        ],
        "emits": ["submit", "cancel"]
      }
    }
  },
  {
    "reason": "API route for listing and creating tasks",
    "description": "Next.js API route handler for GET (list with filters) and POST (create) operations.",
    "dependencies": ["prisma_client_TypeScript.prompt", "types_TypeScript.prompt"],
    "priority": 11,
    "filename": "api_tasks_route_TypeScript.prompt",
    "filepath": "app/api/tasks/route.ts",
    "tags": ["backend", "api", "nextjs"],
    "interface": {
      "type": "api",
      "api": {
        "endpoints": [
          {"method": "GET", "path": "/api/tasks", "auth": "none", "responseSchema": "{ tasks: Task[], total: number }"},
          {"method": "POST", "path": "/api/tasks", "auth": "none", "requestSchema": "CreateTaskInput", "responseSchema": "Task"}
        ]
      }
    }
  },
  {
    "reason": "API route for single task operations (read, update, delete)",
    "description": "Dynamic API route for task CRUD operations by ID.",
    "dependencies": ["prisma_client_TypeScript.prompt", "types_TypeScript.prompt"],
    "priority": 12,
    "filename": "api_tasks_id_route_TypeScript.prompt",
    "filepath": "app/api/tasks/[id]/route.ts",
    "tags": ["backend", "api", "nextjs", "dynamic"],
    "interface": {
      "type": "api",
      "api": {
        "endpoints": [
          {"method": "GET", "path": "/api/tasks/[id]", "auth": "none", "responseSchema": "Task"},
          {"method": "PATCH", "path": "/api/tasks/[id]", "auth": "none", "requestSchema": "Partial<Task>", "responseSchema": "Task"},
          {"method": "DELETE", "path": "/api/tasks/[id]", "auth": "none", "responseSchema": "{ success: boolean }"}
        ]
      }
    }
  },
  {
    "reason": "API route for category management",
    "description": "API route for listing categories with task counts and creating new categories.",
    "dependencies": ["prisma_client_TypeScript.prompt", "types_TypeScript.prompt"],
    "priority": 13,
    "filename": "api_categories_route_TypeScript.prompt",
    "filepath": "app/api/categories/route.ts",
    "tags": ["backend", "api", "nextjs"],
    "interface": {
      "type": "api",
      "api": {
        "endpoints": [
          {"method": "GET", "path": "/api/categories", "auth": "none", "responseSchema": "{ categories: CategoryWithCount[] }"},
          {"method": "POST", "path": "/api/categories", "auth": "none", "requestSchema": "{ name: string, color?: string }", "responseSchema": "Category"}
        ]
      }
    }
  }
]
```

% ============================================================================
% .PDDRC CONFIGURATION (VERIFIED WORKING)
% ============================================================================

```yaml
version: "1.0"

contexts:
  # ============================================================
  # DATABASE / PRISMA
  # ============================================================

  prisma_schema:
    paths: ["*prisma_schema*"]
    defaults:
      outputs:
        code:
          path: "prisma/schema.prisma"

  prisma_client:
    paths: ["*prisma_client*"]
    defaults:
      outputs:
        code:
          path: "lib/prisma.ts"

  # ============================================================
  # SHARED TYPES
  # ============================================================

  types:
    paths: ["*types*"]
    defaults:
      outputs:
        code:
          path: "lib/types.ts"

  # ============================================================
  # PAGES (Next.js App Router)
  # ============================================================

  root_layout:
    paths: ["*root_layout*"]
    defaults:
      outputs:
        code:
          path: "app/layout.tsx"

  home_page:
    paths: ["*home_page*"]
    defaults:
      outputs:
        code:
          path: "app/page.tsx"

  tasks_page:
    paths: ["*tasks_page*"]
    defaults:
      outputs:
        code:
          path: "app/tasks/page.tsx"

  task_detail_page:
    paths: ["*task_detail_page*"]
    defaults:
      outputs:
        code:
          path: "app/tasks/[id]/page.tsx"

  categories_page:
    paths: ["*categories_page*"]
    defaults:
      outputs:
        code:
          path: "app/categories/page.tsx"

  # ============================================================
  # COMPONENTS
  # ============================================================

  task_card_component:
    paths: ["*task_card_component*"]
    defaults:
      outputs:
        code:
          path: "components/TaskCard.tsx"

  task_form_component:
    paths: ["*task_form_component*"]
    defaults:
      outputs:
        code:
          path: "components/TaskForm.tsx"

  # ============================================================
  # API ROUTES
  # ============================================================

  api_tasks_route:
    paths: ["*api_tasks_route*"]
    defaults:
      outputs:
        code:
          path: "app/api/tasks/route.ts"

  api_tasks_id_route:
    paths: ["*api_tasks_id_route*"]
    defaults:
      outputs:
        code:
          path: "app/api/tasks/[id]/route.ts"

  api_categories_route:
    paths: ["*api_categories_route*"]
    defaults:
      outputs:
        code:
          path: "app/api/categories/route.ts"

  # ============================================================
  # DEFAULT FALLBACK
  # ============================================================
  # CRITICAL: prompts_dir goes ONLY here, not in other contexts!

  default:
    defaults:
      prompts_dir: "prompts/"
      generate_output_path: "src/"
```

% ============================================================================
% PROMPT FILES (FLAT DIRECTORY STRUCTURE)
% ============================================================================

All prompt files are placed FLAT in the `prompts/` directory:

```
prompts/
├── prisma_schema_Prisma.prompt
├── prisma_client_TypeScript.prompt
├── types_TypeScript.prompt
├── root_layout_TypeScriptReact.prompt
├── home_page_TypeScriptReact.prompt
├── tasks_page_TypeScriptReact.prompt
├── task_detail_page_TypeScriptReact.prompt
├── categories_page_TypeScriptReact.prompt
├── task_card_component_TypeScriptReact.prompt
├── task_form_component_TypeScriptReact.prompt
├── api_tasks_route_TypeScript.prompt
├── api_tasks_id_route_TypeScript.prompt
└── api_categories_route_TypeScript.prompt
```

% ============================================================================
% VERIFICATION RESULTS (CONFIRMED WORKING)
% ============================================================================

Running the verification script:

```python
from pdd.sync_determine_operation import get_pdd_file_paths

modules = [
    ('prisma_schema', 'prisma', 'prisma_schema'),
    ('prisma_client', 'typescript', 'prisma_client'),
    ('types', 'typescript', 'types'),
    ('root_layout', 'typescriptreact', 'root_layout'),
    ('home_page', 'typescriptreact', 'home_page'),
    ('tasks_page', 'typescriptreact', 'tasks_page'),
    ('task_detail_page', 'typescriptreact', 'task_detail_page'),
    ('categories_page', 'typescriptreact', 'categories_page'),
    ('task_card_component', 'typescriptreact', 'task_card_component'),
    ('task_form_component', 'typescriptreact', 'task_form_component'),
    ('api_tasks_route', 'typescript', 'api_tasks_route'),
    ('api_tasks_id_route', 'typescript', 'api_tasks_id_route'),
    ('api_categories_route', 'typescript', 'api_categories_route'),
]

for basename, language, context in modules:
    result = get_pdd_file_paths(basename, language, 'prompts', context_override=context)
    print(f"{{basename}}: {{result.get('code')}}")
```

**Output (all paths correct):**
```
prisma_schema: prisma/schema.prisma
prisma_client: lib/prisma.ts
types: lib/types.ts
root_layout: app/layout.tsx
home_page: app/page.tsx
tasks_page: app/tasks/page.tsx
task_detail_page: app/tasks/[id]/page.tsx
categories_page: app/categories/page.tsx
task_card_component: components/TaskCard.tsx
task_form_component: components/TaskForm.tsx
api_tasks_route: app/api/tasks/route.ts
api_tasks_id_route: app/api/tasks/[id]/route.ts
api_categories_route: app/api/categories/route.ts
```

% ============================================================================
% KEY PATTERNS TO FOLLOW
% ============================================================================

1. **Filename format**: `{{descriptive_name}}_{{Language}}.prompt`
   - Use underscores, NOT slashes
   - Language is PascalCase: `TypeScript`, `TypeScriptReact`, `Prisma`

2. **Basename extraction**:
   - `home_page_TypeScriptReact.prompt` → basename = `home_page`
   - `api_tasks_id_route_TypeScript.prompt` → basename = `api_tasks_id_route`

3. **Context naming**: Use basename as context name
   - filename `home_page_TypeScriptReact.prompt` → context name `home_page`

4. **paths pattern**: Use `["*{{basename}}*"]`
   - Context `home_page` → paths `["*home_page*"]`

5. **outputs.code.path**: Use EXACT filepath from architecture.json
   - filepath `app/page.tsx` → `outputs.code.path: "app/page.tsx"`

6. **prompts_dir**: ONLY in `default` context
   - Never duplicate in other contexts

% ============================================================================
% COMMANDS TO RUN
% ============================================================================

```bash
# Sync individual modules
pdd sync prisma_schema    # → prisma/schema.prisma
pdd sync home_page        # → app/page.tsx
pdd sync api_tasks_route  # → app/api/tasks/route.ts

# Dry run to verify without generating
pdd sync home_page --dry-run
```

</verified_working_example>

% Your Task

Generate prompt files for ALL modules in architecture.json.

For each module:
1. Create file at `prompts/{filename}` (filename from architecture.json)
2. Include rich context from reason, description, interface fields
3. Add <include> tags for dependencies

Remember:
- Prompts are FLAT in prompts/ directory (no subdirectories)
- Filename comes directly from architecture.json
- Filenames MUST use valid language suffixes: `TypeScript`, `TypeScriptReact`, `Python`, etc.
  - ❌ WRONG: `_NextJS.prompt`, `_React.prompt`, `_Node.prompt`
  - ✅ CORRECT: `_TypeScript.prompt`, `_TypeScriptReact.prompt`, `_Python.prompt`
