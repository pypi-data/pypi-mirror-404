% You are an expert prompt engineer. You will be given a list of LLM prompts and a change description. Your task is to analyze which prompts need to be changed based on the change description, and provide detailed instructions on how they should be changed.

% Here are the inputs:
<input>
    <prompt_list>
    {PROMPT_LIST}
    </prompt_list>

    <change_description>
    {CHANGE_DESCRIPTION}
    </change_description>
</input>
 

% Here is an example of an output for a given input:
<example>
    <input_example>
        <prompt_list_example>
        [{"PROMPT_NAME": "change_python.prompt", "PROMPT_DESCRIPTION": "% You are an expert Python Software Engineer. Your goal is to write a Python function, \"change\", that will modify an input_prompt into a modified_prompt per the change_prompt. All output to the console will be pretty printed using the Python Rich library. Ensure that the module imports are done using relative imports.\n\n% Here are the inputs and outputs of the function:\n    Inputs:\n        - 'input_prompt' - A string that contains the prompt that will be modified by the change_prompt.\n        - 'input_code' - A string that contains the code that was generated from the input_prompt.\n        - 'change_prompt' - A string that contains the instructions of how to modify the input_prompt.\n        - 'strength': A float value representing the strength parameter for the LLM model, used to influence the model's behavior.\n        - 'temperature': A float value representing the temperature parameter for the LLM model, used to control the randomness of the model's output.\n    Outputs:\n        - 'modified_prompt' - A string that contains the modified prompt that was changed based on the change_prompt.\n        - 'total_cost': A float value representing the total cost of running the function.\n        - 'model_name': A string representing the name of the selected LLM model.\n\n% Here is an example how to preprocess the prompt from a file: ```<./context/preprocess_example.py>```\n\n% Example usage of the Langchain LCEL program: ```<./context/langchain_lcel_example.py>```\n\n% Example of selecting a Langchain LLM and counting tokens using llm_selector: ```<./context/llm_selector_example.py>```\n\n% Steps to be followed by the function:\n    1. Load the '$PDD_PATH/prompts/xml/change_LLM.prompt' and '$PDD_PATH/prompts/extract_prompt_change_LLM.prompt' files.\n    2. Preprocess the change_LLM prompt using the preprocess function from the preprocess module and set double_curly_brackets to false.\n    3. Create a Langchain LCEL template from the processed change_LLM prompt to return a string output.    \n    4. Use the llm_selector function for the LLM model and token counting.\n    5. Run the input_prompt through the model using Langchain LCEL:\n        - a. Pass the following string parameters to the prompt during invocation:             \n            * 'input_prompt'\n            * 'input_code'\n            * 'change_prompt' (preprocess this with double_curly_brackets set to false)\n        - b. Calculate the input and output token count using token_counter from llm_selector and pretty print the output of 4a, including the token count and estimated cost. The cost from llm_selector is in dollars per million tokens.\n    6. Create a Langchain LCEL template with strength .9 from the extract_prompt_change_LLM prompt that outputs JSON:\n        - a. Pass the following string parameters to the prompt during invocation: 'llm_output' (this string is from Step 4).\n        - b. Calculate input and output token count using token_counter from llm_selector and pretty print the running message with the token count and cost.\n        - c. Use 'get' function to extract 'modified_prompt' key values using from the dictionary output.\n    7. Pretty print the extracted modified_prompt using Rich Markdown function. Include token counts and costs.\n    8. Return the 'modified_prompt' string, the total_cost of both invokes and model_name use for the change_LLM prompt.\n\n% Ensure the function handles edge cases, such as missing inputs or model errors, and provide clear error messages."}, {"PROMPT_NAME": "preprocess_python.prompt", "PROMPT_DESCRIPTION": "% You are an expert Python engineer. Your goal is to write a Python function, 'preprocess_prompt', that will preprocess the prompt from a prompt string for a LLM. This will use regular expressions to preprocess specific XML-like tags, if any, in the prompt. All output to the console will be pretty print using the Python rich library.\n\n% Here are the inputs and outputs of the function:\n    Input: \n        'prompt' - A string that is the prompt to preprocess\n        'recursive' - A boolean that is True if the program needs to recursively process the includes in the prompt and False if it does not need to recursively process the prompt. Default is True.\n        'double_curly_brackets' - A boolean that is True if the curly brackets need to be doubled and False if they do not need to be doubled. Default is True.\n        'exclude_keys' - An optional list of strings that are excluded from the curly bracket doubling.\n    Output: returns a string that is the preprocessed prompt, with any leading or trailing whitespace removed.\n\n% Here are the XML-like tags to preprocess, other tags will remain unmodified:\n    'include' - This tag will include the content of the file indicated in the include tag. The 'include tag' will be directly replaced with the content of the file in the prompt, without wrapping it in a new tag.\n    'pdd' - This tag indicates a comment and anything in this XML will be deleted from the string including the 'pdd' tags themselves.\n    'shell' - This tag indicates that there are shell commands to run. Capture all output of the shell commands and include it in the prompt but remove the shell tags.\n\n% Includes can be nested, that is there can be includes inside of the files of the includes and 'preprocess' should be called recursively on these include files if recursive is True. There are two ways of having includes in the prompt:\n    1. Will check to see if the file has any angle brackets in triple backticks. If so, it will read the included file indicated in the angle brackets and replace the angle brackets with the content of the included file. This will be done recursively until there are no more angle brackets in triple backticks. The program will then remove the angle brackets but leave the contents in the triple backticks.\n    2. The XML 'include' mentioned above.\n\n% If double_curly_brackets is True, the program will check to see if the file has any single curly brackets and if it does and the string in the curly brackets are not in the exclude_keys list, it will check to see if the curly brackets are already doubled before doubling the curly brackets.\n\n% The program should resolve file paths using the PDD_PATH environment variable. Implement a function 'get_file_path' that takes a file name and returns the full path using this environment variable.\n\n% Keep the user informed of the progress of the program by pretty printing messages."}, {"PROMPT_NAME": "unfinished_prompt_python.prompt", "PROMPT_DESCRIPTION": "% You are an expert Python engineer. Your goal is to write a python function called 'unfinished_prompt' that will determine if a given prompt is complete or needs to continue.\n\n% Here are the inputs and outputs of the function:\n    Inputs:\n        'prompt_text' - A string containing the prompt text to analyze.\n        'strength' - A float that is the strength of the LLM model to use for the analysis. Default is 0.5.\n        'temperature' - A float that is the temperature of the LLM model to use for the analysis. Default is 0.\n    Outputs:\n        'reasoning' - A string containing the structured reasoning for the completeness assessment.\n        'is_finished' - A boolean indicating whether the prompt is complete (True) or incomplete (False).\n        'total_cost' - A float that is the total cost of the analysis function. This is an optional output.\n        'model_name' - A string that is the name of the LLM model used for the analysis. This is an optional output.\n\n% Here is an example of a Langchain LCEL program: ```<./context/langchain_lcel_example.py>```\n\n% Here is an example how to select the Langchain llm and count tokens: ```<./context/llm_selector_example.py>```\n\n% Note: Use relative import for 'llm_selector' to ensure compatibility within the package structure (i.e. 'from .llm_selector') instead of 'from pdd.llm_selector'.\n\n% This function will do the following:\n    Step 1. Use $PDD_PATH environment variable to get the path to the project. Load the '$PDD_PATH/prompts/unfinished_prompt_LLM.prompt' file.\n    Step 2. Create a Langchain LCEL template from unfinished_prompt_LLM prompt so that it returns a JSON output.\n    Step 3. Use the llm_selector function for the LLM model.\n    Step 4. Run the prompt text through the model using Langchain LCEL.\n        4a. Pass the following string parameters to the prompt during invoke:\n            - 'PROMPT_TEXT'\n        4b. Pretty print a message letting the user know it is running and how many tokens (using token_counter function from llm_selector) are in the prompt and the cost. The cost from llm_selector is in dollars per million tokens.\n        4c. The dictionary output of the LCEL will have the keys 'reasoning' and 'is_finished'. Be sure to access these keys using the get method with default error messages.\n        4d. Pretty print the reasoning and completion status using the rich library. Also, print the number of tokens in the result, the output token cost and the total_cost.\n    Step 5. Return the 'reasoning' string and 'is_finished' boolean from the JSON output using 'get', and the 'total_cost' float, and 'model_name' string.\n\n% Ensure that the function handles potential errors gracefully, such as missing input parameters or issues with the LLM model responses.\n\n"}, {"PROMPT_NAME": "xml_tagger_python.prompt", "PROMPT_DESCRIPTION": "% You are an expert Python engineer. Your goal is to write a Python function, \"xml_tagger\", that will enhance a given LLM prompt by adding XML tags to improve its structure and readability.\n\n% You are an expert Python engineer.

% Code Style Requirements
- File must start with `from __future__ import annotations`.
- All functions must be fully type-hinted.
- Use `rich.console.Console` for all printing.

% Package Structure
- The function should be part of a Python package, using relative imports (single dot) for internal modules (e.g. 'from .module_name import module_name').
- The ./pdd/__init__.py file will have the EXTRACTION_STRENGTH, DEFAULT_STRENGTH, DEFAULT_TIME and other global constants. Example: ```from . import DEFAULT_STRENGTH```

% Error Handling
- Ensure the function handles edge cases, such as missing inputs or model errors, and provide clear error messages.\n\n% Here are the inputs and outputs of the function:\n    Input: \n        'raw_prompt' - A string containing the prompt that needs XML tagging to improve its organization and clarity.\n        'strength' - A float value representing the strength parameter for the LLM model.\n        'temperature' - A float value representing the temperature parameter for the LLM model.\n    Output: \n        'xml_tagged' - A string containing the prompt with properly added XML tags.\n        'total_cost' - A float representing the total cost of running the LCELs.\n        'model_name' - A string representing the name of the selected LLM model.\n\n% Here is an example of a LangChain Expression Language (LCEL) program: <lcel_example>import os
from langchain_core.prompts import PromptTemplate
from langchain_community.cache import SQLiteCache
from langchain_community.llms.mlx_pipeline import MLXPipeline
from langchain.globals import set_llm_cache
from langchain_core.output_parsers import JsonOutputParser, PydanticOutputParser # Parsers are only avaiable in langchain_core.output_parsers not langchain.output_parsers
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough, ConfigurableField

from langchain_openai import AzureChatOpenAI
from langchain_fireworks import Fireworks 
from langchain_anthropic import ChatAnthropic
from langchain_openai import ChatOpenAI # Chatbot and conversational tasks
from langchain_openai import OpenAI # General language tasks
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_google_vertexai import ChatVertexAI
from langchain_groq import ChatGroq
from langchain_together import Together

from langchain.callbacks.base import BaseCallbackHandler
from langchain.schema import LLMResult

import json

from langchain_community.chat_models.mlx import ChatMLX
from langchain_core.messages import HumanMessage

from langchain_ollama.llms import OllamaLLM
from langchain_aws import ChatBedrockConverse

# Define a base output parser (e.g., PydanticOutputParser)
from pydantic import BaseModel, Field



class CompletionStatusHandler(BaseCallbackHandler):
    def __init__(self):
        self.is_complete = False
        self.finish_reason = None
        self.input_tokens = None
        self.output_tokens = None

    def on_llm_end(self, response: LLMResult, **kwargs) -> None:
        self.is_complete = True
        if response.generations and response.generations[0]:
            generation = response.generations[0][0]
            self.finish_reason = generation.generation_info.get('finish_reason').lower()
            
            # Extract token usage
            if hasattr(generation.message, 'usage_metadata'):
                usage_metadata = generation.message.usage_metadata
                self.input_tokens = usage_metadata.get('input_tokens')
                self.output_tokens = usage_metadata.get('output_tokens')
        # print("response:",response)
        print("Extracted information:")
        print(f"Finish reason: {self.finish_reason}")
        print(f"Input tokens: {self.input_tokens}")
        print(f"Output tokens: {self.output_tokens}")

# Set up the LLM with the custom handler
handler = CompletionStatusHandler()
# Always setup cache to save money and increase speeds
set_llm_cache(SQLiteCache(database_path=".langchain.db"))


# Create the LCEL template. Make note of the variable {topic} which will be filled in later.
prompt_template = PromptTemplate.from_template("Tell me a joke about {topic}")

llm = ChatGoogleGenerativeAI(model="gemini-2.5-pro-exp-03-25", temperature=0, callbacks=[handler])
# Combine with a model and parser to output a string
chain = prompt_template |llm| StrOutputParser()

# Run the template. Notice that the input is a dictionary with a single key "topic" which feeds it into the above prompt template. This is needed because the prompt template has a variable {topic} which needs to be filled in when invoked.
result = chain.invoke({"topic": "cats"})
print("********Google:", result)


llm = ChatVertexAI(model="gemini-2.5-pro-exp-03-25", temperature=0, callbacks=[handler])
# Combine with a model and parser to output a string
chain = prompt_template |llm| StrOutputParser()

# Run the template. Notice that the input is a dictionary with a single key "topic" which feeds it into the above prompt template. This is needed because the prompt template has a variable {topic} which needs to be filled in when invoked.
result = chain.invoke({"topic": "cats"})
print("********GoogleVertex:", result)


# Define your desired data structure.
class Joke(BaseModel):
    setup: str = Field(description="question to set up a joke")
    punchline: str = Field(description="answer to resolve the joke")


# Set up a parser
parser = JsonOutputParser(pydantic_object=Joke)

# Create a prompt template
prompt = PromptTemplate(
    template="Answer the user query.\n{format_instructions}\n{query}\n",
    input_variables=["query"],
    partial_variables={"format_instructions": parser.get_format_instructions()},
)

llm_no_struct = ChatOpenAI(model="gpt-4o-mini", temperature=0, 
                           callbacks=[handler]) 
llm = llm_no_struct.with_structured_output(Joke) # with structured output forces the output to be a specific object, in this case Joke. Only OpenAI models have structured output
# Chain the components. 
#  The class `LLMChain` was deprecated in LangChain 0.1.17 and will be removed in 1.0. Use RunnableSequence, e.g., `prompt | llm` instead.
chain = prompt | llm 

# Invoke the chain with a query. 
# IMPORTANT: chain.run is now obsolete. Use chain.invoke instead.
result = chain.invoke({"query": "Tell me a joke about openai."})
print("4o mini JSON: ",result)
print(result.setup) # How to access the structured output

llm = ChatOpenAI(model="o1", temperature=1, 
                           callbacks=[handler],model_kwargs = {"max_completion_tokens" : 1000})
# Chain the components. 
#  The class `LLMChain` was deprecated in LangChain 0.1.17 and will be removed in 1.0. Use RunnableSequence, e.g., `prompt | llm` instead.
chain = prompt | llm | parser

# Invoke the chain with a query. 
# IMPORTANT: chain.run is now obsolete. Use chain.invoke instead.
result = chain.invoke({"query": "Tell me a joke about openai."})
print("o1 JSON: ",result)

# Get DEEPSEEK_API_KEY environmental variable

deepseek_api_key = os.getenv('DEEPSEEK_API_KEY')

# Ensure the API key is retrieved successfully
if deepseek_api_key is None:
    raise ValueError("DEEPSEEK_API_KEY environment variable is not set")

llm = ChatOpenAI(
    model='deepseek-chat', 
    openai_api_key=deepseek_api_key, 
    openai_api_base='https://api.deepseek.com',
    temperature=0, callbacks=[handler]
)

# Chain the components
chain = prompt | llm | parser

# Invoke the chain with a query
result = chain.invoke({"query": "Write joke about deepseek."})
print("deepseek",result)


# Set up a parser
parser = PydanticOutputParser(pydantic_object=Joke)
# Chain the components
chain = prompt | llm | parser

# Invoke the chain with a query
result = chain.invoke({"query": "Write joke about deepseek and pydantic."})
print("deepseek pydantic",result)

# Set up the Azure ChatOpenAI LLM instance
llm_no_struct = AzureChatOpenAI(
    model="o4-mini",
    temperature=1,
    callbacks=[handler]
)
llm = llm_no_struct.with_structured_output(Joke) # with structured output forces the output to be a specific JSON format
# Chain the components: prompt | llm | parser
chain = prompt | llm # returns a Joke object

# Invoke the chain with a query
result = chain.invoke({"query": "What is Azure?"})  # Pass a dictionary if `invoke` expects it
print("Azure Result:", result)

# Set up a parser
parser = JsonOutputParser(pydantic_object=Joke)

llm = Fireworks(
    model="accounts/fireworks/models/llama4-maverick-instruct-basic",
    temperature=0, callbacks=[handler])
# Chain the components
chain = prompt | llm | parser

# Invoke the chain with a query
# no money in account
# result = chain.invoke({"query": "Tell me a joke about the president"})
# print("fireworks",result)





prompt = ChatPromptTemplate.from_template(
    "Tell me a short joke about {topic}"
)
chat_openai = ChatOpenAI(model="gpt-3.5-turbo", callbacks=[handler])
openai = OpenAI(model="gpt-3.5-turbo-instruct", callbacks=[handler])
anthropic = ChatAnthropic(model="claude-2", callbacks=[handler])
model = (
    chat_openai
    .with_fallbacks([anthropic])
    .configurable_alternatives(
        ConfigurableField(id="model"),
        default_key="chat_openai",
        openai=openai,
        anthropic=anthropic,
    )
)

chain = (
    {"topic": RunnablePassthrough()} 
    | prompt 
    | model 
    | StrOutputParser()
)
result = chain.invoke({"topic": "Tell me a joke about the president"})
print("config alt:",result)



llm = ChatAnthropic(
    model="claude-3-7-sonnet-latest",
    max_tokens=5000,  # Total tokens for the response
    thinking={"type": "enabled", "budget_tokens": 2000},  # Tokens for internal reasoning
)

response = llm.invoke("What is the cube root of 50.653?")
print(json.dumps(response.content, indent=2))


llm = ChatGroq(temperature=0, model_name="qwen-qwq-32b", callbacks=[handler])
system = "You are a helpful assistant."
human = "{text}"
prompt = ChatPromptTemplate.from_messages([("system", system), ("human", human)])

chain = prompt | llm | StrOutputParser()
print(chain.invoke({"text": "Explain the importance of low latency LLMs."}))


llm = Together(
    model="meta-llama/Llama-3-70b-chat-hf",
    max_tokens=500, callbacks=[handler]
)
chain = prompt | llm | StrOutputParser()
print(chain.invoke({"text": "Explain the importance of together.ai."}))


# Define a prompt template with placeholders for variables
prompt_template = PromptTemplate.from_template("Tell me a {adjective} joke about {content}.")

# Format the prompt with the variables
formatted_prompt = prompt_template.format(adjective="funny", content="data scientists")

# Print the formatted prompt
print(formatted_prompt)


# Set up the LLM with the custom handler
handler = CompletionStatusHandler()


llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.9, callbacks=[handler])

prompt = PromptTemplate.from_template("What is a good name for a company that makes {product}?")

chain = prompt | llm

# Invoke the chain
response = chain.invoke({"product":"colorful socks"})

# Check completion status
print(f"Is complete: {handler.is_complete}")
print(f"Finish reason: {handler.finish_reason}")
print(f"Response: {response}")
print(f"Input tokens: {handler.input_tokens}")
print(f"Output tokens: {handler.output_tokens}")



template = """Question: {question}"""

prompt = ChatPromptTemplate.from_template(template)

model = OllamaLLM(model="qwen2.5-coder:32b")

chain = prompt | model

output = chain.invoke({"question": "Write a python function that calculates Pi"})
print(output)



llm = MLXPipeline.from_model_id(
    "mlx-community/quantized-gemma-2b-it",
    pipeline_kwargs={"max_tokens": 10, "temp": 0.1},
)


chat_model = ChatMLX(llm=llm)
messages = [HumanMessage(content="What happens when an unstoppable force meets an immovable object?")]
response = chat_model.invoke(messages)
print(response.content)



llm = ChatBedrockConverse(
    model_id="anthropic.claude-3-5-sonnet-20240620-v1:0",
    # Additional parameters like temperature, max_tokens can be set here
)

messages = [HumanMessage(content="What happens when an unstoppable force meets an immovable sonnet?")]
response = llm.invoke(messages)
print(response.content)</lcel_example>\n\n% Here are examples of how to use internal modules:\n<internal_example_modules>\n    % Example of selecting a Langchain LLM and counting tokens using llm_selector: <llm_selector_example>from pdd.llm_selector import llm_selector

def main() -> None:
    """
    Main function to demonstrate the usage of the llm_selector function.
    """
    # Define the strength and temperature parameters
    strength: float = 0.5  # Example strength value for the LLM model
    temperature: float = 1.0  # Example temperature value for the LLM model

    try:       
        while strength <= 1.1: 
            # Call the llm_selector function with the specified strength and temperature
            llm, token_counter, input_cost, output_cost, model_name = llm_selector(strength, temperature)
            print(f"Strength: {strength}")
            
            # Print the details of the selected LLM model
            print(f"Selected LLM Model: {model_name}")
            print(f"Input Cost per Million Tokens: {input_cost}")
            print(f"Output Cost per Million Tokens: {output_cost}")

            # Example usage of the token counter function
            sample_text: str = "This is a sample text to count tokens."
            token_count: int = token_counter(sample_text)
            print(f"Token Count for Sample Text: {token_count}")
            print(f"model_name: {model_name}")
            strength += 0.05
    except FileNotFoundError as e:
        print(f"Error: {e}")
    except ValueError as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()</llm_selector_example>\n</internal_example_modules>\n\n% This program will use Langchain to do the following:\n    Step 1. Use $PDD_PATH environment variable to get the path to the project. Load the '$PDD_PATH/prompts/xml_convertor_LLM.prompt' and '$PDD_PATH/prompts/extract_xml_LLM.prompt' files.\n    Step 2. Create a Langchain LCEL template from xml_convertor prompt so that it returns a string output.\n    Step 3. Use the llm_selector function for the LLM model and token counting.\n    Step 4. Run the code through the model using Langchain LCEL. \n        4a. Pass the following string parameters to the prompt during invoke:\n            - 'raw_prompt'\n        4b. Pretty print a message letting the user know it is running and how many tokens (using token_counter from llm_selector) are in the prompt and the cost. The cost from llm_selector is in dollars per million tokens. \n        4c. The string output of the LCEL will be 'xml_generated_analysis' that contains the tagged prompt.\n    Step 5. The code result of the model will contain a mix of text and XML separated by triple backticks. Create a Langchain LCEL template but with a llm_selector with strength .8 from the extract_xml prompt that has a JSON output.\n        5a. Pass the following string parameters to the prompt during invoke:\n            - 'xml_generated_analysis'\n        5b. Pretty print a message letting the user know it is running and how many tokens (using token_counter from llm_selector) are in the prompt and the cost. The cost from llm_selector is in dollars per million tokens.\n        5c. The JSON output of the LCEL will have the key 'xml_tagged' that contains the extracted tagged prompt.\n    Step 6. Pretty print the extracted tagged prompt using the rich Markdown function. Also, print the number of tokens in the result and the cost.\n    Step 7. Calculate the total cost by summing the costs from both LCEL runs.\n    Step 8. Return the 'xml_tagged' string using 'get', the 'total_cost' and 'model_name'."}]
        </prompt_list_example>

        <change_description_example>
        % Use context/python_preamble.prompt to make prompts more compact. Some prompts might already have this.

% Here is what is inside context/python_preamble.prompt:<preamble>% You are an expert Python engineer.

% Code Style Requirements
- File must start with `from __future__ import annotations`.
- All functions must be fully type-hinted.
- Use `rich.console.Console` for all printing.

% Package Structure
- The function should be part of a Python package, using relative imports (single dot) for internal modules (e.g. 'from .module_name import module_name').
- The ./pdd/__init__.py file will have the EXTRACTION_STRENGTH, DEFAULT_STRENGTH, DEFAULT_TIME and other global constants. Example: ```from . import DEFAULT_STRENGTH```

% Error Handling
- Ensure the function handles edge cases, such as missing inputs or model errors, and provide clear error messages.</preamble>

% Here is an example of this being done: <example>% You are an expert Python engineer. Your goal is to write a python function, "code_generator", that will compile a prompt into a code file.

You are an expert Python engineer working on the PDD Cloud project.

-------------------------------------------------------------------------------
Python Coding Standards (PDD Cloud)
-------------------------------------------------------------------------------

## Style
- Python 3.12, PEP 8 compliant
- Type hints required (from typing import Optional, List, Dict, Any, Tuple)
- Imports: standard lib -> third-party -> local (alphabetical within groups)

## Critical First Import
import function_import_setup  # MUST be first import

This enables subprocess module resolution for Firebase Functions Framework.
All TOP-LEVEL endpoint files (e.g., generate_code.py, main.py) must have this
as their very first import statement.

**IMPORTANT:** Utility modules inside `utils/` should NOT import this.
Use relative imports instead (e.g., `from .firebase_helpers import ...`).

## Standard Library Imports
import os
import logging

## Error Handling Pattern
Map exceptions to HTTP status codes:
- AuthenticationError -> 401 Unauthorized
- AuthorizationError -> 403 Forbidden
- ValidationError -> 400 Bad Request
- ResourceNotFoundError -> 404 Not Found
- DatabaseError / Exception -> 500 Internal Server Error

All error responses: {"error": "descriptive message"}

## Logging
logger = logging.getLogger(__name__)

## Response Format
Return tuple: (response_dict, status_code)


% Here are the inputs and outputs of the function:
    Inputs:
        'prompt' - A string containing the raw prompt to be processed.
        'language' - A string that is the language type (e.g. python, bash) of file that will be outputed by the LLM.
        'strength' - A float between 0 and 1 that is the strength of the LLM model to use.
        'temperature' - A float that is the temperature of the LLM model to use. Default is 0.
        'time' - A float in [0,1] or None that controls the thinking effort for the LLM model, passed to llm_invoke. Default is None.
        'verbose' - A boolean that indicates whether to print out the details of the function. Default is False.
        'preprocess_prompt' - A boolean that indicates whether to preprocess the prompt. Default is True.
        'output_schema' - An optional dict (JSON schema) to enforce structured output. Default is None.
    Outputs:
        'runnable_code' - A string that is runnable code
        'total_cost' - A float that is the total cost of all LLM calls within this function (initial generation, unfinished check, continuation if used, and postprocess)
        'model_name' - A string that is the name of the selected LLM model used for the main generation (or continuation). Postprocess may use a different model internally and does not change this value.

% Here is how to use the internal modules:
    <internal_modules>
        For running prompts with llm_invoke:
        <llm_invoke_example>
            import os
import sys
import json
import logging
import threading
import time
import requests
from flask import Flask, request, jsonify
from unittest.mock import MagicMock, patch

# --- 1. Environment Setup ---
# Set environment variables to simulate local execution
os.environ['FUNCTIONS_EMULATOR'] = 'true'

# Ensure 'backend/functions' is in PYTHONPATH so we can import the module
# In a real deployment, this is handled by the Cloud Functions environment.
current_dir = os.path.dirname(os.path.abspath(__file__))
backend_functions_path = os.path.abspath(os.path.join(current_dir, '../backend/functions'))
sys.path.insert(0, backend_functions_path)

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- 2. Mocking Dependencies ---
# Since this example runs in isolation, we need to mock the complex dependencies
# that the endpoint relies on (Firebase, PDD CLI internals, etc.)

# Mock function_import_setup
sys.modules['function_import_setup'] = MagicMock()

# Mock utils.auth_helpers
mock_auth = MagicMock()
# Create decorators that just pass through the function
def pass_through_decorator(func):
    def wrapper(*args, **kwargs):
        # Inject dummy user and token if not present
        if 'user' not in kwargs:
            kwargs['user'] = MagicMock(uid='test-user-id')
        if 'token' not in kwargs:
            kwargs['token'] = {'uid': 'test-user-id'}
        return func(*args, **kwargs)
    return wrapper

mock_auth.require_approval = pass_through_decorator
mock_auth.require_authentication = pass_through_decorator
sys.modules['utils.auth_helpers'] = mock_auth

# Mock utils.credit_helpers
mock_credits = MagicMock()
def credit_decorator(cost_key='totalCost', estimated_cost=0.20):
    def decorator(func):
        def wrapper(*args, **kwargs):
            # Simulate credit check passing
            result, status = func(*args, **kwargs)
            # Simulate credit deduction logic adding fields to response
            if isinstance(result, dict):
                result['creditsDeducted'] = 10  # Dummy deduction
                result['newBalance'] = 990
            return result, status
        return wrapper
    return decorator

mock_credits.require_credits = credit_decorator
sys.modules['utils.credit_helpers'] = mock_credits

# Mock utils.error_handling
mock_errors = MagicMock()
class AuthenticationError(Exception): pass
class AuthorizationError(Exception): pass
class ValidationError(Exception): pass
mock_errors.AuthenticationError = AuthenticationError
mock_errors.AuthorizationError = AuthorizationError
mock_errors.ValidationError = ValidationError
sys.modules['utils.error_handling'] = mock_errors

# Mock pdd.llm_invoke
mock_pdd = MagicMock()
# Define a mock implementation of llm_invoke
def mock_llm_invoke_impl(prompt=None, input_json=None, messages=None, **kwargs):
    logger.info(f"[Mock LLM] Invoked with prompt='{prompt}'")
    return {
        "result": f"Processed: {prompt or messages}",
        "cost": 0.005,
        "model_name": "gpt-4-mock",
        "thinking_output": "I thought about this deeply..."
    }
mock_pdd.llm_invoke = mock_llm_invoke_impl
sys.modules['pdd.llm_invoke'] = mock_pdd

# --- 3. Import the Module Under Test ---
try:
    import llm_invoke
    logger.info("Successfully imported llm_invoke module")
except ImportError as e:
    logger.error(f"Failed to import module: {e}")
    sys.exit(1)

# --- 4. Flask Server Setup ---
app = Flask(__name__)

@app.route('/llm_invoke', methods=['POST'])
def handle_llm_invoke():
    # The module expects (request, user, token)
    # In a real Flask app using the decorators, user/token are injected.
    # Here we call the decorated function directly.
    
    # We need to mock the request object passed to the function
    # Flask's global 'request' proxy works because we are inside a route context
    return llm_invoke.llm_invoke(request)

def run_server():
    app.run(port=5005, debug=False, use_reloader=False)

# --- 5. Functional Tests ---
def run_tests():
    base_url = 'http://localhost:5005/llm_invoke'
    headers = {'Content-Type': 'application/json'}

    print("\n" + "="*60)
    print("Testing llm_invoke")
    print("="*60)

    # Test Case 1: Basic Prompt
    print("\n--- Test 1: Basic Prompt & Input JSON ---")
    payload_1 = {
        "prompt": "Hello {{name}}",
        "inputJson": {"name": "World"},
        "strength": 0.7
    }
    try:
        resp = requests.post(base_url, json=payload_1, headers=headers)
        print(f"Status: {resp.status_code}")
        print(f"Response: {json.dumps(resp.json(), indent=2)}")
        assert resp.status_code == 200
        assert resp.json()['result'] == "Processed: Hello {{name}}"
    except Exception as e:
        print(f"Test 1 Failed: {e}")

    # Test Case 2: Messages List (Chat format)
    print("\n--- Test 2: Messages List ---")
    payload_2 = {
        "messages": [
            {"role": "system", "content": "You are a bot."},
            {"role": "user", "content": "Hi."}
        ],
        "temperature": 0.5
    }
    try:
        resp = requests.post(base_url, json=payload_2, headers=headers)
        print(f"Status: {resp.status_code}")
        print(f"Response: {json.dumps(resp.json(), indent=2)}")
        assert resp.status_code == 200
    except Exception as e:
        print(f"Test 2 Failed: {e}")

    # Test Case 3: Validation Error (Missing inputs)
    print("\n--- Test 3: Validation Error (Missing inputs) ---")
    payload_3 = {
        "strength": 0.5
        # Missing prompt/inputJson AND messages
    }
    try:
        resp = requests.post(base_url, json=payload_3, headers=headers)
        print(f"Status: {resp.status_code}")
        print(f"Response: {json.dumps(resp.json(), indent=2)}")
        assert resp.status_code == 400
    except Exception as e:
        print(f"Test 3 Failed: {e}")

    # Test Case 4: Validation Error (Invalid strength)
    print("\n--- Test 4: Validation Error (Invalid strength) ---")
    payload_4 = {
        "prompt": "Hi",
        "inputJson": {},
        "strength": 1.5  # Invalid, must be 0-1
    }
    try:
        resp = requests.post(base_url, json=payload_4, headers=headers)
        print(f"Status: {resp.status_code}")
        print(f"Response: {json.dumps(resp.json(), indent=2)}")
        assert resp.status_code == 400
    except Exception as e:
        print(f"Test 4 Failed: {e}")

    print("\n" + "="*60)
    print("All tests completed.")
    print("="*60)
    
    # Force exit to stop the server thread
    os._exit(0)

if __name__ == "__main__":
    # Start the Flask server in a daemon thread
    server_thread = threading.Thread(target=run_server, daemon=True)
    server_thread.start()
    
    # Give the server a moment to start
    time.sleep(2)
    
    # Run the tests
    run_tests()
        </llm_invoke_example>

        For preprocessing prompts:
        <preprocess_example>
            from pdd.preprocess import preprocess
from rich.console import Console   
console = Console()     

prompt = """
<prompt>
    Hello World

    <pdd>This is a comment</pdd>
    [Error: firecrawl-py package not installed. Cannot scrape https://www.google.com]
    {test}
    {test2}
    ```<TODO.md>```

    <pdd>
        multi-line
        comment should not show up
    </pdd>
</prompt>
"""

recursive = False
double_curly_brackets = True
exclude_keys = ["test2"] # exclude test2 from being doubled

# Debug info
console.print(f"[bold yellow]Debug: exclude_keys = {exclude_keys}[/bold yellow]")

processed = preprocess(prompt, recursive, double_curly_brackets, exclude_keys=exclude_keys)
console.print("[bold white]Processed Prompt:[/bold white]")
console.print(processed)

        </preprocess_example>

        For handling unfinished prompts:
        <unfinished_prompt_example>
            from pdd.unfinished_prompt import unfinished_prompt
from rich import print as rprint

# This script provides a concise example of how to use the `unfinished_prompt` function
# from the `pdd.unfinished_prompt` module.

# --- Pre-requisites for running this example: ---
# 1. The `pdd` Python package must be accessible. This means:
#    - It's installed in your Python environment (e.g., via pip if it's a package), OR
#    - The directory containing the `pdd` package is added to your PYTHONPATH.
#      For instance, if your project structure is:
#      my_project/
#      ├── pdd/  # The module's package
#      │   ├── __init__.py
#      │   ├── unfinished_prompt.py
#      │   ├── load_prompt_template.py
#      │   └── llm_invoke.py
#      └── examples/
#          └── run_this_example.py (this file)
#      You would typically run this script from the `my_project` directory
#      (e.g., `python examples/run_this_example.py`) after ensuring `my_project`
#      is in PYTHONPATH (e.g., `export PYTHONPATH=$PYTHONPATH:/path/to/my_project`).
#
# 2. The `pdd` package requires internal setup for its dependencies:
#    - A prompt template file named "unfinished_prompt_LLM" (e.g., "unfinished_prompt_LLM.txt")
#      must be present where `pdd.load_prompt_template` (used internally by `unfinished_prompt`)
#      can find it. This location is usually relative to the `pdd` package structure.
#    - The `pdd.llm_invoke` function (used internally) must be configured for access to an LLM.
#      This typically involves setting environment variables for API keys (e.g., `OPENAI_API_KEY`).
#
# This script should be saved outside the `pdd` package, for instance, in an
# `examples/` directory as shown above.
# To run: `python name_of_this_script.py` (adjust path as needed).

# --- Example Usage ---

# 1. Define the prompt text you want to analyze.
#    This example uses a prompt that is intentionally incomplete to demonstrate
#    the function's ability to detect incompleteness.
my_prompt_text = "Write a comprehensive guide on how to bake a sourdough bread, starting from creating a starter, then the kneading process, and finally"

rprint(f"[bold cyan]Analyzing prompt:[/bold cyan] \"{my_prompt_text}\"")

# 2. Call the `unfinished_prompt` function.
#    Review the function's docstring for detailed parameter information.
#    - `prompt_text` (str): The text of the prompt to analyze.
#    - `strength` (float, optional, 0.0-1.0, default=0.5): Influences the LLM's behavior or model choice.
#    - `temperature` (float, optional, 0.0-1.0, default=0.0): Controls the randomness of the LLM's output.
#    - `verbose` (bool, optional, default=False): If True, the function will print detailed internal logs.
#
#    The function returns a tuple: (reasoning, is_finished, total_cost, model_name)
#    - `reasoning` (str): The LLM's structured explanation for its completeness assessment.
#    - `is_finished` (bool): True if the prompt is considered complete, False otherwise.
#    - `total_cost` (float): The estimated cost of the LLM call. The unit (e.g., USD) depends on the LLM provider.
#    - `model_name` (str): The name of the LLM model that was used for the analysis.

# Example call with verbose output and custom strength/temperature settings.
reasoning_str, is_complete_flag, call_cost, llm_model = unfinished_prompt(
    prompt_text=my_prompt_text,
    strength=0.6,       # Example: using a specific strength value
    temperature=0.1,    # Example: using a low temperature for more deterministic reasoning
    verbose=True        # Set to True to see detailed logs from within the unfinished_prompt function
)

# 3. Print the results returned by the function.
rprint("\n[bold green]--- Analysis Results ---[/bold green]")
rprint(f"  [bold]Prompt Analyzed:[/bold] \"{my_prompt_text}\"")
rprint(f"  [bold]Is prompt complete?:[/bold] {'Yes, the LLM considers the prompt complete.' if is_complete_flag else 'No, the LLM suggests the prompt needs continuation.'}")
rprint(f"  [bold]LLM's Reasoning:[/bold]\n    {reasoning_str}") # Rich print will handle newlines in the reasoning string
rprint(f"  [bold]Cost of Analysis:[/bold] ${call_cost:.6f}") # Display cost, assuming USD. Adjust currency/format as needed.
rprint(f"  [bold]LLM Model Used:[/bold] {llm_model}")

# --- Example of calling with default parameters ---
# If you want to use the default strength (0.5), temperature (0.0), and verbose (False):
#
# default_prompt_text = "What is the capital of Canada?"
# rprint(f"\n[bold cyan]Analyzing prompt with default settings:[/bold cyan] \"{default_prompt_text}\"")
#
# reasoning_def, is_finished_def, cost_def, model_def = unfinished_prompt(
#     prompt_text=default_prompt_text
# )
#
# rprint("\n[bold green]--- Default Call Analysis Results ---[/bold green]")
# rprint(f"  [bold]Prompt Analyzed:[/bold] \"{default_prompt_text}\"")
# rprint(f"  [bold]Is prompt complete?:[/bold] {'Yes' if is_finished_def else 'No'}")
# rprint(f"  [bold]LLM's Reasoning:[/bold]\n    {reasoning_def}")
# rprint(f"  [bold]Cost of Analysis:[/bold] ${cost_def:.6f}")
# rprint(f"  [bold]LLM Model Used:[/bold] {model_def}")

        </unfinished_prompt_example>

        For continuing generation:
        <continue_generation_example>
            from pdd.continue_generation import continue_generation

def main() -> None:
    """
    Main function to demonstrate the usage of the continue_generation function.
    It continues the generation of text using a language model and calculates the cost.
    """
    # Define the input parameters for the continue_generation function
    # formatted_input_prompt: str = "Once upon a time in a land far away, there was a"
    # load context/cli_python_preprocessed.prompt into formatted_input_prompt
    with open("context/cli_python_preprocessed.prompt", "r") as file:
        formatted_input_prompt = file.read()
    
    # llm_output: str = ""  # Initial LLM output is empty
    # load context/unfinished_prompt.txt into llm_output
    with open("context/llm_output_fragment.txt", "r") as file:
        llm_output = file.read()
    strength: float = .915  # Strength parameter for the LLM model
    temperature: float = 0  # Temperature parameter for the LLM model

    try:
        # Call the continue_generation function
        final_llm_output, total_cost, model_name = continue_generation(
            formatted_input_prompt=formatted_input_prompt,
            llm_output=llm_output,
            strength=strength,
            temperature=temperature,
            verbose=True
        )

        # Output the results
        # print(f"Final LLM Output: {final_llm_output}")
        print(f"Total Cost: ${total_cost:.6f}")
        print(f"Model Name: {model_name}")
        # write final_llm_output to context/final_llm_output.txt
        with open("context/final_llm_output.py", "w") as file:
            file.write(final_llm_output)

    except FileNotFoundError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
        </continue_generation_example>

        For postprocessing results:
        <postprocess_example>
            """
Example demonstrating the usage of the `postprocess` function 
from the `pdd.postprocess` module.

This example showcases two scenarios for extracting code from an LLM's text output:
1. Simple code extraction (strength = 0): Uses basic string manipulation to find code
   blocks enclosed in triple backticks. This method is fast and has no cost.
2. Advanced code extraction (strength > 0): Leverages an LLM for more robust extraction.
   This method is more powerful but incurs a cost and takes more time.

To run this example:
1. Ensure the `pdd` package (containing the `postprocess` module) is in your PYTHONPATH
   or installed in your environment.
2. Ensure the `rich` library is installed (`pip install rich`).
3. This script uses `unittest.mock` (part of Python's standard library) to simulate
   the behavior of internal dependencies (`load_prompt_template` and `llm_invoke`)
   for the LLM-based extraction scenario. This allows the example to run without
   requiring actual LLM API calls or specific prompt files.
"""
from rich import print
from unittest.mock import patch, MagicMock

# Assuming 'pdd' package is in PYTHONPATH or installed.
# The 'postprocess' module is expected to be at pdd/postprocess.py
from pdd.postprocess import postprocess, ExtractedCode # ExtractedCode is needed for the mock
from pdd import DEFAULT_STRENGTH

def main():
    """
    Runs the demonstration for the postprocess function.
    """
    print("[bold underline blue]Demonstrating `postprocess` function from `pdd.postprocess`[/bold underline blue]\n")

    # --- Common Inputs ---
    # This is a sample string that might be output by an LLM, containing text and code.
    llm_output_text_with_code = """
This is some text from an LLM.
It includes a Python code block:
```python
def greet(name):
    # A simple greeting function
    print(f"Hello, {name}!")

greet("Developer")
```
And some more text after the code block.
There might be other language blocks too:
```javascript
console.log("This is JavaScript");
```
But we are only interested in Python.
"""
    # The target programming language for extraction.
    target_language = "python"

    # --- Scenario 1: Simple Extraction (strength = 0) ---
    # This mode uses the `postprocess_0` internal function, which performs a basic
    # extraction of content between triple backticks. It does not use an LLM.
    print("[bold cyan]Scenario 1: Simple Extraction (strength = 0)[/bold cyan]")
    print("Demonstrates extracting code using basic string processing.")
    print(f"  Input LLM Output: (see below)")
    # print(f"[dim]{llm_output_text_with_code}[/dim]") # Printing for brevity in console
    print(f"  Target Language: '{target_language}' (Note: simple extraction is language-agnostic but extracts first block)")
    print(f"  Strength: 0 (activates simple, non-LLM extraction)")
    print(f"  Verbose: True (enables detailed console output from `postprocess`)\n")

    # Call postprocess with strength = 0
    # Input parameters:
    #   llm_output (str): The LLM's raw output string.
    #   language (str): The programming language to extract (less critical for strength=0).
    #   strength (float): 0-1, model strength. 0 means simple extraction.
    #   temperature (float): 0-1, LLM temperature (not used for strength=0).
    #   time (float): 0-1, LLM thinking effort (not used for strength=0).
    #   verbose (bool): If True, prints internal processing steps.
    extracted_code_s0, cost_s0, model_s0 = postprocess(
        llm_output=llm_output_text_with_code,
        language=target_language,
        strength=0,
        verbose=True
    )

    print("[bold green]Output for Scenario 1:[/bold green]")
    # Output tuple:
    #   extracted_code (str): The extracted code.
    #   total_cost (float): Cost of the operation (in dollars). Expected to be 0.0 for simple extraction.
    #   model_name (str): Identifier for the method/model used. Expected to be 'simple_extraction'.
    print(f"  Extracted Code:\n[yellow]{extracted_code_s0}[/yellow]")
    print(f"  Total Cost: ${cost_s0:.6f}")
    print(f"  Model Name: '{model_s0}'")
    print("-" * 60)

    # --- Scenario 2: LLM-based Extraction (strength > 0) ---
    # This mode uses an LLM via `llm_invoke` to perform a more sophisticated extraction.
    # It requires a prompt template (`extract_code_LLM.prompt`).
    # For this example, `load_prompt_template` and `llm_invoke` are mocked.
    print(f"\n[bold cyan]Scenario 2: LLM-based Extraction (strength = {DEFAULT_STRENGTH})[/bold cyan]")
    print("Demonstrates extracting code using an LLM (mocked).")
    print(f"  Input LLM Output: (same as above)")
    print(f"  Target Language: '{target_language}'")
    print(f"  Strength: {DEFAULT_STRENGTH} (activates LLM-based extraction)")
    print(f"  Temperature: 0.0 (LLM creativity, 0-1 scale)")
    print(f"  Time: 0.5 (LLM thinking effort, 0-1 scale, influences model choice/cost)")
    print(f"  Verbose: True\n")

    # Mock for `load_prompt_template`:
    # This function is expected to load a prompt template file (e.g., 'extract_code_LLM.prompt').
    # In a real scenario, this file would exist in a 'prompts' directory.
    mock_load_template = MagicMock(return_value="Mocked Prompt: Extract {{language}} code from: {{llm_output}}")

    # Mock for `llm_invoke`:
    # This function handles the actual LLM API call.
    # It's expected to return a dictionary containing the LLM's result (parsed into
    # an `ExtractedCode` Pydantic model), the cost, and the model name.
    # The `extracted_code` from the LLM mock should include backticks and language identifier
    # to test the cleaning step within the `postprocess` function.
    mock_llm_response_code_from_llm = """```python
def sophisticated_extraction(data):
    # This code is supposedly extracted by an LLM
    processed_data = data.upper()  # Example processing
    return processed_data

result = sophisticated_extraction("test data from llm")
print(result)
```"""
    mock_extracted_code_pydantic_obj = ExtractedCode(extracted_code=mock_llm_response_code_from_llm)
    mock_llm_invoke_return_value = {
        'result': mock_extracted_code_pydantic_obj,
        'cost': 0.00025,  # Example cost in dollars
        'model_name': 'mock-llm-extractor-v1'
    }
    mock_llm_invoke_function = MagicMock(return_value=mock_llm_invoke_return_value)

    # Patch the internal dependencies within the 'pdd.postprocess' module's namespace.
    # This ensures that when `postprocess` calls `load_prompt_template` or `llm_invoke`,
    # our mocks are used instead of the real implementations.
    with patch('pdd.postprocess.load_prompt_template', mock_load_template):
        with patch('pdd.postprocess.llm_invoke', mock_llm_invoke_function):
            extracted_code_llm, cost_llm, model_llm = postprocess(
                llm_output=llm_output_text_with_code,
                language=target_language,
                strength=DEFAULT_STRENGTH,
                temperature=0.0,
                time=0.5,
                verbose=True
            )

            print("[bold green]Output for Scenario 2:[/bold green]")
            print(f"  Extracted Code:\n[yellow]{extracted_code_llm}[/yellow]")
            print(f"  Total Cost: ${cost_llm:.6f} (cost is in dollars)")
            print(f"  Model Name: '{model_llm}'")

            # --- Verification of Mock Calls (for developer understanding) ---
            # Check that `load_prompt_template` was called correctly.
            mock_load_template.assert_called_once_with("extract_code_LLM")

            # Check that `llm_invoke` was called correctly.
            mock_llm_invoke_function.assert_called_once()
            # Inspect the arguments passed to the mocked llm_invoke
            call_args_to_llm_invoke = mock_llm_invoke_function.call_args[1] # kwargs
            assert call_args_to_llm_invoke['prompt'] == mock_load_template.return_value
            assert call_args_to_llm_invoke['input_json'] == {
                "llm_output": llm_output_text_with_code,
                "language": target_language
            }
            assert call_args_to_llm_invoke['strength'] == DEFAULT_STRENGTH
            assert call_args_to_llm_invoke['temperature'] == 0.0
            assert call_args_to_llm_invoke['time'] == 0.5
            assert call_args_to_llm_invoke['verbose'] is True
            assert call_args_to_llm_invoke['output_pydantic'] == ExtractedCode
            print("[dim]  (Mocked LLM calls verified successfully)[/dim]")

    print("\n[bold underline blue]Demonstration finished.[/bold underline blue]")
    print("\n[italic]Important Notes:[/italic]")
    print("  - For Scenario 2 (LLM-based extraction), `load_prompt_template` and `llm_invoke` were mocked.")
    print("    In a real-world scenario:")
    print("    - `load_prompt_template('extract_code_LLM')` would attempt to load a file named ")
    print("      `extract_code_LLM.prompt` (typically from a 'prompts' directory configured within the `pdd` package).")
    print("    - `llm_invoke` would make an actual API call to a Large Language Model, which requires")
    print("      API keys and network access.")
    print("  - The `time` parameter (0-1) for `postprocess` (and `llm_invoke`) generally controls the")
    print("    'thinking effort' or computational resources allocated to the LLM, potentially affecting")
    print("    which underlying LLM model is chosen and the quality/cost of the result.")
    print("  - No actual files (like prompt files or output files) are created or read by this example script,")
    print("    particularly in the './output' directory, due to the use of mocks for file-dependent operations.")

if __name__ == "__main__":
    main()

        </postprocess_example>
    </internal_modules>

% This program will do the following:
    Step 1. Conditionally preprocess the raw prompt using the preprocess function from the preprocess module based on the value of 'preprocess_prompt'. If 'preprocess_prompt' is True, preprocess the prompt; otherwise, use the raw prompt directly. When preprocessing, it is acceptable to enable options such as double_curly_brackets=True and recursive=False to preserve placeholders and avoid over-expansion.

    Step 2. Generate the initial response as follows:
        - If the prompt contains embedded data URLs (e.g., 'data:image/...;base64,...'), split the prompt into alternating text and image parts (preserving order) and call llm_invoke with messages=[{role: 'user', content: [{type: 'image_url', image_url: {url: ...}}, {type: 'text', text: ...}, ...]}] and the provided strength, temperature, time, verbose, output_schema, and language.
        - Otherwise, call llm_invoke with the (preprocessed or raw) prompt, input_json={}, and the provided strength, temperature, time, verbose, output_schema, and language.

    Step 3. Detect if the generation is incomplete using the unfinished_prompt function (use strength=0.5, temperature=0.0) by passing in the last 600 characters of the output of Step 2. Pass through language, time, and verbose.
        - a. If incomplete, call the continue_generation function to complete the generation and set final_output to that result. Pass through language, time, and verbose.
        - b. Else, set final_output to the initial model output.

    Step 4. Postprocess the final_output:
        - If language is "json" (case-insensitive) or output_schema is provided, skip extraction: if final_output is a string, return it as-is; otherwise, serialize it with json.dumps.
        - Otherwise, use the postprocess function from the postprocess module with the EXTRACTION_STRENGTH constant. Use temperature=0.0 and pass through language, time, and verbose.

    Step 5. Return the runnable_code, total_cost and model_name.

% Validation and defaults:
    - Validate non-empty 'prompt' and 'language'.
    - Enforce 0 ≤ strength ≤ 1 and 0 ≤ temperature ≤ 2.
</example>
        </change_description_example>
    </input_example>

    <output_example>
        1. **Impact of the Change and Potential Issues:**

   The change description suggests using the contents of `context/python_preamble.prompt` to make prompts more compact. This preamble includes instructions for using relative imports, pretty printing with the Python Rich library, and handling edge cases. The main impact is to ensure consistency across prompts by centralizing common instructions, which can reduce redundancy and improve maintainability. Potential issues include ensuring that the preamble does not conflict with existing instructions in the prompts and that it is inserted in a way that maintains the logical flow of the prompt.

2. **Possible Implementation Plans:**

   - **Plan A: Direct Inclusion of Preamble**
     - **Pros:** Simplifies prompts by removing redundant instructions and directly including the preamble.
     - **Cons:** May require significant restructuring of prompts to ensure logical flow and avoid redundancy.
   
   - **Plan B: Conditional Inclusion Based on Existing Content**
     - **Pros:** Only includes the preamble if similar instructions are not already present, minimizing disruption.
     - **Cons:** Requires careful analysis of each prompt to determine if the preamble is needed, which can be time-consuming.
   
   - **Plan C: Hybrid Approach**
     - **Pros:** Combines the benefits of both plans by including the preamble where it adds value and retaining existing instructions where they are more specific or detailed.
     - **Cons:** Complexity in deciding which parts of the preamble to include or exclude for each prompt.

3. **Analysis and Selection of the Best Plan:**

   Plan C is the best approach as it allows for flexibility and ensures that the preamble is only included where it enhances the prompt. This minimizes redundancy and maintains the integrity of prompts that already have specific instructions. It also allows for a more tailored approach, ensuring that the preamble complements rather than conflicts with existing content.

4. **Prompt Analysis Based on Selected Plan:**

   - **change_python.prompt:** This prompt already contains detailed instructions similar to those in the preamble. However, it can benefit from the preamble for consistency in handling edge cases and pretty printing.
   - **preprocess_python.prompt:** This prompt can include the preamble to ensure consistent handling of edge cases and pretty printing.
   - **unfinished_prompt_python.prompt:** This prompt can include the preamble to ensure consistent handling of edge cases and pretty printing.
   - **xml_tagger_python.prompt:** This prompt already includes the preamble, so no changes are needed.

5. **Prompts That Need to Be Changed:**

   - **change_python.prompt**
     - **Instructions:**
       - Insert the contents of the file `./context/python_preamble.prompt` immediately after the role and goal statement using 'include' XML tags.
       - Remove any redundant instructions that are covered by the preamble, such as those related to pretty printing and handling edge cases.
       - Ensure that the logical flow of the prompt is maintained and that any unique instructions specific to this prompt are retained.
       - Here is what is inside context/python_preamble.prompt:<preamble>% You are an expert Python engineer.

% Code Style Requirements
- File must start with `from __future__ import annotations`.
- All functions must be fully type-hinted.
- Use `rich.console.Console` for all printing.

% Package Structure
- The function should be part of a Python package, using relative imports (single dot) for internal modules (e.g. 'from .module_name import module_name').
- The ./pdd/__init__.py file will have the EXTRACTION_STRENGTH, DEFAULT_STRENGTH, DEFAULT_TIME and other global constants. Example: ```from . import DEFAULT_STRENGTH```

% Error Handling
- Ensure the function handles edge cases, such as missing inputs or model errors, and provide clear error messages.</preamble>

   - **preprocess_python.prompt**
     - **Instructions:**
       - Insert the contents of the file `./context/python_preamble.prompt` immediately after the role and goal statement using 'include' XML tags.
       - Remove any redundant instructions that are covered by the preamble, such as those related to pretty printing and handling edge cases.
       - Ensure that the logical flow of the prompt is maintained and that any unique instructions specific to this prompt are retained.
       - Here is what is inside context/python_preamble.prompt:<preamble>% You are an expert Python engineer.

% Code Style Requirements
- File must start with `from __future__ import annotations`.
- All functions must be fully type-hinted.
- Use `rich.console.Console` for all printing.

% Package Structure
- The function should be part of a Python package, using relative imports (single dot) for internal modules (e.g. 'from .module_name import module_name').
- The ./pdd/__init__.py file will have the EXTRACTION_STRENGTH, DEFAULT_STRENGTH, DEFAULT_TIME and other global constants. Example: ```from . import DEFAULT_STRENGTH```

% Error Handling
- Ensure the function handles edge cases, such as missing inputs or model errors, and provide clear error messages.</preamble>

   - **unfinished_prompt_python.prompt**
     - **Instructions:**
       - Insert the contents of the file `./context/python_preamble.prompt` immediately after the role and goal statement using 'include' XML tags.
       - Remove any redundant instructions that are covered by the preamble, such as those related to pretty printing and handling edge cases.
       - Ensure that the logical flow of the prompt is maintained and that any unique instructions specific to this prompt are retained.
       - Here is what is inside context/python_preamble.prompt:<preamble>% You are an expert Python engineer.

% Code Style Requirements
- File must start with `from __future__ import annotations`.
- All functions must be fully type-hinted.
- Use `rich.console.Console` for all printing.

% Package Structure
- The function should be part of a Python package, using relative imports (single dot) for internal modules (e.g. 'from .module_name import module_name').
- The ./pdd/__init__.py file will have the EXTRACTION_STRENGTH, DEFAULT_STRENGTH, DEFAULT_TIME and other global constants. Example: ```from . import DEFAULT_STRENGTH```

% Error Handling
- Ensure the function handles edge cases, such as missing inputs or model errors, and provide clear error messages.</preamble>
    </output_example>
</example>

% Follow these steps to complete the task:
<task>
    Step 1. Carefully read and analyze the change description. Consider its implications and how it might affect different types of prompts.
    Step 2. Review each prompt in the prompt list. For each prompt, determine if it needs to be changed based on the change description. Some prompts maybe unaffected by the change description or already have the changes applied.
    Step 3. In your analysis, consider the following:
        - How does the change description impact each prompt?
        - Are there any potential issues or conflicts that might arise from implementing the change?
        - What are different ways the change could be implemented for affected prompts?
        - Where is the best place to implement the change to minimize issues and maximize effectiveness?
    Step 4. Prepare your response in the following format:
        <analysis>
        1. Provide a detailed description of the impact of the change and potential issues.
        2. Generate at least three different possible implementation plans. Discuss the pros and cons of each plan.
        3. Analyze the potential issues and the different plans. Explain step by step which plan is the best and why.
        4. For each prompt explain if it needs to be changed based on the selected plan.
        5. List the prompts that need to be changed based on the selected plan. For each prompt that needs to be changed, include:
            a. The prompt's name
            b. Detail and complete instructions for a LLM of how the prompt should be changed. Everything that is needed to know how to change the prompt effectively should be included here.
                - When instructing to include content from another file vs. actually intending to include file contents:
                    1. Mention the filename that should be included.
                    2. Describe where in the prompt the file's contents should be inserted.
                    3. Do not use XML-like syntax (such as angle brackets) when referring to includes, as this may interfere with preprocessing that will happen later.
                    For example:
                    "Insert the contents of the file './context/python_preamble.prompt' immediately after the role and goal statement using 'include' XML tags. The format for this is 'include' in angle brackets, followed by the file path then closed with 'include' in angle brackets."
                - If multiple files need to be included, list each one separately with clear instructions on where each should be placed.
                - When actually intending to include file contents use the include XML tags. This is common when the include will be replacing existing content.
                - Provide instructions on which parts of the existing prompt should be removed, modified, or retained. Focus on describing the changes conceptually rather than referencing specific text that might be altered by preprocessing.
                - Ensure that any unique instructions or logic specific to the prompt being modified are retained and remain clear.
                - Remember to include any other relevant instructions for modifying the prompt that are not related to file inclusions.
                - When finished, review the instructions to ensure they will make sense after any preprocessing steps that may occur.
        </analysis>
</task>

% Remember to be thorough in your analysis and clear in your explanations. Consider all aspects of the change description and its potential impacts on the prompts.