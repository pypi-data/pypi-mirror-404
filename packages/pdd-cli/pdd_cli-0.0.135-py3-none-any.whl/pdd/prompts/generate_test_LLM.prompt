% You are an expert Software Test Engineer. Your goal is to generate tests that ensures correct functionality of the code under test.

% Here a description of what the code is supposed to do and was the prompt that generated the code: <prompt_that_generated_code>{prompt_that_generated_code}</prompt_that_generated_code>

% Here is the code under test: <code_under_test>{code}</code_under_test>

% File path information:
 - The code under test module file is located at: <code_under_test_file_path>{source_file_path}</code_under_test_file_path>
 - The example file will be saved at: <test_file_path>{test_file_path}</test_file_path>
 - The module name (without extension) is: <module_name>{module_name}</module_name>

% EXISTING TESTS (if provided - your output will be APPENDED to this file):
<existing_tests>{existing_tests}</existing_tests>

% If existing tests are provided above:
    - Generate ONLY NEW test functions (your output will be appended to the existing file)
    - Do NOT include import statements (they already exist in the file)
    - Do NOT duplicate any existing test function names
    - Maintain consistent style with existing tests (fixtures, naming conventions)
    - Focus on testing functionality NOT already covered by existing tests

% Follow these rules:
    - CRITICAL: You MUST analyze the actual code provided in code_under_test and generate tests for the EXACT functions defined in that code
    - CRITICAL: Import statements must use the ACTUAL module name from the code file path, not generic names. Include the necessary code/path info to import the code under test.
    - CRITICAL: Test the ACTUAL function names, parameters, and behavior shown in the provided code
    - The module name for the code under test will have the same name as the function name
    - The unit test should be in {language}. If Python, use pytest.
    - Use individual test functions for each case to make it easier to identify which specific cases pass or fail.
    - Use the description of the functionality in the prompt to generate tests with useful tests with good code coverage.
    - The code might get regenerated by a LLM so focus the tests on the functionality of the code, not the implementation details.
    - NEVER access internal implementation details (variables/functions starting with underscore) in your tests.
    - CRITICAL (Python only): NEVER use module-level `sys.modules[...] = MagicMock()` - it pollutes pytest's module cache and breaks other test files. Use @pytest.fixture with types.ModuleType and __path__ = [] instead.
    - Setup and teardown methods should only use public APIs and environment variables, never reset internal module state directly.
    - Design tests to be independent of implementation details that might change when code is regenerated.
    - For test isolation, use fixtures and mocking of external dependencies rather than manipulating internal module state. In general minimize the amount of mocking needed so that the tests are more robust to changes in the code under test and more code is tested.

% TEST ISOLATION PRINCIPLE:
% CRITICAL: Each test MUST be isolated and not pollute state for other tests.
    - Tests must clean up any state they modify (environment variables, global state, files, mocks)
    - Use the testing framework's built-in isolation mechanisms (fixtures, setup/teardown, context managers)
    - Avoid modifying global or module-level state directly; if unavoidable, always restore original state
    - Prefer function-scoped test resources over shared/module-scoped ones to ensure isolation

<include>context/test.prompt</include>

<instructions>
    1. FIRST: Carefully analyze the ACTUAL code provided in code_under_test:
        - Identify the EXACT function names defined in the code
        - Identify the EXACT parameters and their types
        - Identify the EXACT return values and behavior
        - Identify any error conditions or edge cases
    2. SECOND: Analyze the prompt that generated the code to understand the intended functionality and edge cases.
    3. THIRD: For each edge case explain whether it is better to do the test using Z3 formal verification or unit tests.
    4. FOURTH: Develop a detailed test plan that will ensure the code under test is correct. This should involve both Z3 formal verification and unit tests.
    5. FIFTH: Write the test file with:
        a) The first part of the test file should be the detailed test plan from step 4 above in comments. 
        b) Import statements using the ACTUAL module name from the code file path (e.g., if code is in "my_function.py", use "from my_function import function_name")
        c) Tests for the ACTUAL function names and behavior shown in the provided code
        d) Z3 formal verification tests that are runnable as unit tests.
</instructions>