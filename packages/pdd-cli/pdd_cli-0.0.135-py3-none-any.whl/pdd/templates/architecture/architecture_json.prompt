---
name: architecture/architecture_json
description: Unified architecture template for multiple tech stacks
version: 1.0.0
tags: [architecture, template, json]
language: json
output: architecture.json
post_process_python: ./pdd/render_mermaid.py
post_process_args:
  - "{{INPUT_FILE}}"
  - "{{APP_NAME}}"
  - "{{OUTPUT_HTML}}"
variables:
  APP_NAME:
    required: false
    type: string
    description: Optional app name for context.
    example: Shop
  PRD_FILE:
    required: true
    type: path
    description: Primary product requirements document (PRD) describing scope and goals.
    example_paths: [PRD.md, docs/specs.md, docs/product/prd.md]
    example_content: |
      Title: Order Management MVP
      Goals: Enable customers to create and track orders end-to-end.
      Key Features:
        - Create Order: id, user_id, items[], total, status
        - View Order: details page with status timeline
        - List Orders: filter by status, date, user
      Non-Functional Requirements:
        - P95 latency < 300ms for read endpoints
        - Error rate < 0.1%
  TECH_STACK_FILE:
    required: false
    type: path
    description: Tech stack overview (languages, frameworks, infrastructure, and tools).
    example_paths: [docs/tech_stack.md, docs/architecture/stack.md]
    example_content: |
      Backend: Python (FastAPI), Postgres (SQLAlchemy), PyTest
      Frontend: Next.js (TypeScript), shadcn/ui, Tailwind CSS
      API: REST
      Auth: Firebase Auth (GitHub Device Flow), JWT for API
      Infra: Vercel (frontend), Cloud Run (backend), Cloud SQL (Postgres)
      Observability: OpenTelemetry traces, Cloud Logging
  DOC_FILES:
    required: false
    type: list
    description: Additional documentation files (comma/newline-separated).
    example_paths: [docs/ux.md, docs/components.md]
    example_content: |
      Design overview, patterns and constraints
  INCLUDE_FILES:
    required: false
    type: list
    description: Specific source files to include (comma/newline-separated).
    example_paths: [src/app.py, src/api.py, frontend/app/layout.tsx, frontend/app/page.tsx]
usage:
  generate:
    - name: Minimal (PRD only)
      command: pdd generate --template architecture/architecture_json -e PRD_FILE=docs/specs.md --output architecture.json
    - name: With tech stack overview
      command: pdd generate --template architecture/architecture_json -e PRD_FILE=docs/specs.md -e TECH_STACK_FILE=docs/tech_stack.md --output architecture.json

discover:
  enabled: false
  max_per_pattern: 5
  max_total: 10

output_schema:
  type: array
  items:
    type: object
    required: [reason, description, dependencies, priority, filename, filepath]
    properties:
      reason: { type: string }
      description: { type: string }
      dependencies: { type: array, items: { type: string } }
      priority: { type: integer, minimum: 1 }
      filename: { type: string }
      filepath: { type: string }
      tags: { type: array, items: { type: string } }
      context_urls:
        type: array
        items:
          type: object
          required: [url, purpose]
          properties:
            url: { type: string }
            purpose: { type: string }
      interface:
        type: object
        properties:
          type: { type: string, enum: [component, page, module, api, graphql, cli, job, message, config] }
          component: { type: object }
          page:
            type: object
            properties:
              route: { type: string }
              params:
                type: array
                items:
                  type: object
                  required: [name, type]
                  properties:
                    name: { type: string }
                    type: { type: string }
                    description: { type: string }
              dataSources:
                type: array
                items:
                  type: object
                  required: [kind, source]
                  properties:
                    kind: { type: string, enum: [api, query, stream, file, cache, message, job, other] }
                    source: { type: string }
                    method: { type: string }
                    description: { type: string }
                    auth: { type: string }
                    inputs: { type: array, items: { type: string } }
                    outputs: { type: array, items: { type: string } }
                    refreshInterval: { type: string }
                    notes: { type: string }
              layout: { type: object }
          module: { type: object }
          api: { type: object }
          graphql: { type: object }
          cli: { type: object }
          job: { type: object }
          message: { type: object }
          config: { type: object }
---

Purpose: Produce an architecture JSON that enumerates prompt files to generate code files for the project.

<PRD_FILE><include>${PRD_FILE}</include></PRD_FILE>
<TECH_STACK_FILE><include>${TECH_STACK_FILE}</include></TECH_STACK_FILE>
<DOC_FILES><include-many>${DOC_FILES}</include-many></DOC_FILES>

<INCLUDE_FILES><include-many>${INCLUDE_FILES}</include-many></INCLUDE_FILES>

INSTRUCTIONS:
- Use only the facts from the included documents and files. Do not invent technologies or filenames.
- If TECH_STACK_FILE is absent, infer a reasonable tech stack from the PRD and included files; state key assumptions within each item's description.
- Output a single top-level JSON array of items. Each item must include:
  - reason (briefly explain why this code module needs to exist), description, dependencies (filenames), priority (1 = highest), filename, filepath, optional tags.
  - interface: include only the applicable sub-object (component, page, module, api, graphql, cli, job, message, or config). Omit all non-applicable sub-objects entirely.
  - When interface.type is "page", each entry in `dataSources` must be an object with at least `kind` and `source` (e.g., URL or identifier). The `kind` field MUST be exactly one of: `"api"`, `"query"`, `"stream"`, `"file"`, `"cache"`, `"message"`, `"job"`, or `"other"`. Do not invent new values like `"api/mutation"`; instead, use `"api"` (for any HTTP/REST/GraphQL endpoint) or `"other"` and describe details such as queries vs. mutations in `description` or `notes`. Provide `method`, `description`, and any other useful metadata when known.
- context_urls (optional): An array of {{url, purpose}} objects associating web documentation references with this module. These are converted to `<web>` tags during prompt generation, enabling the LLM to fetch relevant API documentation. Populate with official docs, tutorials, or code examples relevant to the module's implementation.
- Valid JSON only. No comments or trailing commas.

OUTPUT FORMAT - CRITICAL: Return a raw JSON array, NOT an object with "items" or "data" wrapper:
```json
[
  {
    "reason": "Core data models needed by all other modules",
    "description": "Defines Order, User, and Item data models with validation",
    "dependencies": [],
    "priority": 1,
    "filename": "models_Python.prompt",
    "filepath": "src/models.py",
    "tags": ["backend", "data"],
    "interface": {
      "type": "module",
      "module": {
        "functions": [
          {"name": "Order", "signature": "class Order(BaseModel)", "returns": "Order instance"}
        ]
      }
    }
  },
  {
    "reason": "API endpoints for order management",
    "description": "REST API for creating, reading, updating orders",
    "dependencies": ["models_Python.prompt"],
    "priority": 2,
    "filename": "orders_api_Python.prompt",
    "filepath": "src/api/orders.py",
    "tags": ["backend", "api"],
    "interface": {
      "type": "api",
      "api": {
        "endpoints": [
          {"method": "POST", "path": "/orders", "auth": "jwt"},
          {"method": "GET", "path": "/orders/{id}", "auth": "jwt"}
        ]
      }
    }
  }
]
```
WRONG (do NOT do this):
```json
{"items": [...]}  // WRONG - no wrapper objects!
{"data": [...]}   // WRONG - no wrapper objects!
{"type": "array", "items": [...]}  // WRONG - this is schema, not output!
```

INTERFACE TYPES (emit only applicable):
- page: route (string), params? (array of {name, type, description?}), dataSources? (array), layout? (object)
- component: props (array of {name, type, required?}), emits? (array), context? (array)
- module: functions (array of {name, signature, returns?, errors?, sideEffects?})
- api: endpoints (array of {method, path, auth?, requestSchema?, responseSchema?, errors?})
- graphql: sdl? (string) or operations {queries?[], mutations?[], subscriptions?[]}
- cli: commands (array of {name, args?[], flags?[], exitCodes?[]}), io? {stdin?, stdout?}
- job: trigger {schedule? | event?}, inputs? (array), outputs? (array), retryPolicy? (string)
- message: topics (array of {name, direction: "publish"|"subscribe", schema?, qos?})
- config: keys (array of {name, type, default?, required?, source: "env"|"file"|"secret"})

FRAMEWORK DETECTION (do this first):
Before generating architecture, detect the framework from PRD/tech stack:
- Next.js App Router: Look for "app router", "app/", "Next.js 13+", "Next.js 14", "Next.js 15"
- Next.js Pages Router: Look for "pages router", "pages/", "Next.js 12" or older
- Nuxt 3: Look for "Nuxt", "nuxt.config", "Vue"
- SvelteKit: Look for "SvelteKit", "+page.svelte", "Svelte"
- Standard (Python, Go, Rust, etc.): No special file naming requirements

For frameworks with strict file naming conventions (Next.js, Nuxt, SvelteKit), you MUST follow their required filenames.

FILENAME CONVENTIONS:
- The "filename" field is the prompt filename: <base>_<Language>.prompt
- Use DESCRIPTIVE basenames that capture the module's purpose and context
- The basename should be unique and meaningful so prompts are self-documenting
- CRITICAL: The filename field must NOT contain slashes (/). Use underscores (_) to separate path components.
  - WRONG: "api/courses/route_TypeScript.prompt" (slashes create nested directories)
  - CORRECT: "api_courses_route_TypeScript.prompt" (underscores keep prompt flat)

**VALID LANGUAGE SUFFIXES** (MUST use exactly one of these - case-sensitive PascalCase):
- **TypeScript projects**: `TypeScript` (.ts) or `TypeScriptReact` (.tsx)
- **JavaScript projects**: `JavaScript` (.js) or `JavaScriptReact` (.jsx)
- **Python projects**: `Python` (.py)
- **Go projects**: `Go` (.go)
- **Rust projects**: `Rust` (.rs)
- **Prisma schemas**: `Prisma` (.prisma)
- **Other**: `Java`, `C#`, `Ruby`, `PHP`, `Swift`, `Kotlin`, `Scala`, `SQL`, `Shell`, `YAML`, `JSON`, `HTML`, `CSS`, `SCSS`, `Svelte`, `Vue`

**WRONG language suffixes** (DO NOT use these invented names):
- ❌ `NextJS`, `Next`, `Nextjs` - Use `TypeScript` or `TypeScriptReact` instead
- ❌ `React`, `ReactJS` - Use `TypeScriptReact` or `JavaScriptReact` instead
- ❌ `Node`, `NodeJS` - Use `TypeScript` or `JavaScript` instead
- ❌ `FastAPI`, `Flask`, `Django` - Use `Python` instead
- ❌ `Express`, `NestJS` - Use `TypeScript` or `JavaScript` instead

Examples for Next.js App Router (use descriptive names with path context):
  ✓ "api_courses_route_TypeScript.prompt" - API route for courses endpoint
  ✓ "api_lessons_id_route_TypeScript.prompt" - API route for lessons with dynamic [id]
  ✓ "dashboard_page_TypeScriptReact.prompt" - Dashboard page component
  ✓ "app_layout_TypeScriptReact.prompt" - Root app layout
  ✓ "auth_middleware_TypeScript.prompt" - Authentication middleware

Examples for standard projects (Python, Go, etc.):
  ✓ "orders_Python.prompt" - Orders module
  ✓ "api_routes_Python.prompt" - API routes module
  ✓ "models_Python.prompt" - Data models

Keep names consistent across dependencies - if module A depends on B, use the same naming style.

FILEPATH CONVENTIONS:
- The "filepath" field specifies the FULL output path including filename
- Use framework-appropriate paths and filenames

For Next.js App Router (STRICT naming - file MUST be route.ts, page.tsx, layout.tsx):
- API routes: app/api/{path}/route.ts
  Example: filepath="app/api/courses/route.ts", filepath="app/api/lessons/[id]/route.ts"
- Pages: app/{path}/page.tsx
  Example: filepath="app/dashboard/page.tsx", filepath="app/orders/[id]/page.tsx"
- Layouts: app/{path}/layout.tsx
  Example: filepath="app/layout.tsx", filepath="app/dashboard/layout.tsx"
- Middleware: middleware.ts (at project root)
  Example: filepath="middleware.ts"

For standard projects:
- Use descriptive filenames matching the prompt basename
  Example: filename="orders_Python.prompt" → filepath="src/orders.py"
  Example: filename="api_routes_Python.prompt" → filepath="src/api/routes.py"

PATH-FILENAME RELATIONSHIP:
- For Next.js/Nuxt/SvelteKit: The filepath uses framework-required filenames (route.ts, page.tsx)
  while the prompt filename remains descriptive for context
- For standard projects: The filepath filename should match the prompt basename
  (e.g., orders_Python.prompt → orders.py)

Use forward slashes (/) for path separators regardless of OS.
Follow standard directory structures for the framework (e.g., app/ for Next.js 13+, src/ for typical Python projects).

DEPENDENCY RULES:
- The "dependencies" array must list other items by their prompt filenames (the "filename" values), not code filenames.
- Do not reference files that are not part of this array unless they were explicitly provided via INCLUDE_FILES/DOC_FILES.
- Avoid cycles; if a cycle is necessary, justify it in the description and clarify initialization order.

PRIORITY AND ORDERING:
- Use unique integer priorities starting at 1 without gaps (1,2,3,...).
- Sort the top-level array by ascending priority.

TAGS (optional):
- Use short, lower-case tags for slicing (e.g., ["frontend","nextjs"], ["backend","api"], ["config"]).

CONTENT GUIDANCE:
- Descriptions must be architectural and actionable: responsibilities, interfaces, error handling, cross-cutting concerns.
- For API items, outline endpoints (method, path, auth) and high-level request/response shapes.
- For page/component items, include the route, key props, and data sources.

DO NOT INCLUDE the schema or these conventions in the output; return only the JSON array.
