"""Cython compilation backend."""

from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING, Any

from lazy_bear import lazy

from build_cub.models._base import PathSource
from build_cub.workers.backends._base import CompileBackend

if TYPE_CHECKING:
    from Cython.Build import cythonize
    from setuptools import Extension

    from build_cub.models._backends import CythonSettings
    from build_cub.models._build_data import BuildData
    from build_cub.models._defaults import CompilerSettings
    from build_cub.plugins import BuildCubHook
    from build_cub.utils._printer import ColorPrinter
    from build_cub.validation._models import Artifact
else:
    CythonSettings = lazy("build_cub.models._backends", "CythonSettings")
    cythonize = lazy("Cython.Build", "cythonize")
    Extension = lazy("setuptools", "Extension")
    Artifact = lazy("build_cub.validation._models", "Artifact")
    BuildCubHook = lazy("build_cub.plugins", "BuildCubHook")


class CythonBackend(CompileBackend[CythonSettings, PathSource]):
    """Cython compilation backend.

    Compiles .pyx files into Python extension modules via Cython + setuptools.
    Uses _pre_compile hook to wrap extensions with cythonize().
    Uses _post_artifact_copy hook to clean up intermediate .c/.cpp files.
    """

    name: str = "cython"
    display_name: str = "Cython"
    dependencies: tuple[str, ...] = ("Cython", "setuptools")

    def __init__(self, should_run: bool, settings: BuildData, printer: ColorPrinter, hook: BuildCubHook) -> None:
        """Initialize the Cython backend."""
        super().__init__(should_run, settings, printer, hook)
        self._compiler_directives: dict[str, Any] | None = None
        if not self.local_settings.cleanup:
            from build_cub.utils import NOOP_FUNCTION

            setattr(self, "_post_execute", NOOP_FUNCTION)  # noqa: B010

    @property
    def compiler_directives(self) -> dict[str, Any]:
        """Get the Cython compiler directives from settings."""
        if self._compiler_directives is None:
            self._compiler_directives = self.local_settings.compiler_directives.model_dump(exclude_none=True)
            self.printer.debug(f"[{self.name}] Compiler directives: {self._compiler_directives}")
        return self._compiler_directives

    def _get_extensions(self, targets: list[PathSource]) -> list[Extension]:
        """Build Extension objects from .pyx file paths."""
        extensions: list[Extension] = []

        base_include_dirs: list[str] = [
            str(self.settings.pkg_root),
            str(self.settings.pkg_root / self.settings.general.name),
        ]
        compiler_settings: CompilerSettings = self.local_settings.get_compiler_settings()
        include_dirs: list[str] = [*base_include_dirs, *compiler_settings.include_dirs]

        for file in targets:
            extensions.append(
                Extension(
                    name=file.module_name,
                    include_dirs=include_dirs,
                    library_dirs=list(compiler_settings.library_dirs),
                    libraries=list(compiler_settings.libraries),
                    sources=[str(file.sources)],
                    extra_compile_args=list(compiler_settings.extra_compile_args),
                    extra_link_args=list(compiler_settings.extra_link_args),
                )
            )
        return extensions

    def _pre_execute(self, data: list[Extension]) -> list[Extension]:
        """Wrap extensions with cythonize() before compilation."""
        self.printer.debug(
            f"[{self.name}] Running cythonize on {len(data)} extensions (quiet={self.local_settings.quiet})"
        )
        return cythonize(
            module_list=data,
            quiet=self.local_settings.quiet,
            compiler_directives=self.compiler_directives,
        )

    def _post_execute(self, data: Artifact) -> None:
        """Remove intermediate C/C++ files generated by Cython."""
        name: str = self._get_base_name(data.path)
        path_obj: Path = data.path.parent / Path(name)
        intermediate_cpp: Path = path_obj.with_suffix(".cpp")
        intermediate_c: Path = path_obj.with_suffix(".c")
        self.printer.debug(f"[{self.name}] Checking for intermediate files: {path_obj}.c/.cpp")
        if intermediate_c.exists():
            intermediate_c.unlink()
            c_name: str = intermediate_c.name
            self.hook.register_message(name=self.name, key="Removed Intermediate", value=c_name, worker="backend")
        if intermediate_cpp.exists():
            intermediate_cpp.unlink()
            cpp_name: str = intermediate_cpp.name
            self.hook.register_message(name=self.name, key="Removed Intermediate", value=cpp_name, worker="backend")
