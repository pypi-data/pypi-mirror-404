# Evaluation: conversation-display Sprint Plans — Ambiguity & Contradiction Audit
Timestamp: 2026-01-29-183112
Git Commit: 7477c54

## Executive Summary
Overall: Plans 85% coherent | Critical contradictions: 3 | Internally consistent: Sprint 1 YES, Sprint 2 NO

Sprint 1 (widget-arch) is internally consistent and well-specified. Sprint 2 (scroll-nav) was written against an older architecture (TurnWidget/ScrollableContainer) and has NOT been updated to reflect Sprint 1's Line API/TurnData approach. This creates 3 critical contradictions and several design questions that must be resolved before Sprint 2 can be implemented.

## Critical Contradictions

### C1: Sprint 2 references TurnWidget throughout, but Sprint 1 does not create TurnWidget
**Severity**: CRITICAL — Sprint 2 is unimplementable as written

Sprint 1 architecture: ConversationView(ScrollView) stores `list[TurnData]` (plain dataclass). Rendering is via `render_line(y)` which maps virtual line y to a TurnData's pre-rendered Strip. There are no child widgets. No TurnWidget exists.

Sprint 2 references `TurnWidget` in 30+ locations across PLAN and CONTEXT files:
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 67: "Dependencies: Sprint 1 (TurnWidget exists)"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 71: "TurnWidget posts TurnSelected on on_click()"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 81: "self.add_class('selected') and self.remove_class('selected') on TurnWidget instances"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 99: "finds next visible TurnWidget, selects it"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 106: "self.query(TurnWidget)"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 107: "scroll_to_widget(tw) or tw.scroll_visible()"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 127: "TurnWidget.selected CSS rule"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 146-147: "Dependencies: Sprint 1 (ConversationView with TurnWidget children)"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 172: "self.query(TurnWidget)"
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` line 181: "ConversationView must be a ScrollableContainer with TurnWidget children"
- `SPRINT-20260129-130000-scroll-nav-CONTEXT.md` line 25: "Add on_click to TurnWidget"
- `SPRINT-20260129-130000-scroll-nav-CONTEXT.md` line 127-149: All navigation methods use `self.query(TurnWidget)`

**Impact**: Every Sprint 2 feature that involves turn selection, click handling, navigation, or CSS highlighting is broken by design. These features must be redesigned for the Line API architecture.

**Resolution needed**: Sprint 2 must be rewritten. In a Line API architecture:
- Turn selection = tracking `_selected_turn_index: int | None` and re-rendering affected lines with a highlight style
- Click handling = overriding `on_click(event)` on ConversationView, using `event.y + scroll_y` to find which turn was clicked via binary search on line offsets
- CSS `.selected` = not applicable. Visual highlighting must be done by modifying Strip styles at render time (e.g., applying a background style in `render_line()` for lines belonging to the selected turn)
- Navigation = pure data operations on `_turns` list, then `scroll_to(y=turn.line_offset)` to bring a turn into view
- `scroll_to_widget()` = not available. Use `scroll_to(y=turn.line_offset)` instead

### C2: Sprint 2 references StreamingTurnWidget, Sprint 1 creates StreamingRichLog
**Severity**: MEDIUM — naming confusion, functionally different classes

Sprint 2 CONTEXT line 77-91 references `StreamingTurnWidget._flush()` and `StreamingTurnWidget.ContentUpdated` message. Sprint 1 creates `StreamingRichLog(RichLog)` which uses `RichLog.write()` for incremental append, not `Static.update()`.

The follow-mode streaming coordination in Sprint 2 must be redesigned:
- Sprint 2 assumes `StreamingTurnWidget._flush()` posts `ContentUpdated` message
- Sprint 1's `StreamingRichLog` uses `RichLog.write()` which has its own `auto_scroll` behavior
- The two models are fundamentally different (Static.update vs RichLog.write)

**Resolution**: StreamingRichLog is a RichLog, which has built-in `auto_scroll = True` by default. Follow-mode during streaming should rely on RichLog's native auto-scroll. ConversationView only needs to know when streaming finishes (to call `add_turn`). The `ContentUpdated` message pattern is unnecessary.

### C3: Sprint 2 scroll anchor uses widget.region and query(TurnWidget) — incompatible with Line API
**Severity**: MEDIUM — scroll anchor feature must be redesigned

`SPRINT-20260129-130000-scroll-nav-PLAN.md` lines 144-178 and CONTEXT lines 191-228 describe scroll anchor logic using:
- `self.query(TurnWidget)` to iterate turn widgets
- `tw.region.y` for coordinate lookup
- `scroll_to_widget(tw)` for restoration

None of these work with Line API. In the Line API architecture, scroll anchor becomes simpler:
- Before filter change: record `anchor_line = scroll_y`, find which turn that maps to via binary search, record the turn index and offset within that turn
- After filter change: find the new `line_offset` for that turn, scroll to `new_line_offset + offset_within_turn`

This is actually easier than the widget-based approach since it is pure arithmetic on the line offset table.

## Internal Contradictions Within Sprint 1

### I1: ConversationView retains stub append_block() and finish_turn()
**Severity**: LOW — dead code, confusing but not harmful

`SPRINT-20260129-120000-widget-arch-CONTEXT.md` lines 324-336 shows `append_block()` and `finish_turn()` as `pass` stubs on ConversationView. The PLAN description at line 112 says "Maintains same public API: append_block(), finish_turn(), rerender(), get_state(), restore_state()."

But the event handler routing (CONTEXT lines 437-460) routes streaming to `StreamingRichLog` and finalized turns to `conv.add_turn(blocks)`. The stubs are never called. They exist only for "API compatibility" but nothing calls them.

**Resolution**: Remove the stubs from ConversationView. They violate the "no silent fallbacks" principle. If something accidentally calls `conv.append_block()`, it silently does nothing instead of raising an error.

### I2: DOD lists both add_turn and append_block/finish_turn as public API
**Severity**: LOW — documentation inconsistency

`SPRINT-20260129-120000-widget-arch-DOD.md` line 38: "Public API: append_block, finish_turn, add_turn, rerender, get_state, restore_state"

But per the event handler plan, only `add_turn`, `rerender`, `get_state`, `restore_state` are actually used. `append_block` and `finish_turn` are stubs.

## Unspecified Integration Points

### U1: How does _handle_event_inner provide StreamingRichLog to event handlers?
**Status**: Partially specified

Sprint 1 CONTEXT line 510 says: "Add `'streaming': self._get_streaming()` to the widgets dict." But `_handle_event_inner` in `app.py` (line 322-376) builds the widgets dict. The plan does not show the actual diff for this function.

Currently (`app.py` line 327-332):
```python
widgets = {
    "conv": self._get_conv(),
    "stats": self._get_stats(),
    "filters": self.active_filters,
    "show_expand": self.show_expand,
}
```

Must become:
```python
widgets = {
    "conv": self._get_conv(),
    "stats": self._get_stats(),
    "streaming": self._get_streaming(),
    "filters": self.active_filters,
    "show_expand": self.show_expand,
}
```

This is straightforward but the plan should make it explicit. Also note: `handle_request` does not use `streaming` (it calls `conv.add_turn()` directly). But `handle_error` and `handle_proxy_error` also do not use streaming. Only `handle_response_event` and `handle_response_done` need it. The widgets dict will carry an unused key for most handlers, which is fine.

### U2: handle_response_done signature change
**Status**: Not addressed in plan

Current `handle_response_done` (`event_handlers.py` line 102) signature:
```python
def handle_response_done(event, state, widgets, app_state, refresh_callbacks, db_context, log_fn):
```

The plan changes the body to call `streaming.finalize()` then `conv.add_turn(blocks)`. But `handle_response_done` also does (line 135-136):
```python
if show_expand:
    conv.rerender(filters)
```

In the new architecture, `conv.add_turn(blocks)` renders the turn with current filters at add time. The `rerender` call afterward would be redundant for the just-added turn. However, the expand filter specifically relates to cache data that becomes available at response_done time. The existing code re-renders ALL turns when expand is on. With the new architecture, this should still work (rerender re-renders all TurnData) but the question is whether this is necessary. If the blocks already contain TurnBudgetBlock with cache data at the time they are formatted, then the initial `add_turn` render will include it. But looking at the current flow: `handle_response_done` calls `conv.finish_turn()` THEN `conv.rerender(filters)` — the re-render updates ALL previous turns, not just the current one. The cache data comes from a DB refresh that happens between lines 129-132. So the `rerender` is for previous turns' TurnBudgetBlocks that now have updated cache data from the DB.

**This flow is unchanged by the new architecture.** `conv.rerender(filters)` on the new ConversationView re-renders all TurnData. No issue here.

### U3: _replace_all_widgets must handle StreamingRichLog
**Status**: Mentioned in DOD but not specified in CONTEXT

`SPRINT-20260129-120000-widget-arch-DOD.md` line 59: "_replace_all_widgets handles StreamingRichLog state"

The current `_replace_all_widgets()` in `app.py` lines 229-308 does not handle StreamingRichLog. The plan shows `StreamingRichLog.get_state()` and `restore_state()` methods but does not show the diff for `_replace_all_widgets()`.

The implementation needs to:
1. Get StreamingRichLog state before removal
2. Create new StreamingRichLog from factory
3. Restore state
4. Mount in correct position

This is straightforward but should be specified.

### U4: Compose tree layout — ConversationView and StreamingRichLog coexistence
**Status**: Unknown with two proposed options, neither confirmed

Sprint 1 PLAN line 154 identifies this as an unknown: "Options: (a) vertical container with both, RichLog docked bottom; (b) ConversationView allocates space for the RichLog at the bottom of its virtual space."

Sprint 1 CONTEXT line 487-499 shows them as siblings in `compose()`:
```python
yield conv
streaming = ...
yield streaming
```

Sprint 1 CONTEXT line 162-163 says: "The simplest layout: VerticalScroll container with ConversationView (flex: 1) and StreamingRichLog (height: auto, max-height: 50%)."

But the current CSS has `ConversationView { height: 1fr }` and other panels docked bottom. Adding `StreamingRichLog` with `dock: bottom` between ConversationView and the other bottom-docked panels should work — Textual stacks docked elements and the `1fr` ConversationView gets whatever space remains.

**However**: There is a subtle issue. When StreamingRichLog is visible (`display: True`, `height: auto`), it will eat vertical space from ConversationView. When it hides on finalize (`display: False`), ConversationView gets that space back. This causes a layout jump — ConversationView's height changes, which means its viewport changes, which means `render_line` renders different lines. If follow mode is on, this is fine (scroll to bottom). If follow mode is off, the user's viewport will shift because the ConversationView grew taller.

**Resolution needed**: Decide whether this layout jump is acceptable. If not, consider making StreamingRichLog an overlay or using a fixed split.

## watch_scroll_y Signature Mismatch

### W1: Sprint 2 uses wrong signature for watch_scroll_y override
**Severity**: HIGH — will cause runtime error

`SPRINT-20260129-130000-scroll-nav-CONTEXT.md` line 64-66:
```python
def watch_scroll_y(self, value: float):
    if not self.is_vertical_scroll_end:
        self._follow_mode = False
```

Textual's `ScrollView.watch_scroll_y` at `/Users/bmf/code/cc-dump/.venv/lib/python3.12/site-packages/textual/scroll_view.py` line 52 has signature:
```python
def watch_scroll_y(self, old_value: float, new_value: float) -> None:
```

The override must match: `def watch_scroll_y(self, old_value: float, new_value: float)`. Textual watcher dispatch uses introspection on the parameter count. A one-arg watcher is valid for the base `reactive` protocol, but since `ScrollView` already defines a two-arg watcher, the override MUST call super to preserve scrollbar sync and refresh behavior:

```python
def watch_scroll_y(self, old_value: float, new_value: float) -> None:
    super().watch_scroll_y(old_value, new_value)
    if not self.is_vertical_scroll_end:
        self._follow_mode = False
```

Without calling super, the vertical scrollbar position will not update and the widget will not refresh on scroll.

## Missing Error Handling / Edge Cases

### E1: render_turn_to_strips with zero-width console
Sprint 1 CONTEXT line 342: `width = self.scrollable_content_region.width if self._size_known else self._last_width`

`_size_known` checks `self.size.width > 0`. But `scrollable_content_region` might have width 0 if borders/scrollbars consume all space. `render_turn_to_strips` with `width=0` will produce strips of 0 cells, which is technically correct but wasteful. The `_last_width` default is 78. Need to ensure `_last_width` is updated before first `add_turn` call. If `add_turn` is called before `on_mount` (e.g., during state restore), width will be 78 regardless of actual terminal size.

### E2: Binary search correctness when turns list is empty or has one element
Sprint 1 CONTEXT lines 291-306 shows `_find_turn_for_line`. The binary search is standard and handles empty list. No issue.

### E3: Concurrent add_turn during rerender
If `add_turn()` is called while `rerender()` is in progress (both run on the main thread via `call_from_thread`), could `_recalculate_offsets()` be called with inconsistent state? Since both execute on the main thread (Textual event loop), they are serialized. No issue.

### E4: StreamingRichLog.finalize() called when no blocks accumulated
Sprint 1 CONTEXT line 208: `finalize()` returns empty list if no blocks. Sprint 1 CONTEXT line 453: `if blocks: conv.add_turn(blocks)`. This handles the empty case correctly.

### E5: Hot-reload state key mismatch between old and new ConversationView
Current `get_state()` returns keys: `turn_blocks`, `current_turn_blocks`, `text_delta_buffer`
New `get_state()` returns keys: `all_blocks`, `follow_mode`, `turn_count`

During hot-reload, old widget's `get_state()` returns old keys. New widget's `restore_state()` looks for `all_blocks`. It will find nothing and restore with empty state — losing all conversation data.

**Resolution**: `restore_state()` must handle BOTH old and new key formats during the transition period. Or: accept that the first hot-reload after the migration loses state (one-time cost).

## Stale References Audit

| Location | Stale Reference | Should Be |
|----------|----------------|-----------|
| Sprint 2 PLAN line 67 | "Dependencies: Sprint 1 (TurnWidget exists)" | "Dependencies: Sprint 1 (ConversationView with TurnData)" |
| Sprint 2 PLAN line 71 | "TurnWidget posts TurnSelected on on_click()" | "ConversationView.on_click maps click y to turn index" |
| Sprint 2 PLAN line 75 | "TurnWidget.on_click()" | Removed — no TurnWidget |
| Sprint 2 PLAN line 77 | "removes .selected from old, adds to new" | "re-renders affected lines with/without highlight" |
| Sprint 2 PLAN line 81 | "self.add_class('selected')...on TurnWidget instances" | N/A — no widget CSS classes in Line API |
| Sprint 2 PLAN line 99 | "finds next visible TurnWidget" | "finds next TurnData in _turns list" |
| Sprint 2 PLAN line 106 | "self.query(TurnWidget)" | "iterate self._turns" |
| Sprint 2 PLAN line 107 | "scroll_to_widget(tw)" | "scroll_to(y=turn.line_offset)" |
| Sprint 2 PLAN line 108 | "tw._blocks" | "turn_data.blocks" |
| Sprint 2 PLAN line 127 | "TurnWidget.selected CSS rule" | Inline style in render_line |
| Sprint 2 PLAN line 146 | "Sprint 1 (ConversationView with TurnWidget children)" | "Sprint 1 (ConversationView with Line API)" |
| Sprint 2 PLAN line 172-173 | "self.query(TurnWidget)" iteration | "iterate self._turns" |
| Sprint 2 PLAN line 181 | "ScrollableContainer with TurnWidget children" | "ScrollView with Line API" |
| Sprint 2 PLAN line 187 | "query(TurnWidget)" performance concern | N/A — data iteration, not widget query |
| Sprint 2 CONTEXT line 25 | "Add on_click to TurnWidget" | "Override on_click on ConversationView" |
| Sprint 2 CONTEXT line 36-40 | TurnWidget constructor with turn_index | N/A — no TurnWidget |
| Sprint 2 CONTEXT line 75 | "self._auto_scroll() at end of finish_turn()" | "self._auto_scroll() at end of add_turn()" |
| Sprint 2 CONTEXT line 80-98 | StreamingTurnWidget._flush, ContentUpdated | StreamingRichLog — use RichLog auto_scroll |
| Sprint 2 CONTEXT line 106-119 | query_one(f"#turn-{index}") for selection | Track selection in _selected_turn_index, re-render |
| Sprint 2 CONTEXT line 127-173 | All query(TurnWidget) iteration | Iterate self._turns |
| Sprint 2 CONTEXT line 202-226 | query(TurnWidget) for viewport anchor | Binary search on line_offset |
| Sprint 2 CONTEXT line 289 | "TurnWidget rule added in Sprint 1" | Sprint 1 does not add TurnWidget CSS |
| Sprint 2 CONTEXT line 300-313 | widgets.py re-exports TurnWidget, StreamingTurnWidget, TurnSelected | Only TurnSelected (if kept), StreamingRichLog |

## Ambiguities Found

| Area | Question | How LLM Guessed | Impact |
|------|----------|-----------------|--------|
| Turn selection rendering | How to visually highlight selected turn without CSS classes? | Not addressed (Sprint 2 assumes TurnWidget) | HIGH — requires render_line to check selected_turn and apply background style |
| Click-to-select coordinate mapping | How to map mouse click y to turn index? | Not addressed (Sprint 2 assumes TurnWidget.on_click) | MEDIUM — must use binary search same as render_line |
| Layout transition on StreamingRichLog hide | Does ConversationView resize cause viewport jump? | Plan acknowledges unknown but does not resolve | MEDIUM — affects UX during streaming-to-finalized transition |
| watch_scroll_y super call | Must override preserve ScrollView's scrollbar/refresh behavior? | Sprint 2 uses 1-arg signature, skips super | HIGH — will break scrollbar and refresh |
| Hot-reload state key migration | Old keys (turn_blocks) vs new keys (all_blocks) | Plan does not address transitional compatibility | LOW — one-time loss during migration deploy |
| "visible turn" in navigation | What makes a turn "visible" in Line API? | Sprint 2 checks `tw.display == True` on TurnWidget | MEDIUM — needs filter-aware check on TurnData (a turn with 0 rendered strips is "invisible") |

## Recommendations

1. **Rewrite Sprint 2 for Line API architecture** (CRITICAL). Sprint 2 was written against the ScrollableContainer/TurnWidget design that was superseded by Sprint 1's ScrollView/Line API design. Every feature in Sprint 2 must be redesigned:
   - Turn selection: index tracking + render_line style injection
   - Click handling: ConversationView.on_click with coordinate mapping
   - Navigation: iterate self._turns instead of query(TurnWidget)
   - CSS .selected: not applicable, use Strip style modification
   - Scroll anchor: pure arithmetic on line offsets
   - Follow mode: correct watch_scroll_y signature with super() call

2. **Fix watch_scroll_y signature** (HIGH). The override must be `(self, old_value: float, new_value: float)` and must call `super().watch_scroll_y(old_value, new_value)` to preserve scrollbar position sync and widget refresh. Reference: `/Users/bmf/code/cc-dump/.venv/lib/python3.12/site-packages/textual/scroll_view.py` line 52-56.

3. **Remove ConversationView stub methods** (LOW). `append_block()` and `finish_turn()` as `pass` stubs violate no-silent-fallback principle. Either raise `NotImplementedError` or remove entirely.

4. **Handle hot-reload state key migration** (LOW). New `restore_state()` should check for both old key (`turn_blocks`) and new key (`all_blocks`).

5. **Resolve StreamingRichLog layout behavior** (MEDIUM). Decide and document whether the height jump when StreamingRichLog appears/disappears is acceptable. If not, use a fixed split or overlay approach.

6. **Clarify "turn visibility" for navigation** (MEDIUM). In the Line API model, a turn is "invisible" if all its blocks are filtered out (strips list is empty after rendering). Navigation should skip these turns. Sprint 2 must define this clearly.

## Verdict
- [ ] CONTINUE - Issues clear, implementer can fix
- [x] PAUSE - Ambiguities need clarification

Sprint 1 is ready to implement. Sprint 2 must be rewritten to match Sprint 1's architecture. The Sprint 2 rewrite is not a minor edit — every work item references TurnWidget which does not exist. Implementing Sprint 2 as-written will fail. The rewrite should be done AFTER Sprint 1 is complete, using Sprint 1's actual API as the foundation.

**Specific questions needing answers:**
1. How should turn selection be rendered in Line API? (render_line style injection is the only option, but what style? background? border simulation with leading characters?)
2. Should the StreamingRichLog layout be a dock:bottom sibling or something else?
3. Is the one-time hot-reload state loss during migration acceptable?
