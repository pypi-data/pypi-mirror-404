# Explore Output: conversation-display Sprint Plans
Timestamp: 2026-01-29-183112
Git Commit: 7477c54

## Files Examined

### Sprint Plans
- `SPRINT-20260129-120000-widget-arch-PLAN.md` (228 lines)
- `SPRINT-20260129-120000-widget-arch-CONTEXT.md` (533 lines)
- `SPRINT-20260129-120000-widget-arch-DOD.md` (77 lines)
- `SPRINT-20260129-130000-scroll-nav-PLAN.md` (188 lines)
- `SPRINT-20260129-130000-scroll-nav-CONTEXT.md` (346 lines)
- `SPRINT-20260129-130000-scroll-nav-DOD.md` (43 lines)
- `plan-adjustments.` (notes file with design decisions)
- `EVALUATION-20260129.md` (prior evaluation)

### Source Files
- `src/cc_dump/tui/widget_factory.py` (397 lines) - ConversationView(RichLog), StatsPanel, etc.
- `src/cc_dump/tui/event_handlers.py` (206 lines) - 5 handlers: request, response_event, response_done, error, proxy_error
- `src/cc_dump/tui/app.py` (489 lines) - CcDumpApp, compose(), hot-reload, event routing
- `src/cc_dump/tui/rendering.py` (404 lines) - BLOCK_RENDERERS (19 types), render_block(), render_blocks()
- `src/cc_dump/tui/widgets.py` (25 lines) - re-export shell
- `src/cc_dump/tui/styles.css` (48 lines) - current CSS

## Key Observations

### Sprint 1 (widget-arch) Architecture
- Replaces ConversationView(RichLog) with ConversationView(ScrollView)
- Introduces TurnData dataclass, StreamingRichLog(RichLog), Line API rendering
- Adds BLOCK_FILTER_KEY, render_turn_to_strips(), combine_rendered_texts()
- Changes API: append_block/finish_turn -> add_turn(blocks) for finalized turns
- StreamingRichLog handles in-progress streaming with RichLog's native append

### Sprint 2 (scroll-nav) Architecture
- Adds follow mode (_follow_mode), watch_scroll_y, toggle_follow()
- Turn navigation: j/k/n/N/g/G keybindings
- TurnSelected message, .selected CSS class
- Scroll anchor preservation on filter toggle
- References TurnWidget extensively (click handling, query(TurnWidget), CSS classes)

### Critical Cross-Sprint Contradictions Found
1. Sprint 2 references `TurnWidget` 30+ times but Sprint 1 does NOT create TurnWidget. Sprint 1 uses TurnData (plain dataclass) + Line API. No widgets per turn.
2. Sprint 2 CONTEXT references `StreamingTurnWidget` but Sprint 1 creates `StreamingRichLog` (a RichLog, not StreamingTurnWidget).
3. Sprint 2 uses `self.query(TurnWidget)` for navigation but Sprint 1 has no queryable turn widgets.
4. Sprint 2 uses `.selected` CSS class on TurnWidget but Sprint 1 has no TurnWidget to apply CSS to.
5. Sprint 2 uses `scroll_to_widget(tw)` and `tw.scroll_visible()` but Sprint 1 has no turn widgets.
6. Sprint 2 dependency line says "ConversationView must be a ScrollableContainer with TurnWidget children" but Sprint 1 makes it a ScrollView with Line API (no children).

### Event Handler Migration
Current call sites:
- handle_request (line 34-37): for block in blocks: conv.append_block(block, filters); conv.finish_turn()
- handle_response_event (line 72-73): for block in blocks: conv.append_block(block, filters)
- handle_response_done (line 123): conv.finish_turn()
- handle_error (line 174-175): conv.append_block(block, filters); conv.finish_turn()
- handle_proxy_error (line 202-203): conv.append_block(block, filters); conv.finish_turn()

Plan changes to:
- handle_request: conv.add_turn(blocks)
- handle_response_event: streaming.append_block(block, filters)
- handle_response_done: blocks = streaming.finalize(); conv.add_turn(blocks)
- handle_error: conv.add_turn([block])
- handle_proxy_error: conv.add_turn([block])

### Hot-Reload State Format
Current get_state() keys: turn_blocks, current_turn_blocks, text_delta_buffer
New get_state() keys: all_blocks, follow_mode, turn_count
StreamingRichLog has separate get_state(): blocks, text_delta_buffer

### Layout Questions
- Sprint 1 says ConversationView and StreamingRichLog are siblings in compose tree
- styles.css has ConversationView { height: 1fr } -- StreamingRichLog needs to share vertical space
- Sprint 1 CONTEXT proposes StreamingRichLog docked bottom with height:auto, max-height:50%
- ConversationView stays height:1fr but StreamingRichLog eats into that space when visible

### render_line(y) Implementation
- Sprint 1 CONTEXT shows render_line adding scroll_y to y: `actual_y = scroll_y + y`
- This may double-count ScrollView's built-in scroll offset handling. ScrollView's render_line(y) receives y in virtual space coordinates, not viewport coordinates. Need to verify.
