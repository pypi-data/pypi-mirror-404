# ==============================================================================
# Sisyphus API Engine - 企业级测试用例最佳实践
# ==============================================================================
# 本文件演示编写高质量、可维护的企业级API测试用例的最佳实践
#
# 核心原则：
# 1. 清晰的命名和注释
# 2. 模块化和可重用性
# 3. 完善的验证和断言
# 4. 错误处理和重试机制
# 5. 数据管理和清理
# 6. 性能考虑
# ==============================================================================

name: "企业级测试用例最佳实践"
description: "演示高质量测试用例的编写规范和最佳实践"

config:
  name: "最佳实践配置"
  timeout: 120

  # ========================================================================
  # 多环境配置
  # ========================================================================
  profiles:
    dev:
      base_url: "https://httpbin.org"
      variables:
        env: "dev"
        timeout: 30
        retry_times: 3

    staging:
      base_url: "https://httpbin.org"
      variables:
        env: "staging"
        timeout: 20
        retry_times: 2

    prod:
      base_url: "https://httpbin.org"
      variables:
        env: "prod"
        timeout: 10
        retry_times: 1

  # 当前激活环境
  active_profile: "prod"

  # ========================================================================
  # 全局变量
  # ========================================================================
  variables:
    # 测试数据
    test_user_prefix: "test_user_"
    test_domain: "example.com"

    # 配置参数
    default_timeout: 30
    max_retry: 3

    # 开关控制
    enable_cleanup: true
    enable_logging: true

# ============================================================================
# 测试步骤
# ============================================================================
steps:
  # ============================================================================
  # 第一部分：测试数据准备
  # ============================================================================

  # ----------------------------------------------------------------------------
  # 最佳实践1：使用脚本生成唯一测试数据
  # 目的：避免测试数据冲突，确保测试可重复执行
  # ----------------------------------------------------------------------------
  - name: "Setup-生成唯一测试数据"
    description: "生成唯一的测试数据，包括时间戳和随机数"
    type: script
    script_type: python
    script: |
      import random
      import string
      from datetime import datetime

      # 生成唯一标识符
      timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
      random_str = ''.join(random.choices(string.ascii_lowercase, k=6))
      unique_id = f"{timestamp}_{random_str}"

      # 生成测试用户数据
      username = f"{get_var('test_user_prefix')}{unique_id}"
      email = f"{username}@{get_var('test_domain')}"
      user_id = f"UID_{random.randint(10000, 99999)}"

      # 设置全局变量
      set_var('test_username', username)
      set_var('test_email', email)
      set_var('test_user_id', user_id)
      set_var('test_timestamp', timestamp)

      # 输出日志信息（使用print而不是return）
      print(f"Generated test data: {username}, {email}, {user_id}")
      result = f"Generated test data: {username}, {email}, {user_id}"

  # ----------------------------------------------------------------------------
  # 最佳实践2：用户注册（完整的三步验证）
  # 目的：演示如何对单个操作进行多层验证
  # ----------------------------------------------------------------------------
  - name: "Test-用户注册"
    description: "测试用户注册功能，包含状态码、业务数据和响应结构验证"
    type: request
    method: POST
    url: "${config.profiles.prod.base_url}/post"
    headers:
      Content-Type: "application/json"
      X-Request-ID: "${uuid()}"
      X-Environment: "${config.profiles.prod.variables.env}"
    body:
      username: "${test_username}"
      email: "${test_email}"
      user_id: "${test_user_id}"
      action: "register"
      timestamp: "${test_timestamp}"

    # 重试配置：网络不稳定时自动重试
    retry_policy:
      max_attempts: 3
      strategy: exponential
      base_delay: 1.0
      backoff_multiplier: 2.0
      retry_on:
        - network
        - timeout
      stop_on:
        - assertion

    # 多层验证
    validations:
      # 第1层：HTTP状态码验证
      - type: status_code
        path: "$.status_code"
        expect: "200"
        description: "验证HTTP状态码为200"

      # 第2层：业务数据验证
      - type: eq
        path: "$.json.username"
        expect: "${test_username}"
        description: "验证用户名正确"

      - type: eq
        path: "$.json.email"
        expect: "${test_email}"
        description: "验证邮箱正确"

      - type: eq
        path: "$.json.action"
        expect: "register"
        description: "验证操作类型"

      # 第3层：数据完整性验证
      - type: exists
        path: "$.json.user_id"
        expect: true
        description: "验证user_id字段存在"

      - type: exists
        path: "$.json.timestamp"
        expect: true
        description: "验证timestamp字段存在"

      # 第4层：数据格式验证
      - type: regex
        path: "$.json.email"
        expect: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
        description: "验证邮箱格式正确"

    # 提取响应数据供后续步骤使用
    extractors:
      - type: jsonpath
        name: response_url
        path: "$.url"
        description: "提取响应URL"

  # ============================================================================
  # 第二部分：条件测试和依赖管理
  # ============================================================================

  # ----------------------------------------------------------------------------
  # 最佳实践3：使用条件执行控制测试流程
  # 目的：根据环境或配置动态调整测试行为
  # ----------------------------------------------------------------------------
  - name: "Test-条件查询（仅生产环境）"
    description: "只在生产环境执行的测试"
    type: request
    method: GET
    url: "${config.profiles.prod.base_url}/get"
    headers:
      X-Environment: "${config.profiles.prod.variables.env}"
    # 条件执行：只在生产环境运行
    only_if: "${env == 'prod'}"
    validations:
      - type: status_code
        path: "$.status_code"
        expect: "200"
        description: "验证状态码为200"

  # ----------------------------------------------------------------------------
  # 最佳实践4：使用依赖关系确保执行顺序
  # 目的：确保关键步骤成功后再执行后续步骤
  # ----------------------------------------------------------------------------
  - name: "Test-用户信息查询（依赖注册成功）"
    description: "查询用户信息，依赖用户注册步骤"
    type: request
    method: GET
    url: "${config.profiles.prod.base_url}/get"
    params:
      user_id: "${test_user_id}"
      username: "${test_username}"
    # 明确声明依赖关系
    depends_on:
      - "Setup-生成唯一测试数据"
      - "Test-用户注册"
    validations:
      - type: status_code
        path: "$.status_code"
        expect: "200"
        description: "验证状态码为200"
      - type: contains
        path: "$.args.user_id"
        expect: "UID_"
        description: "验证用户ID参数"

  # ============================================================================
  # 第三部分：数据验证和边界测试
  # ============================================================================

  # ----------------------------------------------------------------------------
  # 最佳实践5：全面的断言验证
  # 目的：使用多种比较器进行深度验证
  # ----------------------------------------------------------------------------
  - name: "Test-数据验证"
    description: "演示各种断言验证器的使用"
    type: request
    method: POST
    url: "${config.profiles.prod.base_url}/post"
    headers:
      Content-Type: "application/json"
    body:
      username: "${test_username}"
      age: 28
      score: 85.5
      tags: ["python", "api", "testing"]
      is_active: true
      profile:
        level: "premium"
        expires: "2025-12-31"
    validations:
      # 基础相等验证
      - type: eq
        path: "$.json.username"
        expect: "${test_username}"
        description: "验证用户名"

      # 数值范围验证
      - type: between
        path: "$.json.age"
        expect: [18, 65]
        description: "验证年龄在18-65之间"

      # 类型验证
      - type: type
        path: "$.json.username"
        expect: "str"
        description: "验证用户名是字符串"

      - type: type
        path: "$.json.is_active"
        expect: "bool"
        description: "验证激活状态是布尔值"

      # 列表验证
      - type: contains
        path: "$.json.tags"
        expect: "python"
        description: "验证tags包含python"

      - type: length_eq
        path: "$.json.tags"
        expect: 3
        description: "验证tags有3个元素"

      # 嵌套对象验证
      - type: eq
        path: "$.json.profile.level"
        expect: "premium"
        description: "验证会员等级"

  # ============================================================================
  # 第四部分：错误处理和重试
  # ============================================================================

  # ----------------------------------------------------------------------------
  # 最佳实践6：配置重试策略
  # 目的：提高测试的稳定性和可靠性
  # ----------------------------------------------------------------------------
  - name: "Test-重试机制演示"
    description: "演示各种重试策略的配置"
    type: request
    method: POST
    url: "${config.profiles.prod.base_url}/post"
    headers:
      Content-Type: "application/json"
    body:
      test: "retry"
      strategy: "exponential"
    # 配置增强重试策略
    retry_policy:
      max_attempts: 5
      strategy: exponential
      base_delay: 1.0
      max_delay: 10.0
      backoff_multiplier: 2.0
      jitter: true
      retry_on:
        - network
        - timeout
      stop_on:
        - assertion
    validations:
      - type: status_code
        path: "$.status_code"
        expect: "200"

  # ============================================================================
  # 第五部分：性能和并发测试
  # ============================================================================

  # ----------------------------------------------------------------------------
  # 最佳实践7：并发测试
  # 目的：验证系统在高并发场景下的表现
  # ----------------------------------------------------------------------------
  - name: "Test-并发性能测试"
    description: "同时发送多个请求，测试系统并发处理能力"
    type: concurrent
    max_concurrency: 5
    concurrent_steps:
      - name: "并发请求1"
        type: request
        method: GET
        url: "${config.profiles.prod.base_url}/delay/1"
        validations:
          - type: status_code
            path: "$.status_code"
            expect: "200"

      - name: "并发请求2"
        type: request
        method: GET
        url: "${config.profiles.prod.base_url}/delay/1"
        validations:
          - type: status_code
            path: "$.status_code"
            expect: "200"

      - name: "并发请求3"
        type: request
        method: GET
        url: "${config.profiles.prod.base_url}/delay/1"
        validations:
          - type: status_code
            path: "$.status_code"
            expect: "200"

  # ============================================================================
  # 第六部分：数据清理
  # ============================================================================

  # ----------------------------------------------------------------------------
  # 最佳实践8：测试数据清理
  # 目的：保持测试环境干净，避免数据污染
  # ----------------------------------------------------------------------------
  - name: "Cleanup-清理测试数据"
    description: "清理测试过程中产生的数据"
    type: script
    script_type: python
    script: |
      # 获取清理开关
      enable_cleanup = get_var('enable_cleanup')

      if enable_cleanup:
          # 记录测试数据
          username = get_var('test_username')
          user_id = get_var('test_user_id')
          timestamp = get_var('test_timestamp')

          # 在实际测试中，这里会调用API删除测试数据
          # 例如：DELETE /api/users/{user_id}

          cleanup_info = {
              'username': username,
              'user_id': user_id,
              'timestamp': timestamp,
              'cleaned': True
          }

          set_var('cleanup_info', cleanup_info)
          result = f"Cleanup completed: {username}"
          print(result)
      else:
          result = "Cleanup skipped by configuration"
          print(result)

  # ----------------------------------------------------------------------------
  # 最佳实践9：生成测试报告摘要
  # 目的：汇总测试结果，提供清晰的测试报告
  # ----------------------------------------------------------------------------
  - name: "Summary-生成测试报告"
    description: "汇总测试执行结果和关键指标"
    type: script
    script_type: python
    script: |
      # 收集测试数据
      test_username = get_var('test_username', 'N/A')
      test_user_id = get_var('test_user_id', 'N/A')
      test_timestamp = get_var('test_timestamp', 'N/A')
      cleanup_info = get_var('cleanup_info', {})

      # 生成测试摘要
      summary = f"""
      =====================================================================
      测试执行摘要
      =====================================================================
      测试用户: {test_username}
      用户ID: {test_user_id}
      测试时间: {test_timestamp}
      清理状态: {'已完成' if cleanup_info.get('cleaned', False) else '未执行'}

      测试覆盖:
      ✓ 测试数据生成
      ✓ 用户注册流程
      ✓ 条件执行测试
      ✓ 数据验证测试
      ✓ 重试机制测试
      ✓ 并发性能测试
      ✓ 数据清理流程

      最佳实践应用:
      ✓ 唯一测试数据生成
      ✓ 多层验证机制
      ✓ 条件执行控制
      ✓ 依赖关系管理
      ✓ 错误处理和重试
      ✓ 并发测试
      ✓ 数据清理策略
      =====================================================================
      """

      # 设置摘要变量
      set_var('test_summary', summary)
      result = summary
      print(summary)

# ============================================================================
# 标签和分类
# ============================================================================
tags:
  - "最佳实践"
  - "企业级"
  - "完整示例"
  - "tutorial"

# 是否启用此测试用例
enabled: true

# ============================================================================
# 最佳实践说明
# ============================================================================
#
# 1. 命名规范
#    - 测试用例名称：清晰描述测试目的
#    - 步骤名称：使用 "阶段-操作" 格式（如：Setup-初始化数据）
#    - 变量名称：使用描述性名称，添加前缀（如：test_）
#
# 2. 注释规范
#    - 每个步骤添加description描述目的
#    - 复杂逻辑添加注释说明
#    - 验证规则添加description说明验证目的
#
# 3. 数据管理
#    - 使用脚本生成唯一测试数据
#    - 测试完成后清理数据
#    - 避免硬编码，使用变量
#
# 4. 验证策略
#    - 多层验证：状态码 -> 业务数据 -> 数据完整性
#    - 使用多种比较器：eq/type/regex/contains/length等
#    - 验证关键业务逻辑，不仅仅是技术实现
#
# 5. 错误处理
#    - 配置合理的重试策略
#    - 使用条件跳过不相关的测试
#    - 明确依赖关系，确保执行顺序
#
# 6. 性能考虑
#    - 合理设置timeout
#    - 使用并发测试提高效率
#    - 避免不必要的等待
#
# 7. 可维护性
#    - 模块化设计，功能分离
#    - 使用变量和提取器实现数据共享
#    - 定期review和更新测试用例
#
# ==============================================================================
