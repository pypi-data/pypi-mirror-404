# coding: utf-8

"""
    Pinterest REST API

    Pinterest's REST API

    The version of the OpenAPI document: 5.23.0
    Contact: blah+oapicf@cliffano.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pinterestsdk.models.creative_type import CreativeType
from pinterestsdk.models.entity_status import EntityStatus
from pinterestsdk.models.grid_click_type import GridClickType
from typing import Optional, Set
from typing_extensions import Self

class ProductGroupPromotion(BaseModel):
    """
    ProductGroupPromotion
    """ # noqa: E501
    ad_group_id: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="ID of the ad group the product group belongs to.")
    bid_in_micro_currency: Optional[StrictInt] = Field(default=None, description="The bid in micro currency.")
    catalog_product_group_id: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="ID of the catalogs product group that this product group promotion references")
    catalog_product_group_name: Optional[StrictStr] = Field(default=None, description="Catalogs product group name")
    collections_header_type: Optional[StrictStr] = Field(default=None, description="Collections ad header type")
    collections_hero_destination_url: Optional[StrictStr] = Field(default=None, description="Collections Hero Destination Url")
    collections_hero_pin_id: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Hero Pin ID if this PG is promoted as a Collection")
    creative_type: Optional[CreativeType] = None
    customizable_cta_type: Optional[StrictStr] = Field(default=None, description="Select a call to action (CTA) to display below your ad. CTA options for catalog sales campaigns are SHOP_NOW, BOOK_NOW, ON_SALE, GET_DEAL, BUY_ONLINE_PICKUP_IN_STORE")
    definition: Optional[StrictStr] = Field(default=None, description="The full product group definition path")
    grid_click_type: Optional[GridClickType] = None
    id: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="ID of the product group promotion.")
    included: Optional[StrictBool] = Field(default=None, description="True if the group is BIDDABLE, false if it should be EXCLUDED from serving ads.")
    is_generate_background: Optional[StrictBool] = Field(default=None, description="Enable generate backgrounds for the product group, default value is FALSE. When enabled, Pinterest will use generative AI to apply backgrounds for your product images that help drive user inspiration and engagement.")
    is_mdl: Optional[StrictBool] = Field(default=None, description="If set to true products promoted in this product group will use the Mobile Deep Link specified in your catalog")
    parent_id: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="The parent Product Group ID of this Product Group")
    preferred_media_type: Optional[StrictStr] = Field(default=None, description="Select whether to promote the image or video pin by default for items in the promoted product group. If selecting IMAGE, image will be promoted for all ads in the product group, and when selecting VIDEO, video will be promoted when present, otherwise fall back to image. This is applicable for standard shopping ads only.")
    relative_definition: Optional[StrictStr] = Field(default=None, description="The definition of the product group, relative to its parent - an attribute name/value pair")
    selected_image_tag: Optional[StrictStr] = Field(default=None, description="The ad image tag selected for the product group promotion.")
    selected_video_tag: Optional[StrictStr] = Field(default=None, description="The ad video tag selected for the product group promotion.")
    slideshow_collections_description: Optional[StrictStr] = Field(default=None, description="Slideshow Collections Description")
    slideshow_collections_title: Optional[StrictStr] = Field(default=None, description="Slideshow Collections Title")
    status: Optional[EntityStatus] = None
    tracking_url: Optional[StrictStr] = Field(default=None, description="Tracking template for proudct group promotions. 4000 limit")
    __properties: ClassVar[List[str]] = ["ad_group_id", "bid_in_micro_currency", "catalog_product_group_id", "catalog_product_group_name", "collections_header_type", "collections_hero_destination_url", "collections_hero_pin_id", "creative_type", "customizable_cta_type", "definition", "grid_click_type", "id", "included", "is_generate_background", "is_mdl", "parent_id", "preferred_media_type", "relative_definition", "selected_image_tag", "selected_video_tag", "slideshow_collections_description", "slideshow_collections_title", "status", "tracking_url"]

    @field_validator('ad_group_id')
    def ad_group_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(AG)?\d+$", value):
            raise ValueError(r"must validate the regular expression /^(AG)?\d+$/")
        return value

    @field_validator('catalog_product_group_id')
    def catalog_product_group_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    @field_validator('collections_header_type')
    def collections_header_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SHOP_THIS_COLLECTION', 'EXPLORE_THIS_COLLECTION', 'NO_HEADER', 'ON_SALE', 'GET_DEAL']):
            raise ValueError("must be one of enum values ('SHOP_THIS_COLLECTION', 'EXPLORE_THIS_COLLECTION', 'NO_HEADER', 'ON_SALE', 'GET_DEAL')")
        return value

    @field_validator('collections_hero_pin_id')
    def collections_hero_pin_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    @field_validator('customizable_cta_type')
    def customizable_cta_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SHOP_NOW', 'BOOK_NOW', 'ON_SALE', 'GET_DEAL', 'BUY_ONLINE_PICKUP_IN_STORE']):
            raise ValueError("must be one of enum values ('SHOP_NOW', 'BOOK_NOW', 'ON_SALE', 'GET_DEAL', 'BUY_ONLINE_PICKUP_IN_STORE')")
        return value

    @field_validator('id')
    def id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    @field_validator('parent_id')
    def parent_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    @field_validator('preferred_media_type')
    def preferred_media_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['VIDEO', 'IMAGE']):
            raise ValueError("must be one of enum values ('VIDEO', 'IMAGE')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ProductGroupPromotion from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if bid_in_micro_currency (nullable) is None
        # and model_fields_set contains the field
        if self.bid_in_micro_currency is None and "bid_in_micro_currency" in self.model_fields_set:
            _dict['bid_in_micro_currency'] = None

        # set to None if catalog_product_group_id (nullable) is None
        # and model_fields_set contains the field
        if self.catalog_product_group_id is None and "catalog_product_group_id" in self.model_fields_set:
            _dict['catalog_product_group_id'] = None

        # set to None if catalog_product_group_name (nullable) is None
        # and model_fields_set contains the field
        if self.catalog_product_group_name is None and "catalog_product_group_name" in self.model_fields_set:
            _dict['catalog_product_group_name'] = None

        # set to None if collections_header_type (nullable) is None
        # and model_fields_set contains the field
        if self.collections_header_type is None and "collections_header_type" in self.model_fields_set:
            _dict['collections_header_type'] = None

        # set to None if collections_hero_destination_url (nullable) is None
        # and model_fields_set contains the field
        if self.collections_hero_destination_url is None and "collections_hero_destination_url" in self.model_fields_set:
            _dict['collections_hero_destination_url'] = None

        # set to None if collections_hero_pin_id (nullable) is None
        # and model_fields_set contains the field
        if self.collections_hero_pin_id is None and "collections_hero_pin_id" in self.model_fields_set:
            _dict['collections_hero_pin_id'] = None

        # set to None if customizable_cta_type (nullable) is None
        # and model_fields_set contains the field
        if self.customizable_cta_type is None and "customizable_cta_type" in self.model_fields_set:
            _dict['customizable_cta_type'] = None

        # set to None if definition (nullable) is None
        # and model_fields_set contains the field
        if self.definition is None and "definition" in self.model_fields_set:
            _dict['definition'] = None

        # set to None if grid_click_type (nullable) is None
        # and model_fields_set contains the field
        if self.grid_click_type is None and "grid_click_type" in self.model_fields_set:
            _dict['grid_click_type'] = None

        # set to None if included (nullable) is None
        # and model_fields_set contains the field
        if self.included is None and "included" in self.model_fields_set:
            _dict['included'] = None

        # set to None if is_generate_background (nullable) is None
        # and model_fields_set contains the field
        if self.is_generate_background is None and "is_generate_background" in self.model_fields_set:
            _dict['is_generate_background'] = None

        # set to None if is_mdl (nullable) is None
        # and model_fields_set contains the field
        if self.is_mdl is None and "is_mdl" in self.model_fields_set:
            _dict['is_mdl'] = None

        # set to None if parent_id (nullable) is None
        # and model_fields_set contains the field
        if self.parent_id is None and "parent_id" in self.model_fields_set:
            _dict['parent_id'] = None

        # set to None if preferred_media_type (nullable) is None
        # and model_fields_set contains the field
        if self.preferred_media_type is None and "preferred_media_type" in self.model_fields_set:
            _dict['preferred_media_type'] = None

        # set to None if relative_definition (nullable) is None
        # and model_fields_set contains the field
        if self.relative_definition is None and "relative_definition" in self.model_fields_set:
            _dict['relative_definition'] = None

        # set to None if selected_image_tag (nullable) is None
        # and model_fields_set contains the field
        if self.selected_image_tag is None and "selected_image_tag" in self.model_fields_set:
            _dict['selected_image_tag'] = None

        # set to None if selected_video_tag (nullable) is None
        # and model_fields_set contains the field
        if self.selected_video_tag is None and "selected_video_tag" in self.model_fields_set:
            _dict['selected_video_tag'] = None

        # set to None if slideshow_collections_description (nullable) is None
        # and model_fields_set contains the field
        if self.slideshow_collections_description is None and "slideshow_collections_description" in self.model_fields_set:
            _dict['slideshow_collections_description'] = None

        # set to None if slideshow_collections_title (nullable) is None
        # and model_fields_set contains the field
        if self.slideshow_collections_title is None and "slideshow_collections_title" in self.model_fields_set:
            _dict['slideshow_collections_title'] = None

        # set to None if tracking_url (nullable) is None
        # and model_fields_set contains the field
        if self.tracking_url is None and "tracking_url" in self.model_fields_set:
            _dict['tracking_url'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ProductGroupPromotion from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ad_group_id": obj.get("ad_group_id"),
            "bid_in_micro_currency": obj.get("bid_in_micro_currency"),
            "catalog_product_group_id": obj.get("catalog_product_group_id"),
            "catalog_product_group_name": obj.get("catalog_product_group_name"),
            "collections_header_type": obj.get("collections_header_type"),
            "collections_hero_destination_url": obj.get("collections_hero_destination_url"),
            "collections_hero_pin_id": obj.get("collections_hero_pin_id"),
            "creative_type": obj.get("creative_type"),
            "customizable_cta_type": obj.get("customizable_cta_type"),
            "definition": obj.get("definition"),
            "grid_click_type": obj.get("grid_click_type"),
            "id": obj.get("id"),
            "included": obj.get("included"),
            "is_generate_background": obj.get("is_generate_background"),
            "is_mdl": obj.get("is_mdl"),
            "parent_id": obj.get("parent_id"),
            "preferred_media_type": obj.get("preferred_media_type"),
            "relative_definition": obj.get("relative_definition"),
            "selected_image_tag": obj.get("selected_image_tag"),
            "selected_video_tag": obj.get("selected_video_tag"),
            "slideshow_collections_description": obj.get("slideshow_collections_description"),
            "slideshow_collections_title": obj.get("slideshow_collections_title"),
            "status": obj.get("status"),
            "tracking_url": obj.get("tracking_url")
        })
        return _obj


