# coding: utf-8

"""
    Pinterest REST API

    Pinterest's REST API

    The version of the OpenAPI document: 5.23.0
    Contact: blah+oapicf@cliffano.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from pinterestsdk.models.catalogs_item_validation_details import CatalogsItemValidationDetails
from typing import Optional, Set
from typing_extensions import Self

class CatalogsItemValidationErrors(BaseModel):
    """
    CatalogsItemValidationErrors
    """ # noqa: E501
    adult_invalid: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="ADULT_INVALID")
    adwords_format_invalid: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="ADWORDS_FORMAT_INVALID")
    availability_invalid: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="AVAILABILITY_INVALID")
    blocklisted_image_signature: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="BLOCKLISTED_IMAGE_SIGNATURE")
    description_missing: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="DESCRIPTION_MISSING")
    duplicate_products: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="DUPLICATE_PRODUCTS")
    image_link_invalid: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="IMAGE_LINK_INVALID")
    image_link_length_too_long: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="IMAGE_LINK_LENGTH_TOO_LONG")
    image_link_missing: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="IMAGE_LINK_MISSING")
    invalid_domain: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="INVALID_DOMAIN")
    item_main_image_download_failure: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE")
    itemid_missing: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="ITEMID_MISSING")
    link_format_invalid: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="LINK_FORMAT_INVALID")
    link_length_too_long: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="LINK_LENGTH_TOO_LONG")
    list_price_invalid: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="LIST_PRICE_INVALID")
    max_items_per_item_group_exceeded: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED")
    parse_line_error: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="PARSE_LINE_ERROR")
    pinjoin_content_unsafe: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="PINJOIN_CONTENT_UNSAFE")
    price_cannot_be_determined: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="PRICE_CANNOT_BE_DETERMINED")
    price_missing: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="PRICE_MISSING")
    product_link_missing: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="PRODUCT_LINK_MISSING")
    product_price_invalid: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="PRODUCT_PRICE_INVALID")
    title_missing: Optional[CatalogsItemValidationDetails] = Field(default=None, alias="TITLE_MISSING")
    __properties: ClassVar[List[str]] = ["ADULT_INVALID", "ADWORDS_FORMAT_INVALID", "AVAILABILITY_INVALID", "BLOCKLISTED_IMAGE_SIGNATURE", "DESCRIPTION_MISSING", "DUPLICATE_PRODUCTS", "IMAGE_LINK_INVALID", "IMAGE_LINK_LENGTH_TOO_LONG", "IMAGE_LINK_MISSING", "INVALID_DOMAIN", "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE", "ITEMID_MISSING", "LINK_FORMAT_INVALID", "LINK_LENGTH_TOO_LONG", "LIST_PRICE_INVALID", "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED", "PARSE_LINE_ERROR", "PINJOIN_CONTENT_UNSAFE", "PRICE_CANNOT_BE_DETERMINED", "PRICE_MISSING", "PRODUCT_LINK_MISSING", "PRODUCT_PRICE_INVALID", "TITLE_MISSING"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CatalogsItemValidationErrors from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of adult_invalid
        if self.adult_invalid:
            _dict['ADULT_INVALID'] = self.adult_invalid.to_dict()
        # override the default output from pydantic by calling `to_dict()` of adwords_format_invalid
        if self.adwords_format_invalid:
            _dict['ADWORDS_FORMAT_INVALID'] = self.adwords_format_invalid.to_dict()
        # override the default output from pydantic by calling `to_dict()` of availability_invalid
        if self.availability_invalid:
            _dict['AVAILABILITY_INVALID'] = self.availability_invalid.to_dict()
        # override the default output from pydantic by calling `to_dict()` of blocklisted_image_signature
        if self.blocklisted_image_signature:
            _dict['BLOCKLISTED_IMAGE_SIGNATURE'] = self.blocklisted_image_signature.to_dict()
        # override the default output from pydantic by calling `to_dict()` of description_missing
        if self.description_missing:
            _dict['DESCRIPTION_MISSING'] = self.description_missing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of duplicate_products
        if self.duplicate_products:
            _dict['DUPLICATE_PRODUCTS'] = self.duplicate_products.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image_link_invalid
        if self.image_link_invalid:
            _dict['IMAGE_LINK_INVALID'] = self.image_link_invalid.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image_link_length_too_long
        if self.image_link_length_too_long:
            _dict['IMAGE_LINK_LENGTH_TOO_LONG'] = self.image_link_length_too_long.to_dict()
        # override the default output from pydantic by calling `to_dict()` of image_link_missing
        if self.image_link_missing:
            _dict['IMAGE_LINK_MISSING'] = self.image_link_missing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of invalid_domain
        if self.invalid_domain:
            _dict['INVALID_DOMAIN'] = self.invalid_domain.to_dict()
        # override the default output from pydantic by calling `to_dict()` of item_main_image_download_failure
        if self.item_main_image_download_failure:
            _dict['ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE'] = self.item_main_image_download_failure.to_dict()
        # override the default output from pydantic by calling `to_dict()` of itemid_missing
        if self.itemid_missing:
            _dict['ITEMID_MISSING'] = self.itemid_missing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of link_format_invalid
        if self.link_format_invalid:
            _dict['LINK_FORMAT_INVALID'] = self.link_format_invalid.to_dict()
        # override the default output from pydantic by calling `to_dict()` of link_length_too_long
        if self.link_length_too_long:
            _dict['LINK_LENGTH_TOO_LONG'] = self.link_length_too_long.to_dict()
        # override the default output from pydantic by calling `to_dict()` of list_price_invalid
        if self.list_price_invalid:
            _dict['LIST_PRICE_INVALID'] = self.list_price_invalid.to_dict()
        # override the default output from pydantic by calling `to_dict()` of max_items_per_item_group_exceeded
        if self.max_items_per_item_group_exceeded:
            _dict['MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED'] = self.max_items_per_item_group_exceeded.to_dict()
        # override the default output from pydantic by calling `to_dict()` of parse_line_error
        if self.parse_line_error:
            _dict['PARSE_LINE_ERROR'] = self.parse_line_error.to_dict()
        # override the default output from pydantic by calling `to_dict()` of pinjoin_content_unsafe
        if self.pinjoin_content_unsafe:
            _dict['PINJOIN_CONTENT_UNSAFE'] = self.pinjoin_content_unsafe.to_dict()
        # override the default output from pydantic by calling `to_dict()` of price_cannot_be_determined
        if self.price_cannot_be_determined:
            _dict['PRICE_CANNOT_BE_DETERMINED'] = self.price_cannot_be_determined.to_dict()
        # override the default output from pydantic by calling `to_dict()` of price_missing
        if self.price_missing:
            _dict['PRICE_MISSING'] = self.price_missing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of product_link_missing
        if self.product_link_missing:
            _dict['PRODUCT_LINK_MISSING'] = self.product_link_missing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of product_price_invalid
        if self.product_price_invalid:
            _dict['PRODUCT_PRICE_INVALID'] = self.product_price_invalid.to_dict()
        # override the default output from pydantic by calling `to_dict()` of title_missing
        if self.title_missing:
            _dict['TITLE_MISSING'] = self.title_missing.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CatalogsItemValidationErrors from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ADULT_INVALID": CatalogsItemValidationDetails.from_dict(obj["ADULT_INVALID"]) if obj.get("ADULT_INVALID") is not None else None,
            "ADWORDS_FORMAT_INVALID": CatalogsItemValidationDetails.from_dict(obj["ADWORDS_FORMAT_INVALID"]) if obj.get("ADWORDS_FORMAT_INVALID") is not None else None,
            "AVAILABILITY_INVALID": CatalogsItemValidationDetails.from_dict(obj["AVAILABILITY_INVALID"]) if obj.get("AVAILABILITY_INVALID") is not None else None,
            "BLOCKLISTED_IMAGE_SIGNATURE": CatalogsItemValidationDetails.from_dict(obj["BLOCKLISTED_IMAGE_SIGNATURE"]) if obj.get("BLOCKLISTED_IMAGE_SIGNATURE") is not None else None,
            "DESCRIPTION_MISSING": CatalogsItemValidationDetails.from_dict(obj["DESCRIPTION_MISSING"]) if obj.get("DESCRIPTION_MISSING") is not None else None,
            "DUPLICATE_PRODUCTS": CatalogsItemValidationDetails.from_dict(obj["DUPLICATE_PRODUCTS"]) if obj.get("DUPLICATE_PRODUCTS") is not None else None,
            "IMAGE_LINK_INVALID": CatalogsItemValidationDetails.from_dict(obj["IMAGE_LINK_INVALID"]) if obj.get("IMAGE_LINK_INVALID") is not None else None,
            "IMAGE_LINK_LENGTH_TOO_LONG": CatalogsItemValidationDetails.from_dict(obj["IMAGE_LINK_LENGTH_TOO_LONG"]) if obj.get("IMAGE_LINK_LENGTH_TOO_LONG") is not None else None,
            "IMAGE_LINK_MISSING": CatalogsItemValidationDetails.from_dict(obj["IMAGE_LINK_MISSING"]) if obj.get("IMAGE_LINK_MISSING") is not None else None,
            "INVALID_DOMAIN": CatalogsItemValidationDetails.from_dict(obj["INVALID_DOMAIN"]) if obj.get("INVALID_DOMAIN") is not None else None,
            "ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE": CatalogsItemValidationDetails.from_dict(obj["ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE"]) if obj.get("ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE") is not None else None,
            "ITEMID_MISSING": CatalogsItemValidationDetails.from_dict(obj["ITEMID_MISSING"]) if obj.get("ITEMID_MISSING") is not None else None,
            "LINK_FORMAT_INVALID": CatalogsItemValidationDetails.from_dict(obj["LINK_FORMAT_INVALID"]) if obj.get("LINK_FORMAT_INVALID") is not None else None,
            "LINK_LENGTH_TOO_LONG": CatalogsItemValidationDetails.from_dict(obj["LINK_LENGTH_TOO_LONG"]) if obj.get("LINK_LENGTH_TOO_LONG") is not None else None,
            "LIST_PRICE_INVALID": CatalogsItemValidationDetails.from_dict(obj["LIST_PRICE_INVALID"]) if obj.get("LIST_PRICE_INVALID") is not None else None,
            "MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED": CatalogsItemValidationDetails.from_dict(obj["MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED"]) if obj.get("MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED") is not None else None,
            "PARSE_LINE_ERROR": CatalogsItemValidationDetails.from_dict(obj["PARSE_LINE_ERROR"]) if obj.get("PARSE_LINE_ERROR") is not None else None,
            "PINJOIN_CONTENT_UNSAFE": CatalogsItemValidationDetails.from_dict(obj["PINJOIN_CONTENT_UNSAFE"]) if obj.get("PINJOIN_CONTENT_UNSAFE") is not None else None,
            "PRICE_CANNOT_BE_DETERMINED": CatalogsItemValidationDetails.from_dict(obj["PRICE_CANNOT_BE_DETERMINED"]) if obj.get("PRICE_CANNOT_BE_DETERMINED") is not None else None,
            "PRICE_MISSING": CatalogsItemValidationDetails.from_dict(obj["PRICE_MISSING"]) if obj.get("PRICE_MISSING") is not None else None,
            "PRODUCT_LINK_MISSING": CatalogsItemValidationDetails.from_dict(obj["PRODUCT_LINK_MISSING"]) if obj.get("PRODUCT_LINK_MISSING") is not None else None,
            "PRODUCT_PRICE_INVALID": CatalogsItemValidationDetails.from_dict(obj["PRODUCT_PRICE_INVALID"]) if obj.get("PRODUCT_PRICE_INVALID") is not None else None,
            "TITLE_MISSING": CatalogsItemValidationDetails.from_dict(obj["TITLE_MISSING"]) if obj.get("TITLE_MISSING") is not None else None
        })
        return _obj


