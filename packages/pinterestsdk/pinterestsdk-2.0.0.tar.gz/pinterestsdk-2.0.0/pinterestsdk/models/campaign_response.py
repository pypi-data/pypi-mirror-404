# coding: utf-8

"""
    Pinterest REST API

    Pinterest's REST API

    The version of the OpenAPI document: 5.23.0
    Contact: blah+oapicf@cliffano.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pinterestsdk.models.campaign_bid_options import CampaignBidOptions
from pinterestsdk.models.campaign_summary_status import CampaignSummaryStatus
from pinterestsdk.models.entity_status import EntityStatus
from pinterestsdk.models.objective_type import ObjectiveType
from pinterestsdk.models.tracking_urls import TrackingUrls
from typing import Optional, Set
from typing_extensions import Self

class CampaignResponse(BaseModel):
    """
    CampaignResponse
    """ # noqa: E501
    id: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Campaign ID.")
    ad_account_id: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Campaign's Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.")
    daily_spend_cap: Optional[StrictInt] = Field(default=None, description="Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.")
    end_time: Optional[StrictInt] = Field(default=None, description="Timestamp in Unix format for scheduling when ads in the campaign stop appearing. Must occur after any end times for child ad groups. If `end_time` is not specified for the campaign, ads run indefinitely unless you update the campaign, changing their status to `paused`. Learn about <a href=\"/docs/api-features/managing-campaigns/#campaign-scheduling\" target=\"blank\">scheduling campaigns</a>. Different end times can be set for the campaign's child ad groups, but they cannot occur after an `end_time` specified for the campaign. - If your campaign has a child ad group with an end time specified, and if you update that campaign with an `end_time` that is earlier than that of the ad group, the campaign `end_time` will supersede the ad group `end_time`, and the request will not return an error. - In this scenario, if you call <a href=\"/docs/api/v5/campaigns-list\" target=\"blank\">List campaigns</a> or <a href=\"/docs/api/v5/ad_groups-list\" target=\"blank\">List ad groups</a>, the returned campaigns or ad groups are listed with the start and end times that you assigned them, regardless of supersedence.")
    is_automated_campaign: Optional[StrictBool] = Field(default=None, description="Specifies whether the campaign was created in the automated campaign flow")
    is_flexible_daily_budgets: Optional[StrictBool] = Field(default=None, description="Determine if a campaign has setup for flexible daily budgets, also known as \"Pinterest Performance+ budgets\".")
    lifetime_spend_cap: Optional[StrictInt] = Field(default=None, description="Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.")
    name: Optional[StrictStr] = Field(default=None, description="Campaign name.")
    order_line_id: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Order line ID that appears on the invoice.")
    start_time: Optional[StrictInt] = Field(default=None, description="Timestamp in Unix format for scheduling when ads in the campaign start to appear. Must precede any start times set for child ad groups. Defaults to current time if no time is specified. Learn about <a href=\"/docs/api-features/managing-campaigns/#campaign-scheduling\" target=\"blank\">scheduling campaigns</a>. Different start times can be set for the campaign's child ad groups, but they cannot occur before a `start_time` specified for the campaign. - If your campaign has a child ad group with a start time specified, and if you update that campaign with a `start_time` that is later than that of the ad group, the campaign `start_time` will supersede the ad group `start_time`, and the request will not return an error. - In this scenario, if you call <a href=\"/docs/api/v5/campaigns-list\" target=\"blank\">List campaigns</a> or <a href=\"/docs/api/v5/ad_groups-list\" target=\"blank\">List ad groups</a>, the returned campaigns or ad groups are listed with the start and end times that you assigned them, regardless of supersedence.")
    status: Optional[EntityStatus] = None
    tracking_urls: Optional[TrackingUrls] = None
    bid_options: Optional[CampaignBidOptions] = None
    created_time: Optional[StrictInt] = Field(default=None, description="Campaign creation time. Unix timestamp in seconds.")
    is_campaign_budget_optimization: Optional[StrictBool] = Field(default=None, description="Determines if a campaign automatically generate ad-group level budgets given a campaign budget to maximize campaign outcome. When transitioning from non-cbo to cbo, all previous child ad group budget will be cleared.")
    is_performance_plus: Optional[StrictBool] = Field(default=None, description="Enable Pinterest Performance+ for your campaign. To learn more, see <a href=\"https://developers.pinterest.com/docs/api-features/pinterest-performance-plus-setup/\">Pinterest Performance+ Setup</a>.")
    objective_type: Optional[ObjectiveType] = None
    summary_status: Optional[CampaignSummaryStatus] = None
    type: Optional[StrictStr] = Field(default=None, description="Always \"campaign\".")
    updated_time: Optional[StrictInt] = Field(default=None, description="UTC timestamp. Last update time.")
    __properties: ClassVar[List[str]] = ["id", "ad_account_id", "daily_spend_cap", "end_time", "is_automated_campaign", "is_flexible_daily_budgets", "lifetime_spend_cap", "name", "order_line_id", "start_time", "status", "tracking_urls", "bid_options", "created_time", "is_campaign_budget_optimization", "is_performance_plus", "objective_type", "summary_status", "type", "updated_time"]

    @field_validator('id')
    def id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    @field_validator('ad_account_id')
    def ad_account_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    @field_validator('order_line_id')
    def order_line_id_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CampaignResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of tracking_urls
        if self.tracking_urls:
            _dict['tracking_urls'] = self.tracking_urls.to_dict()
        # override the default output from pydantic by calling `to_dict()` of bid_options
        if self.bid_options:
            _dict['bid_options'] = self.bid_options.to_dict()
        # set to None if daily_spend_cap (nullable) is None
        # and model_fields_set contains the field
        if self.daily_spend_cap is None and "daily_spend_cap" in self.model_fields_set:
            _dict['daily_spend_cap'] = None

        # set to None if end_time (nullable) is None
        # and model_fields_set contains the field
        if self.end_time is None and "end_time" in self.model_fields_set:
            _dict['end_time'] = None

        # set to None if is_automated_campaign (nullable) is None
        # and model_fields_set contains the field
        if self.is_automated_campaign is None and "is_automated_campaign" in self.model_fields_set:
            _dict['is_automated_campaign'] = None

        # set to None if is_flexible_daily_budgets (nullable) is None
        # and model_fields_set contains the field
        if self.is_flexible_daily_budgets is None and "is_flexible_daily_budgets" in self.model_fields_set:
            _dict['is_flexible_daily_budgets'] = None

        # set to None if lifetime_spend_cap (nullable) is None
        # and model_fields_set contains the field
        if self.lifetime_spend_cap is None and "lifetime_spend_cap" in self.model_fields_set:
            _dict['lifetime_spend_cap'] = None

        # set to None if order_line_id (nullable) is None
        # and model_fields_set contains the field
        if self.order_line_id is None and "order_line_id" in self.model_fields_set:
            _dict['order_line_id'] = None

        # set to None if start_time (nullable) is None
        # and model_fields_set contains the field
        if self.start_time is None and "start_time" in self.model_fields_set:
            _dict['start_time'] = None

        # set to None if tracking_urls (nullable) is None
        # and model_fields_set contains the field
        if self.tracking_urls is None and "tracking_urls" in self.model_fields_set:
            _dict['tracking_urls'] = None

        # set to None if bid_options (nullable) is None
        # and model_fields_set contains the field
        if self.bid_options is None and "bid_options" in self.model_fields_set:
            _dict['bid_options'] = None

        # set to None if is_campaign_budget_optimization (nullable) is None
        # and model_fields_set contains the field
        if self.is_campaign_budget_optimization is None and "is_campaign_budget_optimization" in self.model_fields_set:
            _dict['is_campaign_budget_optimization'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CampaignResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "ad_account_id": obj.get("ad_account_id"),
            "daily_spend_cap": obj.get("daily_spend_cap"),
            "end_time": obj.get("end_time"),
            "is_automated_campaign": obj.get("is_automated_campaign"),
            "is_flexible_daily_budgets": obj.get("is_flexible_daily_budgets"),
            "lifetime_spend_cap": obj.get("lifetime_spend_cap"),
            "name": obj.get("name"),
            "order_line_id": obj.get("order_line_id"),
            "start_time": obj.get("start_time"),
            "status": obj.get("status"),
            "tracking_urls": TrackingUrls.from_dict(obj["tracking_urls"]) if obj.get("tracking_urls") is not None else None,
            "bid_options": CampaignBidOptions.from_dict(obj["bid_options"]) if obj.get("bid_options") is not None else None,
            "created_time": obj.get("created_time"),
            "is_campaign_budget_optimization": obj.get("is_campaign_budget_optimization"),
            "is_performance_plus": obj.get("is_performance_plus"),
            "objective_type": obj.get("objective_type"),
            "summary_status": obj.get("summary_status"),
            "type": obj.get("type"),
            "updated_time": obj.get("updated_time")
        })
        return _obj


