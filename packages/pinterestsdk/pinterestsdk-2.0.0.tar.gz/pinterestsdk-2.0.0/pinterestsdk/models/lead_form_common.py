# coding: utf-8

"""
    Pinterest REST API

    Pinterest's REST API

    The version of the OpenAPI document: 5.23.0
    Contact: blah+oapicf@cliffano.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pinterestsdk.models.lead_form_common_policy_links_inner import LeadFormCommonPolicyLinksInner
from pinterestsdk.models.lead_form_question import LeadFormQuestion
from pinterestsdk.models.lead_form_status import LeadFormStatus
from typing import Optional, Set
from typing_extensions import Self

class LeadFormCommon(BaseModel):
    """
    Creation fields
    """ # noqa: E501
    completion_message: Optional[StrictStr] = Field(default=None, description="A message for people who complete the form to let them know what happens next.")
    disclosure_language: Optional[StrictStr] = Field(default=None, description="Additional disclosure language to be included in the lead form.")
    has_accepted_terms: Optional[StrictBool] = Field(default=None, description="Whether the advertiser has accepted Pinterest's terms of service for creating a lead ad.  By sending us TRUE for this parameter, you agree that (i) you will use any personal information received in compliance with the privacy policy you share with Pinterest, and (ii) you will comply with Pinterest's <a href=\"https://policy.pinterest.com/en/lead-ad-terms\">Lead Ad Terms</a>. As a reminder, all advertising on Pinterest is subject to the <a href=\"https://business.pinterest.com/en/pinterest-advertising-services-agreement/\">Pinterest Advertising Services Agreement</a> or an equivalent agreement as set forth on an IO")
    name: Optional[StrictStr] = Field(default=None, description="Internal name of the lead form.")
    policy_links: Optional[Annotated[List[LeadFormCommonPolicyLinksInner], Field(min_length=0, max_length=3)]] = Field(default=None, description="List of additional policy links to be displayed on the lead form.")
    privacy_policy_link: Optional[StrictStr] = Field(default=None, description="A link to the advertiser's privacy policy. This will be included in the lead form's disclosure language.")
    questions: Optional[Annotated[List[LeadFormQuestion], Field(min_length=0, max_length=10)]] = Field(default=None, description="List of questions to be displayed on the lead form.")
    status: Optional[LeadFormStatus] = None
    __properties: ClassVar[List[str]] = ["completion_message", "disclosure_language", "has_accepted_terms", "name", "policy_links", "privacy_policy_link", "questions", "status"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of LeadFormCommon from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in policy_links (list)
        _items = []
        if self.policy_links:
            for _item_policy_links in self.policy_links:
                if _item_policy_links:
                    _items.append(_item_policy_links.to_dict())
            _dict['policy_links'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in questions (list)
        _items = []
        if self.questions:
            for _item_questions in self.questions:
                if _item_questions:
                    _items.append(_item_questions.to_dict())
            _dict['questions'] = _items
        # set to None if completion_message (nullable) is None
        # and model_fields_set contains the field
        if self.completion_message is None and "completion_message" in self.model_fields_set:
            _dict['completion_message'] = None

        # set to None if disclosure_language (nullable) is None
        # and model_fields_set contains the field
        if self.disclosure_language is None and "disclosure_language" in self.model_fields_set:
            _dict['disclosure_language'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if privacy_policy_link (nullable) is None
        # and model_fields_set contains the field
        if self.privacy_policy_link is None and "privacy_policy_link" in self.model_fields_set:
            _dict['privacy_policy_link'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of LeadFormCommon from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "completion_message": obj.get("completion_message"),
            "disclosure_language": obj.get("disclosure_language"),
            "has_accepted_terms": obj.get("has_accepted_terms"),
            "name": obj.get("name"),
            "policy_links": [LeadFormCommonPolicyLinksInner.from_dict(_item) for _item in obj["policy_links"]] if obj.get("policy_links") is not None else None,
            "privacy_policy_link": obj.get("privacy_policy_link"),
            "questions": [LeadFormQuestion.from_dict(_item) for _item in obj["questions"]] if obj.get("questions") is not None else None,
            "status": obj.get("status")
        })
        return _obj


