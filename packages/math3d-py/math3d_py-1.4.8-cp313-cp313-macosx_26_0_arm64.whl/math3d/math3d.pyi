from __future__ import annotations
import pybind11_stubgen.typing_ext
import typing
__all__: list[str] = ['AABB', 'Extent', 'Identity2', 'Identity3', 'Identity4', 'LinearSystem2', 'LinearSystem3', 'LinearSystem4', 'Matrix2', 'Matrix3', 'Matrix4', 'Remap', 'Triangle', 'Vector2', 'Vector3', 'Vector4', 'col_major', 'order', 'row_major']
class AABB:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Extent, arg1: Extent, arg2: Extent) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vector3, arg1: Vector3) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def merge(self, arg0: AABB) -> None:
        ...
    def transform(self, arg0: Matrix4) -> AABB:
        ...
    @property
    def corners(self) -> typing.Annotated[list[Vector3], pybind11_stubgen.typing_ext.FixedSize(8)]:
        ...
    @property
    def edges() -> typing.Annotated[list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def max(self) -> Vector3:
        ...
    @property
    def min(self) -> Vector3:
        ...
class Extent:
    max: float
    min: float
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def update(self, arg0: float) -> None:
        ...
    @property
    def center(self) -> float:
        ...
    @property
    def length(self) -> float:
        ...
class Identity2(Matrix2):
    def __init__(self) -> None:
        ...
class Identity3(Matrix3):
    def __init__(self) -> None:
        ...
class Identity4(Matrix4):
    def __init__(self) -> None:
        ...
class LinearSystem2:
    @staticmethod
    def solve(arg0: Matrix2, arg1: Vector2) -> Vector2:
        ...
class LinearSystem3:
    @staticmethod
    def solve(arg0: Matrix3, arg1: Vector3) -> Vector3:
        ...
class LinearSystem4:
    @staticmethod
    def solve(arg0: Matrix4, arg1: Vector4) -> Vector4:
        ...
class Matrix2:
    @typing.overload
    def __getitem__(self, arg0: int) -> Vector2:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple[int, int]) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Iterable, arg1: order) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix2) -> Matrix2:
        ...
    @typing.overload
    def __mul__(self, arg0: Vector2) -> Vector2:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def determinant(self) -> float:
        ...
    def inverse(self) -> Matrix2:
        ...
    def row(self, arg0: int) -> Vector2:
        ...
    def transpose(self) -> Matrix2:
        ...
    def upper_triangular(self) -> Matrix2:
        ...
class Matrix3:
    @typing.overload
    def __getitem__(self, arg0: int) -> Vector3:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple[int, int]) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Iterable, arg1: order) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix3) -> Matrix3:
        ...
    @typing.overload
    def __mul__(self, arg0: Vector3) -> Vector3:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def determinant(self) -> float:
        ...
    def inverse(self) -> Matrix3:
        ...
    def row(self, arg0: int) -> Vector3:
        ...
    def transpose(self) -> Matrix3:
        ...
    def upper_triangular(self) -> Matrix3:
        ...
class Matrix4:
    @typing.overload
    def __getitem__(self, arg0: int) -> Vector4:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple[int, int]) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Iterable, arg1: order) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix4) -> Matrix4:
        ...
    @typing.overload
    def __mul__(self, arg0: Vector4) -> Vector4:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def determinant(self) -> float:
        ...
    def inverse(self) -> Matrix4:
        ...
    def row(self, arg0: int) -> Vector4:
        ...
    def transpose(self) -> Matrix4:
        ...
    def upper_triangular(self) -> Matrix4:
        ...
class Remap:
    def __init__(self, arg0: AABB, arg1: AABB) -> None:
        ...
    def decode(self) -> Matrix4:
        ...
    def remap(self, arg0: Vector3) -> Vector3:
        ...
class Triangle:
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[Vector3], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vector3, arg1: Vector3, arg2: Vector3) -> None:
        ...
    def barycentric(self, arg0: Vector3) -> Vector3:
        ...
    def contains(self, arg0: Vector3) -> bool:
        ...
    def distance(self, point: Vector3, absolute: bool = True) -> float:
        ...
    def projection(self, arg0: Vector3) -> Vector3:
        ...
    @property
    def area(self) -> float:
        ...
    @property
    def normal(self) -> Vector3:
        ...
    @property
    def points(self) -> typing.Annotated[list[Vector3], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def signed_area(self) -> float:
        ...
class Vector2:
    x: float
    y: float
    def __add__(self, arg0: Vector2) -> Vector2:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __mul__(self, arg0: float) -> Vector2:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vector2:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vector2) -> Vector2:
        ...
    def __truediv__(self, arg0: float) -> Vector2:
        ...
    def dot(self, arg0: Vector2) -> float:
        ...
    def length(self) -> float:
        ...
    def length_sqr(self) -> float:
        ...
    def normalize(self) -> Vector2:
        ...
    def projection(self, arg0: Vector2) -> tuple[Vector2, Vector2]:
        ...
class Vector3:
    x: float
    y: float
    z: float
    def __add__(self, arg0: Vector3) -> Vector3:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vector3:
        ...
    @typing.overload
    def __mul__(self, arg0: Vector3) -> Vector3:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vector3:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vector3) -> Vector3:
        ...
    def __truediv__(self, arg0: float) -> Vector3:
        ...
    def dot(self, arg0: Vector3) -> float:
        ...
    def length(self) -> float:
        ...
    def length_sqr(self) -> float:
        ...
    def normalize(self) -> Vector3:
        ...
    def projection(self, arg0: Vector3) -> tuple[Vector3, Vector3]:
        ...
class Vector4:
    w: float
    x: float
    y: float
    z: float
    def __add__(self, arg0: Vector4) -> Vector4:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vector3) -> None:
        ...
    def __mul__(self, arg0: float) -> Vector4:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vector4:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vector4) -> Vector4:
        ...
    def __truediv__(self, arg0: float) -> Vector4:
        ...
    def dot(self, arg0: Vector4) -> float:
        ...
    def length(self) -> float:
        ...
    def length_sqr(self) -> float:
        ...
    def normalize(self) -> Vector4:
        ...
    def projection(self, arg0: Vector4) -> tuple[Vector4, Vector4]:
        ...
class order:
    """
    Members:
    
      row_major
    
      col_major
    """
    __members__: typing.ClassVar[dict[str, order]]  # value = {'row_major': <order.row_major: 1>, 'col_major': <order.col_major: 0>}
    col_major: typing.ClassVar[order]  # value = <order.col_major: 0>
    row_major: typing.ClassVar[order]  # value = <order.row_major: 1>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
col_major: order  # value = <order.col_major: 0>
row_major: order  # value = <order.row_major: 1>
