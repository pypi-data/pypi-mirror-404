#pragma once

#include "Primitive.h"
#include "../TypeAliases.h"
#include "../Vector.h"
#include <tuple>
#include <vector>
#include <filesystem>
#include <fstream>
#include <sstream>

namespace math3d {


    // A convex shape specified using an origin or reference point. Instances of
    // this class are geometrically represented using triangles
    class ConvexPrimitive : public Primitive {

    public:
        explicit ConvexPrimitive(types::Point3D const& origin) // NOLINT
        : origin(origin) {
        }

        types::Tri orientTriangleNormalOutside(types::Tri&& tri) {
            auto correctNormalOrientation = vertices.at(std::get<0>(tri)) - Utilities::asFloat(origin);
            auto AB = vertices.at(std::get<1>(tri)) - vertices.at(std::get<0>(tri));
            auto AC = vertices.at(std::get<2>(tri)) - vertices.at(std::get<0>(tri));
            auto normal = AB * AC;
            if (correctNormalOrientation.dot(normal) < 0) {
                auto tmp = std::get<2>(tri);
                std::get<2>(tri) = std::get<1>(tri);
                std::get<1>(tri) = tmp;
            }
            return tri;
        }

        [[nodiscard]]
        types::Point3D getOrigin() const {
            return origin;
        }

        [[nodiscard]]
        types::Tris const& getTris() {
            return tris;
        }


    private:
        void writeToOBJ(std::filesystem::path const& outputFile) {
            if (vertices.empty()) {
                generateGeometry();
            }
            std::ofstream ofs(outputFile.string());
            std::string buffer;
            buffer.reserve(vertices.size() * sizeof(types::Vector3D) + tris.size() * sizeof(unsigned) * 3);
            std::ostringstream stringStream;
            auto clearStringStream = [&stringStream]() {
                stringStream.str("");
                stringStream.clear();
            };
            for (size_t i = 0; i < vertices.size(); ++i) {
                stringStream << "v " << vertices.at(i).x << ' ' << vertices.at(i).y << ' ' << vertices.at(i).z << std::endl;
                buffer += stringStream.str();
                clearStringStream();
            }
            for (size_t i = 0; i < tris.size(); ++i) {
                stringStream << "f " << get<0>(tris.at(i)) + 1 << ' ' << get<1>(tris.at(i)) + 1 << ' ' << get<2>(tris.at(i)) + 1 << std::endl;
                buffer += stringStream.str();
                clearStringStream();
            }
            ofs.write(buffer.c_str(), buffer.size() * sizeof(char));

            ofs.close();
        }

        void writeToSTL(std::filesystem::path const& outputFile) {
            if (vertices.empty()) {
                generateGeometry();
            }

            std::ofstream ofs(outputFile.string());
            if (!ofs) {
                throw std::runtime_error("Unable to open " + outputFile.string() + " for writing");
            }

            constexpr unsigned char STLHeaderLength {80};
            std::array<char, STLHeaderLength> header{"STL generated by 3dmath"};
            ofs.write(header.data(), STLHeaderLength);
            unsigned numTris = tris.size();
            unsigned short dummy = 0;
            ofs.write(reinterpret_cast<char*>(&numTris), sizeof(numTris));
            for (auto& tri : tris) {
                auto& a = vertices.at(get<0>(tri));
                auto& b = vertices.at(get<1>(tri));
                auto& c = vertices.at(get<2>(tri));
                auto ab = b - a;
                auto ac = c - a;
                auto normal = ab * ac;
                ofs.write(reinterpret_cast<char*>(normal.getData()), sizeof(float) * 3);
                ofs.write(reinterpret_cast<char*>(a.getData()), sizeof(float) * 3);
                ofs.write(reinterpret_cast<char*>(b.getData()), sizeof(float) * 3);
                ofs.write(reinterpret_cast<char*>(c.getData()), sizeof(float) * 3);
                ofs.write(reinterpret_cast<char*>(&dummy), sizeof(unsigned short));
            }
            ofs.close();
        }

    public:
        void writeToFile(std::filesystem::path const& outputFile) override {
            auto extension = outputFile.extension().string().substr(1);
            if (extension == "STL" || extension == "stl") {
                writeToSTL(outputFile);
            } else if (extension == "OBJ" || extension == "obj") {
                writeToOBJ(outputFile);
            }
        }

    protected:
        types::Point3D origin;
        types::Tris tris;
    };

}