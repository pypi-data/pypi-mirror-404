"""Unit tests for TopParser class."""
import warnings

# Suppress NumPy/SciPy compatibility warning (harmless with NumPy 2.x + SciPy 1.16+)
warnings.filterwarnings('ignore', message='numpy.ndarray size changed', category=RuntimeWarning)

from pathlib import Path

import numpy as np
import pytest

from kbkit.io.top import TopParser


@pytest.fixture
def sample_top_file(tmp_path):
    """Create a sample topology file."""
    top_content = """; Topology file
; Generated by some tool

[ defaults ]
; nbfunc    comb-rule   gen-pairs   fudgeLJ fudgeQQ
1           2           yes         0.5     0.8333

[ atomtypes ]
; name  at.num   mass     charge  ptype  sigma      epsilon
C       6        12.01    0.000   A      0.3400     0.3598
H       1        1.008    0.000   A      0.2600     0.0628

[ moleculetype ]
; Name            nrexcl
Water             3

[ atoms ]
; nr  type  resnr  residue  atom  cgnr  charge    mass
1     OW    1      WAT      O     1     -0.834    16.00
2     HW    1      WAT      H1    1      0.417     1.008
3     HW    1      WAT      H2    1      0.417     1.008

[ molecules ]
; Compound        #mols
Water             1000
Ethanol           500
Methanol          250
"""
    top_file = tmp_path / "test.top"
    top_file.write_text(top_content)
    return str(top_file)


@pytest.fixture
def top_file_with_comments(tmp_path):
    """Create a topology file with inline comments."""
    top_content = """[ molecules ]
; Compound        #mols
Water             1000  ; This is water
Ethanol           500   ; Ethanol molecules
; This is a comment line
Methanol          250
"""
    top_file = tmp_path / "comments.top"
    top_file.write_text(top_content)
    return str(top_file)


@pytest.fixture
def top_file_with_errors(tmp_path):
    """Create a topology file with various errors."""
    top_content = """[ molecules ]
; Compound        #mols
Water             1000
Invalid           ; Missing count
TooManyParts      100   extra   data
123Invalid        50    ; Invalid name starting with number
Valid_Name-123    200
BadCount          abc   ; Non-numeric count
"""
    top_file = tmp_path / "errors.top"
    top_file.write_text(top_content)
    return str(top_file)


@pytest.fixture
def empty_molecules_section(tmp_path):
    """Create a topology file with empty molecules section."""
    top_content = """[ defaults ]
1  2  yes  0.5  0.8333

[ molecules ]
; Compound        #mols
"""
    top_file = tmp_path / "empty.top"
    top_file.write_text(top_content)
    return str(top_file)


@pytest.fixture
def no_molecules_section(tmp_path):
    """Create a topology file without molecules section."""
    top_content = """[ defaults ]
1  2  yes  0.5  0.8333

[ atomtypes ]
C  6  12.01  0.0  A  0.34  0.36
"""
    top_file = tmp_path / "no_molecules.top"
    top_file.write_text(top_content)
    return str(top_file)


class TestTopParserInitialization:
    """Test TopParser initialization."""

    def test_valid_top_file(self, sample_top_file):
        """Test initialization with valid .top file."""
        parser = TopParser(sample_top_file)

        assert parser.filepath == Path(sample_top_file)
        assert isinstance(parser.skipped_lines, list)
        assert len(parser.skipped_lines) == 0

    def test_invalid_file_extension(self, tmp_path):
        """Test that non-.top files raise an error."""
        txt_file = tmp_path / "test.txt"
        txt_file.touch()

        with pytest.raises(ValueError, match=".*\\.top"):
            TopParser(str(txt_file))

    def test_nonexistent_file(self):
        """Test that nonexistent files raise an error."""
        with pytest.raises((FileNotFoundError, ValueError)):
            TopParser("/nonexistent/path/file.top")

    def test_path_conversion(self, sample_top_file):
        """Test that path is properly converted to Path object."""
        parser = TopParser(sample_top_file)
        assert isinstance(parser.filepath, Path)


class TestValidationMethods:
    """Test validation helper methods."""

    def test_is_valid_molecule_name_valid(self, sample_top_file):
        """Test valid molecule names."""
        parser = TopParser(sample_top_file)

        assert parser._is_valid_molecule_name("Water") is True
        assert parser._is_valid_molecule_name("H2O") is True
        assert parser._is_valid_molecule_name("Ethanol_123") is True
        assert parser._is_valid_molecule_name("Valid-Name") is True
        assert parser._is_valid_molecule_name("ABC_123-xyz") is True

    def test_is_valid_molecule_name_invalid(self, sample_top_file):
        """Test invalid molecule names."""
        parser = TopParser(sample_top_file)

        # Too short (less than 2 characters)
        assert parser._is_valid_molecule_name("A") is False

        # Contains invalid characters
        assert parser._is_valid_molecule_name("Water@123") is False
        assert parser._is_valid_molecule_name("H2O!") is False
        assert parser._is_valid_molecule_name("Name with spaces") is False

        # Empty string
        assert parser._is_valid_molecule_name("") is False

        # Too long (more than 50 characters)
        assert parser._is_valid_molecule_name("A" * 51) is False

    def test_is_valid_count_valid(self, sample_top_file):
        """Test valid count strings."""
        parser = TopParser(sample_top_file)

        assert parser._is_valid_count("0") is True
        assert parser._is_valid_count("1") is True
        assert parser._is_valid_count("100") is True
        assert parser._is_valid_count("999999") is True

    def test_is_valid_count_invalid(self, sample_top_file):
        """Test invalid count strings."""
        parser = TopParser(sample_top_file)

        assert parser._is_valid_count("abc") is False
        assert parser._is_valid_count("12.5") is False
        assert parser._is_valid_count("-10") is False
        assert parser._is_valid_count("1e3") is False
        assert parser._is_valid_count("") is False
        assert parser._is_valid_count("10 20") is False


class TestParseMethod:
    """Test parse method."""

    def test_parse_basic_file(self, sample_top_file):
        """Test parsing a basic topology file."""
        parser = TopParser(sample_top_file)
        parser.parse()

        assert hasattr(parser, '_molecule_count')
        assert isinstance(parser._molecule_count, dict)
        assert len(parser._molecule_count) == 3

    def test_parse_extracts_correct_molecules(self, sample_top_file):
        """Test that parse extracts correct molecule names."""
        parser = TopParser(sample_top_file)
        parser.parse()

        assert "Water" in parser._molecule_count
        assert "Ethanol" in parser._molecule_count
        assert "Methanol" in parser._molecule_count

    def test_parse_extracts_correct_counts(self, sample_top_file):
        """Test that parse extracts correct molecule counts."""
        parser = TopParser(sample_top_file)
        parser.parse()

        assert parser._molecule_count["Water"] == 1000
        assert parser._molecule_count["Ethanol"] == 500
        assert parser._molecule_count["Methanol"] == 250

    def test_parse_handles_comments(self, top_file_with_comments):
        """Test that parse correctly handles inline comments."""
        parser = TopParser(top_file_with_comments)
        parser.parse()

        assert len(parser._molecule_count) == 3
        assert parser._molecule_count["Water"] == 1000
        assert parser._molecule_count["Ethanol"] == 500
        assert parser._molecule_count["Methanol"] == 250

    def test_parse_skips_invalid_lines(self, top_file_with_errors):
        """Test that parse skips invalid lines and records them."""
        parser = TopParser(top_file_with_errors)
        parser.parse()

        # Should have skipped some lines
        assert len(parser.skipped_lines) > 0

        # Should still parse valid lines
        assert "Water" in parser._molecule_count
        assert "Valid_Name-123" in parser._molecule_count

    def test_parse_empty_molecules_section(self, empty_molecules_section):
        """Test parsing file with empty molecules section."""
        parser = TopParser(empty_molecules_section)

        with pytest.raises(ValueError, match="No molecules found"):
            parser.parse()

    def test_parse_no_molecules_section(self, no_molecules_section):
        """Test parsing file without molecules section."""
        parser = TopParser(no_molecules_section)

        with pytest.raises(ValueError, match="No molecules found"):
            parser.parse()

    def test_parse_stops_at_next_section(self, tmp_path):
        """Test that parse stops at the next section header."""
        top_content = """[ molecules ]
Water             1000
Ethanol           500

[ system ]
; System name
Test System

[ molecules ]
; This should not be parsed
Methanol          250
"""
        top_file = tmp_path / "multiple_sections.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        # Should only parse first molecules section
        assert len(parser._molecule_count) == 2
        assert "Methanol" not in parser._molecule_count

    def test_parse_case_insensitive_section_header(self, tmp_path):
        """Test that section header matching is case-insensitive."""
        top_content = """[ MOLECULES ]
Water             1000
"""
        top_file = tmp_path / "uppercase.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert "Water" in parser._molecule_count

    def test_parse_handles_tabs_and_spaces(self, tmp_path):
        """Test that parse handles mixed tabs and spaces."""
        top_content = """[ molecules ]
Water\t\t1000
Ethanol   \t  500
Methanol\t250
"""
        top_file = tmp_path / "mixed_whitespace.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert len(parser._molecule_count) == 3
        assert parser._molecule_count["Water"] == 1000


class TestReportSkipped:
    """Test report_skipped method."""

    def test_report_skipped_no_errors(self, sample_top_file, capsys):
        """Test report_skipped with no skipped lines."""
        parser = TopParser(sample_top_file)
        parser.parse()
        parser.report_skipped()

        captured = capsys.readouterr()
        # Should not print anything if no lines were skipped
        assert captured.out == ""

    def test_report_skipped_with_errors(self, top_file_with_errors, capsys):
        """Test report_skipped with skipped lines."""
        parser = TopParser(top_file_with_errors)
        parser.parse()
        parser.report_skipped()

        captured = capsys.readouterr()
        assert "Skipped lines during parsing:" in captured.out
        assert "Reason:" in captured.out

    def test_report_skipped_shows_line_content(self, top_file_with_errors, capsys):
        """Test that report_skipped shows actual line content."""
        parser = TopParser(top_file_with_errors)
        parser.parse()
        parser.report_skipped()

        captured = capsys.readouterr()
        # Should show some of the invalid lines
        assert "Invalid" in captured.out or "BadCount" in captured.out

    def test_report_skipped_shows_reasons(self, top_file_with_errors, capsys):
        """Test that report_skipped shows skip reasons."""
        parser = TopParser(top_file_with_errors)
        parser.parse()
        parser.report_skipped()

        captured = capsys.readouterr()
        # Should show reasons for skipping
        assert any(reason in captured.out for reason in [
            "Missing molecule name or count",
            "Invalid molecule name format",
            "Invalid molecule count"
        ])


class TestMoleculeCountProperty:
    """Test molecule_count property."""

    def test_molecule_count_cached(self, sample_top_file):
        """Test that molecule_count is cached."""
        parser = TopParser(sample_top_file)

        # Access twice
        count1 = parser.molecule_count
        count2 = parser.molecule_count

        # Should be the same object (cached)
        assert count1 is count2

    def test_molecule_count_auto_parses(self, sample_top_file):
        """Test that accessing molecule_count triggers parse."""
        parser = TopParser(sample_top_file)

        # Should not have _molecule_count yet
        assert "_molecule_count" not in parser.__dict__

        # Access property
        count = parser.molecule_count

        # Should now have _molecule_count
        assert "_molecule_count" in parser.__dict__
        assert count == parser._molecule_count

    def test_molecule_count_returns_dict(self, sample_top_file):
        """Test that molecule_count returns a dictionary."""
        parser = TopParser(sample_top_file)
        count = parser.molecule_count

        assert isinstance(count, dict)

    def test_molecule_count_values_are_ints(self, sample_top_file):
        """Test that all counts are integers."""
        parser = TopParser(sample_top_file)
        count = parser.molecule_count

        for value in count.values():
            assert isinstance(value, int)


class TestMoleculesProperty:
    """Test molecules property."""

    def test_molecules_returns_list(self, sample_top_file):
        """Test that molecules returns a list."""
        parser = TopParser(sample_top_file)
        molecules = parser.molecules

        assert isinstance(molecules, list)

    def test_molecules_contains_correct_names(self, sample_top_file):
        """Test that molecules contains correct molecule names."""
        parser = TopParser(sample_top_file)
        molecules = parser.molecules

        assert "Water" in molecules
        assert "Ethanol" in molecules
        assert "Methanol" in molecules

    def test_molecules_length(self, sample_top_file):
        """Test that molecules has correct length."""
        parser = TopParser(sample_top_file)
        molecules = parser.molecules

        assert len(molecules) == 3

    def test_molecules_unique(self, sample_top_file):
        """Test that molecules list contains unique entries."""
        parser = TopParser(sample_top_file)
        molecules = parser.molecules

        assert len(molecules) == len(set(molecules))


class TestTotalMoleculesProperty:
    """Test total_molecules property."""

    def test_total_molecules_correct_sum(self, sample_top_file):
        """Test that total_molecules returns correct sum."""
        parser = TopParser(sample_top_file)
        total = parser.total_molecules

        # 1000 + 500 + 250 = 1750
        assert total == 1750

    def test_total_molecules_is_int(self, sample_top_file):
        """Test that total_molecules returns an integer."""
        parser = TopParser(sample_top_file)
        total = parser.total_molecules

        assert isinstance(total, int)

    def test_total_molecules_single_molecule(self, tmp_path):
        """Test total_molecules with single molecule type."""
        top_content = """[ molecules ]
Water             100
"""
        top_file = tmp_path / "single.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        total = parser.total_molecules

        assert total == 100


class TestElectronCountProperty:
    """Test electron_count property."""

    def test_electron_count_returns_empty_dict(self, sample_top_file):
        """Test that electron_count returns empty dictionary."""
        parser = TopParser(sample_top_file)
        electron_count = parser.electron_count

        assert isinstance(electron_count, dict)
        assert len(electron_count) == 0


class TestBoxVolumeProperty:
    """Test box_volume property."""

    def test_box_volume_returns_nan(self, sample_top_file):
        """Test that box_volume returns NaN."""
        parser = TopParser(sample_top_file)
        volume = parser.box_volume

        assert isinstance(volume, float)
        assert np.isnan(volume)


class TestEdgeCases:
    """Test edge cases and special scenarios."""

    def test_molecule_name_with_numbers(self, tmp_path):
        """Test molecule names containing numbers."""
        top_content = """[ molecules ]
H2O               1000
CO2               500
CH3OH             250
"""
        top_file = tmp_path / "numbers.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert "H2O" in parser._molecule_count
        assert "CO2" in parser._molecule_count
        assert "CH3OH" in parser._molecule_count

    def test_molecule_name_with_underscores(self, tmp_path):
        """Test molecule names with underscores."""
        top_content = """[ molecules ]
Water_TIP3P       1000
Ethanol_OPLS      500
"""
        top_file = tmp_path / "underscores.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert "Water_TIP3P" in parser._molecule_count
        assert "Ethanol_OPLS" in parser._molecule_count

    def test_molecule_name_with_hyphens(self, tmp_path):
        """Test molecule names with hyphens."""
        top_content = """[ molecules ]
Water-Model       1000
Ethanol-AA        500
"""
        top_file = tmp_path / "hyphens.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert "Water-Model" in parser._molecule_count
        assert "Ethanol-AA" in parser._molecule_count

    def test_zero_molecule_count(self, tmp_path):
        """Test handling of zero molecule count."""
        top_content = """[ molecules ]
Water             0
Ethanol           100
"""
        top_file = tmp_path / "zero.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert parser._molecule_count["Water"] == 0
        assert parser._molecule_count["Ethanol"] == 100

    def test_large_molecule_count(self, tmp_path):
        """Test handling of large molecule counts."""
        top_content = """[ molecules ]
Water             999999999
"""
        top_file = tmp_path / "large.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert parser._molecule_count["Water"] == 999999999

    def test_empty_lines_in_molecules_section(self, tmp_path):
        """Test handling of empty lines in molecules section."""
        top_content = """[ molecules ]

Water             1000

Ethanol           500

"""
        top_file = tmp_path / "empty_lines.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert len(parser._molecule_count) == 2

    def test_comment_only_lines(self, tmp_path):
        """Test handling of comment-only lines."""
        top_content = """[ molecules ]
; This is a comment
Water             1000
; Another comment
; And another
Ethanol           500
"""
        top_file = tmp_path / "comments_only.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert len(parser._molecule_count) == 2

    def test_extra_whitespace(self, tmp_path):
        """Test handling of extra whitespace."""
        top_content = """[ molecules ]
Water                     1000
Ethanol     500
Methanol\t\t\t250
"""
        top_file = tmp_path / "whitespace.top"
        top_file.write_text(top_content)

        parser = TopParser(str(top_file))
        parser.parse()

        assert len(parser._molecule_count) == 3


class TestIntegration:
    """Integration tests for TopParser."""

    def test_complete_workflow(self, sample_top_file):
        """Test complete workflow from initialization to property access."""
        parser = TopParser(sample_top_file)

        # Access all properties
        molecules = parser.molecules
        count = parser.molecule_count
        total = parser.total_molecules
        electrons = parser.electron_count
        volume = parser.box_volume

        # Verify consistency
        assert len(molecules) == len(count)
        assert total == sum(count.values())
        assert isinstance(electrons, dict)
        assert np.isnan(volume)

    def test_parse_then_access_properties(self, sample_top_file):
        """Test explicit parse followed by property access."""
        parser = TopParser(sample_top_file)

        # Explicit parse
        parser.parse()

        # Access properties
        assert len(parser.molecules) == 3
        assert parser.total_molecules == 1750

    def test_multiple_property_accesses(self, sample_top_file):
        """Test multiple accesses to properties."""
        parser = TopParser(sample_top_file)

        # Access properties multiple times
        for _ in range(3):
            _ = parser.molecules
            _ = parser.molecule_count
            _ = parser.total_molecules

        # Should not raise errors or re-parse

    def test_error_handling_workflow(self, top_file_with_errors, capsys):
        """Test complete workflow with error handling."""
        parser = TopParser(top_file_with_errors)

        # Parse (will skip some lines)
        parser.parse()

        # Check that valid molecules were parsed
        assert len(parser.molecules) > 0

        # Report skipped lines
        parser.report_skipped()

        captured = capsys.readouterr()
        assert "Skipped lines" in captured.out

    def test_property_consistency(self, sample_top_file):
        """Test that all properties are consistent with each other."""
        parser = TopParser(sample_top_file)

        # Get all properties
        molecules = parser.molecules
        count = parser.molecule_count
        total = parser.total_molecules

        # Verify consistency
        assert set(molecules) == set(count.keys())
        assert total == sum(count.values())

        # Each molecule in list should be in count dict
        for mol in molecules:
            assert mol in count
            assert count[mol] > 0
