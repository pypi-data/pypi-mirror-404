"""Handles parsing and validation of RDF (.xvg) files generated by GROMACS."""

import os
import re
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import linregress

from kbkit.config.mplstyle import load_mplstyle
from kbkit.utils.validation import validate_path

load_mplstyle()  # load mpl figure configuration


class RdfParser:
    """
    Class to handle RDF (Radial Distribution Function) data.

    Reads RDF data from a file, checks for convergence, and provides methods to plot the RDF and extract molecular information.

    Parameters
    ----------
    filepath : str
        Path to the RDF text file.
    convergence_thresholds: tuple, optional
        Thresholds for convergence requirements.
    tail_length: float, optional
        Optional tail length to enforce if ``use_fixed_tail`` is `True`.

    Attributes
    ----------
    fname: str
        File name.
    r: np.ndarray
        Array of radial distances (nm).
    g: np.ndarray
        Array of radial distribution function values.
    mask: np.ndarray
        Boolean mask for RDF tail.
    """

    def __init__(
        self,
        path: str | Path,
        convergence_thresholds: tuple = (1e-3, 1e-2),
        tail_length: float | None = None,
    ) -> None:
        # first validate file
        fpath = Path(path)
        self.filepath = validate_path(fpath, suffix=fpath.suffix)
        self.fname = self.filepath.name

        # read file
        self.r, self.g = self._read()

        # get convergence
        if not tail_length:
            max_length = 2  # nm
            tail_lengths = np.arange(0.5, max_length, 0.1)[::-1]
            self.mask, self._tail_slope, self._total_change, self._grade = self.find_converged_tail(
                list(tail_lengths), thresholds=convergence_thresholds
            )
        else:
            self.mask, self._tail_slope, self._total_change, self._grade = self.find_converged_tail(
                [tail_length], thresholds=convergence_thresholds
            )

    def _read(self) -> tuple[np.ndarray, np.ndarray]:
        """Read RDF file and extracts radial distances (r) and g(r) values.

        The file is expected to have two columns: r and g(r).
        It filters out noise from the tail of the RDF curve.
        """
        try:
            r, g = np.loadtxt(self.filepath, comments=["@", "#"], unpack=True)
            return r[:-3], g[:-3]
        except FileNotFoundError as e:
            raise FileNotFoundError(f"RDF file '{self.filepath}' not found.") from e
        except IOError as ioe:
            raise IOError(f"Error reading file '{self.filepath}': {ioe}.") from ioe
        except ValueError as ve:
            raise ValueError(f"Failed to parse RDF data from '{self.filepath}': {ve}.") from ve
        except Exception as e:
            raise RuntimeError(f"Unexpected error reading '{self.filepath}': {e}") from e

    @property
    def r_tail(self) -> np.ndarray:
        """np.ndarray: filtered r values of RDF tail."""
        return self.r[self.mask]

    @property
    def g_tail(self) -> np.ndarray:
        """np.ndarray: filtered g(r) values of RDF tail."""
        return self.g[self.mask]

    def find_converged_tail(self, tail_lengths: list[float], thresholds: tuple = (1e-3, 1e-2)) -> tuple:
        """Iteratively searches for the largest tail window that meets convergence criteria.

        Parameters
        ----------
        tail_length: float, optional
            Optionally takes in a tail length to evaluate convergence at.
        """
        for tail_length in tail_lengths:
            mask, slope, total_change, grade = self._get_tail_drift(tail_length, thresholds)
            if grade == "PASS":
                return mask, slope, total_change, grade
            elif grade == "MARGINAL" and tail_length == tail_lengths[-1]:
                return mask, slope, total_change, grade
        return mask, slope, total_change, "FAIL"

    def _get_tail_drift(self, tail_length: float, thresholds: tuple = (1e-3, 1e-2)) -> tuple:
        """
        Get the tail mask, tail slope, and total drift of the tail for a given RDF ``tail_length``, and check if convergence threshold is passed.

        Parameters
        ----------
        tail_length: float
            Length of RDF tail to evaluate.

        Returns
        -------
        tuple
            Result for convergence evaluation.

        .. note::
            Convergence criteria is set to a slope < 1e-3 of the tail section with < 1e-2 acceptable for last step (grade: `PASS`). If convergence threshold is not passed, a grade of `FAIL` is assigned while still recording the values at the last step.
        """
        # get mask
        mask = self.r > (self.r.max() - tail_length)

        # perform linear regression on tail to get slope
        slope, _intercept, _r_value, _p_value, _std_err = linregress(self.r[mask], self.g[mask])

        # Calculate the total "rise" or "fall" over the tail
        total_change = slope * tail_length

        min_thresh, max_thresh = min(thresholds), max(thresholds)
        if abs(total_change) < min_thresh:
            return mask, slope, total_change, "PASS"
        elif abs(total_change) < max_thresh:
            return mask, slope, total_change, "MARGINAL"
        else:
            return mask, slope, total_change, "FAIL"

    @property
    def is_converged(self) -> bool:
        """bool: Checks if RDF tail convergenced passes check."""
        return True if self._grade in ("PASS", "MARGINAL") else False

    @property
    def convergence_report(self) -> str:
        """str: Convergence report of the RDF tail."""
        line1 = f"--- RDF Plateau Analysis: {self.fname} ---"
        line2 = f"Tail Range: {self.r_tail.min():.2f} to {self.r_tail.max():.2f} nm"
        line3 = f"Slope:      {self._tail_slope:.4f} g(r)/nm"
        line4 = f"Avg Drift:  {self._total_change:.4f} over the tail"
        line5 = f"Result:     {self._grade}"
        return f"""{line1}\n{line2}\n{line3}\n{line4}\n{line5}"""

    def plot(
        self,
        xlim: tuple[float, float] = (4, 5),
        ylim: tuple[float, float] = (0.99, 1.01),
        line: bool = False,
        save_dir: str | None = None,
    ) -> None:
        """
        Plot RDF with an inset showing a zoomed-in view of the specified region.

        Parameters
        ----------
        xlim : list of float, optional
            x-axis limits for the inset plot. Default is [4, 5].
        ylim : list of float, optional
            y-axis limits for the inset plot. Default is [0.99, 1.01].
        line : bool, optional
            If True, adds a horizontal line at y=1. Default is False.
        save_dir : str, optional
            Directory to save the plot. If None, the plot is displayed but not saved. Default is None.
        """
        # set up main fig/axes
        fig, main_ax = plt.subplots(figsize=(6, 6))
        main_ax.set_box_aspect(0.8)
        inset_ax = main_ax.inset_axes(
            (0.65, 0.12, 0.3, 0.3),  # x, y, width, height
            xlim=xlim,
            ylim=ylim,  # sets viewport &amp; tells relation to main axes
            # xticklabels=[], yticklabels=[]
        )
        inset_ax.tick_params(axis="x", labelsize=11)
        inset_ax.tick_params(axis="y", labelsize=11)

        # add plot content
        for ax in main_ax, inset_ax:
            ax.plot(self.r, self.g)  # first example line
        if line:
            inset_ax.axhline(1.0, c="k", ls="--", lw=1.5)

        # add zoom leaders
        main_ax.indicate_inset_zoom(inset_ax, edgecolor="black")
        main_ax.set_xlabel(r"$r$ [$nm$]")
        main_ax.set_ylabel(r"$g(r)$")
        if save_dir is not None:
            rdf_name = str(self.fname).strip(".xvg")
            fig.savefig(os.path.join(save_dir, rdf_name + ".pdf"))

    @staticmethod
    def extract_molecules(text: str, mol_list: list[str]) -> list[str]:
        """
        Extract molecule names used in RDF from the RDF file name.

        Parameters
        ----------
        rdf_file : str
            Path to the RDF file.
        mol_list : list of str
            List of molecule names to search for in the file name.

        Returns
        -------
        list[str]
            List of molecule names found in the RDF file name.
        """
        if not isinstance(text, str):
            try:
                text = str(text)
            except TypeError as e:
                raise TypeError("Could not convert filename to type str.") from e

        if not mol_list:
            raise ValueError("Unable to match molecules to an empty list.")

        # define pattern for mol in mol_list
        pattern = r"(" + "|".join(re.escape(mol) for mol in mol_list) + r")"

        # find matches of pattern in filename
        matches = re.findall(pattern, text)
        return matches
