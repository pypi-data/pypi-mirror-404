"""Configuring nbdev and bootstrapping notebook export"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/01_config.ipynb.

# %% auto #0
__all__ = ['pyproject_nm', 'pyproject_tmpl', 'nbdev_defaults', 'pyproj_tmpl', 'nbdev_create_config', 'ConfigToml', 'get_config',
           'is_nbdev', 'create_output', 'show_src', 'read_version', 'set_version', 'bump_version', 'update_version',
           'update_proj', 'add_init', 'import_obj', 'write_cells']

# %% ../nbs/api/01_config.ipynb #6fd14ecd
from datetime import datetime
from fastcore.docments import *
from fastcore.utils import *
from fastcore.meta import *
from fastcore.script import *
from fastcore.style import *
from fastcore.xdg import *

import ast,importlib,warnings
from IPython.display import Markdown
from execnb.nbio import read_nb,NbCell
from urllib.error import HTTPError

try: import tomllib
except ImportError: import tomli as tomllib

# %% ../nbs/api/01_config.ipynb #117128e6
pyproject_nm = 'pyproject.toml'
_nbdev_home_dir = 'nbdev'
_user_cfg_name = 'config.toml'

# %% ../nbs/api/01_config.ipynb #adf0834f
def _git_repo():
    try: return repo_details(run('git config --get remote.origin.url'))[1]
    except OSError: return

# %% ../nbs/api/01_config.ipynb #6eeafafd
def _get_info(owner, repo, default_branch='main', default_kw='nbdev'):
    from ghapi.all import GhApi
    api = GhApi(owner=owner, repo=repo, token=os.getenv('GITHUB_TOKEN'))
    
    try: r = api.repos.get()
    except HTTPError:
        msg= [f"""Could not access repo: {owner}/{repo} to find your default branch - `{default_branch}` assumed.
Edit `pyproject.toml` if this is incorrect.
In the future, you can allow nbdev to see private repos by setting the environment variable GITHUB_TOKEN as described here:
https://nbdev.fast.ai/api/release.html#setup"""]
        print(''.join(msg))
        return default_branch,default_kw,''
    
    return r.default_branch, default_kw if not getattr(r, 'topics', []) else ' '.join(r.topics), r.description

# %% ../nbs/api/01_config.ipynb #35d5c037
def _fetch_from_git(raise_err=False):
    "Get information for pyproject.toml from git."
    res={}
    try:
        url = run('git config --get remote.origin.url')
        res['user'],res['repo'] = repo_details(url)
        res['branch'],res['keywords'],desc = _get_info(owner=res['user'], repo=res['repo'])
        if desc: res['description'] = desc
        res['author'] = run('git config --get user.name').strip()
        res['author_email'] = run('git config --get user.email').strip()
    except OSError as e:
        if raise_err: raise(e)
    else: res['lib_name'] = res['repo'].replace('-','_')
    return res

# %% ../nbs/api/01_config.ipynb #05aae09f
pyproject_tmpl = '''[build-system]
requires = ["setuptools>=64"]
build-backend = "setuptools.build_meta"

[project]
name = "{name}"
dynamic = ["version"]
description = "{description}"
readme = "README.md"
requires-python = ">={min_python}"
license = {{text = "{license}"}}
authors = [{{name = "{author}", email = "{author_email}"}}]
keywords = {keywords}
classifiers = [
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3 :: Only",
]
dependencies = []

[project.urls]
Repository = "{git_url}"
Documentation = "{doc_url}"

[project.entry-points.nbdev]
{lib_path} = "{lib_path}._modidx:d"

[tool.setuptools.dynamic]
version = {{attr = "{lib_path}.__version__"}}

[tool.setuptools.packages.find]
include = ["{lib_path}"]

[tool.nbdev]
'''

# %% ../nbs/api/01_config.ipynb #3fc5c33f
@call_parse
def nbdev_create_config(
    repo:str=None, # Repo name
    branch:str='main', # Repo default branch
    user:str=None, # Repo username
    author:str=None, # Package author's name
    author_email:str=None, # Package author's email address
    description:str='', # Short summary of the package
    path:str='.', # Path to create config file
    min_python:str='3.10', # Minimum Python version
    license:str='Apache-2.0', # License (SPDX identifier)
):
    "Create a pyproject.toml config file."
    path = Path(path)
    path.mkdir(exist_ok=True, parents=True)
    
    # Infer from git if not provided
    inf = _fetch_from_git()
    repo = repo or inf.get('repo') or path.resolve().name
    user = user or inf.get('user', '')
    if not user: raise ValueError("Could not infer `user` from git. Please pass --user explicitly.")
    author = author or inf.get('author', '')
    if not author: raise ValueError("Could not infer `author` from git. Please pass --author explicitly.")
    author_email = author_email or inf.get('author_email', '')
    if not author_email: raise ValueError("Could not infer `author_email` from git. Please pass --author_email explicitly.")
    branch = branch or inf.get('branch', 'main')
    description = description or inf.get('description', '')
    
    lib_path = repo.replace('-', '_')
    git_url = f"https://github.com/{user}/{repo}" if user else ''
    doc_url = f"https://{user}.github.io/{repo}/" if user else ''
    keywords = inf.get('keywords', 'nbdev').split()
    
    txt = pyproject_tmpl.format(name=repo, lib_path=lib_path, description=description, min_python=min_python, license=license,
        author=author, author_email=author_email, keywords=keywords, git_url=git_url, doc_url=doc_url, branch=branch)
    
    cfg_file = path / pyproject_nm
    if cfg_file.exists(): warn(f'{cfg_file} already exists')
    else:
        cfg_file.write_text(txt)
        print(f'{cfg_file} created.')

# %% ../nbs/api/01_config.ipynb #0e56064f
def _load_toml(p):
    "Load TOML file at `p` into a dict"
    return tomllib.loads(Path(p).read_text(encoding='utf-8'))

def _has_nbdev(p):
    "True if pyproject.toml at `p` has [tool.nbdev]"
    try: return bool(_load_toml(p).get('tool', {}).get('nbdev', {}))
    except Exception: return False

def _find_nbdev_pyproject(path=None):
    "Find nearest pyproject.toml containing [tool.nbdev], walking up from `path`"
    p = Path(path or Path.cwd()).resolve()
    for d in [p] + list(p.parents):
        f = d/pyproject_nm
        if f.exists() and _has_nbdev(f): return f
    for d in [p] + list(p.parents):
        if (d/'settings.ini').exists():
            raise ValueError(f"Found old settings.ini. Migrate to pyproject.toml using `nbdev_migrate_config`. See https://nbdev.fast.ai/getting_started.html")

# %% ../nbs/api/01_config.ipynb #3dac70e0
nbdev_defaults = dict(nbs_path='nbs', doc_path='_docs', tst_flags='notest', recursive=True, readme_nb='index.ipynb',
    clean_ids=True, clear_all=False, put_version_in_init=True, jupyter_hooks=False, branch='main',
    doc_procs=[], export_procs=[])

_path_keys = 'lib_path', 'nbs_path', 'doc_path'

# %% ../nbs/api/01_config.ipynb #165ff301
class ConfigToml(AttrDict):
    def __init__(self, d, proj, cfg_file):
        super().__init__({**nbdev_defaults, **d})
        self.config_file = cfg_file
        self.config_path = cfg_file.parent
        
        self.lib_name = proj.get('name', '')
        self.title = self.get('title') or self.lib_name
        self.description = proj.get('description', '')
        self.keywords = proj.get('keywords', [])
        self.min_python = (proj.get('requires-python') or '>=3.9').lstrip('>=')
        auths = proj.get('authors') or [{}]
        self.author = auths[0].get('name')
        self.author_email = auths[0].get('email')
        
        
        urls = proj.get('urls') or {}
        self.git_url = (urls.get('Repository') or urls.get('Source') or '').rstrip('/')
        self.doc_url = urls.get('Documentation') or ''
        self.user, self.repo = repo_details(self.git_url) if self.git_url else ('', '')
        # Derive doc_host and doc_baseurl from doc_url
        from urllib.parse import urlparse
        u = urlparse(self.doc_url)
        self.doc_host = f"{u.scheme}://{u.netloc}" if u.scheme else ''
        self.doc_baseurl = (u.path or '/').rstrip('/') or '/'
        if 'lib_path' not in self: self['lib_path'] = self.lib_name.replace('-', '_')

    @property
    def version(self):
        return read_version(self.config_path / self['lib_path']) or '0.0.1'

    @property
    def d(self): return {k:v for k,v in super().items()}

    def __getattr__(self, k): return stop(AttributeError(k)) if k=='d' or k not in self.d else self.get(k)
    def __getitem__(self, k): return stop(IndexError(k)) if k not in self.d else self.get(k)

    def get(self, k, default=None):
        v = self.d.get(k, default)
        if v is None: return None
        return self.config_path / v if k in _path_keys else v

    def path(self, k, default=None):
        v = self.d.get(k, default)
        return v if v is None else self.config_path / v

# %% ../nbs/api/01_config.ipynb #6fed9c91
def _user_config():
    "Load user config from ~/.config/nbdev/config.toml if it exists"
    p = xdg_config_home() / _nbdev_home_dir / _user_cfg_name
    if p.exists(): return _load_toml(p)
    return {}

# %% ../nbs/api/01_config.ipynb #f6660849
def get_config(path=None, also_settings=False):
    "Return nbdev config."
    cfg_file = _find_nbdev_pyproject(path)
    if cfg_file is not None:
        d = _load_toml(cfg_file)
        user = _user_config()
        nbdev = {**user, **d.get('tool', {}).get('nbdev', {})}
        return ConfigToml(nbdev, d.get('project', {}), cfg_file)
    if also_settings:
        from fastcore.foundation import Config
        cfg = Config.find('settings.ini', path)
        if cfg: return cfg
    cfg_path = Path(path or Path.cwd()).expanduser().absolute()
    return ConfigToml(nbdev_defaults, {}, cfg_path/'pyproject.toml')

# %% ../nbs/api/01_config.ipynb #6939b40e
def is_nbdev(path=None): return _find_nbdev_pyproject(path) is not None

# %% ../nbs/api/01_config.ipynb #6e89fe6c
def create_output(txt, mime):
    "Add a cell output containing `txt` of the `mime` text MIME sub-type"
    return [dict(data={f"text/{mime}": str(txt).splitlines(True)},
                 execution_count=1, metadata={}, output_type="execute_result")]

# %% ../nbs/api/01_config.ipynb #5a4d8e52
def show_src(src, lang='python'): return Markdown(f'```{lang}\n{src}\n```')

# %% ../nbs/api/01_config.ipynb #163177f2
pyproj_tmpl = """[build-system]
requires = ["setuptools>=64.0"]
build-backend = "setuptools.build_meta"

[project]
name = "FILL_IN"
requires-python="FILL_IN"
dynamic = [ "keywords", "description", "version", "dependencies", "optional-dependencies", "readme",
    "license", "authors", "classifiers", "entry-points", "scripts", "urls"]

[tool.uv]
cache-keys = [{ file = "pyproject.toml" }, { file = "setup.py" }]
"""

# %% ../nbs/api/01_config.ipynb #f1c85f45
_re_version = re.compile(r'^__version__\s*=\s*[\'"]([^\'"]+)[\'"]', re.MULTILINE)
_re_proj = re.compile(r'^name\s*=\s*".*$', re.MULTILINE)
_re_reqpy = re.compile(r'^requires-python\s*=\s*".*$', re.MULTILINE)
_init = '__init__.py'
_pyproj = 'pyproject.toml'

# %% ../nbs/api/01_config.ipynb #680e62a5
def read_version(path):
    "Read __version__ from `path/__init__.py`, or None if not found"
    fname = Path(path)/_init
    if not fname.exists(): return None
    m = _re_version.search(fname.read_text())
    return m.group(1) if m else None

# %% ../nbs/api/01_config.ipynb #cf0fc6a3
def set_version(path, version):
    "Set __version__ in `path/__init__.py`"
    path = Path(path)
    path.mkdir(exist_ok=True, parents=True)
    fname = path/_init
    if not fname.exists(): fname.touch()
    ver_line = f'__version__ = "{version}"'
    code = fname.read_text()
    if _re_version.search(code) is None: code = ver_line + "\n" + code
    else: code = _re_version.sub(ver_line, code)
    fname.write_text(code)

# %% ../nbs/api/01_config.ipynb #d00889e5
def bump_version(v, part=2, unbump=False):
    "Bump semver string `v` at index `part` (0=major, 1=minor, 2=patch)"
    parts = (v or '0.0.0').split('.')
    parts += ['0'] * (3 - len(parts))
    parts[part] = str(int(parts[part]) + (-1 if unbump else 1))
    for i in range(part+1, 3): parts[i] = '0'
    return '.'.join(parts[:3])

# %% ../nbs/api/01_config.ipynb #e32583e6
def update_version(path=None):
    "Add __version__ to `path/__init__.py` if it doesn't exist"
    path = Path(path or get_config().lib_path)
    if read_version(path) is None: set_version(path, get_config().version)

# %% ../nbs/api/01_config.ipynb #275ef862
def _has_py(fs): return any(1 for f in fs if f.endswith('.py'))

def update_proj(path):
    "Create or update `pyproject.toml` in the project root."
    fname = path/_pyproj
    if not fname.exists(): fname.write_text(pyproj_tmpl)
    txt = fname.read_text()
    txt = _re_proj.sub(f'name = "{get_config().lib_name}"', txt)
    txt = _re_reqpy.sub(f'requires-python = ">={get_config().min_python}"', txt)
    fname.write_text(txt)

# %% ../nbs/api/01_config.ipynb #bdf57184
def add_init(path=None):
    "Add `__init__.py` in all subdirs of `path` containing python files if it's not there already."
    # we add the lowest-level `__init__.py` files first, which ensures _has_py succeeds for parent modules
    path = Path(path or get_config().lib_path)
    path.mkdir(exist_ok=True)
    if not (path/_init).exists(): (path/_init).touch()
    for r,ds,fs in os.walk(path, topdown=False):
        r = Path(r)
        subds = (os.listdir(r/d) for d in ds)
        if _has_py(fs) or any(filter(_has_py, subds)) and not (r/_init).exists(): (r/_init).touch()
    if get_config().get('put_version_in_init', True): update_version(path)
    if get_config().get('update_pyproject', True): update_proj(path.parent)

# %% ../nbs/api/01_config.ipynb #95cebda6
def import_obj(s):
    "Import and return `module:obj` string"
    mod_nm, obj_nm = s.split(':')
    mod = importlib.import_module(mod_nm)
    return getattr(mod, obj_nm)

# %% ../nbs/api/01_config.ipynb #cdd05b4c
def write_cells(cells, hdr, file, solo_nb=False):
    "Write `cells` to `file` along with header `hdr` (mainly for nbdev internal use)."
    for cell in cells:
        if cell.cell_type=='code' and cell.source.strip():
            cell_id = f" #{cell.id}" if cell.get('id') else ""
            file.write(f'\n\n{hdr}{cell_id}\n{cell.source}') if not solo_nb else file.write(f'\n\n{cell.source}')

# %% ../nbs/api/01_config.ipynb #34cfeb82
def _basic_export_nb(fname, name, dest=None):
    "Basic exporter to bootstrap nbdev."
    if dest is None: dest = get_config().lib_path
    add_init()
    fname,dest = Path(fname),Path(dest)
    nb = read_nb(fname)

    # grab the source from all the cells that have an `export` comment
    cells = L(cell for cell in nb.cells if re.match(r'#\s*\|export', cell.source))

    # find all the exported functions, to create `__all__`:
    trees = cells.map(NbCell.parsed_).concat()
    funcs = trees.filter(risinstance((ast.FunctionDef,ast.ClassDef))).attrgot('name')
    exp_funcs = [f for f in funcs if f[0]!='_']

    # write out the file
    with (dest/name).open('w',encoding="utf-8") as f:
        f.write(f"# %% auto 0\n__all__ = {exp_funcs}")
        write_cells(cells, f"# %% {fname.relpath(dest)}", f)
        f.write('\n')
