{"version":3,"file":"index-CS-zxv7Z.js","sources":["../../src/routes/flows/index.tsx?tsr-split=errorComponent"],"sourcesContent":["import {\n\tuseQuery,\n\tuseQueryClient,\n\tuseSuspenseQuery,\n} from \"@tanstack/react-query\";\nimport type { ErrorComponentProps } from \"@tanstack/react-router\";\nimport { createFileRoute } from \"@tanstack/react-router\";\nimport type {\n\tColumnFiltersState,\n\tPaginationState,\n} from \"@tanstack/react-table\";\nimport { zodValidator } from \"@tanstack/zod-adapter\";\nimport { useCallback, useMemo } from \"react\";\nimport { z } from \"zod\";\nimport { categorizeError } from \"@/api/error-utils\";\nimport { buildFilterFlowRunsQuery } from \"@/api/flow-runs\";\nimport {\n\tbuildCountFlowsFilteredQuery,\n\tbuildDeploymentsCountByFlowQuery,\n\tbuildNextRunsByFlowQuery,\n\tbuildPaginateFlowsQuery,\n\ttype FlowsPaginateFilter,\n} from \"@/api/flows\";\nimport FlowsPage from \"@/components/flows/flows-page\";\nimport { RouteErrorState } from \"@/components/ui/route-error-state\";\n\n// Route for /flows/\n\nconst searchParams = z\n\t.object({\n\t\tname: z.string().optional(),\n\t\tpage: z.number().int().positive().optional().default(1).catch(1),\n\t\tlimit: z\n\t\t\t.number()\n\t\t\t.int()\n\t\t\t.positive()\n\t\t\t.max(100)\n\t\t\t.optional()\n\t\t\t.default(10)\n\t\t\t.catch(10),\n\t\ttags: z.array(z.string()).optional(),\n\t\tsort: z\n\t\t\t.enum([\"CREATED_DESC\", \"UPDATED_DESC\", \"NAME_ASC\", \"NAME_DESC\"])\n\t\t\t.optional()\n\t\t\t.default(\"NAME_ASC\"),\n\t})\n\t.optional()\n\t.default({});\n\ntype SearchParams = z.infer<typeof searchParams>;\n\nconst buildPaginationBody = (search?: SearchParams): FlowsPaginateFilter => {\n\tconst hasNameFilter = Boolean(search?.name);\n\tconst hasTagsFilter = Boolean(search?.tags?.length);\n\n\tif (!hasNameFilter && !hasTagsFilter) {\n\t\treturn {\n\t\t\tpage: search?.page ?? 1,\n\t\t\tlimit: search?.limit ?? 10,\n\t\t\tsort: search?.sort ?? \"NAME_ASC\",\n\t\t};\n\t}\n\n\treturn {\n\t\tpage: search?.page ?? 1,\n\t\tlimit: search?.limit ?? 10,\n\t\tsort: search?.sort ?? \"NAME_ASC\",\n\t\tflows: {\n\t\t\toperator: \"and_\",\n\t\t\t...(hasNameFilter && { name: { like_: search?.name } }),\n\t\t\t...(hasTagsFilter && {\n\t\t\t\ttags: { operator: \"and_\", all_: search?.tags },\n\t\t\t}),\n\t\t},\n\t};\n};\n\nconst NUMBER_OF_ACTIVITY_BARS = 16;\n\nfunction FlowsErrorComponent({ error, reset }: ErrorComponentProps) {\n\tconst serverError = categorizeError(error, \"Failed to load flows\");\n\n\t// Only handle API errors (server-error, client-error) at route level\n\t// Let network errors and unknown errors bubble up to root error component\n\tif (\n\t\tserverError.type !== \"server-error\" &&\n\t\tserverError.type !== \"client-error\"\n\t) {\n\t\tthrow error;\n\t}\n\n\treturn (\n\t\t<div className=\"flex flex-col gap-4\">\n\t\t\t<div>\n\t\t\t\t<h1 className=\"text-2xl font-semibold\">Flows</h1>\n\t\t\t</div>\n\t\t\t<RouteErrorState error={serverError} onRetry={reset} />\n\t\t</div>\n\t);\n}\n\nexport const Route = createFileRoute(\"/flows/\")({\n\tvalidateSearch: zodValidator(searchParams),\n\tcomponent: FlowsRoute,\n\terrorComponent: FlowsErrorComponent,\n\tloaderDeps: ({ search }) => buildPaginationBody(search),\n\tloader: ({ deps, context }) => {\n\t\t// Prefetch current page queries without blocking the loader\n\t\tvoid context.queryClient.prefetchQuery(\n\t\t\tbuildPaginateFlowsQuery(deps, 30_000),\n\t\t);\n\t\tvoid context.queryClient.prefetchQuery(\n\t\t\tbuildCountFlowsFilteredQuery({\n\t\t\t\toffset: 0,\n\t\t\t\tsort: deps.sort,\n\t\t\t\tflows: deps.flows ?? undefined,\n\t\t\t}),\n\t\t);\n\t\t// Prefetch total count for empty state check\n\t\tvoid context.queryClient.prefetchQuery(\n\t\t\tbuildCountFlowsFilteredQuery({\n\t\t\t\toffset: 0,\n\t\t\t\tsort: \"NAME_ASC\",\n\t\t\t}),\n\t\t);\n\t},\n\twrapInSuspense: true,\n});\n\nconst usePagination = () => {\n\tconst search = Route.useSearch();\n\tconst navigate = Route.useNavigate();\n\n\t// Convert URL params (1-based page) to TanStack Table's PaginationState (0-based pageIndex)\n\tconst pagination: PaginationState = useMemo(\n\t\t() => ({\n\t\t\tpageIndex: (search.page ?? 1) - 1,\n\t\t\tpageSize: search.limit ?? 10,\n\t\t}),\n\t\t[search.page, search.limit],\n\t);\n\n\tconst onPaginationChange = useCallback(\n\t\t(newPagination: PaginationState) => {\n\t\t\tvoid navigate({\n\t\t\t\tto: \".\",\n\t\t\t\tsearch: (prev) => ({\n\t\t\t\t\t...prev,\n\t\t\t\t\t// Convert TanStack Table's 0-based pageIndex back to 1-based page for URL\n\t\t\t\t\tpage: newPagination.pageIndex + 1,\n\t\t\t\t\tlimit: newPagination.pageSize,\n\t\t\t\t}),\n\t\t\t\treplace: true,\n\t\t\t});\n\t\t},\n\t\t[navigate],\n\t);\n\n\treturn [pagination, onPaginationChange] as const;\n};\n\ntype FlowSort = \"CREATED_DESC\" | \"UPDATED_DESC\" | \"NAME_ASC\" | \"NAME_DESC\";\n\nconst useSort = () => {\n\tconst search = Route.useSearch();\n\tconst navigate = Route.useNavigate();\n\n\tconst onSortChange = useCallback(\n\t\t(sort: FlowSort) => {\n\t\t\tvoid navigate({\n\t\t\t\tto: \".\",\n\t\t\t\tsearch: (prev) => ({ ...prev, sort }),\n\t\t\t\treplace: true,\n\t\t\t});\n\t\t},\n\t\t[navigate],\n\t);\n\n\treturn [search.sort, onSortChange] as const;\n};\n\nconst useFlowsColumnFilters = () => {\n\tconst search = Route.useSearch();\n\tconst navigate = Route.useNavigate();\n\tconst columnFilters: ColumnFiltersState = useMemo(\n\t\t() => [\n\t\t\t{ id: \"name\", value: search.name },\n\t\t\t{ id: \"tags\", value: search.tags },\n\t\t],\n\t\t[search.name, search.tags],\n\t);\n\n\tconst onColumnFiltersChange = useCallback(\n\t\t(newColumnFilters: ColumnFiltersState) => {\n\t\t\tvoid navigate({\n\t\t\t\tto: \".\",\n\t\t\t\tsearch: (prev) => {\n\t\t\t\t\tconst name = newColumnFilters.find((filter) => filter.id === \"name\")\n\t\t\t\t\t\t?.value as string | undefined;\n\t\t\t\t\tconst tags = newColumnFilters.find((filter) => filter.id === \"tags\")\n\t\t\t\t\t\t?.value as string[] | undefined;\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...prev,\n\t\t\t\t\t\tpage: 1,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttags,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\treplace: true,\n\t\t\t});\n\t\t},\n\t\t[navigate],\n\t);\n\n\treturn [columnFilters, onColumnFiltersChange] as const;\n};\n\nfunction FlowsRoute() {\n\tconst search = Route.useSearch();\n\tconst queryClient = useQueryClient();\n\tconst [pagination, onPaginationChange] = usePagination();\n\tconst [sort, onSortChange] = useSort();\n\tconst [columnFilters, onColumnFiltersChange] = useFlowsColumnFilters();\n\n\tconst paginationBody = buildPaginationBody(search);\n\n\t// Use useSuspenseQuery for count (stable key, won't cause suspense on search change)\n\tconst { data: count } = useSuspenseQuery(\n\t\tbuildCountFlowsFilteredQuery({\n\t\t\toffset: 0,\n\t\t\tsort: search.sort,\n\t\t\tflows: paginationBody.flows ?? undefined,\n\t\t}),\n\t);\n\n\t// Get total count of all flows (without filters) to determine if empty state should be shown\n\tconst { data: totalCount } = useSuspenseQuery(\n\t\tbuildCountFlowsFilteredQuery({\n\t\t\toffset: 0,\n\t\t\tsort: \"NAME_ASC\",\n\t\t}),\n\t);\n\n\t// Use useQuery for paginated flows to leverage placeholderData: keepPreviousData\n\t// This prevents the page from suspending when search/filter changes\n\tconst { data: flowsPage } = useQuery(\n\t\tbuildPaginateFlowsQuery(paginationBody, 30_000),\n\t);\n\n\tconst flows = flowsPage?.results ?? [];\n\n\t// Prefetch a page and its child component data when user hovers over pagination buttons\n\tconst onPrefetchPage = useCallback(\n\t\t(page: number) => {\n\t\t\tconst pageDeps = { ...paginationBody, page };\n\t\t\tvoid queryClient\n\t\t\t\t.prefetchQuery(buildPaginateFlowsQuery(pageDeps, 30_000))\n\t\t\t\t.then(() => {\n\t\t\t\t\t// Get the prefetched page data from cache\n\t\t\t\t\tconst pageData = queryClient.getQueryData<{\n\t\t\t\t\t\tresults?: Array<{ id?: string }>;\n\t\t\t\t\t}>(buildPaginateFlowsQuery(pageDeps, 30_000).queryKey);\n\n\t\t\t\t\tconst flowIds =\n\t\t\t\t\t\tpageData?.results\n\t\t\t\t\t\t\t?.map((flow) => flow.id)\n\t\t\t\t\t\t\t.filter((id): id is string => Boolean(id)) ?? [];\n\n\t\t\t\t\tif (flowIds.length === 0) return;\n\n\t\t\t\t\t// Prefetch child component queries for each flow individually\n\t\t\t\t\t// Using individual flow IDs ensures query keys match what components use\n\t\t\t\t\tfor (const flowId of flowIds) {\n\t\t\t\t\t\t// FlowNextRun query - uses single flow ID array for query key matching\n\t\t\t\t\t\tvoid queryClient.prefetchQuery(buildNextRunsByFlowQuery([flowId]));\n\n\t\t\t\t\t\t// FlowDeploymentCount query - uses single flow ID array for query key matching\n\t\t\t\t\t\tvoid queryClient.prefetchQuery(\n\t\t\t\t\t\t\tbuildDeploymentsCountByFlowQuery([flowId]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// FlowLastRun query - last completed run\n\t\t\t\t\t\tvoid queryClient.prefetchQuery(\n\t\t\t\t\t\t\tbuildFilterFlowRunsQuery({\n\t\t\t\t\t\t\t\tflows: { operator: \"and_\", id: { any_: [flowId] } },\n\t\t\t\t\t\t\t\tflow_runs: {\n\t\t\t\t\t\t\t\t\toperator: \"and_\",\n\t\t\t\t\t\t\t\t\tstart_time: { is_null_: false },\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\toffset: 0,\n\t\t\t\t\t\t\t\tlimit: 1,\n\t\t\t\t\t\t\t\tsort: \"START_TIME_DESC\",\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// FlowActivity query - recent runs for activity chart\n\t\t\t\t\t\tvoid queryClient.prefetchQuery(\n\t\t\t\t\t\t\tbuildFilterFlowRunsQuery({\n\t\t\t\t\t\t\t\tflows: { operator: \"and_\", id: { any_: [flowId] } },\n\t\t\t\t\t\t\t\tflow_runs: {\n\t\t\t\t\t\t\t\t\toperator: \"and_\",\n\t\t\t\t\t\t\t\t\tstart_time: { is_null_: false },\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\toffset: 0,\n\t\t\t\t\t\t\t\tlimit: NUMBER_OF_ACTIVITY_BARS,\n\t\t\t\t\t\t\t\tsort: \"START_TIME_DESC\",\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t},\n\t\t[queryClient, paginationBody],\n\t);\n\n\treturn (\n\t\t<FlowsPage\n\t\t\tflows={flows}\n\t\t\tcount={count ?? 0}\n\t\t\ttotalCount={totalCount ?? 0}\n\t\t\tpageCount={flowsPage?.pages ?? 0}\n\t\t\tsort={sort as \"NAME_ASC\" | \"NAME_DESC\" | \"CREATED_DESC\"}\n\t\t\tpagination={pagination}\n\t\t\tonPaginationChange={onPaginationChange}\n\t\t\tonSortChange={onSortChange}\n\t\t\tcolumnFilters={columnFilters}\n\t\t\tonColumnFiltersChange={onColumnFiltersChange}\n\t\t\tonPrefetchPage={onPrefetchPage}\n\t\t/>\n\t);\n}\n"],"names":["z","name","string","optional","page","number","int","positive","default","catch","limit","max","tags","sort","FlowsErrorComponent","error","reset","serverError","categorizeError","type","jsxs","jsx","RouteErrorState"],"mappings":"kWA4BqBA,EACZ,CACPC,KAAMD,EAAEE,EAASC,SAAAA,EACjBC,KAAMJ,EAAEK,EAASC,MAAMC,SAAAA,EAAWJ,SAAAA,EAAWK,QAAQ,CAAC,EAAEC,MAAM,CAAC,EAC/DC,MAAOV,EACLK,EACAC,IAAAA,EACAC,SAAAA,EACAI,IAAI,GAAG,EACPR,SAAAA,EACAK,QAAQ,EAAE,EACVC,MAAM,EAAE,EACVG,KAAMZ,EAAQA,EAAEE,CAAQ,EAAEC,SAAAA,EAC1BU,KAAMb,EACC,CAAC,eAAgB,eAAgB,WAAY,WAAW,CAAC,EAC9DG,WACAK,QAAQ,UAAU,CACrB,CAAC,EACAL,WACAK,QAAQ,CAAA,CAAE,EAgCZ,SAASM,EAAoB,CAAEC,MAAAA,EAAOC,MAAAA,CAA2B,EAAG,CACnE,MAAMC,EAAcC,EAAgBH,EAAO,sBAAsB,EAIjE,GACCE,EAAYE,OAAS,gBACrBF,EAAYE,OAAS,eAErB,MAAMJ,EAGP,OACCK,EAAAA,KAAC,MAAA,CAAI,UAAU,sBACd,SAAA,CAAAC,EAAAA,IAAC,OACA,SAAAA,EAAAA,IAAC,KAAA,CAAG,UAAU,yBAAyB,iBAAK,CAAA,CAC7C,EACAA,EAAAA,IAACC,EAAA,CAAgB,MAAOL,EAAa,QAASD,CAAAA,CAAM,CAAA,EACrD,CAEF"}