# coding: utf-8

"""
    MultiFlexi API

    MultiFlexi API provides comprehensive access to job execution, application management, and user data operations. The API includes GDPR compliance endpoints for data export (Article 15 - Right of Access) and uses OAuth2 Application Flow for security.

    The version of the OpenAPI document: 1.2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from multiflexi_client.models.app_environment_value import AppEnvironmentValue
from multiflexi_client.models.app_exit_codes_inner import AppExitCodesInner
from multiflexi_client.models.tag import Tag
from typing import Optional, Set
from typing_extensions import Self

class App(BaseModel):
    """
    App
    """ # noqa: E501
    id: Optional[StrictInt] = None
    enabled: Optional[StrictBool] = Field(default=None, description="Whether the application is enabled")
    image: Optional[StrictStr] = Field(default=None, description="Base64-encoded application image or URL")
    name: StrictStr
    description: Optional[StrictStr] = None
    executable: StrictStr
    dat_create: Optional[datetime] = Field(default=None, description="Creation timestamp", alias="DatCreate")
    dat_update: Optional[datetime] = Field(default=None, description="Last update timestamp", alias="DatUpdate")
    setup: Optional[StrictStr] = Field(default=None, description="Setup command or instructions")
    cmdparams: Optional[StrictStr] = Field(default=None, description="Command line parameters")
    deploy: Optional[StrictStr] = Field(default=None, description="Deployment instructions")
    homepage: Optional[StrictStr] = None
    requirements: Optional[StrictStr] = Field(default=None, description="Comma-separated list of required credential types")
    ociimage: Optional[StrictStr] = Field(default=None, description="OCI/Docker container image name")
    version: Optional[StrictStr] = None
    code: Optional[StrictStr] = Field(default=None, description="Short application code")
    uuid: Optional[StrictStr] = None
    topics: Optional[StrictStr] = Field(default=None, description="Comma-separated list of topics/tags")
    resultfile: Optional[StrictStr] = Field(default=None, description="Result file path")
    artifacts: Optional[StrictStr] = Field(default=None, description="Output artifacts produced by the application")
    environment: Optional[Dict[str, AppEnvironmentValue]] = Field(default=None, description="Application environment configuration fields")
    exit_codes: Optional[List[AppExitCodesInner]] = Field(default=None, description="Exit code definitions with multilingual descriptions", alias="exitCodes")
    tags: Optional[List[Tag]] = None
    status: Optional[StrictStr] = Field(default=None, description="App status in the store")
    __properties: ClassVar[List[str]] = ["id", "enabled", "image", "name", "description", "executable", "DatCreate", "DatUpdate", "setup", "cmdparams", "deploy", "homepage", "requirements", "ociimage", "version", "code", "uuid", "topics", "resultfile", "artifacts", "environment", "exitCodes", "tags", "status"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['available', 'pending', 'sold']):
            raise ValueError("must be one of enum values ('available', 'pending', 'sold')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of App from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in environment (dict)
        _field_dict = {}
        if self.environment:
            for _key_environment in self.environment:
                if self.environment[_key_environment]:
                    _field_dict[_key_environment] = self.environment[_key_environment].to_dict()
            _dict['environment'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each item in exit_codes (list)
        _items = []
        if self.exit_codes:
            for _item_exit_codes in self.exit_codes:
                if _item_exit_codes:
                    _items.append(_item_exit_codes.to_dict())
            _dict['exitCodes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tags (list)
        _items = []
        if self.tags:
            for _item_tags in self.tags:
                if _item_tags:
                    _items.append(_item_tags.to_dict())
            _dict['tags'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of App from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "enabled": obj.get("enabled"),
            "image": obj.get("image"),
            "name": obj.get("name"),
            "description": obj.get("description"),
            "executable": obj.get("executable"),
            "DatCreate": obj.get("DatCreate"),
            "DatUpdate": obj.get("DatUpdate"),
            "setup": obj.get("setup"),
            "cmdparams": obj.get("cmdparams"),
            "deploy": obj.get("deploy"),
            "homepage": obj.get("homepage"),
            "requirements": obj.get("requirements"),
            "ociimage": obj.get("ociimage"),
            "version": obj.get("version"),
            "code": obj.get("code"),
            "uuid": obj.get("uuid"),
            "topics": obj.get("topics"),
            "resultfile": obj.get("resultfile"),
            "artifacts": obj.get("artifacts"),
            "environment": dict(
                (_k, AppEnvironmentValue.from_dict(_v))
                for _k, _v in obj["environment"].items()
            )
            if obj.get("environment") is not None
            else None,
            "exitCodes": [AppExitCodesInner.from_dict(_item) for _item in obj["exitCodes"]] if obj.get("exitCodes") is not None else None,
            "tags": [Tag.from_dict(_item) for _item in obj["tags"]] if obj.get("tags") is not None else None,
            "status": obj.get("status")
        })
        return _obj


