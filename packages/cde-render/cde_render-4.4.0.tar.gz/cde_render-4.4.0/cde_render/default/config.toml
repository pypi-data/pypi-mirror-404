# This is the default config file. Please don't modify this file, since it will probably be changed in later versions of
# this script. To override options in this file, please create a `config.ini` file in your custom directory and insert
# the relevant options in its section.
#
# The config files are parsed as a TOML file: https://toml.io/en/

[meta]
pdf_author = "Orgateam"

[api]
# To use the API, create an Orga Token and place it in a simple textfile under the name given
# here (relative to your custom directory).
# Set 'offline_host' to the host (including port) of a local vm to retrieve data from there.
# Leave the 'token_file' entry unset if the vm is in offline mode, as no token is needed then.
# If the vm is in non-offline dev mode, specify a token file as usual.
#offline_host = "localhost:20443"
token_file = "my_orga_token.secret"

[data]
timezone = "Europe/Berlin"
time_locale = "de"

[[data.meals]]
# If present, the name of the registration datafield, storing the desired type of meal.
field_name = "Verpflegung"

# If present, the name of the registration datafield, storing the group of half-time meat.
#halfmeat_group_field_name =

# Suffix appended when locating assets for this meal.
#asset_suffix = ""

# If present, the name of the registration datafield, storing any meal related allergies.
#meal_allergies_field =

# names of the possible values of the meal datafield.
[data.meals.value_map]
meat = "fleisch"
vegetarian = "vegetarisch"
vegan = "vegan"
special = "besonderes"
halfmeat = "halbvegetarisch"

#[[data.meals]]
# If present, the name of the registration datafield, storing the desired type of meal.
#field_name = "VerpflegungGrillen"

# If present, the name of the registration datafield, storing the group of half-time meat.
#halfmeat_group_field_name =

# Suffix appended when locating assets for this meal.
#asset_suffix = "_Grillen"

# If present, the name of the registration datafield, storing any meal related allergies.
#meal_allergies_field =

# names of the possible values of the meal datafield.
#[data.meals.value_map]
#meat = "Fleisch"
#vegetarian = "vegetarisch"
#vegan = "vegan"

# names of the possible values of the `arrival_transport_field` and `departure_tranport_field` datafields
[data.transport_values]
train = "Zug"
car = "Auto"
stay = "bleiben"
misc = "sonstiges"

[data.vertrauenspersonen]
# For every event part with Vertrauenspersonen specify a field name. Registrations for which this field is true will
# receive a duplicate of their nametag to be printed in a different color.
#1.H. = "vp1"
#2.H. = "vp2

[data.overrides]
# Use this to define field names used for overriding things in specific circumstances.
#  For example with the following definition you can use
#   'registration.name.nametag_forename|override(registration, CONFIG.data.overrides.nametag_name)'
#  in your nametags override to use the name in the specified datafield instead, if it is set.
#  You can also use the equivalent
#   'registration.name.nametag_forename|override(registration, "some_datafield_name")'
#  without needing to adjust the config here.
# These settings and the 'override' filter have no effect elsewhere.
#nametag_forename = "some_datafield_name"
#nametag_pronouns = "some_datafield_name"
#nametag_surname = "some_datafield_name"

[data.replacements]
# Use this to define replacement fields for entity attributes. Unlike the overrides, this will cause that
#  attribute to be completely replaced by the value of the given field (if not empty) _everywhere_!
# The orignal value will be unaffected, if the field is not set or is empty ('None' in python or 'null' in json).

[data.replacements.courses]
# This would replace course titles with the value of the given custom course datafield.
#title = "some_datafield"

[data.replacements.lodgements]
# This would replace lodgement titles with the value of the given custom lodgement datafield.
#title = "some_datafield"

[data.replacements.registrations]
# The name of a registration datafield, storing an alternative mobile phone number of the participant.
#  If that field is not emtpy, its value will be shown instead of the mobile number from the participant's CdEDB profile data.
#mobile = "some_datafield"

[layout]
#logo_file      = "logo.pdf"
design_color   = "404040"
link_color     = "000080"
row_color      = "808080"

# Using LuaLaTeX with fontspec, there are three ways to define documents fonts. By default, we use the libertine font
# package. If you want to use one of the other following options, please override `font_packages` and
# `fontswitch_headings` with an empty value.
# a) use latex packages and a macro to switch font for headings
#  'font_packages' is a list of tuples, where the first element is a package to be imported and the second is a commaseparated
#  list of options for that package.
#  E.g. An entry ["ABC", "X,Y,Z"] will result in the import '\usepackage[X,Y,Z]{ABC}'.
#  Note that some additional import options (like fallback fonts) may be added due to other configuration entries.

font_packages =  [
    ["libertine", ""],
]
fontswitch_headings = '\rmfamily'

# b) use installed system fonts by their family name
#systemfont            = "Linux Libertine"
#systemfont_headings   = "Linux Libertine"

# c) use font files, placed in a directory (`fontfile_dir`) in the assets folder
#fontfile_dir          = "fonts/"
#fontfile              = "LinLibertine_Rah.ttf"
#fontfile_bold         = "LinLibertine_RBah.ttf"
#fontfile_italic       = "LinLibertine_RIah.ttf"
#fontfile_bolditalic   = "LinLibertine_RBIah.ttf"
#fontfile_heading_dir          = "fonts/"
#fontfile_heading              = "LinLibertine_Rah.ttf"
#fontfile_heading_bold         = "LinLibertine_RBah.ttf"
#fontfile_heading_italic       = "LinLibertine_RIah.ttf"
#fontfile_heading_bolditalic   = "LinLibertine_RBIah.ttf"

# Enable 'lua-visual-debug' package to debug layout and spacings
lua-visual-debug = false

# Fallbackfont for unicode characters that are not available in the chosen font.
#  Can be the name of a system font or the path of a .ttf file relative to your custom asset directory.
fallback_font = "NotoColorEmoji"

[nametags]
# Path is relative to the asset directory. Course attributes can be used as placeholder (id, nr, shortname and title).
# Can be either a single string with placeholders or a list of strings with placeholders.
# If set to a list, the first existing icon will be used. This can be used to specify fallbacks.
course_icon_path = "course_icons/{nr:0>2}.pdf"

# Fontsizes for names over a certain length. Format is (max_length, font_height, line_height). Use a max_length of -1
# for a fallback fontsize.
forename_fontsizes = [
    [18, 26, 37],
    [-1, 18, 24],
]
pronouns_fontsizes = [
    [10, 18, 24],
    [-1, 12, 16],
]
surname_fontsizes = [
    [25, 18, 24],
    [-1, 12, 16],
]

# If true, generate one set of nametags for each event part. If not specified, it will automatically set to true, if the
# event has more than 2 tracks or more than 2 parts.
#per_part = false

# Comma-separated list of age groups. Each group catches all participants who are less than x years old. Participants
# who are older then the highest age group are sorted into lodgement groups
age_groups = [16, 18]

# Whether to create regular nametags for orgas (based on age/lodgement group) or not.
orga_nametags_regular = true
# Whether to create separate nametags for orgas or not.
orga_nametags_separate = false

# If true and the course in both tracks is the same, merge the course logos and names and append the
# `merge_courses_suffix`. The course rooms will always be merged.
merge_courses = true
# The suffix for the course names and course rooms, if merged
merge_courses_suffix = "(beide Hälften)"
# The suffix for the course names if participant is instructor of the course
course_instructor_suffix = "(KL)"

# If true and the participants only has a course in the second track but not in the first, the left side is left empty
# and the course is shown right. Otherwise the the course of the second track is shown left in this case.
second_track_always_right = true

# Maximum number of icons that may appear in the `nametag_frontrighticons` block at the front of the nametags.
# This can be adapted when overriding this block in custom nametags.tex template to make more room for the lodgement
# name.
max_front_icons = 4

[nametags.puzzles]
# Whether puzzles icons should have a consistent or a random order.
# Put "once" for a random but consistent order across all registrations.
# Put "all" for an individually random order for all registrations.
randomize = "all"

# Set to true to display distribution of total number of puzzles in solutions.
#show_distribution = true

# Set to true to display frequency of each puzzle in solutions.
#show_frequency = true

# Comment (raw LaTeX code) to print at the bottom of solution pdf. Useful for crediting icon source.
#  Put "\\" here to get one backslash in the latex template.
#comment = "Sind diese Rätsel nicht \\textbf{toll}?"

[participation_letter]
# Override for the event title shown on the participation letter.
#event_title
sender = "Max Muster-Orga"
sender_address = "Musterstraße 123"
sender_postal_code = "12345"
sender_location = "Musterstadt"
#sender_country = "Musterland"
per_part = false


[participant_lists]
# Whether or not to show guests on orga lists
show_guests_orga = true
# Whether or not to show guests on public lists
show_guests = false

# The suffix for the course names if participant is instructor of the course
course_instructor_suffix = "(KL)"
# The suffix for the course names if participant is orga and participates in a course
orga_suffix = "(O)"

[arrival]
# Exclude people from being included in the checklist based on their transport.
#  This is based on the 'arrival_transport_field' below and the 'transport_field_values' definition in the 'data' section.
#  This can be combined with the 'previous_parts' option below.
checklist_exclude_car = true
checklist_exclude_stay = true

# Set this to "time" to only create checklists sorted by time or to "name" to only create checklists sorted by name.
#  Anything else (or nothing) will create both checklist variants.
#checklist_sort = "time"

# The arrival section can be configured individually for each part of your event, e.g. if you have separate data fields for
#  arrival time and transport for each part.
#  If you do not need that, simply leave the 'part = XY' definition commented out below.
#  If you need to configure multiple parts, copy the entire section below (including the [[arrival.parts]]) for every part
#  you want to configure and adjust the 'part = XY' definition accordingly.

[[arrival.parts]]
# Set this to the shortname of an event part to only apply to that event part. Leave empty or commented out to have this
#  configuration to apply to all (other) parts.
#part = "B"

# You can provide a list of 'previous parts' to automatically exclude everyone who is present at any of those.
#previous_parts = ["A"]
# Set 'show_previous_part_with_arrival_time' to true to still show those who have explicitly set an arrival time.
#  This is only recommended if you have a separate arrival time per part.
#show_previous_part_with_arrival_time = true

# The name of the registration datafield, storing the arrival time
time_field = ""
# The name of the registration datafield, storing the means of transport for arrival
transport_field = ""
# An optional name of the registration datafield, storing an arrival comment by the participant
comment_field = ""

[departure]
# Exclude people from being included in the checklist based on their transport.
#  This is based on the 'arrival_transport_field' below and the 'transport_field_values' definition in the 'data' section.
#  This can be combined with the 'previous_parts' option below.
checklist_exclude_car = true
checklist_exclude_stay = true

# As above, but for the departure list (not checklist).
list_exclude_car = false
list_exclude_stay = false

# As above but for the departure nametags.
nametags_exclude_car = false
nametage_exclude_stay = true

# The departure section can be configured individually for each part of your event, e.g. if you have separate data fields for
#  daparture time and transport for each part.
#  If you do not need that, simply leave the 'part = XY' definition commented out below.
#  If you need to configure multiple parts, copy the entire section below (including the [[departure.parts]]) for every part
#  you want to configure and adjust the 'part = XY' definition accordingly.

[[departure.parts]]
# Set this to the shortname of an event part to only apply to that event part. Leave empty or commented out to have this
#  configuration to apply to all (other) parts.
#part = "B"

# You can provide a list of 'next parts' to automatically exclude everyone who is present at any of those.
#next_parts = ["C"]
# Set 'show_next_part_with_departure_time' to true to still show those who have explicitly set a departure time.
#  This is only recommended if you have a separate departure time per part.
#show_next_part_with_departure_time = true

# The name of the registration datafield, storing the departure time
time_field = ""
# The name of the registration datafield, storing the means of transport for departure
transport_field = ""
# An optional name of the registration datafield, storing a departure comment by the participant.
comment_field = ""
# The name of the registration datafield, storing the number or name of the CdE-organized bus for departure
bus_field = ""
# A table of display texts for the departure bus numbers/names from the departur_bus_field data field
bus_descriptions = {}

[room_lists]
# Whether to highlight minors on lodgement lists. If true, will put a (U18), (U16), etc. marker behind their name.
highlight_minors = true

# Whether to create pages for empty lodgements (those with no inhabitants and no courses in a given part). Options are:
#  "all": Include all empty lodgements.
#  "group": Only include empty lodgements if any lodgement in their group has inhabitants in a given part.
#  "none" (or any other value): Don't include empty lodgements.
include_empty_lodgements = "group"

# If true a page is created for every non-lodgement course room even if it has no courses in this part (but does in others).
include_empty_course_rooms = false

# The string used to separate multiple room names in the course room field, when a course uses multiple rooms. This is
# used for the room_lists to split the course room field value and correctly match the individual course rooms with
# equally named lodgements.
course_room_delimiter = " & "

[attendee_lists]
# Whether to include and if so mark guests on the attendee list for instructors.
include_guests = true
mark_guests = true
# For courses taking place in multiple tracks, display display shortname or title? Leave empty to omit entirely.
track_identifier = "title"
# Alternatively define a map of track shortname to displayed string:
# [attendee_lists.shortname_map]
# K1 = morgens
# K2 = nachmittags


[donation]
# Field name of a boolean field which knows if this persona wants a donation receipt
wants_receipts_field = ""
# Maps field names of boolean fields to amount of donation.
# For each participant, the sum of the here-declared values, filtered by the individual
# boolean data field entry, is calculated.
donation_fields = {}
# Persona who issues the donation receipt, in general a Finanzvorstand
issuer = ""
# Location where the issuer issued the donation receipt
place_of_issue = ""

[room_changes]
# For generating lists of people who move to another lodgement between event parts.

# If true, include people who do not need to change their room.
#include_non_changing = true

# If true, mark guests on the list.
mark_guests = true

# For every pair of event part you want to create such a list for, create an entry like below.
# Event parts are referenced by shortname.
#[[room_changes.parts]]
#first = "A"
#second = "B"
#
#[[room_changes.parts]]
#first = "B"
#second = "C"

[envelopes]
# Adjust papersize at own risk.
#paperwidth = "220mm"
#paperheight = "110mm"

# Override default margins.
#top_margin = ""
#bottom_margin = ""
#left_margin = ""
#right_margin = ""

# Create one such entry for every group of parts that should get a combined set of envelopes.
# Remaining parts will get their own set of envelopes.
# Such a part group need not exist in the database for this.
#[[envelopes.part_groups]]
#shortname = "O"
#parts = ["O1", "O2"]
#
#[[envelopes.part_groups]]
#shortname = "W"
#parts = ["W1", "W2"]
