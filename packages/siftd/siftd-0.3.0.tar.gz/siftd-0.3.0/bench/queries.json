{
  "groups": [
    {
      "name": "conceptual",
      "description": "Queries about ideas, patterns, and design philosophy",
      "queries": [
        "separation of concerns between parsing and storage layers",
        "when to use composition vs inheritance for plugin systems",
        "normalized schema design for variable metadata",
        "query-time computation vs materialized/precomputed values",
        "adapter pattern for isolating format-specific logic"
      ]
    },
    {
      "name": "philosophical",
      "description": "Queries about decision-making, trade-offs, and reasoning about why",
      "queries": [
        "why store approximate cost instead of exact billing amounts",
        "why prefer user-defined SQL over a built-in query API",
        "trade-offs of adding nullable columns vs key-value attribute tables",
        "why defer automation until usage patterns emerge",
        "why use ULIDs instead of auto-increment or UUIDs"
      ]
    },
    {
      "name": "technical",
      "description": "Queries about specific technologies, implementations, and APIs",
      "queries": [
        "FTS5 full-text search indexing for conversation content",
        "SQLite WAL mode and concurrent read performance",
        "JSONL streaming parser for large log files",
        "argparse subcommand pattern for CLI tools",
        "cosine similarity for embedding-based semantic search"
      ]
    },
    {
      "name": "specific",
      "description": "Queries targeting known features in this corpus",
      "queries": [
        "how siftd discovers and loads adapter plugins from the drop-in directory",
        "FTS5 tokenizer configuration for searching conversation turns",
        "model name parsing and token cost lookup logic",
        "tool call canonicalization across different LLM providers",
        "XDG base directory paths for config and data storage"
      ]
    },
    {
      "name": "exploratory",
      "description": "Open-ended discovery queries, informal and recall-oriented",
      "queries": [
        "that conversation where we figured out the dedup strategy",
        "something about entry points for plugin loading",
        "how did we handle conversations that span multiple sessions",
        "the part where cost tracking got complicated",
        "when we talked about what fields to put in the schema vs attributes"
      ]
    },
    {
      "name": "cross-workspace",
      "description": "Queries that span multiple workspaces to test diversity across projects",
      "queries": [
        "error handling patterns across different projects",
        "testing strategies used in different codebases",
        "configuration management approaches across workspaces",
        "database schema design decisions in various projects",
        "CLI argument parsing patterns used across tools"
      ]
    },
    {
      "name": "broad-then-narrow",
      "description": "Paired queries — broad followed by focused follow-up — to measure overlap",
      "queries": [
        "how does the ingestion pipeline work",
        "ingestion dedup strategy for already-processed files",
        "what search features does siftd have",
        "hybrid FTS5 and embeddings search ranking",
        "how are conversations stored and queried"
      ]
    },
    {
      "name": "temporal-trace",
      "description": "Queries where chronological ordering reveals evolution of ideas",
      "queries": [
        "when did we first discuss embedding-based search",
        "evolution of the chunking strategy over time",
        "how the adapter interface changed across iterations",
        "earliest discussion of tag-based filtering",
        "progression of cost tracking implementation"
      ]
    },
    {
      "name": "tagged-subset",
      "description": "Queries combining semantic search with tag-oriented filtering context",
      "queries": [
        "architecture decisions tagged as important",
        "research findings about performance optimization",
        "design rationale discussions worth bookmarking",
        "useful patterns discovered during code review",
        "investigations into data quality issues"
      ]
    },
    {
      "name": "research-workflow",
      "description": "Multi-step sequences mimicking real research: discover, drill down, compare",
      "queries": [
        "what approaches did we consider for semantic search",
        "why did we choose cosine similarity over other distance metrics",
        "how does the current search compare to earlier prototypes",
        "what problems did the first search implementation have",
        "lessons learned from search quality benchmarking"
      ]
    }
  ]
}
