/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Graph database handle (single-file or multi-file) */
export declare class Database {
  /** Open a database file */
  static open(path: string, options?: OpenOptions | undefined | null): Database
  /** Close the database */
  close(): void
  /** Check if database is open */
  get isOpen(): boolean
  /** Get database path */
  get path(): string
  /** Check if database is read-only */
  get readOnly(): boolean
  /** Begin a transaction */
  begin(readOnly?: boolean | undefined | null): number
  /** Commit the current transaction */
  commit(): void
  /** Rollback the current transaction */
  rollback(): void
  /** Check if there's an active transaction */
  hasTransaction(): boolean
  /** Create a new node */
  createNode(key?: string | undefined | null): number
  /** Delete a node */
  deleteNode(nodeId: number): void
  /** Check if a node exists */
  nodeExists(nodeId: number): boolean
  /** Get node by key */
  getNodeByKey(key: string): number | null
  /** Get the key for a node */
  getNodeKey(nodeId: number): string | null
  /** List all node IDs */
  listNodes(): Array<number>
  /** Count all nodes */
  countNodes(): number
  /** Add an edge */
  addEdge(src: number, etype: number, dst: number): void
  /** Add an edge by type name */
  addEdgeByName(src: number, etypeName: string, dst: number): void
  /** Delete an edge */
  deleteEdge(src: number, etype: number, dst: number): void
  /** Check if an edge exists */
  edgeExists(src: number, etype: number, dst: number): boolean
  /** Get outgoing edges for a node */
  getOutEdges(nodeId: number): Array<JsEdge>
  /** Get incoming edges for a node */
  getInEdges(nodeId: number): Array<JsEdge>
  /** Get out-degree for a node */
  getOutDegree(nodeId: number): number
  /** Get in-degree for a node */
  getInDegree(nodeId: number): number
  /** Count all edges */
  countEdges(): number
  /**
   * List all edges in the database
   *
   * Returns an array of {src, etype, dst} objects representing all edges.
   * Optionally filter by edge type.
   */
  listEdges(etype?: number | undefined | null): Array<JsFullEdge>
  /**
   * List edges by type name
   *
   * Returns an array of {src, etype, dst} objects for the given edge type.
   */
  listEdgesByName(etypeName: string): Array<JsFullEdge>
  /** Count edges by type */
  countEdgesByType(etype: number): number
  /** Count edges by type name */
  countEdgesByName(etypeName: string): number
  /** Stream nodes in batches */
  streamNodes(options?: StreamOptions | undefined | null): Array<Array<number>>
  /** Stream nodes with properties in batches */
  streamNodesWithProps(options?: StreamOptions | undefined | null): Array<Array<NodeWithProps>>
  /** Stream edges in batches */
  streamEdges(options?: StreamOptions | undefined | null): Array<Array<JsFullEdge>>
  /** Stream edges with properties in batches */
  streamEdgesWithProps(options?: StreamOptions | undefined | null): Array<Array<EdgeWithProps>>
  /** Get a page of node IDs */
  getNodesPage(options?: PaginationOptions | undefined | null): NodePage
  /** Get a page of edges */
  getEdgesPage(options?: PaginationOptions | undefined | null): EdgePage
  /** Set a node property */
  setNodeProp(nodeId: number, keyId: number, value: JsPropValue): void
  /** Set a node property by key name */
  setNodePropByName(nodeId: number, keyName: string, value: JsPropValue): void
  /** Delete a node property */
  deleteNodeProp(nodeId: number, keyId: number): void
  /** Get a specific node property */
  getNodeProp(nodeId: number, keyId: number): JsPropValue | null
  /** Get all properties for a node (returns array of {key_id, value} pairs) */
  getNodeProps(nodeId: number): Array<JsNodeProp> | null
  /** Set an edge property */
  setEdgeProp(src: number, etype: number, dst: number, keyId: number, value: JsPropValue): void
  /** Set an edge property by key name */
  setEdgePropByName(src: number, etype: number, dst: number, keyName: string, value: JsPropValue): void
  /** Delete an edge property */
  deleteEdgeProp(src: number, etype: number, dst: number, keyId: number): void
  /** Get a specific edge property */
  getEdgeProp(src: number, etype: number, dst: number, keyId: number): JsPropValue | null
  /** Get all properties for an edge (returns array of {key_id, value} pairs) */
  getEdgeProps(src: number, etype: number, dst: number): Array<JsNodeProp> | null
  /** Set a vector embedding for a node */
  setNodeVector(nodeId: number, propKeyId: number, vector: Array<number>): void
  /** Get a vector embedding for a node */
  getNodeVector(nodeId: number, propKeyId: number): Array<number> | null
  /** Delete a vector embedding for a node */
  deleteNodeVector(nodeId: number, propKeyId: number): void
  /** Check if a node has a vector embedding */
  hasNodeVector(nodeId: number, propKeyId: number): boolean
  /** Get or create a label ID */
  getOrCreateLabel(name: string): number
  /** Get label ID by name */
  getLabelId(name: string): number | null
  /** Get label name by ID */
  getLabelName(id: number): string | null
  /** Get or create an edge type ID */
  getOrCreateEtype(name: string): number
  /** Get edge type ID by name */
  getEtypeId(name: string): number | null
  /** Get edge type name by ID */
  getEtypeName(id: number): string | null
  /** Get or create a property key ID */
  getOrCreatePropkey(name: string): number
  /** Get property key ID by name */
  getPropkeyId(name: string): number | null
  /** Get property key name by ID */
  getPropkeyName(id: number): string | null
  /** Define a new label (requires transaction) */
  defineLabel(name: string): number
  /** Add a label to a node */
  addNodeLabel(nodeId: number, labelId: number): void
  /** Add a label to a node by name */
  addNodeLabelByName(nodeId: number, labelName: string): void
  /** Remove a label from a node */
  removeNodeLabel(nodeId: number, labelId: number): void
  /** Check if a node has a label */
  nodeHasLabel(nodeId: number, labelId: number): boolean
  /** Get all labels for a node */
  getNodeLabels(nodeId: number): Array<number>
  /**
   * Execute a single-hop traversal from start nodes
   *
   * @param startNodes - Array of starting node IDs
   * @param direction - Traversal direction
   * @param edgeType - Optional edge type filter
   * @returns Array of traversal results
   */
  traverseSingle(startNodes: Array<number>, direction: JsTraversalDirection, edgeType?: number | undefined | null): Array<JsTraversalResult>
  /**
   * Execute a multi-hop traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps (direction, edgeType)
   * @param limit - Maximum number of results
   * @returns Array of traversal results
   */
  traverse(startNodes: Array<number>, steps: Array<JsTraversalStep>, limit?: number | undefined | null): Array<JsTraversalResult>
  /**
   * Execute a variable-depth traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param edgeType - Optional edge type filter
   * @param options - Traversal options (maxDepth, minDepth, direction, unique)
   * @returns Array of traversal results
   */
  traverseDepth(startNodes: Array<number>, edgeType: number | undefined | null, options: JsTraverseOptions): Array<JsTraversalResult>
  /**
   * Count traversal results without materializing them
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps
   * @returns Number of results
   */
  traverseCount(startNodes: Array<number>, steps: Array<JsTraversalStep>): number
  /**
   * Get just the node IDs from a traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps
   * @param limit - Maximum number of results
   * @returns Array of node IDs
   */
  traverseNodeIds(startNodes: Array<number>, steps: Array<JsTraversalStep>, limit?: number | undefined | null): Array<number>
  /**
   * Find shortest path using Dijkstra's algorithm
   *
   * @param config - Pathfinding configuration
   * @returns Path result with nodes, edges, and weight
   */
  dijkstra(config: JsPathConfig): JsPathResult
  /**
   * Find shortest path using BFS (unweighted)
   *
   * Faster than Dijkstra for unweighted graphs.
   *
   * @param config - Pathfinding configuration
   * @returns Path result with nodes, edges, and weight
   */
  bfs(config: JsPathConfig): JsPathResult
  /**
   * Find k shortest paths using Yen's algorithm
   *
   * @param config - Pathfinding configuration
   * @param k - Maximum number of paths to find
   * @returns Array of path results sorted by weight
   */
  kShortest(config: JsPathConfig, k: number): Array<JsPathResult>
  /**
   * Find shortest path between two nodes (convenience method)
   *
   * @param source - Source node ID
   * @param target - Target node ID
   * @param edgeType - Optional edge type filter
   * @param maxDepth - Maximum search depth
   * @returns Path result
   */
  shortestPath(source: number, target: number, edgeType?: number | undefined | null, maxDepth?: number | undefined | null): JsPathResult
  /**
   * Check if a path exists between two nodes
   *
   * @param source - Source node ID
   * @param target - Target node ID
   * @param edgeType - Optional edge type filter
   * @param maxDepth - Maximum search depth
   * @returns true if path exists
   */
  hasPath(source: number, target: number, edgeType?: number | undefined | null, maxDepth?: number | undefined | null): boolean
  /**
   * Get all nodes reachable from a source within a certain depth
   *
   * @param source - Source node ID
   * @param maxDepth - Maximum depth to traverse
   * @param edgeType - Optional edge type filter
   * @returns Array of reachable node IDs
   */
  reachableNodes(source: number, maxDepth: number, edgeType?: number | undefined | null): Array<number>
  /** Perform a checkpoint (compact WAL into snapshot) */
  checkpoint(): void
  /** Perform a background (non-blocking) checkpoint */
  backgroundCheckpoint(): void
  /** Check if checkpoint is recommended */
  shouldCheckpoint(threshold?: number | undefined | null): boolean
  /**
   * Optimize (compact) the database
   *
   * For single-file databases, this compacts the WAL into a new snapshot
   * (equivalent to optimizeSingleFile in the TypeScript API).
   */
  optimize(): void
  /** Optimize (compact) a single-file database with options */
  optimizeSingleFile(options?: SingleFileOptimizeOptions | undefined | null): void
  /** Vacuum a single-file database to reclaim free space */
  vacuum(options?: VacuumOptions | undefined | null): void
  /** Vacuum a single-file database to reclaim free space */
  vacuumSingleFile(options?: VacuumOptions | undefined | null): void
  /** Get database statistics */
  stats(): DbStats
  /** Check database integrity */
  check(): CheckResult
  /** Export database to a JSON object */
  exportToObject(options?: ExportOptions | undefined | null): any
  /** Export database to a JSON file */
  exportToJson(path: string, options?: ExportOptions | undefined | null): ExportResult
  /** Export database to JSONL */
  exportToJsonl(path: string, options?: ExportOptions | undefined | null): ExportResult
  /** Import database from a JSON object */
  importFromObject(data: any, options?: ImportOptions | undefined | null): ImportResult
  /** Import database from a JSON file */
  importFromJson(path: string, options?: ImportOptions | undefined | null): ImportResult
  /** Check if caching is enabled */
  cacheIsEnabled(): boolean
  /** Invalidate all caches for a node */
  cacheInvalidateNode(nodeId: number): void
  /** Invalidate caches for a specific edge */
  cacheInvalidateEdge(src: number, etype: number, dst: number): void
  /** Invalidate a cached key lookup */
  cacheInvalidateKey(key: string): void
  /** Clear all caches */
  cacheClear(): void
  /** Clear only the query cache */
  cacheClearQuery(): void
  /** Clear only the key cache */
  cacheClearKey(): void
  /** Clear only the property cache */
  cacheClearProperty(): void
  /** Clear only the traversal cache */
  cacheClearTraversal(): void
  /** Get cache statistics */
  cacheStats(): JsCacheStats | null
  /** Reset cache statistics */
  cacheResetStats(): void
}

/**
 * Stored graph data for traversal operations
 *
 * Since NAPI doesn't support passing closures directly, we need to
 * store the graph data and query it. This struct holds edge lists
 * indexed by source and destination.
 */
export declare class JsGraphAccessor {
  /** Create a new empty graph accessor */
  constructor()
  /**
   * Add an edge to the graph
   *
   * @param src - Source node ID
   * @param etype - Edge type ID
   * @param dst - Destination node ID
   * @param weight - Optional edge weight (default: 1.0)
   */
  addEdge(src: number, etype: number, dst: number, weight?: number | undefined | null): void
  /**
   * Add multiple edges at once (more efficient than individual adds)
   *
   * @param edges - Array of [src, etype, dst, weight?] tuples
   */
  addEdges(edges: Array<JsEdgeInput>): void
  /** Clear all edges */
  clear(): void
  /** Get the number of edges */
  edgeCount(): number
  /** Get the number of unique nodes */
  nodeCount(): number
  /**
   * Execute a single-hop traversal from start nodes
   *
   * @param startNodes - Array of starting node IDs
   * @param direction - Traversal direction
   * @param edgeType - Optional edge type filter
   * @returns Array of traversal results
   */
  traverseSingle(startNodes: Array<number>, direction: JsTraversalDirection, edgeType?: number | undefined | null): Array<JsTraversalResult>
  /**
   * Execute a multi-hop traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps (direction, edgeType)
   * @param limit - Maximum number of results
   * @returns Array of traversal results
   */
  traverse(startNodes: Array<number>, steps: Array<JsTraversalStep>, limit?: number | undefined | null): Array<JsTraversalResult>
  /**
   * Execute a variable-depth traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param edgeType - Optional edge type filter
   * @param options - Traversal options (maxDepth, minDepth, direction, unique)
   * @returns Array of traversal results
   */
  traverseDepth(startNodes: Array<number>, edgeType: number | undefined | null, options: JsTraverseOptions): Array<JsTraversalResult>
  /**
   * Count traversal results without materializing them
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps
   * @returns Number of results
   */
  traverseCount(startNodes: Array<number>, steps: Array<JsTraversalStep>): number
  /**
   * Get just the node IDs from a traversal
   *
   * @param startNodes - Array of starting node IDs
   * @param steps - Array of traversal steps
   * @param limit - Maximum number of results
   * @returns Array of node IDs
   */
  traverseNodeIds(startNodes: Array<number>, steps: Array<JsTraversalStep>, limit?: number | undefined | null): Array<number>
  /**
   * Find shortest path using Dijkstra's algorithm
   *
   * @param config - Pathfinding configuration
   * @returns Path result with nodes, edges, and weight
   */
  dijkstra(config: JsPathConfig): JsPathResult
  /**
   * Find shortest path using BFS (unweighted)
   *
   * Faster than Dijkstra for unweighted graphs.
   *
   * @param config - Pathfinding configuration
   * @returns Path result with nodes, edges, and weight
   */
  bfs(config: JsPathConfig): JsPathResult
  /**
   * Find k shortest paths using Yen's algorithm
   *
   * @param config - Pathfinding configuration
   * @param k - Maximum number of paths to find
   * @returns Array of path results sorted by weight
   */
  kShortest(config: JsPathConfig, k: number): Array<JsPathResult>
  /**
   * Find shortest path between two nodes (convenience method)
   *
   * @param source - Source node ID
   * @param target - Target node ID
   * @param edgeType - Optional edge type filter
   * @param maxDepth - Maximum search depth
   * @returns Path result
   */
  shortestPath(source: number, target: number, edgeType?: number | undefined | null, maxDepth?: number | undefined | null): JsPathResult
  /**
   * Check if a path exists between two nodes
   *
   * @param source - Source node ID
   * @param target - Target node ID
   * @param edgeType - Optional edge type filter
   * @param maxDepth - Maximum search depth
   * @returns true if path exists
   */
  hasPath(source: number, target: number, edgeType?: number | undefined | null, maxDepth?: number | undefined | null): boolean
  /**
   * Get all nodes reachable from a source within a certain depth
   *
   * @param source - Source node ID
   * @param maxDepth - Maximum depth to traverse
   * @param edgeType - Optional edge type filter
   * @returns Array of reachable node IDs
   */
  reachableNodes(source: number, maxDepth: number, edgeType?: number | undefined | null): Array<number>
}

/** IVF (Inverted File) index for approximate nearest neighbor search */
export declare class JsIvfIndex {
  /** Create a new IVF index */
  constructor(dimensions: number, config?: JsIvfConfig | undefined | null)
  /** Get the number of dimensions */
  get dimensions(): number
  /** Check if the index is trained */
  get trained(): boolean
  /**
   * Add training vectors
   *
   * Call this before train() with representative vectors from your dataset.
   */
  addTrainingVectors(vectors: Array<number>, numVectors: number): void
  /**
   * Train the index on added training vectors
   *
   * This runs k-means clustering to create the inverted file structure.
   */
  train(): void
  /**
   * Insert a vector into the index
   *
   * The index must be trained first.
   */
  insert(vectorId: number, vector: Array<number>): void
  /**
   * Delete a vector from the index
   *
   * Requires the vector data to determine which cluster to remove from.
   */
  delete(vectorId: number, vector: Array<number>): boolean
  /** Clear all data from the index */
  clear(): void
  /**
   * Search for k nearest neighbors
   *
   * Requires a VectorManifest to look up actual vector data.
   */
  search(manifestJson: string, query: Array<number>, k: number, options?: JsSearchOptions | undefined | null): Array<JsSearchResult>
  /**
   * Search with multiple query vectors
   *
   * Aggregates results using the specified method.
   */
  searchMulti(manifestJson: string, queries: Array<Array<number>>, k: number, aggregation: JsAggregation, options?: JsSearchOptions | undefined | null): Array<JsSearchResult>
  /** Get index statistics */
  stats(): JsIvfStats
  /** Serialize the index to bytes */
  serialize(): Buffer
  /** Deserialize an index from bytes */
  static deserialize(data: Buffer): JsIvfIndex
}

/** IVF-PQ combined index for memory-efficient approximate nearest neighbor search */
export declare class JsIvfPqIndex {
  /** Create a new IVF-PQ index */
  constructor(dimensions: number, ivfConfig?: JsIvfConfig | undefined | null, pqConfig?: JsPqConfig | undefined | null, useResiduals?: boolean | undefined | null)
  /** Get the number of dimensions */
  get dimensions(): number
  /** Check if the index is trained */
  get trained(): boolean
  /** Add training vectors */
  addTrainingVectors(vectors: Array<number>, numVectors: number): void
  /** Train the index */
  train(): void
  /** Insert a vector */
  insert(vectorId: number, vector: Array<number>): void
  /**
   * Delete a vector
   *
   * Requires the vector data to determine which cluster to remove from.
   */
  delete(vectorId: number, vector: Array<number>): boolean
  /** Clear the index */
  clear(): void
  /** Search for k nearest neighbors using PQ distance approximation */
  search(manifestJson: string, query: Array<number>, k: number, options?: JsSearchOptions | undefined | null): Array<JsSearchResult>
  /** Search with multiple query vectors */
  searchMulti(manifestJson: string, queries: Array<Array<number>>, k: number, aggregation: JsAggregation, options?: JsSearchOptions | undefined | null): Array<JsSearchResult>
  /** Get index statistics */
  stats(): JsIvfStats
  /** Serialize the index to bytes */
  serialize(): Buffer
  /** Deserialize an index from bytes */
  static deserialize(data: Buffer): JsIvfPqIndex
}

/**
 * High-level Ray database handle for Node.js/Bun.
 *
 * # Thread Safety and Concurrent Access
 *
 * Ray uses an internal RwLock to support concurrent operations:
 *
 * - **Read operations** (get, exists, neighbors, traversals) use a shared read lock,
 *   allowing multiple concurrent reads without blocking each other.
 * - **Write operations** (insert, update, link, delete) use an exclusive write lock,
 *   blocking all other operations until complete.
 *
 * This means you can safely call multiple read methods concurrently:
 *
 * ```javascript
 * // These execute concurrently - reads don't block each other
 * const [user1, user2, user3] = await Promise.all([
 *   db.get("User", "alice"),
 *   db.get("User", "bob"),
 *   db.get("User", "charlie"),
 * ]);
 * ```
 *
 * Write operations will wait for in-progress reads and block new operations:
 *
 * ```javascript
 * // This will wait for any in-progress reads, then block new reads
 * await db.insert("User").key("david").set("name", "David").execute();
 * ```
 */
export declare class Ray {
  /** Open a Ray database */
  static open(path: string, options: JsRayOptions): Ray
  /** Close the database */
  close(): void
  /** Get a node by key (returns node object with props) */
  get(nodeType: string, key: unknown): object | null
  /** Get a node by ID (returns node object with props) */
  getById(nodeId: number): object | null
  /** Get a lightweight node reference by key (no properties) */
  getRef(nodeType: string, key: unknown): object | null
  /** Get a node property value */
  getProp(nodeId: number, propName: string): JsPropValue | null
  /** Set a node property value */
  setProp(nodeId: number, propName: string, value: unknown): void
  /** Check if a node exists */
  exists(nodeId: number): boolean
  /** Delete a node by ID */
  deleteById(nodeId: number): boolean
  /** Delete a node by key */
  deleteByKey(nodeType: string, key: unknown): boolean
  /** Create an insert builder */
  insert(nodeType: string): RayInsertBuilder
  /** Create an update builder by node ID */
  updateById(nodeId: number): RayUpdateBuilder
  /** Create an update builder by key */
  updateByKey(nodeType: string, key: unknown): RayUpdateBuilder
  /** Link two nodes */
  link(src: number, edgeType: string, dst: number, props?: object | undefined | null): void
  /** Unlink two nodes */
  unlink(src: number, edgeType: string, dst: number): boolean
  /** Check if an edge exists */
  hasEdge(src: number, edgeType: string, dst: number): boolean
  /** Get an edge property value */
  getEdgeProp(src: number, edgeType: string, dst: number, propName: string): JsPropValue | null
  /** Get all edge properties */
  getEdgeProps(src: number, edgeType: string, dst: number): Record<string, JsPropValue>
  /** Set an edge property value */
  setEdgeProp(src: number, edgeType: string, dst: number, propName: string, value: unknown): void
  /** Delete an edge property */
  delEdgeProp(src: number, edgeType: string, dst: number, propName: string): void
  /** Update edge properties with a builder */
  updateEdge(src: number, edgeType: string, dst: number): RayUpdateEdgeBuilder
  /** List all nodes of a type (returns array of node objects) */
  all(nodeType: string): Array<object>
  /** Count nodes (optionally by type) */
  countNodes(nodeType?: string | undefined | null): number
  /** Count edges (optionally by type) */
  countEdges(edgeType?: string | undefined | null): number
  /** List all edges (optionally by type) */
  allEdges(edgeType?: string | undefined | null): Array<JsFullEdge>
  /** Check if a path exists between two nodes */
  hasPath(source: number, target: number, edgeType?: string | undefined | null): boolean
  /** Get all nodes reachable within a maximum depth */
  reachableFrom(source: number, maxDepth: number, edgeType?: string | undefined | null): Array<number>
  /** Get all node type names */
  nodeTypes(): Array<string>
  /** Get all edge type names */
  edgeTypes(): Array<string>
  /** Get database statistics */
  stats(): DbStats
  /** Get a human-readable description of the database */
  describe(): string
  /** Check database integrity */
  check(): CheckResult
  /** Execute a batch of operations atomically */
  batch(ops: Array<object>): Array<object>
  /** Begin a traversal from a node ID */
  from(nodeId: number): RayTraversal
  /** Begin a traversal from multiple nodes */
  fromNodes(nodeIds: Array<number>): RayTraversal
  /** Begin a path finding query */
  path(source: number, target: number): RayPath
  /** Begin a path finding query to multiple targets */
  pathToAny(source: number, targets: Array<number>): RayPath
}

export declare class RayInsertBuilder {
  /** Specify values for a single insert */
  values(key: unknown, props?: object | undefined | null): RayInsertExecutorSingle
  /** Specify values for multiple inserts */
  valuesMany(entries: Array<unknown>): RayInsertExecutorMany
}

export declare class RayInsertExecutorMany {
  /** Execute the inserts without returning */
  execute(): void
  /** Execute the inserts and return nodes */
  returning(): Array<object>
}

export declare class RayInsertExecutorSingle {
  /** Execute the insert without returning */
  execute(): void
  /** Execute the insert and return the node */
  returning(): object
}

export declare class RayPath {
  via(edgeType: string): void
  maxDepth(depth: number): void
  direction(direction: string): void
  bidirectional(): void
  find(): JsPathResult
  findBfs(): JsPathResult
  findKShortest(k: number): Array<JsPathResult>
}

export declare class RayTraversal {
  whereEdge(func: unknown): void
  whereNode(func: unknown): void
  out(edgeType?: string | undefined | null): void
  in(edgeType?: string | undefined | null): void
  both(edgeType?: string | undefined | null): void
  traverse(edgeType: string | undefined | null, options: JsTraverseOptions): void
  take(limit: number): void
  select(props: Array<string>): void
  nodes(): Array<number>
  edges(): Array<JsFullEdge>
  count(): number
}

export declare class RayUpdateBuilder {
  /** Set a node property */
  set(propName: string, value: unknown): void
  /** Remove a node property */
  unset(propName: string): void
  /** Set multiple properties at once */
  setAll(props: object): void
  /** Execute the update */
  execute(): void
}

export declare class RayUpdateEdgeBuilder {
  /** Set an edge property */
  set(propName: string, value: unknown): void
  /** Remove an edge property */
  unset(propName: string): void
  /** Set multiple edge properties at once */
  setAll(props: object): void
  /** Execute the edge update */
  execute(): void
}

/** High-level vector index for similarity search */
export declare class VectorIndex {
  /** Create a new vector index */
  constructor(options: VectorIndexOptions)
  /** Set/update a vector for a node */
  set(nodeId: number, vector: Array<number>): void
  /** Get the vector for a node (if any) */
  get(nodeId: number): Array<number> | null
  /** Delete the vector for a node */
  delete(nodeId: number): boolean
  /** Check if a node has a vector */
  has(nodeId: number): boolean
  /** Build/rebuild the IVF index for faster search */
  buildIndex(): void
  /** Search for similar vectors */
  search(query: Array<number>, options: SimilarOptions): Array<VectorSearchHit>
  /** Get index statistics */
  stats(): VectorIndexStats
  /** Clear all vectors and reset the index */
  clear(): void
}

/** Options for creating a backup */
export interface BackupOptions {
  /** Force a checkpoint before backup (single-file only) */
  checkpoint?: boolean
  /** Overwrite existing backup if it exists */
  overwrite?: boolean
}

/** Backup result */
export interface BackupResult {
  /** Backup path */
  path: string
  /** Size in bytes */
  size: number
  /** Timestamp in milliseconds since epoch */
  timestamp: number
  /** Backup type ("single-file" or "multi-file") */
  type: string
}

/**
 * Perform brute-force search over all vectors
 *
 * Useful for small datasets or verifying IVF results.
 */
export declare function bruteForceSearch(vectors: Array<Array<number>>, nodeIds: Array<number>, query: Array<number>, k: number, metric?: JsDistanceMetric | undefined | null): Array<JsBruteForceResult>

/** Cache layer metrics */
export interface CacheLayerMetrics {
  hits: number
  misses: number
  hitRate: number
  size: number
  maxSize: number
  utilizationPercent: number
}

/** Cache metrics */
export interface CacheMetrics {
  enabled: boolean
  propertyCache: CacheLayerMetrics
  traversalCache: CacheLayerMetrics
  queryCache: CacheLayerMetrics
}

/** Database check result */
export interface CheckResult {
  valid: boolean
  errors: Array<string>
  warnings: Array<string>
}

export declare function collectMetrics(db: Database): DatabaseMetrics

/** Compression options */
export interface CompressionOptions {
  /** Enable compression (default false) */
  enabled?: boolean
  /** Compression algorithm */
  type?: JsCompressionType
  /** Minimum section size to compress */
  minSize?: number
  /** Compression level */
  level?: number
}

/** Create a backup from an open database handle */
export declare function createBackup(db: Database, backupPath: string, options?: BackupOptions | undefined | null): BackupResult

/** Create a backup from a database path without opening it */
export declare function createOfflineBackup(dbPath: string, backupPath: string, options?: OfflineBackupOptions | undefined | null): BackupResult

/** Create a new vector index */
export declare function createVectorIndex(options: VectorIndexOptions): VectorIndex

/** Database metrics */
export interface DatabaseMetrics {
  path: string
  isSingleFile: boolean
  readOnly: boolean
  data: DataMetrics
  cache: CacheMetrics
  mvcc?: MvccMetrics
  memory: MemoryMetrics
  /** Timestamp in milliseconds since epoch */
  collectedAt: number
}

/** Data metrics */
export interface DataMetrics {
  nodeCount: number
  edgeCount: number
  deltaNodesCreated: number
  deltaNodesDeleted: number
  deltaEdgesAdded: number
  deltaEdgesDeleted: number
  snapshotGeneration: number
  maxNodeId: number
  schemaLabels: number
  schemaEtypes: number
  schemaPropKeys: number
}

/** Database statistics */
export interface DbStats {
  snapshotGen: number
  snapshotNodes: number
  snapshotEdges: number
  snapshotMaxNodeId: number
  deltaNodesCreated: number
  deltaNodesDeleted: number
  deltaEdgesAdded: number
  deltaEdgesDeleted: number
  walSegment: number
  walBytes: number
  recommendCompact: boolean
  mvccStats?: MvccStats
}

/** Page of edges */
export interface EdgePage {
  items: Array<JsFullEdge>
  nextCursor?: string
  hasMore: boolean
  total?: number
}

/** Edge entry with properties */
export interface EdgeWithProps {
  src: number
  etype: number
  dst: number
  props: Array<JsNodeProp>
}

/** Options for export */
export interface ExportOptions {
  includeNodes?: boolean
  includeEdges?: boolean
  includeSchema?: boolean
  pretty?: boolean
}

/** Export result */
export interface ExportResult {
  nodeCount: number
  edgeCount: number
}

/** Inspect a backup without restoring it */
export declare function getBackupInfo(backupPath: string): BackupResult

export declare function healthCheck(db: Database): HealthCheckResult

/** Health check entry */
export interface HealthCheckEntry {
  name: string
  passed: boolean
  message: string
}

/** Health check result */
export interface HealthCheckResult {
  healthy: boolean
  checks: Array<HealthCheckEntry>
}

/** Options for import */
export interface ImportOptions {
  skipExisting?: boolean
  batchSize?: number
}

/** Import result */
export interface ImportResult {
  nodeCount: number
  edgeCount: number
  skipped: number
}

/** Aggregation method for multi-query search */
export declare const enum JsAggregation {
  /** Minimum distance (best match) */
  Min = 'Min',
  /** Maximum distance (worst match) */
  Max = 'Max',
  /** Average distance */
  Avg = 'Avg',
  /** Sum of distances */
  Sum = 'Sum'
}

/** Brute force search result */
export interface JsBruteForceResult {
  nodeId: number
  distance: number
  similarity: number
}

/** Cache statistics */
export interface JsCacheStats {
  propertyCacheHits: number
  propertyCacheMisses: number
  propertyCacheSize: number
  traversalCacheHits: number
  traversalCacheMisses: number
  traversalCacheSize: number
  queryCacheHits: number
  queryCacheMisses: number
  queryCacheSize: number
}

/** Compression type for snapshot building */
export declare const enum JsCompressionType {
  None = 'None',
  Zstd = 'Zstd',
  Gzip = 'Gzip',
  Deflate = 'Deflate'
}

/** Distance metric for vector similarity */
export declare const enum JsDistanceMetric {
  /** Cosine similarity (1 - cosine) */
  Cosine = 'Cosine',
  /** Euclidean (L2) distance */
  Euclidean = 'Euclidean',
  /** Dot product (negated for distance) */
  DotProduct = 'DotProduct'
}

/** Edge representation for JS (neighbor style) */
export interface JsEdge {
  etype: number
  nodeId: number
}

/** Edge input for bulk loading */
export interface JsEdgeInput {
  src: number
  etype: number
  dst: number
  weight?: number
}

export interface JsEdgeSpec {
  name: string
  props?: Record<string, JsPropSpec>
}

/** Full edge representation for JS (src, etype, dst) */
export interface JsFullEdge {
  src: number
  etype: number
  dst: number
}

/** Configuration for IVF index */
export interface JsIvfConfig {
  /** Number of clusters (default: 100) */
  nClusters?: number
  /** Number of clusters to probe during search (default: 10) */
  nProbe?: number
  /** Distance metric (default: Cosine) */
  metric?: JsDistanceMetric
}

/** Statistics for IVF index */
export interface JsIvfStats {
  /** Whether the index is trained */
  trained: boolean
  /** Number of clusters */
  nClusters: number
  /** Total vectors in the index */
  totalVectors: number
  /** Average vectors per cluster */
  avgVectorsPerCluster: number
  /** Number of empty clusters */
  emptyClusterCount: number
  /** Minimum cluster size */
  minClusterSize: number
  /** Maximum cluster size */
  maxClusterSize: number
}

export interface JsKeySpec {
  kind: string
  prefix?: string
  template?: string
  fields?: Array<string>
  separator?: string
}

/** Node property key-value pair for JS */
export interface JsNodeProp {
  keyId: number
  value: JsPropValue
}

export interface JsNodeSpec {
  name: string
  key?: JsKeySpec
  props?: Record<string, JsPropSpec>
}

/** Configuration for pathfinding */
export interface JsPathConfig {
  /** Source node ID */
  source: number
  /** Target node ID (for single target) */
  target?: number
  /** Multiple target node IDs (find path to any) */
  targets?: Array<number>
  /** Allowed edge types (empty = all) */
  allowedEdgeTypes?: Array<number>
  /** Edge weight property key ID (optional) */
  weightKeyId?: number
  /** Edge weight property key name (optional) */
  weightKeyName?: string
  /** Traversal direction */
  direction?: JsTraversalDirection
  /** Maximum search depth */
  maxDepth?: number
}

export interface JsPathEdge {
  src: number
  etype: number
  dst: number
}

/** An edge in a path result */
export interface JsPathEdge {
  src: number
  etype: number
  dst: number
}

export interface JsPathResult {
  path: Array<number>
  edges: Array<JsPathEdge>
  totalWeight: number
  found: boolean
}

/** Result of a pathfinding query */
export interface JsPathResult {
  /** Nodes in order from source to target */
  path: Array<number>
  /** Edges as [src, etype, dst] triples */
  edges: Array<JsPathEdge>
  /** Sum of edge weights along the path */
  totalWeight: number
  /** Whether a path was found */
  found: boolean
}

/** Configuration for Product Quantization */
export interface JsPqConfig {
  /** Number of subspaces (must divide dimensions evenly) */
  numSubspaces?: number
  /** Number of centroids per subspace (default: 256) */
  numCentroids?: number
  /** Max k-means iterations for training (default: 25) */
  maxIterations?: number
}

export interface JsPropSpec {
  type: string
  optional?: boolean
  default?: JsPropValue
}

/** Property value wrapper for JS */
export interface JsPropValue {
  propType: PropType
  boolValue?: boolean
  intValue?: number
  floatValue?: number
  stringValue?: string
  vectorValue?: Array<number>
}

export interface JsRayOptions {
  nodes: Array<JsNodeSpec>
  edges: Array<JsEdgeSpec>
  readOnly?: boolean
  createIfMissing?: boolean
  lockFile?: boolean
}

/** Options for vector search */
export interface JsSearchOptions {
  /** Number of clusters to probe (overrides index default) */
  nProbe?: number
  /** Minimum similarity threshold (0-1) */
  threshold?: number
}

/** Result of a vector search */
export interface JsSearchResult {
  /** Vector ID */
  vectorId: number
  /** Associated node ID */
  nodeId: number
  /** Distance from query */
  distance: number
  /** Similarity score (0-1, higher is more similar) */
  similarity: number
}

/**
 * Synchronization mode for WAL writes
 *
 * Controls the durability vs performance trade-off for commits.
 * - Full: Fsync on every commit (durable to OS, slowest)
 * - Normal: Fsync only on checkpoint (~1000x faster, safe from app crash)
 * - Off: No fsync (fastest, data may be lost on any crash)
 */
export declare const enum JsSyncMode {
  /** Fsync on every commit (durable to OS, slowest) */
  Full = 'Full',
  /** Fsync on checkpoint only (balanced) */
  Normal = 'Normal',
  /** No fsync (fastest, least safe) */
  Off = 'Off'
}

/** Direction for graph traversal */
export declare const enum JsTraversalDirection {
  /** Follow outgoing edges */
  Out = 'Out',
  /** Follow incoming edges */
  In = 'In',
  /** Follow edges in both directions */
  Both = 'Both'
}

/** A single result from a traversal */
export interface JsTraversalResult {
  /** The node ID that was reached */
  nodeId: number
  /** The depth (number of hops) from the start */
  depth: number
  /** Source node of the edge used (if any) */
  edgeSrc?: number
  /** Destination node of the edge used (if any) */
  edgeDst?: number
  /** Edge type used (if any) */
  edgeType?: number
}

/** A single traversal step */
export interface JsTraversalStep {
  direction: JsTraversalDirection
  edgeType?: number
}

/** Options for variable-depth traversal */
export interface JsTraverseOptions {
  /** Direction of traversal */
  direction?: JsTraversalDirection
  /** Minimum depth (default: 1) */
  minDepth?: number
  /** Maximum depth (required) */
  maxDepth: number
  /** Whether to only visit unique nodes (default: true) */
  unique?: boolean
}

/** Memory metrics */
export interface MemoryMetrics {
  deltaEstimateBytes: number
  cacheEstimateBytes: number
  snapshotBytes: number
  totalEstimateBytes: number
}

/** MVCC metrics */
export interface MvccMetrics {
  enabled: boolean
  activeTransactions: number
  versionsPruned: number
  gcRuns: number
  minActiveTimestamp: number
  committedWritesSize: number
  committedWritesPruned: number
}

/** MVCC stats (from stats()) */
export interface MvccStats {
  activeTransactions: number
  minActiveTs: number
  versionsPruned: number
  gcRuns: number
  lastGcTime: number
  committedWritesSize: number
  committedWritesPruned: number
}

/** Page of node IDs */
export interface NodePage {
  items: Array<number>
  nextCursor?: string
  hasMore: boolean
  total?: number
}

/** Node entry with properties */
export interface NodeWithProps {
  id: number
  key?: string
  props: Array<JsNodeProp>
}

/** Options for offline backup */
export interface OfflineBackupOptions {
  /** Overwrite existing backup if it exists */
  overwrite?: boolean
}

/** Open a database file (standalone function) */
export declare function openDatabase(path: string, options?: OpenOptions | undefined | null): Database

/** Options for opening a database */
export interface OpenOptions {
  /** Open in read-only mode */
  readOnly?: boolean
  /** Create database if it doesn't exist */
  createIfMissing?: boolean
  /** Acquire file lock (multi-file only) */
  lockFile?: boolean
  /** Require locking support (multi-file only) */
  requireLocking?: boolean
  /** Enable MVCC (multi-file only) */
  mvcc?: boolean
  /** MVCC GC interval in ms (multi-file only) */
  mvccGcIntervalMs?: number
  /** MVCC retention in ms (multi-file only) */
  mvccRetentionMs?: number
  /** MVCC max version chain depth (multi-file only) */
  mvccMaxChainDepth?: number
  /** Page size in bytes (default 4096) */
  pageSize?: number
  /** WAL size in bytes (default 1MB) */
  walSize?: number
  /** Enable auto-checkpoint when WAL usage exceeds threshold */
  autoCheckpoint?: boolean
  /** WAL usage threshold (0.0-1.0) to trigger auto-checkpoint */
  checkpointThreshold?: number
  /** Use background (non-blocking) checkpoint */
  backgroundCheckpoint?: boolean
  /** Enable caching */
  cacheEnabled?: boolean
  /** Max node properties in cache */
  cacheMaxNodeProps?: number
  /** Max edge properties in cache */
  cacheMaxEdgeProps?: number
  /** Max traversal cache entries */
  cacheMaxTraversalEntries?: number
  /** Max query cache entries */
  cacheMaxQueryEntries?: number
  /** Query cache TTL in milliseconds */
  cacheQueryTtlMs?: number
  /** Sync mode: "Full", "Normal", or "Off" (default: "Full") */
  syncMode?: JsSyncMode
}

/** Options for cursor-based pagination */
export interface PaginationOptions {
  /** Number of items per page (default: 100) */
  limit?: number
  /** Cursor from previous page */
  cursor?: string
}

/**
 * Create a path configuration
 *
 * @param source - Source node ID
 * @param target - Target node ID
 * @returns Path configuration object
 */
export declare function pathConfig(source: number, target: number): JsPathConfig

/** Test function to verify NAPI bindings work */
export declare function plus100(input: number): number

/** Property value types */
export declare const enum PropType {
  Null = 'Null',
  Bool = 'Bool',
  Int = 'Int',
  Float = 'Float',
  String = 'String',
  Vector = 'Vector'
}

/** Property value tag for binary encoding */
export declare const enum PropValueTag {
  Null = 0,
  Bool = 1,
  I64 = 2,
  F64 = 3,
  String = 4,
  VectorF32 = 5
}

/**
 * Ray entrypoint - async version (recommended)
 * Opens the database on a background thread to avoid blocking the event loop
 */
export declare function ray(path: string, options: JsRayOptions): Promise<unknown>

/** Ray entrypoint - sync version (for backwards compatibility) */
export declare function raySync(path: string, options: JsRayOptions): Ray

/** Restore a backup into a target path */
export declare function restoreBackup(backupPath: string, restorePath: string, options?: RestoreOptions | undefined | null): string

/** Options for restoring a backup */
export interface RestoreOptions {
  /** Overwrite existing database if it exists */
  overwrite?: boolean
}

/** Options for similarity search */
export interface SimilarOptions {
  /** Number of results to return */
  k: number
  /** Minimum similarity threshold (0-1 for cosine) */
  threshold?: number
  /** Number of clusters to probe for IVF (default: 10) */
  nProbe?: number
}

/** Options for optimizing a single-file database */
export interface SingleFileOptimizeOptions {
  /** Compression options for the new snapshot */
  compression?: CompressionOptions
}

/** Options for streaming node/edge batches */
export interface StreamOptions {
  /** Number of items per batch (default: 1000) */
  batchSize?: number
}

/**
 * Create a traversal step
 *
 * @param direction - Traversal direction
 * @param edgeType - Optional edge type filter
 * @returns Traversal step object
 */
export declare function traversalStep(direction: JsTraversalDirection, edgeType?: number | undefined | null): JsTraversalStep

/** Options for vacuuming a single-file database */
export interface VacuumOptions {
  /** Shrink WAL region if empty */
  shrinkWal?: boolean
  /** Minimum WAL size to keep (bytes) */
  minWalSize?: number
}

/** Options for creating a vector index */
export interface VectorIndexOptions {
  /** Vector dimensions (required) */
  dimensions: number
  /** Distance metric (default: Cosine) */
  metric?: JsDistanceMetric
  /** Vectors per row group (default: 1024) */
  rowGroupSize?: number
  /** Vectors per fragment before sealing (default: 100_000) */
  fragmentTargetSize?: number
  /** Whether to auto-normalize vectors (default: true for cosine) */
  normalize?: boolean
  /** IVF index configuration */
  ivf?: JsIvfConfig
  /** Minimum training vectors before index training (default: 1000) */
  trainingThreshold?: number
  /** Maximum node IDs to cache for search results (default: 10_000) */
  cacheMaxSize?: number
}

/** Vector index statistics */
export interface VectorIndexStats {
  totalVectors: number
  liveVectors: number
  dimensions: number
  metric: JsDistanceMetric
  indexTrained: boolean
  indexClusters?: number
}

/** Search result hit */
export interface VectorSearchHit {
  nodeId: number
  distance: number
  similarity: number
}

/** Get KiteDB version */
export declare function version(): string
