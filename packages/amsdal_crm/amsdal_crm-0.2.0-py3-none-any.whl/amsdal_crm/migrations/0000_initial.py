from amsdal_models.migration import migrations
from amsdal_utils.models.enums import ModuleType


class Migration(migrations.Migration):
    operations: list[migrations.Operation] = [
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Activity",
            new_schema={
                "title": "Activity",
                "required": ["activity_type", "subject"],
                "properties": {
                    "created_at": {"type": "datetime", "title": "Created At", "format": "date-time"},
                    "updated_at": {"type": "datetime", "title": "Updated At", "format": "date-time"},
                    "activity_type": {
                        "type": "ActivityType",
                        "options": [
                            {"key": "TASK", "value": "task"},
                            {"key": "EVENT", "value": "event"},
                            {"key": "EMAIL", "value": "email"},
                            {"key": "NOTE", "value": "note"},
                            {"key": "CALL", "value": "call"},
                        ],
                        "title": "ActivityType",
                        "description": "Activity type enumeration.",
                        "enum": ["task", "event", "email", "note", "call"],
                        "x_enum_names": ["TASK", "EVENT", "EMAIL", "NOTE", "CALL"],
                    },
                    "subject": {"type": "string", "title": "Subject"},
                    "description": {"type": "string", "title": "Description"},
                    "related_to_type": {
                        "type": "string",
                        "options": [{"key": "ENTITY", "value": "Entity"}, {"key": "DEAL", "value": "Deal"}],
                        "title": "Related To Type",
                        "description": "What type of record this activity is related to.",
                        "enum": ["Entity", "Deal"],
                        "x_enum_names": ["ENTITY", "DEAL"],
                    },
                    "related_to_id": {"type": "string", "title": "Related To ID"},
                    "due_date": {"type": "datetime", "title": "Due Date", "format": "date-time"},
                    "completed_at": {"type": "datetime", "title": "Completed At", "format": "date-time"},
                    "is_completed": {"type": "boolean", "default": False, "title": "Is Completed"},
                    "assigned_to": {"type": "User", "title": "Assigned To"},
                },
                "custom_code": "import datetime as _dt\n\nfrom amsdal.contrib.auth.models.user import User\n\n\n@property\ndef display_name(self) -> str:\n    \"\"\"Return display name for the activity.\"\"\"\n    return f'{self.activity_type.value}: {self.subject}'\n\nasync def apre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    await super().apre_create()\n\nasync def apre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = await self.aget_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    await super().apre_update()\n\ndef has_object_permission(self, user: 'User', action: str) -> bool:\n    \"\"\"Check if user has permission to perform action on this activity.\n\n        Args:\n            user: The user attempting the action\n            action: The action being attempted (read, create, update, delete)\n\n        Returns:\n            True if user has permission, False otherwise\n        \"\"\"\n    if self.assigned_to and self.assigned_to.email == user.email:\n        return True\n    if user.permissions:\n        for permission in user.permissions:\n            if permission.model == '*' and permission.action in ('*', action):\n                return True\n            if permission.model == 'Activity' and permission.action in ('*', action):\n                return True\n    return False\n\ndef pre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    super().pre_create()\n\ndef pre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = self.get_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    super().pre_update()",
                "storage_metadata": {
                    "table_name": "Activity",
                    "db_fields": {"assigned_to": ["assigned_to_partition_key"]},
                    "primary_key": ["partition_key"],
                    "indexed": [["related_to_id"], ["created_at"], ["due_date"]],
                    "foreign_keys": {
                        "assigned_to": [{"assigned_to_partition_key": "string"}, "User", ["partition_key"]]
                    },
                },
                "description": "Base activity model with polymorphic related_to field.\n\nActivities can be linked to Contacts, Accounts, or Deals using\na generic foreign key pattern (related_to_type + related_to_id).",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Entity",
            new_schema={
                "title": "Entity",
                "required": ["name"],
                "properties": {
                    "created_at": {"type": "datetime", "title": "Created At", "format": "date-time"},
                    "updated_at": {"type": "datetime", "title": "Updated At", "format": "date-time"},
                    "name": {"type": "string", "title": "Entity Name"},
                    "legal_name": {"type": "string", "title": "Legal Name"},
                    "status": {
                        "type": "string",
                        "default": "Active",
                        "options": [{"key": "Active", "value": "Active"}, {"key": "Inactive", "value": "Inactive"}],
                        "title": "Status",
                        "enum": ["Active", "Inactive"],
                    },
                    "note": {"type": "string", "title": "Note"},
                    "custom_fields": {"type": "anything", "title": "Custom Fields"},
                    "assigned_to": {"type": "User", "title": "Assigned To"},
                },
                "custom_code": 'from amsdal.contrib.auth.models.user import User\n\n\n@property\ndef display_name(self) -> str:\n    """Return display name for the account."""\n    return self.name\n\nasync def apost_update(self) -> None:\n    """Async hook called after updating account."""\n    from amsdal_crm.services.workflow_service import WorkflowService\n    await WorkflowService.aexecute_rules(\'Entity\', \'update\', self)\n\nasync def apre_create(self) -> None:\n    """Async hook called before creating account."""\n    if self.custom_fields:\n        from amsdal_crm.services.custom_field_service import CustomFieldService\n        self.custom_fields = await CustomFieldService.avalidate_custom_fields(\'Entity\', self.custom_fields)\n    await super().apre_create()\n\nasync def apre_update(self) -> None:\n    """Async hook called before updating account."""\n    if self.custom_fields:\n        from amsdal_crm.services.custom_field_service import CustomFieldService\n        self.custom_fields = await CustomFieldService.avalidate_custom_fields(\'Entity\', self.custom_fields)\n    await super().apre_update()\n\ndef has_object_permission(self, user: \'User\', action: str) -> bool:\n    """Check if user has permission to perform action on this account.\n\n        Args:\n            user: The user attempting the action\n            action: The action being attempted (read, create, update, delete)\n\n        Returns:\n            True if user has permission, False otherwise\n        """\n    if self.assigned_to and self.assigned_to.email == user.email:\n        return True\n    if user.permissions:\n        for permission in user.permissions:\n            if permission.model == \'*\' and permission.action in (\'*\', action):\n                return True\n            if permission.model == \'Entity\' and permission.action in (\'*\', action):\n                return True\n    return False\n\ndef post_update(self) -> None:\n    """Hook called after updating account."""\n    from amsdal_crm.services.workflow_service import WorkflowService\n    WorkflowService.execute_rules(\'Entity\', \'update\', self)\n\ndef pre_create(self) -> None:\n    """Hook called before creating account."""\n    if self.custom_fields:\n        from amsdal_crm.services.custom_field_service import CustomFieldService\n        self.custom_fields = CustomFieldService.validate_custom_fields(\'Entity\', self.custom_fields)\n    super().pre_create()\n\ndef pre_update(self) -> None:\n    """Hook called before updating account."""\n    if self.custom_fields:\n        from amsdal_crm.services.custom_field_service import CustomFieldService\n        self.custom_fields = CustomFieldService.validate_custom_fields(\'Entity\', self.custom_fields)\n    super().pre_update()',
                "storage_metadata": {
                    "table_name": "Entity",
                    "db_fields": {"assigned_to": ["assigned_to_partition_key"]},
                    "primary_key": ["partition_key"],
                    "indexed": [["created_at"]],
                    "unique": [["name"]],
                    "foreign_keys": {
                        "assigned_to": [{"assigned_to_partition_key": "string"}, "User", ["partition_key"]]
                    },
                },
                "description": "Entity (Person/Organization/Trust) model.\n\nRepresents a company or organization in the CRM system.\nOwned by individual users with permission controls.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Pipeline",
            new_schema={
                "title": "Pipeline",
                "required": ["name"],
                "properties": {
                    "name": {"type": "string", "title": "Pipeline Name"},
                    "description": {"type": "string", "title": "Description"},
                    "is_active": {"type": "boolean", "default": True, "title": "Is Active"},
                },
                "custom_code": '@property\ndef display_name(self) -> str:\n    """Return display name for the pipeline."""\n    return self.name',
                "storage_metadata": {
                    "table_name": "Pipeline",
                    "db_fields": {},
                    "primary_key": ["partition_key"],
                    "unique": [["name"]],
                    "foreign_keys": {},
                },
                "description": "Sales pipeline model.\n\nRepresents a sales pipeline with multiple stages.\nPipelines are system-wide and not owned by individual users.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Call",
            new_schema={
                "title": "Call",
                "type": "Activity",
                "required": ["subject", "phone_number"],
                "properties": {
                    "created_at": {"type": "datetime", "title": "Created At", "format": "date-time"},
                    "updated_at": {"type": "datetime", "title": "Updated At", "format": "date-time"},
                    "activity_type": {"type": "string", "default": "call", "title": "Activity Type", "const": "call"},
                    "subject": {"type": "string", "title": "Subject"},
                    "description": {"type": "string", "title": "Description"},
                    "related_to_type": {
                        "type": "string",
                        "options": [{"key": "ENTITY", "value": "Entity"}, {"key": "DEAL", "value": "Deal"}],
                        "title": "Related To Type",
                        "description": "What type of record this activity is related to.",
                        "enum": ["Entity", "Deal"],
                        "x_enum_names": ["ENTITY", "DEAL"],
                    },
                    "related_to_id": {"type": "string", "title": "Related To ID"},
                    "due_date": {"type": "datetime", "title": "Due Date", "format": "date-time"},
                    "completed_at": {"type": "datetime", "title": "Completed At", "format": "date-time"},
                    "is_completed": {"type": "boolean", "default": False, "title": "Is Completed"},
                    "assigned_to": {"type": "User", "title": "Assigned To"},
                    "phone_number": {"type": "string", "title": "Phone Number"},
                    "duration_seconds": {"type": "integer", "title": "Duration (seconds)"},
                    "call_outcome": {"type": "string", "title": "Call Outcome"},
                },
                "custom_code": "import datetime as _dt\n\nfrom amsdal.contrib.auth.models.user import User\n\n\n@property\ndef display_name(self) -> str:\n    \"\"\"Return display name for the activity.\"\"\"\n    return f'{self.activity_type.value}: {self.subject}'\n\nasync def apre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    await super().apre_create()\n\nasync def apre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = await self.aget_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    await super().apre_update()\n\ndef has_object_permission(self, user: 'User', action: str) -> bool:\n    \"\"\"Check if user has permission to perform action on this activity.\n\n        Args:\n            user: The user attempting the action\n            action: The action being attempted (read, create, update, delete)\n\n        Returns:\n            True if user has permission, False otherwise\n        \"\"\"\n    if self.assigned_to and self.assigned_to.email == user.email:\n        return True\n    if user.permissions:\n        for permission in user.permissions:\n            if permission.model == '*' and permission.action in ('*', action):\n                return True\n            if permission.model == 'Activity' and permission.action in ('*', action):\n                return True\n    return False\n\ndef pre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    super().pre_create()\n\ndef pre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = self.get_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    super().pre_update()",
                "storage_metadata": {
                    "table_name": "Call",
                    "db_fields": {},
                    "primary_key": ["partition_key"],
                    "indexed": [["related_to_id"], ["created_at"], ["due_date"]],
                    "foreign_keys": {},
                },
                "description": "Phone call activity.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="EmailActivity",
            new_schema={
                "title": "EmailActivity",
                "type": "Activity",
                "required": ["subject", "from_address", "to_addresses", "body"],
                "properties": {
                    "created_at": {"type": "datetime", "title": "Created At", "format": "date-time"},
                    "updated_at": {"type": "datetime", "title": "Updated At", "format": "date-time"},
                    "activity_type": {"type": "string", "default": "email", "title": "Activity Type", "const": "email"},
                    "subject": {"type": "string", "title": "Subject"},
                    "description": {"type": "string", "title": "Description"},
                    "related_to_type": {
                        "type": "string",
                        "options": [{"key": "ENTITY", "value": "Entity"}, {"key": "DEAL", "value": "Deal"}],
                        "title": "Related To Type",
                        "description": "What type of record this activity is related to.",
                        "enum": ["Entity", "Deal"],
                        "x_enum_names": ["ENTITY", "DEAL"],
                    },
                    "related_to_id": {"type": "string", "title": "Related To ID"},
                    "due_date": {"type": "datetime", "title": "Due Date", "format": "date-time"},
                    "completed_at": {"type": "datetime", "title": "Completed At", "format": "date-time"},
                    "is_completed": {"type": "boolean", "default": False, "title": "Is Completed"},
                    "assigned_to": {"type": "User", "title": "Assigned To"},
                    "from_address": {"type": "string", "title": "From Address"},
                    "to_addresses": {"type": "array", "items": {"type": "string"}, "title": "To Addresses"},
                    "cc_addresses": {"type": "array", "items": {"type": "string"}, "title": "CC Addresses"},
                    "body": {"type": "string", "title": "Email Body"},
                    "is_outbound": {"type": "boolean", "default": True, "title": "Is Outbound"},
                },
                "custom_code": "import datetime as _dt\n\nfrom amsdal.contrib.auth.models.user import User\n\n\n@property\ndef display_name(self) -> str:\n    \"\"\"Return display name for the activity.\"\"\"\n    return f'{self.activity_type.value}: {self.subject}'\n\nasync def apre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    await super().apre_create()\n\nasync def apre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = await self.aget_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    await super().apre_update()\n\ndef has_object_permission(self, user: 'User', action: str) -> bool:\n    \"\"\"Check if user has permission to perform action on this activity.\n\n        Args:\n            user: The user attempting the action\n            action: The action being attempted (read, create, update, delete)\n\n        Returns:\n            True if user has permission, False otherwise\n        \"\"\"\n    if self.assigned_to and self.assigned_to.email == user.email:\n        return True\n    if user.permissions:\n        for permission in user.permissions:\n            if permission.model == '*' and permission.action in ('*', action):\n                return True\n            if permission.model == 'Activity' and permission.action in ('*', action):\n                return True\n    return False\n\ndef pre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    super().pre_create()\n\ndef pre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = self.get_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    super().pre_update()",
                "storage_metadata": {
                    "table_name": "EmailActivity",
                    "db_fields": {},
                    "primary_key": ["partition_key"],
                    "indexed": [["related_to_id"], ["created_at"], ["due_date"]],
                    "foreign_keys": {},
                },
                "description": "Email activity with sender/recipients.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Event",
            new_schema={
                "title": "Event",
                "type": "Activity",
                "required": ["subject", "start_time", "end_time"],
                "properties": {
                    "created_at": {"type": "datetime", "title": "Created At", "format": "date-time"},
                    "updated_at": {"type": "datetime", "title": "Updated At", "format": "date-time"},
                    "activity_type": {"type": "string", "default": "event", "title": "Activity Type", "const": "event"},
                    "subject": {"type": "string", "title": "Subject"},
                    "description": {"type": "string", "title": "Description"},
                    "related_to_type": {
                        "type": "string",
                        "options": [{"key": "ENTITY", "value": "Entity"}, {"key": "DEAL", "value": "Deal"}],
                        "title": "Related To Type",
                        "description": "What type of record this activity is related to.",
                        "enum": ["Entity", "Deal"],
                        "x_enum_names": ["ENTITY", "DEAL"],
                    },
                    "related_to_id": {"type": "string", "title": "Related To ID"},
                    "due_date": {"type": "datetime", "title": "Due Date", "format": "date-time"},
                    "completed_at": {"type": "datetime", "title": "Completed At", "format": "date-time"},
                    "is_completed": {"type": "boolean", "default": False, "title": "Is Completed"},
                    "assigned_to": {"type": "User", "title": "Assigned To"},
                    "start_time": {"type": "datetime", "title": "Start Time", "format": "date-time"},
                    "end_time": {"type": "datetime", "title": "End Time", "format": "date-time"},
                    "location": {"type": "string", "title": "Location"},
                },
                "custom_code": "import datetime as _dt\n\nfrom amsdal.contrib.auth.models.user import User\n\n\n@property\ndef display_name(self) -> str:\n    \"\"\"Return display name for the activity.\"\"\"\n    return f'{self.activity_type.value}: {self.subject}'\n\nasync def apre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    await super().apre_create()\n\nasync def apre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = await self.aget_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    await super().apre_update()\n\ndef has_object_permission(self, user: 'User', action: str) -> bool:\n    \"\"\"Check if user has permission to perform action on this activity.\n\n        Args:\n            user: The user attempting the action\n            action: The action being attempted (read, create, update, delete)\n\n        Returns:\n            True if user has permission, False otherwise\n        \"\"\"\n    if self.assigned_to and self.assigned_to.email == user.email:\n        return True\n    if user.permissions:\n        for permission in user.permissions:\n            if permission.model == '*' and permission.action in ('*', action):\n                return True\n            if permission.model == 'Activity' and permission.action in ('*', action):\n                return True\n    return False\n\ndef pre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    super().pre_create()\n\ndef pre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = self.get_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    super().pre_update()",
                "storage_metadata": {
                    "table_name": "Event",
                    "db_fields": {},
                    "primary_key": ["partition_key"],
                    "indexed": [["related_to_id"], ["created_at"], ["due_date"]],
                    "foreign_keys": {},
                },
                "description": "Event/meeting activity with start/end times.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Note",
            new_schema={
                "title": "Note",
                "type": "Activity",
                "required": ["subject"],
                "properties": {
                    "created_at": {"type": "datetime", "title": "Created At", "format": "date-time"},
                    "updated_at": {"type": "datetime", "title": "Updated At", "format": "date-time"},
                    "activity_type": {"type": "string", "default": "note", "title": "Activity Type", "const": "note"},
                    "subject": {"type": "string", "title": "Subject"},
                    "description": {"type": "string", "title": "Description"},
                    "related_to_type": {
                        "type": "string",
                        "options": [{"key": "ENTITY", "value": "Entity"}, {"key": "DEAL", "value": "Deal"}],
                        "title": "Related To Type",
                        "description": "What type of record this activity is related to.",
                        "enum": ["Entity", "Deal"],
                        "x_enum_names": ["ENTITY", "DEAL"],
                    },
                    "related_to_id": {"type": "string", "title": "Related To ID"},
                    "due_date": {"type": "datetime", "title": "Due Date", "format": "date-time"},
                    "completed_at": {"type": "datetime", "title": "Completed At", "format": "date-time"},
                    "is_completed": {"type": "boolean", "default": False, "title": "Is Completed"},
                    "assigned_to": {"type": "User", "title": "Assigned To"},
                },
                "custom_code": "import datetime as _dt\n\nfrom amsdal.contrib.auth.models.user import User\n\n\n@property\ndef display_name(self) -> str:\n    \"\"\"Return display name for the activity.\"\"\"\n    return f'{self.activity_type.value}: {self.subject}'\n\nasync def apre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    await super().apre_create()\n\nasync def apre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = await self.aget_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    await super().apre_update()\n\ndef has_object_permission(self, user: 'User', action: str) -> bool:\n    \"\"\"Check if user has permission to perform action on this activity.\n\n        Args:\n            user: The user attempting the action\n            action: The action being attempted (read, create, update, delete)\n\n        Returns:\n            True if user has permission, False otherwise\n        \"\"\"\n    if self.assigned_to and self.assigned_to.email == user.email:\n        return True\n    if user.permissions:\n        for permission in user.permissions:\n            if permission.model == '*' and permission.action in ('*', action):\n                return True\n            if permission.model == 'Activity' and permission.action in ('*', action):\n                return True\n    return False\n\ndef pre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    super().pre_create()\n\ndef pre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = self.get_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    super().pre_update()",
                "storage_metadata": {
                    "table_name": "Note",
                    "db_fields": {},
                    "primary_key": ["partition_key"],
                    "indexed": [["related_to_id"], ["created_at"], ["due_date"]],
                    "foreign_keys": {},
                },
                "description": "Simple note activity.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Task",
            new_schema={
                "title": "Task",
                "type": "Activity",
                "required": ["subject"],
                "properties": {
                    "created_at": {"type": "datetime", "title": "Created At", "format": "date-time"},
                    "updated_at": {"type": "datetime", "title": "Updated At", "format": "date-time"},
                    "activity_type": {"type": "string", "default": "task", "title": "Activity Type", "const": "task"},
                    "subject": {"type": "string", "title": "Subject"},
                    "description": {"type": "string", "title": "Description"},
                    "related_to_type": {
                        "type": "string",
                        "options": [{"key": "ENTITY", "value": "Entity"}, {"key": "DEAL", "value": "Deal"}],
                        "title": "Related To Type",
                        "description": "What type of record this activity is related to.",
                        "enum": ["Entity", "Deal"],
                        "x_enum_names": ["ENTITY", "DEAL"],
                    },
                    "related_to_id": {"type": "string", "title": "Related To ID"},
                    "due_date": {"type": "datetime", "title": "Due Date", "format": "date-time"},
                    "completed_at": {"type": "datetime", "title": "Completed At", "format": "date-time"},
                    "is_completed": {"type": "boolean", "default": False, "title": "Is Completed"},
                    "assigned_to": {"type": "User", "title": "Assigned To"},
                    "priority": {
                        "type": "string",
                        "default": "medium",
                        "options": [
                            {"key": "low", "value": "low"},
                            {"key": "medium", "value": "medium"},
                            {"key": "high", "value": "high"},
                        ],
                        "title": "Priority",
                        "enum": ["low", "medium", "high"],
                    },
                    "status": {
                        "type": "string",
                        "default": "not_started",
                        "options": [
                            {"key": "not_started", "value": "not_started"},
                            {"key": "in_progress", "value": "in_progress"},
                            {"key": "waiting", "value": "waiting"},
                            {"key": "completed", "value": "completed"},
                        ],
                        "title": "Status",
                        "enum": ["not_started", "in_progress", "waiting", "completed"],
                    },
                },
                "custom_code": "import datetime as _dt\n\nfrom amsdal.contrib.auth.models.user import User\n\n\n@property\ndef display_name(self) -> str:\n    \"\"\"Return display name for the activity.\"\"\"\n    return f'{self.activity_type.value}: {self.subject}'\n\nasync def apre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    await super().apre_create()\n\nasync def apre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = await self.aget_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    await super().apre_update()\n\ndef has_object_permission(self, user: 'User', action: str) -> bool:\n    \"\"\"Check if user has permission to perform action on this activity.\n\n        Args:\n            user: The user attempting the action\n            action: The action being attempted (read, create, update, delete)\n\n        Returns:\n            True if user has permission, False otherwise\n        \"\"\"\n    if self.assigned_to and self.assigned_to.email == user.email:\n        return True\n    if user.permissions:\n        for permission in user.permissions:\n            if permission.model == '*' and permission.action in ('*', action):\n                return True\n            if permission.model == 'Activity' and permission.action in ('*', action):\n                return True\n    return False\n\ndef pre_create(self) -> None:\n    self.created_at = _dt.datetime.now(tz=_dt.UTC)\n    super().pre_create()\n\ndef pre_update(self) -> None:\n    self.updated_at = _dt.datetime.now(tz=_dt.UTC)\n    if not self.created_at:\n        _metadata = self.get_metadata()\n        self.created_at = _dt.datetime.fromtimestamp(_metadata.created_at / 1000, tz=_dt.UTC)\n    super().pre_update()",
                "storage_metadata": {
                    "table_name": "Task",
                    "db_fields": {},
                    "primary_key": ["partition_key"],
                    "indexed": [["related_to_id"], ["created_at"], ["due_date"]],
                    "foreign_keys": {},
                },
                "description": "Task activity with priority and status.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Stage",
            new_schema={
                "title": "Stage",
                "required": ["pipeline", "name", "order"],
                "properties": {
                    "pipeline": {
                        "type": "Pipeline",
                        "title": "Pipeline",
                        "description": "Sales pipeline model.\n\nRepresents a sales pipeline with multiple stages.\nPipelines are system-wide and not owned by individual users.",
                    },
                    "name": {"type": "string", "title": "Stage Name"},
                    "description": {"type": "string", "title": "Description"},
                    "order": {"type": "integer", "title": "Order"},
                    "probability": {
                        "type": "number",
                        "default": 0.0,
                        "title": "Win Probability (%)",
                        "maximum": 100,
                        "minimum": 0,
                    },
                    "status": {
                        "type": "string",
                        "default": "open",
                        "options": [
                            {"key": "open", "value": "open"},
                            {"key": "closed_won", "value": "closed_won"},
                            {"key": "closed_lost", "value": "closed_lost"},
                        ],
                        "title": "Status",
                        "enum": ["open", "closed_won", "closed_lost"],
                    },
                },
                "custom_code": '@property\ndef display_name(self) -> str:\n    """Return display name for the stage."""\n    if isinstance(self.pipeline, str):\n        return f\'{self.pipeline} - {self.name}\'\n    return f\'{self.pipeline.display_name} - {self.name}\'',
                "storage_metadata": {
                    "table_name": "Stage",
                    "db_fields": {"pipeline": ["pipeline_partition_key"]},
                    "primary_key": ["partition_key"],
                    "indexed": [["order"]],
                    "foreign_keys": {"pipeline": [{"pipeline_partition_key": "string"}, "Pipeline", ["partition_key"]]},
                },
                "description": "Pipeline stage model.\n\nRepresents a stage within a sales pipeline with win probability\nand closed status indicators.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Deal",
            new_schema={
                "title": "Deal",
                "required": ["name", "entity", "stage"],
                "properties": {
                    "created_at": {"type": "datetime", "title": "Created At", "format": "date-time"},
                    "updated_at": {"type": "datetime", "title": "Updated At", "format": "date-time"},
                    "name": {"type": "string", "title": "Deal Name"},
                    "amount": {"type": "number", "title": "Amount"},
                    "currency": {"type": "string", "default": "USD", "title": "Currency"},
                    "entity": {
                        "type": "Entity",
                        "title": "Entity",
                        "description": "Entity (Person/Organization/Trust) model.\n\nRepresents a company or organization in the CRM system.\nOwned by individual users with permission controls.",
                    },
                    "stage": {
                        "type": "Stage",
                        "title": "Stage",
                        "description": "Pipeline stage model.\n\nRepresents a stage within a sales pipeline with win probability\nand closed status indicators.",
                    },
                    "expected_close_date": {"type": "datetime", "title": "Expected Close Date", "format": "date-time"},
                    "closed_date": {"type": "datetime", "title": "Closed Date", "format": "date-time"},
                    "status": {
                        "type": "string",
                        "default": "open",
                        "options": [
                            {"key": "open", "value": "open"},
                            {"key": "closed_won", "value": "closed_won"},
                            {"key": "closed_lost", "value": "closed_lost"},
                        ],
                        "title": "Status",
                        "enum": ["open", "closed_won", "closed_lost"],
                    },
                    "custom_fields": {"type": "anything", "title": "Custom Fields"},
                    "assigned_to": {"type": "User", "title": "Assigned To"},
                },
                "custom_code": "import datetime as _dt\n\nfrom amsdal.contrib.auth.models.user import User\nfrom amsdal_utils.models.data_models.reference import Reference\n\n\n@property\ndef display_name(self) -> str:\n    \"\"\"Return display name for the deal.\"\"\"\n    return self.name\n\n@property\ndef stage_name(self) -> str:\n    \"\"\"Returns stage name for display.\"\"\"\n    if hasattr(self.stage, 'name'):\n        return self.stage.name\n    return str(self.stage)\n\nasync def apost_update(self) -> None:\n    \"\"\"Async hook called after updating deal.\"\"\"\n    from amsdal_crm.services.workflow_service import WorkflowService\n    await WorkflowService.aexecute_rules('Deal', 'update', self)\n\nasync def apre_create(self) -> None:\n    \"\"\"Async hook called before creating deal.\"\"\"\n    if self.custom_fields:\n        from amsdal_crm.services.custom_field_service import CustomFieldService\n        self.custom_fields = await CustomFieldService.avalidate_custom_fields('Deal', self.custom_fields)\n    await super().apre_create()\n\nasync def apre_update(self) -> None:\n    \"\"\"Async hook called before updating deal.\n\n        Automatically syncs is_closed and is_won status with stage,\n        and sets closed_date when deal is closed.\n        \"\"\"\n    if self.custom_fields:\n        from amsdal_crm.services.custom_field_service import CustomFieldService\n        self.custom_fields = await CustomFieldService.avalidate_custom_fields('Deal', self.custom_fields)\n    stage = await self.stage\n    if stage.status == 'open':\n        self.status = 'open'\n    if stage.status == 'closed_won':\n        self.status = 'closed_won'\n    if stage.status == 'closed_lost':\n        self.status = 'closed_lost'\n    if self.status in ('closed_won', 'closed_lost') and (not self.closed_date):\n        self.closed_date = _dt.datetime.now(_dt.UTC)\n    await super().apre_update()\n\ndef has_object_permission(self, user: 'User', action: str) -> bool:\n    \"\"\"Check if user has permission to perform action on this deal.\n\n        Args:\n            user: The user attempting the action\n            action: The action being attempted (read, create, update, delete)\n\n        Returns:\n            True if user has permission, False otherwise\n        \"\"\"\n    if self.assigned_to and self.assigned_to.email == user.email:\n        return True\n    if user.permissions:\n        for permission in user.permissions:\n            if permission.model == '*' and permission.action in ('*', action):\n                return True\n            if permission.model == 'Deal' and permission.action in ('*', action):\n                return True\n    return False\n\ndef post_update(self) -> None:\n    \"\"\"Hook called after updating deal.\"\"\"\n    from amsdal_crm.services.workflow_service import WorkflowService\n    WorkflowService.execute_rules('Deal', 'update', self)\n\ndef pre_create(self) -> None:\n    \"\"\"Hook called before creating deal.\"\"\"\n    if self.custom_fields:\n        from amsdal_crm.services.custom_field_service import CustomFieldService\n        self.custom_fields = CustomFieldService.validate_custom_fields('Deal', self.custom_fields)\n    super().pre_create()\n\ndef pre_update(self) -> None:\n    \"\"\"Hook called before updating deal.\n\n        Automatically syncs is_closed and is_won status with stage,\n        and sets closed_date when deal is closed.\n        \"\"\"\n    if self.custom_fields:\n        from amsdal_crm.services.custom_field_service import CustomFieldService\n        self.custom_fields = CustomFieldService.validate_custom_fields('Deal', self.custom_fields)\n    from amsdal_models.classes.helpers.reference_loader import ReferenceLoader\n    stage = ReferenceLoader(self.stage).load_reference() if isinstance(self.stage, Reference) else self.stage\n    if stage.status == 'open':\n        self.status = 'open'\n    if stage.status == 'closed_won':\n        self.status = 'closed_won'\n    if stage.status == 'closed_lost':\n        self.status = 'closed_lost'\n    if self.status in ('closed_won', 'closed_lost') and (not self.closed_date):\n        self.closed_date = _dt.datetime.now(_dt.UTC)\n    super().pre_update()",
                "storage_metadata": {
                    "table_name": "Deal",
                    "db_fields": {
                        "entity": ["entity_partition_key"],
                        "stage": ["stage_partition_key"],
                        "assigned_to": ["assigned_to_partition_key"],
                    },
                    "primary_key": ["partition_key"],
                    "indexed": [["expected_close_date"], ["created_at"]],
                    "foreign_keys": {
                        "assigned_to": [{"assigned_to_partition_key": "string"}, "User", ["partition_key"]],
                        "entity": [{"entity_partition_key": "string"}, "Entity", ["partition_key"]],
                        "stage": [{"stage_partition_key": "string"}, "Stage", ["partition_key"]],
                    },
                },
                "description": "Deal (Sales Opportunity) model.\n\nRepresents a sales opportunity linked to an account and contact,\nprogressing through pipeline stages.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="Attachment",
            new_schema={
                "title": "Attachment",
                "required": ["related_to_type", "related_to_id", "uploaded_by", "file"],
                "properties": {
                    "related_to_type": {
                        "type": "string",
                        "options": [
                            {"key": "Entity", "value": "Entity"},
                            {"key": "Deal", "value": "Deal"},
                            {"key": "Activity", "value": "Activity"},
                        ],
                        "title": "Related To Type",
                        "enum": ["Entity", "Deal", "Activity"],
                    },
                    "related_to_id": {"type": "string", "title": "Related To ID"},
                    "uploaded_by": {"type": "string", "title": "Uploaded By (User Email)"},
                    "uploaded_at": {"type": "datetime", "title": "Uploaded At", "format": "date-time"},
                    "description": {"type": "string", "title": "Description"},
                    "file": {"type": "File", "title": "File"},
                },
                "custom_code": '@property\ndef display_name(self) -> str:\n    """Return display name for the attachment."""\n    if hasattr(self.file, \'filename\'):\n        return self.file.filename\n    return f\'Attachment {self._object_id}\'',
                "storage_metadata": {
                    "table_name": "Attachment",
                    "db_fields": {"file": ["file_partition_key"]},
                    "primary_key": ["partition_key"],
                    "indexed": [["related_to_id"], ["uploaded_at"]],
                    "foreign_keys": {"file": [{"file_partition_key": "string"}, "File", ["partition_key"]]},
                },
                "description": "Explicit attachment model for tracking file relationships.\n\nUses polymorphic relationship to link files to Contacts, Accounts,\nDeals, or Activities.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="CustomFieldDefinition",
            new_schema={
                "title": "CustomFieldDefinition",
                "required": ["entity_type", "field_name", "field_label", "field_type"],
                "properties": {
                    "entity_type": {
                        "type": "string",
                        "options": [
                            {"key": "Entity", "value": "Entity"},
                            {"key": "EntityRelationship", "value": "EntityRelationship"},
                            {"key": "Deal", "value": "Deal"},
                            {"key": "EntityIdentifier", "value": "EntityIdentifier"},
                            {"key": "EntityContactPoint", "value": "EntityContactPoint"},
                            {"key": "EntityAddress", "value": "EntityAddress"},
                        ],
                        "title": "Entity Type",
                        "enum": [
                            "Entity",
                            "EntityRelationship",
                            "Deal",
                            "EntityIdentifier",
                            "EntityContactPoint",
                            "EntityAddress",
                        ],
                    },
                    "field_name": {"type": "string", "title": "Field Name"},
                    "field_label": {"type": "string", "title": "Field Label"},
                    "field_type": {
                        "type": "string",
                        "options": [
                            {"key": "text", "value": "text"},
                            {"key": "number", "value": "number"},
                            {"key": "date", "value": "date"},
                            {"key": "choice", "value": "choice"},
                        ],
                        "title": "Field Type",
                        "enum": ["text", "number", "date", "choice"],
                    },
                    "choices": {"type": "array", "items": {"type": "string"}, "title": "Choices (for choice type)"},
                    "is_required": {"type": "boolean", "default": False, "title": "Is Required"},
                    "default_value": {"type": "anything", "title": "Default Value"},
                    "help_text": {"type": "string", "title": "Help Text"},
                    "display_order": {"type": "integer", "default": 0, "title": "Display Order"},
                },
                "custom_code": '@property\ndef display_name(self) -> str:\n    """Return display name for the custom field definition."""\n    return f\'{self.entity_type}.{self.field_name}\'',
                "storage_metadata": {
                    "table_name": "CustomFieldDefinition",
                    "db_fields": {},
                    "primary_key": ["partition_key"],
                    "unique": [["entity_type", "field_name"]],
                    "foreign_keys": {},
                },
                "description": "Metadata about custom fields available for CRM entities.\n\nDefines custom fields that users can add to Contacts, Accounts, or Deals.\nField values are stored in the entity's custom_fields JSON dict.",
            },
        ),
        migrations.CreateClass(
            module_type=ModuleType.CONTRIB,
            class_name="WorkflowRule",
            new_schema={
                "title": "WorkflowRule",
                "required": ["name", "entity_type", "trigger_event", "action_type", "action_config"],
                "properties": {
                    "name": {"type": "string", "title": "Rule Name"},
                    "entity_type": {
                        "type": "string",
                        "options": [
                            {"key": "Entity", "value": "Entity"},
                            {"key": "Deal", "value": "Deal"},
                            {"key": "Activity", "value": "Activity"},
                        ],
                        "title": "Entity Type",
                        "enum": ["Entity", "Deal", "Activity"],
                    },
                    "trigger_event": {
                        "type": "string",
                        "options": [
                            {"key": "create", "value": "create"},
                            {"key": "update", "value": "update"},
                            {"key": "delete", "value": "delete"},
                        ],
                        "title": "Trigger Event",
                        "enum": ["create", "update", "delete"],
                    },
                    "condition_field": {"type": "string", "title": "Condition Field"},
                    "condition_operator": {"type": "string", "title": "Condition Operator"},
                    "condition_value": {"type": "anything", "title": "Condition Value"},
                    "action_type": {
                        "type": "string",
                        "options": [
                            {"key": "update_field", "value": "update_field"},
                            {"key": "create_activity", "value": "create_activity"},
                            {"key": "send_notification", "value": "send_notification"},
                        ],
                        "title": "Action Type",
                        "enum": ["update_field", "create_activity", "send_notification"],
                    },
                    "action_config": {
                        "type": "anything",
                        "title": "Action Configuration",
                        "additionalProperties": True,
                    },
                    "is_active": {"type": "boolean", "default": True, "title": "Is Active"},
                },
                "custom_code": '@property\ndef display_name(self) -> str:\n    """Return display name for the workflow rule."""\n    return f\'{self.entity_type}: {self.name}\'',
                "storage_metadata": {
                    "table_name": "WorkflowRule",
                    "db_fields": {},
                    "primary_key": ["partition_key"],
                    "foreign_keys": {},
                },
                "description": "Configuration for workflow automation rules.\n\nDefines rules that trigger actions when certain conditions are met\non CRM entities (create, update, delete events).",
            },
        ),
    ]
