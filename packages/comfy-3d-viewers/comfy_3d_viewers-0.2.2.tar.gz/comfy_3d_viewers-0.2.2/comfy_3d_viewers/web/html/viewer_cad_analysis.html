<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>CADabra Face Analysis Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #container {
            flex: 1;
            min-height: 0;
            width: 100%;
            position: relative;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ccc;
            font-size: 14px;
            text-align: center;
            z-index: 10;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 14px;
            text-align: center;
            z-index: 10;
            max-width: 80%;
            display: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* Settings overlay and panel */
        #settingsOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            display: none;
        }
        #settingsOverlay.visible {
            display: block;
        }
        #settingsPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 16px;
            z-index: 2000;
            display: none;
            min-width: 280px;
            max-width: 320px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            font-size: 12px;
            color: #ccc;
        }
        #settingsPanel.visible {
            display: block;
        }
        #settingsPanel h3 {
            margin: 0 0 12px 0;
            color: #ccc;
            font-size: 14px;
            font-weight: normal;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }
        #settingsPanel .setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        #settingsPanel .setting-row label {
            flex: 1;
            color: #ccc;
            font-size: 11px;
            cursor: pointer;
        }
        #settingsPanel .setting-row input[type="checkbox"] {
            cursor: pointer;
        }
        #settingsPanel .setting-section {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }
        #settingsPanel .setting-section h4 {
            margin: 0 0 8px 0;
            font-size: 11px;
            font-weight: bold;
            color: #888;
        }
        #settingsPanel .slider-row {
            margin-bottom: 8px;
        }
        #settingsPanel .slider-row label {
            display: block;
            font-size: 10px;
            color: #888;
            margin-bottom: 2px;
        }
        #settingsPanel .slider-row input[type="range"] {
            width: 100%;
        }
        #settingsPanel .slider-row .value {
            font-family: monospace;
            color: #ccc;
        }
        #settingsPanel .button-row {
            display: flex;
            gap: 8px;
            margin-top: 14px;
            padding-top: 12px;
            border-top: 1px solid #333;
        }
        #settingsPanel .button-row button {
            flex: 1;
            padding: 6px 12px;
            font-size: 11px;
            background: #333;
            border: 1px solid #555;
            color: #ccc;
            cursor: pointer;
            border-radius: 3px;
        }
        #settingsPanel .button-row button:hover {
            background: #444;
        }
        #settingsPanel .button-row button.primary {
            background: #4CAF50;
            border-color: #4CAF50;
            color: white;
        }
        #settingsPanel .button-row button.primary:hover {
            background: #45a049;
        }
        /* Face info panel */
        #faceInfoPanel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            font-size: 11px;
            color: #ccc;
            max-width: 280px;
            display: none;
            z-index: 100;
        }
        #faceInfoPanel.visible {
            display: block;
        }
        #faceInfoPanel h4 {
            margin: 0 0 8px 0;
            color: #4a9eff;
            font-size: 12px;
        }
        #faceInfoPanel .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        #faceInfoPanel .info-label {
            color: #888;
        }
        #faceInfoPanel .info-value {
            color: #fff;
            font-family: monospace;
        }
        #faceInfoPanel .neighbors-list {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }
        #faceInfoPanel .neighbors-list span {
            display: inline-block;
            background: #ffc107;
            color: #000;
            padding: 1px 4px;
            border-radius: 2px;
            margin: 2px;
            font-size: 10px;
            cursor: pointer;
        }
        #faceInfoPanel .neighbors-list span:hover {
            background: #ffca2c;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div>Ready to load mesh...</div>
        </div>
        <div id="error"></div>

        <!-- Settings overlay and panel (triggered by gear icon in nav bar) -->
        <div id="settingsOverlay"></div>
        <div id="settingsPanel">
            <h3>Analysis Settings</h3>

            <div class="setting-row">
                <input type="checkbox" id="serverTessellation" checked>
                <label for="serverTessellation">Server-Side Tessellation</label>
            </div>
            <div class="setting-row">
                <input type="checkbox" id="wireframe">
                <label for="wireframe">Wireframe</label>
            </div>
            <div class="setting-row">
                <input type="checkbox" id="showEdges" checked>
                <label for="showEdges">Show Edges</label>
            </div>
            <div class="setting-row">
                <input type="checkbox" id="showNeighbors" checked>
                <label for="showNeighbors">Highlight Neighbors</label>
            </div>

            <div class="setting-section">
                <h4>Tessellation Quality</h4>
                <div class="slider-row">
                    <label>Linear Deflection: <span class="value" id="linearValue">0.1</span></label>
                    <input type="range" id="linearDeflection" min="0.01" max="2.0" step="0.01" value="0.1">
                </div>
                <div class="slider-row">
                    <label>Angular Deflection: <span class="value" id="angularValue">0.5</span></label>
                    <input type="range" id="angularDeflection" min="0.1" max="1.0" step="0.05" value="0.5">
                </div>
            </div>

            <div class="button-row">
                <button id="settingsCancel">Cancel</button>
                <button id="settingsApply" class="primary">Apply</button>
            </div>
        </div>

        <!-- Face info panel (shown when a face is selected) -->
        <div id="faceInfoPanel">
            <h4>Face <span id="faceIdDisplay">-</span></h4>
            <div class="info-row">
                <span class="info-label">Type:</span>
                <span class="info-value" id="faceTypeDisplay">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Area:</span>
                <span class="info-value" id="faceAreaDisplay">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Curvature:</span>
                <span class="info-value" id="faceCurvatureDisplay">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Edges:</span>
                <span class="info-value" id="faceEdgeCountDisplay">-</span>
            </div>
            <div class="neighbors-list" id="neighborsSection">
                <span class="info-label">Neighbors:</span>
                <div id="neighborsList"></div>
            </div>
        </div>
    </div>

    <!-- Load Three.js for rendering (bundled locally - r138) -->
    <script src="../three/three.min.js"></script>
    <script src="../three/OrbitControls.js"></script>

    <!-- Load VTK.js for VTP parsing (bundled locally) -->
    <script src="../js/vtk-gltf.js"></script>

    <script>
        // VTK.js VTP reader
        const vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader;

        console.log('[CADabra Analysis] VTK.js loaded for VTP parsing');

        let scene, camera, renderer, controls;
        let currentMesh = null;
        let currentEdges = null;
        let freeEdgesLines = null;
        let sharedEdgesLines = null;
        let currentVisualizationMode = 'normal';
        let currentEdgeCounts = [];  // Per-triangle edge counts from VTP

        // Face selection system
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedFaceId = null;
        let highlightMesh = null;
        let neighborHighlightMeshes = [];  // Array to hold neighbor highlights

        const loadingDiv = document.getElementById('loading');
        const errorDiv = document.getElementById('error');
        const faceInfoPanel = document.getElementById('faceInfoPanel');

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            const container = document.getElementById('container');
            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.01,
                10000
            );
            camera.position.set(100, 100, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);

            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Handle mouse clicks for face selection
            renderer.domElement.addEventListener('click', onMouseClick, false);

            // Start animation loop
            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Mouse click handler for face selection
        function onMouseClick(event) {
            if (!currentMesh || !analysisData) return;

            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObject(currentMesh);

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const faceIndex = intersection.faceIndex;

                // Map triangle index to face ID
                const triangleIndex = Math.floor(faceIndex / 1);
                const faceId = currentMesh.userData.faceTriangleMap[triangleIndex];

                if (faceId !== undefined) {
                    selectFace(faceId);
                }
            } else {
                // Clicked on empty space - deselect
                clearFaceSelection();
            }
        }

        // Select and highlight a face
        function selectFace(faceId) {
            if (selectedFaceId === faceId) {
                // Clicking same face - deselect
                clearFaceSelection();
                return;
            }

            selectedFaceId = faceId;
            console.log('[CADabra Analysis] Selected face:', faceId);

            // Get face data from analysis
            const faceData = analysisData.faces ? analysisData.faces[faceId] : null;

            if (faceData) {
                // Create highlight for the selected face
                createFaceHighlight(faceId, 0xffaa00, 0xff6600);  // Orange for selected

                // Highlight neighbors only in connectivity_inspection mode
                const showNeighbors = document.getElementById('showNeighbors').checked;
                if (showNeighbors && currentVisualizationMode === 'connectivity_inspection' && faceData.adjacent_faces && faceData.adjacent_faces.length > 0) {
                    createNeighborHighlights(faceData.adjacent_faces);
                }

                // Update face info panel
                updateFaceInfoPanel(faceData);

                // Send face data to parent window
                window.parent.postMessage({
                    type: 'FACE_SELECTED',
                    nodeId: nodeId,
                    faceId: faceId,
                    faceData: faceData
                }, '*');

                console.log('[CADabra Analysis] Face data:', faceData);
            }
        }

        // Update the face info panel
        function updateFaceInfoPanel(faceData) {
            document.getElementById('faceIdDisplay').textContent = faceData.face_id;
            document.getElementById('faceTypeDisplay').textContent = faceData.surface_type || '-';
            document.getElementById('faceAreaDisplay').textContent = faceData.area ? faceData.area.toFixed(4) : '-';
            document.getElementById('faceCurvatureDisplay').textContent = faceData.curvature_type || '-';
            document.getElementById('faceEdgeCountDisplay').textContent = faceData.edge_count !== undefined ? faceData.edge_count : '-';

            // Show neighbors only in connectivity_inspection mode
            const neighborsList = document.getElementById('neighborsList');
            neighborsList.innerHTML = '';
            if (currentVisualizationMode === 'connectivity_inspection' && faceData.adjacent_faces && faceData.adjacent_faces.length > 0) {
                faceData.adjacent_faces.forEach(neighborId => {
                    const span = document.createElement('span');
                    span.textContent = neighborId;
                    span.addEventListener('click', () => selectFace(neighborId));
                    neighborsList.appendChild(span);
                });
                document.getElementById('neighborsSection').style.display = 'block';
            } else {
                document.getElementById('neighborsSection').style.display = 'none';
            }

            faceInfoPanel.classList.add('visible');
        }

        // Clear face selection
        function clearFaceSelection() {
            selectedFaceId = null;

            // Remove highlight mesh
            if (highlightMesh) {
                scene.remove(highlightMesh);
                highlightMesh.geometry.dispose();
                highlightMesh.material.dispose();
                highlightMesh = null;
            }

            // Remove neighbor highlights
            clearNeighborHighlights();

            // Hide face info panel
            faceInfoPanel.classList.remove('visible');

            // Notify parent
            window.parent.postMessage({
                type: 'FACE_SELECTED',
                nodeId: nodeId,
                faceId: null,
                faceData: null
            }, '*');

            console.log('[CADabra Analysis] Face selection cleared');
        }

        // Clear neighbor highlights
        function clearNeighborHighlights() {
            neighborHighlightMeshes.forEach(mesh => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            neighborHighlightMeshes = [];
        }

        // Create highlight mesh for selected face
        function createFaceHighlight(faceId, color, emissiveColor) {
            // Remove old highlight
            if (highlightMesh) {
                scene.remove(highlightMesh);
                highlightMesh.geometry.dispose();
                highlightMesh.material.dispose();
            }

            const geometry = extractFaceGeometry(faceId);
            if (!geometry) return;

            // Create highlight material
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: emissiveColor,
                emissiveIntensity: 0.3,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });

            highlightMesh = new THREE.Mesh(geometry, material);
            scene.add(highlightMesh);

            console.log('[CADabra Analysis] Highlight created for face:', faceId);
        }

        // Create highlights for neighbor faces
        function createNeighborHighlights(neighborIds) {
            clearNeighborHighlights();

            neighborIds.forEach(neighborId => {
                const geometry = extractFaceGeometry(neighborId);
                if (!geometry) return;

                // Yellow/green for neighbors
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffc107,
                    emissive: 0x997300,
                    emissiveIntensity: 0.2,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7,
                    polygonOffset: true,
                    polygonOffsetFactor: -0.5,
                    polygonOffsetUnits: -0.5
                });

                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                neighborHighlightMeshes.push(mesh);
            });

            console.log('[CADabra Analysis] Neighbor highlights created:', neighborIds.length);
        }

        // Extract geometry for a specific face
        function extractFaceGeometry(faceId) {
            if (!currentMesh || !currentMesh.userData.faceTriangleMap) return null;

            const faceTriangleMap = currentMesh.userData.faceTriangleMap;
            const indices = currentMesh.geometry.index.array;
            const positions = currentMesh.geometry.attributes.position.array;

            const highlightIndices = [];
            const highlightVertexMap = new Map();
            let highlightVertexCount = 0;

            // Find all triangles belonging to this face
            for (let i = 0; i < faceTriangleMap.length; i++) {
                if (faceTriangleMap[i] === faceId) {
                    const i1 = indices[i * 3];
                    const i2 = indices[i * 3 + 1];
                    const i3 = indices[i * 3 + 2];

                    // Map original indices to new highlight indices
                    for (let idx of [i1, i2, i3]) {
                        if (!highlightVertexMap.has(idx)) {
                            highlightVertexMap.set(idx, highlightVertexCount++);
                        }
                    }

                    highlightIndices.push(
                        highlightVertexMap.get(i1),
                        highlightVertexMap.get(i2),
                        highlightVertexMap.get(i3)
                    );
                }
            }

            if (highlightIndices.length === 0) return null;

            // Create new vertex array
            const highlightVertices = new Float32Array(highlightVertexCount * 3);
            for (let [originalIdx, newIdx] of highlightVertexMap.entries()) {
                highlightVertices[newIdx * 3] = positions[originalIdx * 3];
                highlightVertices[newIdx * 3 + 1] = positions[originalIdx * 3 + 1];
                highlightVertices[newIdx * 3 + 2] = positions[originalIdx * 3 + 2];
            }

            // Create highlight geometry
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(highlightVertices, 3));
            geometry.setIndex(highlightIndices);
            geometry.computeVertexNormals();

            return geometry;
        }

        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            loadingDiv.style.display = 'none';
        }

        function showLoading(message) {
            loadingDiv.innerHTML = `<div>${message}</div>`;
            loadingDiv.style.display = 'block';
            errorDiv.style.display = 'none';
        }

        function fitCameraToModel() {
            if (!currentMesh) return;

            const box = new THREE.Box3().setFromObject(currentMesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

            cameraZ *= 2;

            camera.position.set(center.x + cameraZ, center.y + cameraZ, center.z + cameraZ);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
        }

        // Create B-rep edge lines from analysis data
        function createBRepEdges(edgesData) {
            // Remove existing edge lines
            if (freeEdgesLines) {
                scene.remove(freeEdgesLines);
                freeEdgesLines.geometry.dispose();
                freeEdgesLines.material.dispose();
                freeEdgesLines = null;
            }
            if (sharedEdgesLines) {
                scene.remove(sharedEdgesLines);
                sharedEdgesLines.geometry.dispose();
                sharedEdgesLines.material.dispose();
                sharedEdgesLines = null;
            }
            if (currentEdges) {
                scene.remove(currentEdges);
                if (currentEdges.geometry) currentEdges.geometry.dispose();
                if (currentEdges.material) currentEdges.material.dispose();
                currentEdges = null;
            }

            if (!edgesData || edgesData.length === 0) {
                console.log('[CADabra Analysis] No edge data available');
                return;
            }

            // Separate free and shared edges
            const freeEdgePositions = [];
            const sharedEdgePositions = [];

            for (const edge of edgesData) {
                const positions = edge.is_free ? freeEdgePositions : sharedEdgePositions;
                // Create line segments from polyline points
                for (let i = 0; i < edge.points.length - 1; i++) {
                    positions.push(edge.points[i][0], edge.points[i][1], edge.points[i][2]);
                    positions.push(edge.points[i + 1][0], edge.points[i + 1][1], edge.points[i + 1][2]);
                }
            }

            // Create free edges (red) - these are open boundaries
            if (freeEdgePositions.length > 0) {
                const freeGeom = new THREE.BufferGeometry();
                freeGeom.setAttribute('position', new THREE.Float32BufferAttribute(freeEdgePositions, 3));
                const freeMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
                freeEdgesLines = new THREE.LineSegments(freeGeom, freeMat);
                scene.add(freeEdgesLines);
                console.log('[CADabra Analysis] Created', freeEdgePositions.length / 6, 'free edge segments (red)');
            }

            // Create shared edges (black) - face boundaries
            if (sharedEdgePositions.length > 0) {
                const sharedGeom = new THREE.BufferGeometry();
                sharedGeom.setAttribute('position', new THREE.Float32BufferAttribute(sharedEdgePositions, 3));
                const sharedMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });
                sharedEdgesLines = new THREE.LineSegments(sharedGeom, sharedMat);
                scene.add(sharedEdgesLines);
                console.log('[CADabra Analysis] Created', sharedEdgePositions.length / 6, 'shared edge segments (black)');
            }

            // Store reference for visibility toggle
            currentEdges = sharedEdgesLines;
        }

        // Zoom camera to a specific face
        function zoomToFace(faceId) {
            const faceData = analysisData.faces ? analysisData.faces[faceId] : null;
            if (!faceData || !faceData.centroid) return;

            const center = new THREE.Vector3(
                faceData.centroid[0],
                faceData.centroid[1],
                faceData.centroid[2]
            );

            // Calculate zoom distance from face bbox or use model fraction
            let distance;
            if (faceData.bbox_min && faceData.bbox_max) {
                const faceSize = Math.max(
                    faceData.bbox_max[0] - faceData.bbox_min[0],
                    faceData.bbox_max[1] - faceData.bbox_min[1],
                    faceData.bbox_max[2] - faceData.bbox_min[2]
                );
                distance = faceSize * 3;
            } else {
                // Fallback: use model size fraction
                const box = new THREE.Box3().setFromObject(currentMesh);
                const size = box.getSize(new THREE.Vector3());
                distance = Math.max(size.x, size.y, size.z) * 0.3;
            }

            // Position camera looking at face from current direction
            const dir = camera.position.clone().sub(controls.target).normalize();
            camera.position.copy(center).add(dir.multiplyScalar(distance));
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
        }

        // Set camera to specific view direction
        function setViewDirection(direction) {
            if (!currentMesh) return;

            const box = new THREE.Box3().setFromObject(currentMesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 2;

            const positions = {
                '+X': [center.x + distance, center.y, center.z],
                '-X': [center.x - distance, center.y, center.z],
                '+Y': [center.x, center.y + distance, center.z],
                '-Y': [center.x, center.y - distance, center.z],
                '+Z': [center.x, center.y, center.z + distance],
                '-Z': [center.x, center.y, center.z - distance]
            };

            const pos = positions[direction];
            if (pos) {
                camera.position.set(pos[0], pos[1], pos[2]);
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
            }
        }

        // Settings panel elements
        const settingsOverlay = document.getElementById('settingsOverlay');
        const settingsPanel = document.getElementById('settingsPanel');

        // Store original settings to restore on cancel
        let originalSettings = {};

        function openSettings() {
            originalSettings = {
                serverTessellation: document.getElementById('serverTessellation').checked,
                wireframe: document.getElementById('wireframe').checked,
                showEdges: document.getElementById('showEdges').checked,
                showNeighbors: document.getElementById('showNeighbors').checked,
                linearDeflection: document.getElementById('linearDeflection').value,
                angularDeflection: document.getElementById('angularDeflection').value
            };
            settingsOverlay.classList.add('visible');
            settingsPanel.classList.add('visible');
        }

        function closeSettings() {
            settingsOverlay.classList.remove('visible');
            settingsPanel.classList.remove('visible');
        }

        function restoreSettings() {
            document.getElementById('serverTessellation').checked = originalSettings.serverTessellation;
            document.getElementById('wireframe').checked = originalSettings.wireframe;
            document.getElementById('showEdges').checked = originalSettings.showEdges;
            document.getElementById('showNeighbors').checked = originalSettings.showNeighbors;
            document.getElementById('linearDeflection').value = originalSettings.linearDeflection;
            document.getElementById('angularDeflection').value = originalSettings.angularDeflection;
            document.getElementById('linearValue').textContent = originalSettings.linearDeflection;
            document.getElementById('angularValue').textContent = originalSettings.angularDeflection;

            if (currentMesh) {
                currentMesh.material.wireframe = originalSettings.wireframe;
            }
            // Restore visibility for all edge types
            if (currentEdges) {
                currentEdges.visible = originalSettings.showEdges;
            }
            if (freeEdgesLines) {
                freeEdgesLines.visible = originalSettings.showEdges;
            }
            if (sharedEdgesLines) {
                sharedEdgesLines.visible = originalSettings.showEdges;
            }
        }

        // Settings panel event listeners
        settingsOverlay.addEventListener('click', () => {
            restoreSettings();
            closeSettings();
        });

        document.getElementById('settingsCancel').addEventListener('click', () => {
            restoreSettings();
            closeSettings();
        });

        document.getElementById('settingsApply').addEventListener('click', () => {
            const linearValue = parseFloat(document.getElementById('linearDeflection').value);
            const angularValue = parseFloat(document.getElementById('angularDeflection').value);

            console.log(`[CADabra Analysis] Applying settings: linear=${linearValue}, angular=${angularValue}`);

            window.parent.postMessage({
                type: 'UPDATE_DEFLECTION',
                linear_deflection: linearValue,
                angular_deflection: angularValue
            }, '*');

            closeSettings();
        });

        // Live preview for wireframe and edges
        document.getElementById('wireframe').addEventListener('change', (e) => {
            if (currentMesh) {
                currentMesh.material.wireframe = e.target.checked;
            }
        });

        document.getElementById('showEdges').addEventListener('change', (e) => {
            const visible = e.target.checked;
            if (currentEdges) {
                currentEdges.visible = visible;
            }
            if (freeEdgesLines) {
                freeEdgesLines.visible = visible;
            }
            if (sharedEdgesLines) {
                sharedEdgesLines.visible = visible;
            }
        });

        // Deflection slider updates
        document.getElementById('linearDeflection').addEventListener('input', (e) => {
            document.getElementById('linearValue').textContent = e.target.value;
        });

        document.getElementById('angularDeflection').addEventListener('input', (e) => {
            document.getElementById('angularValue').textContent = e.target.value;
        });

        // Analysis-specific data
        let analysisData = null;
        let nodeId = null;

        // Caching to prevent redundant loading
        let loadedMeshUrl = null;
        let loadedAnalysisUrl = null;
        let isLoading = false;

        // Load pre-tessellated mesh with analysis data
        async function loadCADFileWithAnalysis(meshUrl, analysisUrl, linearDeflection = 0.1, receivedNodeId = null, forceReload = false) {
            nodeId = receivedNodeId;

            // Check if already loading
            if (isLoading) {
                console.log('[CADabra Analysis] Already loading, skipping duplicate request');
                return;
            }

            // Check if same file is already loaded (skip reload unless forced)
            if (!forceReload && loadedMeshUrl === meshUrl && loadedAnalysisUrl === analysisUrl && currentMesh) {
                console.log('[CADabra Analysis] Same file already loaded, skipping reload');
                return;
            }

            isLoading = true;
            showLoading('Loading mesh...');

            try {
                // Fetch analysis JSON first
                console.log('[CADabra Analysis] Fetching analysis data:', analysisUrl);
                const analysisResponse = await fetch(analysisUrl);
                if (!analysisResponse.ok) {
                    throw new Error(`Failed to fetch analysis data: ${analysisResponse.statusText}`);
                }

                analysisData = await analysisResponse.json();
                console.log('[CADabra Analysis] Analysis data loaded:', analysisData.num_faces, 'faces');

                // Log adjacency stats if available
                if (analysisData.adjacency_stats) {
                    console.log('[CADabra Analysis] Adjacency stats:', analysisData.adjacency_stats);
                }

                // Fetch mesh file (VTP or JSON)
                console.log('[CADabra Analysis] Fetching mesh file:', meshUrl);
                const meshResponse = await fetch(meshUrl);
                if (!meshResponse.ok) {
                    throw new Error(`Failed to fetch mesh file: ${meshResponse.statusText}`);
                }

                showLoading('Parsing mesh...');

                let vertices, indices, faceTriangleMap;

                // Extract filename from URL query params to check extension
                const meshFilename = new URL(meshUrl, window.location.origin).searchParams.get('filename') || meshUrl;
                console.log('[CADabra Analysis] Mesh filename:', meshFilename);

                let edgeCounts = [];
                if (meshFilename.endsWith('.vtp')) {
                    // Parse VTP using vtk.js (handles ASCII and binary formats)
                    const arrayBuffer = await meshResponse.arrayBuffer();
                    const result = parseVTP(arrayBuffer);
                    vertices = result.vertices;
                    indices = result.indices;
                    faceTriangleMap = result.faceIds;
                    edgeCounts = result.edgeCounts || [];
                } else {
                    // Parse JSON mesh format
                    const meshData = await meshResponse.json();
                    vertices = meshData.vertices;
                    indices = meshData.indices;

                    // Build face triangle map and edge counts from face_ranges
                    faceTriangleMap = [];
                    edgeCounts = [];
                    for (const range of meshData.face_ranges) {
                        const faceEdgeCount = meshData.face_edge_counts?.[range.face_id] || 0;
                        for (let i = 0; i < range.triangle_count; i++) {
                            faceTriangleMap.push(range.face_id);
                            edgeCounts.push(faceEdgeCount);
                        }
                    }
                }

                // Store edge counts globally for later use
                currentEdgeCounts = edgeCounts;

                console.log('[CADabra Analysis] Mesh loaded:', vertices.length / 3, 'vertices,', indices.length / 3, 'triangles');
                console.log('[CADabra Analysis] Face mapping:', faceTriangleMap.length, 'triangles mapped');

                // Create Three.js geometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                // Remove old mesh if exists
                if (currentMesh) {
                    scene.remove(currentMesh);
                    currentMesh.geometry.dispose();
                    currentMesh.material.dispose();
                }
                if (currentEdges) {
                    scene.remove(currentEdges);
                    currentEdges.geometry.dispose();
                    currentEdges.material.dispose();
                }
                clearFaceSelection();

                // Apply edge count heatmap colors if in heatmap mode
                let material;
                if (currentVisualizationMode === 'edge_count_heatmap' && edgeCounts.length > 0) {
                    // Compute min/max edge counts for normalization (loop to avoid stack overflow)
                    let minEdgeCount = Infinity, maxEdgeCount = -Infinity;
                    for (const count of edgeCounts) {
                        if (count < minEdgeCount) minEdgeCount = count;
                        if (count > maxEdgeCount) maxEdgeCount = count;
                    }
                    console.log('[CADabra Analysis] Edge count range:', minEdgeCount, '-', maxEdgeCount);

                    // Create per-vertex colors (3 colors per triangle, 3 vertices per triangle)
                    const numTriangles = indices.length / 3;
                    const colors = new Float32Array(vertices.length);  // Same size as vertices

                    // Build vertex-to-color mapping from triangles
                    for (let triIdx = 0; triIdx < numTriangles; triIdx++) {
                        const edgeCount = edgeCounts[triIdx] || 0;
                        const color = edgeCountToColor(edgeCount, minEdgeCount, maxEdgeCount);

                        // Get the 3 vertex indices for this triangle
                        const v0 = indices[triIdx * 3];
                        const v1 = indices[triIdx * 3 + 1];
                        const v2 = indices[triIdx * 3 + 2];

                        // Set colors for each vertex (may overwrite, but same face = same color)
                        colors[v0 * 3] = color.r; colors[v0 * 3 + 1] = color.g; colors[v0 * 3 + 2] = color.b;
                        colors[v1 * 3] = color.r; colors[v1 * 3 + 1] = color.g; colors[v1 * 3 + 2] = color.b;
                        colors[v2 * 3] = color.r; colors[v2 * 3 + 1] = color.g; colors[v2 * 3 + 2] = color.b;
                    }

                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                    material = new THREE.MeshPhongMaterial({
                        vertexColors: true,
                        side: THREE.DoubleSide,
                        flatShading: false,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
                } else if (currentVisualizationMode === 'connectivity_inspection') {
                    // Connectivity inspection mode - color by neighbor count
                    const numTriangles = indices.length / 3;

                    // Build face ID â†’ neighbor count mapping from analysis data
                    const faceNeighborCounts = {};
                    if (analysisData && analysisData.faces) {
                        for (const face of analysisData.faces) {
                            faceNeighborCounts[face.face_id] = (face.adjacent_faces || []).length;
                        }
                    }

                    // Compute min/max neighbor counts for normalization (loop to avoid stack overflow)
                    const neighborCounts = Object.values(faceNeighborCounts);
                    let minNeighbors = Infinity, maxNeighbors = -Infinity;
                    for (const count of neighborCounts) {
                        if (count < minNeighbors) minNeighbors = count;
                        if (count > maxNeighbors) maxNeighbors = count;
                    }
                    if (neighborCounts.length === 0) {
                        minNeighbors = 0;
                        maxNeighbors = 0;
                    }
                    console.log('[CADabra Analysis] Neighbor count range:', minNeighbors, '-', maxNeighbors);

                    // Create per-vertex colors
                    const colors = new Float32Array(vertices.length);

                    for (let triIdx = 0; triIdx < numTriangles; triIdx++) {
                        const faceId = faceTriangleMap[triIdx];
                        const neighborCount = faceNeighborCounts[faceId] || 0;
                        const color = neighborCountToColor(neighborCount, minNeighbors, maxNeighbors);

                        const v0 = indices[triIdx * 3];
                        const v1 = indices[triIdx * 3 + 1];
                        const v2 = indices[triIdx * 3 + 2];

                        colors[v0 * 3] = color.r; colors[v0 * 3 + 1] = color.g; colors[v0 * 3 + 2] = color.b;
                        colors[v1 * 3] = color.r; colors[v1 * 3 + 1] = color.g; colors[v1 * 3 + 2] = color.b;
                        colors[v2 * 3] = color.r; colors[v2 * 3 + 1] = color.g; colors[v2 * 3 + 2] = color.b;
                    }

                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                    material = new THREE.MeshPhongMaterial({
                        vertexColors: true,
                        side: THREE.DoubleSide,
                        flatShading: false,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
                } else {
                    // Normal mode - single color
                    material = new THREE.MeshPhongMaterial({
                        color: 0x88ccff,
                        side: THREE.DoubleSide,
                        flatShading: false,
                        polygonOffset: true,
                        polygonOffsetFactor: 1,
                        polygonOffsetUnits: 1
                    });
                }

                currentMesh = new THREE.Mesh(geometry, material);
                currentMesh.userData.faceTriangleMap = faceTriangleMap;
                currentMesh.userData.edgeCounts = edgeCounts;  // Store for later use
                scene.add(currentMesh);

                // Create B-rep edges from analysis data (free edges in red, shared in black)
                createBRepEdges(analysisData.edges);

                // Fit camera to model
                fitCameraToModel();

                // Cache the loaded URLs to prevent redundant reloads
                loadedMeshUrl = meshUrl;
                loadedAnalysisUrl = analysisUrl;

                loadingDiv.style.display = 'none';
                console.log('[CADabra Analysis] Mesh loaded successfully with analysis data');

            } catch (error) {
                console.error('[CADabra Analysis] Error loading mesh:', error);
                showError('Failed to load mesh: ' + error.message);
            } finally {
                isLoading = false;
            }
        }

        // Load mesh without analysis data (simple preview mode)
        async function loadMeshOnly(meshUrl, linearDeflection = 0.1, receivedNodeId = null) {
            nodeId = receivedNodeId;

            // Check if already loading
            if (isLoading) {
                console.log('[CADabra Analysis] Already loading, skipping duplicate request');
                return;
            }

            // Check if same file is already loaded
            if (loadedMeshUrl === meshUrl && currentMesh) {
                console.log('[CADabra Analysis] Same file already loaded, skipping reload');
                return;
            }

            isLoading = true;
            showLoading('Loading mesh...');

            try {
                // Clear analysis data for simple preview
                analysisData = null;

                // Fetch mesh file (VTP or JSON)
                console.log('[CADabra Analysis] Fetching mesh file:', meshUrl);
                const meshResponse = await fetch(meshUrl);
                if (!meshResponse.ok) {
                    throw new Error(`Failed to fetch mesh file: ${meshResponse.statusText}`);
                }

                showLoading('Parsing mesh...');

                let vertices, indices, faceTriangleMap;

                // Extract filename from URL query params to check extension
                const meshFilename = new URL(meshUrl, window.location.origin).searchParams.get('filename') || meshUrl;
                console.log('[CADabra Analysis] Mesh filename:', meshFilename);

                if (meshFilename.endsWith('.vtp')) {
                    // Parse VTP using vtk.js
                    const arrayBuffer = await meshResponse.arrayBuffer();
                    const result = parseVTP(arrayBuffer);
                    vertices = result.vertices;
                    indices = result.indices;
                    faceTriangleMap = result.faceIds || [];
                } else {
                    // Parse JSON mesh format
                    const meshData = await meshResponse.json();
                    vertices = meshData.vertices;
                    indices = meshData.indices;

                    // Build face triangle map from face_ranges
                    faceTriangleMap = [];
                    for (const range of meshData.face_ranges || []) {
                        for (let i = 0; i < range.triangle_count; i++) {
                            faceTriangleMap.push(range.face_id);
                        }
                    }
                }

                console.log('[CADabra Analysis] Mesh loaded:', vertices.length / 3, 'vertices,', indices.length / 3, 'triangles');

                // Create Three.js geometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                // Remove old mesh if exists
                if (currentMesh) {
                    scene.remove(currentMesh);
                    currentMesh.geometry.dispose();
                    currentMesh.material.dispose();
                }
                if (currentEdges) {
                    scene.remove(currentEdges);
                    currentEdges.geometry.dispose();
                    currentEdges.material.dispose();
                    currentEdges = null;
                }
                clearFaceSelection();

                // Simple material for preview
                const material = new THREE.MeshPhongMaterial({
                    color: 0x88ccff,
                    side: THREE.DoubleSide,
                    flatShading: false,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1
                });

                currentMesh = new THREE.Mesh(geometry, material);
                currentMesh.userData.faceTriangleMap = faceTriangleMap;
                scene.add(currentMesh);

                // Create wireframe edges for preview
                const edgeGeometry = new THREE.EdgesGeometry(geometry, 30);
                const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
                currentEdges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                scene.add(currentEdges);

                // Fit camera to model
                fitCameraToModel();

                // Cache the loaded URL
                loadedMeshUrl = meshUrl;
                loadedAnalysisUrl = null;

                loadingDiv.style.display = 'none';
                console.log('[CADabra Analysis] Mesh loaded successfully (preview mode)');

            } catch (error) {
                console.error('[CADabra Analysis] Error loading mesh:', error);
                showError('Failed to load mesh: ' + error.message);
            } finally {
                isLoading = false;
            }
        }

        // Parse VTP (VTK XML PolyData) format using vtk.js
        function parseVTP(arrayBuffer) {
            const reader = vtkXMLPolyDataReader.newInstance();
            reader.parseAsArrayBuffer(arrayBuffer);
            const polydata = reader.getOutputData(0);

            if (!polydata) {
                throw new Error('Failed to parse VTP data');
            }

            // Extract vertices
            const points = polydata.getPoints();
            const vertices = Array.from(points.getData());

            // Extract triangle indices from polys
            const polys = polydata.getPolys();
            const polysData = polys.getData();
            const indices = [];
            let i = 0;
            while (i < polysData.length) {
                const npts = polysData[i++];
                if (npts === 3) {
                    // Triangle
                    indices.push(polysData[i], polysData[i+1], polysData[i+2]);
                }
                i += npts;
            }

            // Extract FaceID cell data
            const cellData = polydata.getCellData();
            const faceIdArray = cellData.getArrayByName('FaceID');
            const faceIds = faceIdArray ? Array.from(faceIdArray.getData()) : [];

            // Extract EdgeCount cell data
            const edgeCountArray = cellData.getArrayByName('EdgeCount');
            const edgeCounts = edgeCountArray ? Array.from(edgeCountArray.getData()) : [];

            console.log('[CADabra Analysis] VTP parsed:', vertices.length / 3, 'vertices,', indices.length / 3, 'triangles,', faceIds.length, 'face IDs,', edgeCounts.length, 'edge counts');

            return { vertices, indices, faceIds, edgeCounts };
        }

        // Convert edge count to heatmap color (green -> yellow -> red)
        function edgeCountToColor(count, minCount, maxCount) {
            if (maxCount <= minCount) return new THREE.Color(0, 1, 0); // All green if no variation
            const t = (count - minCount) / (maxCount - minCount);
            // Green (0,1,0) -> Yellow (1,1,0) -> Red (1,0,0)
            if (t < 0.5) {
                return new THREE.Color(t * 2, 1, 0);
            } else {
                return new THREE.Color(1, 1 - (t - 0.5) * 2, 0);
            }
        }

        // Convert neighbor count to heatmap color (red -> yellow -> green)
        // Inverse of edge count: more neighbors = better connectivity = green
        function neighborCountToColor(count, minCount, maxCount) {
            if (maxCount <= minCount) return new THREE.Color(1, 0, 0); // All red if no variation (all isolated)
            const t = (count - minCount) / (maxCount - minCount);
            // Red (1,0,0) -> Yellow (1,1,0) -> Green (0,1,0)
            if (t < 0.5) {
                return new THREE.Color(1, t * 2, 0);
            } else {
                return new THREE.Color(1 - (t - 0.5) * 2, 1, 0);
            }
        }

        // Listen for messages from parent window
        window.addEventListener('message', (event) => {
            console.log('[CADabra Analysis] Received message:', event.data);

            if (event.data.type === 'OPEN_SETTINGS') {
                openSettings();
                return;
            }

            if (event.data.type === 'FIT_VIEW') {
                fitCameraToModel();
                return;
            }

            if (event.data.type === 'SET_VIEW') {
                setViewDirection(event.data.direction);
                return;
            }

            if (event.data.type === 'LOAD_CAD_ANALYSIS') {
                // Support both old (stepUrl) and new (meshUrl) formats
                const meshUrl = event.data.meshUrl || event.data.stepUrl;
                const { analysisUrl, linearDeflection, nodeId: receivedNodeId, visualizationMode } = event.data;

                // Update visualization mode if provided
                if (visualizationMode) {
                    currentVisualizationMode = visualizationMode;
                    console.log('[CADabra Analysis] Visualization mode:', currentVisualizationMode);
                }

                if (meshUrl && analysisUrl) {
                    console.log('[CADabra Analysis] Loading mesh with analysis data');
                    loadCADFileWithAnalysis(meshUrl, analysisUrl, linearDeflection, receivedNodeId);
                } else if (meshUrl) {
                    // Simple preview mode - load mesh without analysis
                    console.log('[CADabra Analysis] Loading mesh without analysis (preview mode)');
                    loadMeshOnly(meshUrl, linearDeflection, receivedNodeId);
                } else {
                    showError('No mesh data available to load');
                }
            } else if (event.data.type === 'DESELECT_FACE') {
                clearFaceSelection();
            } else if (event.data.type === 'SELECT_FACE_BY_ID') {
                const faceId = event.data.faceId;
                if (!analysisData || !analysisData.faces) {
                    alert('No model loaded. Please load a CAD model first.');
                    return;
                }
                const numFaces = analysisData.num_faces || analysisData.faces.length;
                if (faceId < 0 || faceId >= numFaces) {
                    alert(`Face ID ${faceId} not found (model has ${numFaces} faces, IDs 0-${numFaces - 1})`);
                    return;
                }
                selectFace(faceId);
                zoomToFace(faceId);
            }
        });

        // Initialize everything
        initScene();
        loadingDiv.style.display = 'none';

        console.log('[CADabra Analysis] Viewer initialized and ready');
    </script>
</body>
</html>
