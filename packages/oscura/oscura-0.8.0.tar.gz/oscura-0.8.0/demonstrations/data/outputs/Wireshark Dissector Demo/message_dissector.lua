-- message_proto.lua
-- Generated by Oscura on 2026-01-27T16:58:11.356242+00:00
--
-- Protocol: Variable-length message protocol
-- Version: 2.0
-- Endianness: little


-- Protocol declaration
local message_proto_proto = Proto("message_proto", "Variable-length message protocol")

-- Field declarations

local f_sync = ProtoField.bytes(
    "message_proto.sync",
    "Sync pattern",
    base.NONE
)

local f_msg_type = ProtoField.uint8(
    "message_proto.msg_type",
    "Message type",
    base.HEX, {[0] = "Heartbeat", [1] = "Request", [2] = "Response", [3] = "Notification", [255] = "Error"}
)

local f_sequence = ProtoField.uint16(
    "message_proto.sequence",
    "Sequence number",
    base.HEX
)

local f_payload_length = ProtoField.uint16(
    "message_proto.payload_length",
    "Payload length",
    base.HEX
)

local f_payload = ProtoField.bytes(
    "message_proto.payload",
    "Message payload",
    base.NONE
)

local f_crc16 = ProtoField.uint16(
    "message_proto.crc16",
    "CRC-16 checksum",
    base.HEX
)


-- Register fields
message_proto_proto.fields = { f_sync, f_msg_type, f_sequence, f_payload_length, f_payload, f_crc16 }

-- Dissector function
function message_proto_proto.dissector(buffer, pinfo, tree)
    local pktlen = buffer:len()

    -- Check minimum length
    if pktlen < 9 then
        return 0  -- Not enough data
    end

    -- Set protocol column
    pinfo.cols.protocol = message_proto_proto.name

    -- Create protocol subtree
    local subtree = tree:add(message_proto_proto, buffer(), "Variable-length message protocol")
    local offset = 0

    -- Decode fields



    -- Fixed-length field: sync (2 bytes)
    if offset + 2 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated sync")
        return pktlen
    end
    subtree:add(f_sync, buffer(offset, 2))
    offset = offset + 2





    -- Fixed-length field: msg_type (1 bytes)
    if offset + 1 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated msg_type")
        return pktlen
    end
    subtree:add(f_msg_type, buffer(offset, 1))
    offset = offset + 1





    -- Fixed-length field: sequence (2 bytes)
    if offset + 2 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated sequence")
        return pktlen
    end
    subtree:add(f_sequence, buffer(offset, 2))
    offset = offset + 2





    -- Fixed-length field: payload_length (2 bytes)
    if offset + 2 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated payload_length")
        return pktlen
    end
    subtree:add(f_payload_length, buffer(offset, 2))
    offset = offset + 2





    -- Variable-length field: payload

    local payload_len = buffer(5, 2):le_uint16()
    if offset + payload_len > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated payload")
        return pktlen
    end
    subtree:add(f_payload, buffer(offset, payload_len))
    offset = offset + payload_len






    -- Fixed-length field: crc16 (2 bytes)
    if offset + 2 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated crc16")
        return pktlen
    end
    subtree:add(f_crc16, buffer(offset, 2))
    offset = offset + 2



    return offset
end

-- Protocol registration

-- Register on TCP port 9999
local tcp_table = DissectorTable.get("tcp.port")
tcp_table:add(9999, message_proto_proto)
