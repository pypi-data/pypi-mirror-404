-- sensor_proto.lua
-- Generated by Oscura on 2026-01-27T22:14:12.130504+00:00
--
-- Protocol: Simple sensor data protocol
-- Version: 1.0
-- Endianness: big


-- Protocol declaration
local sensor_proto_proto = Proto("sensor_proto", "Simple sensor data protocol")

-- Field declarations

local f_magic = ProtoField.uint16(
    "sensor_proto.magic",
    "Protocol magic number",
    base.HEX
)

local f_version = ProtoField.uint8(
    "sensor_proto.version",
    "Protocol version",
    base.HEX
)

local f_sensor_type = ProtoField.uint8(
    "sensor_proto.sensor_type",
    "Sensor type",
    base.HEX, {[1] = "Temperature", [2] = "Humidity", [3] = "Pressure", [4] = "Light"}
)

local f_sensor_id = ProtoField.uint16(
    "sensor_proto.sensor_id",
    "Sensor device ID",
    base.HEX
)

local f_timestamp = ProtoField.uint32(
    "sensor_proto.timestamp",
    "Unix timestamp",
    base.HEX
)

local f_value = ProtoField.float(
    "sensor_proto.value",
    "Sensor reading",
    base.NONE
)

local f_checksum = ProtoField.uint8(
    "sensor_proto.checksum",
    "XOR checksum",
    base.HEX
)


-- Register fields
sensor_proto_proto.fields = { f_magic, f_version, f_sensor_type, f_sensor_id, f_timestamp, f_value, f_checksum }

-- Dissector function
function sensor_proto_proto.dissector(buffer, pinfo, tree)
    local pktlen = buffer:len()

    -- Check minimum length
    if pktlen < 15 then
        return 0  -- Not enough data
    end

    -- Set protocol column
    pinfo.cols.protocol = sensor_proto_proto.name

    -- Create protocol subtree
    local subtree = tree:add(sensor_proto_proto, buffer(), "Simple sensor data protocol")
    local offset = 0

    -- Decode fields



    -- Fixed-length field: magic (2 bytes)
    if offset + 2 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated magic")
        return pktlen
    end
    subtree:add(f_magic, buffer(offset, 2))
    offset = offset + 2





    -- Fixed-length field: version (1 bytes)
    if offset + 1 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated version")
        return pktlen
    end
    subtree:add(f_version, buffer(offset, 1))
    offset = offset + 1





    -- Fixed-length field: sensor_type (1 bytes)
    if offset + 1 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated sensor_type")
        return pktlen
    end
    subtree:add(f_sensor_type, buffer(offset, 1))
    offset = offset + 1





    -- Fixed-length field: sensor_id (2 bytes)
    if offset + 2 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated sensor_id")
        return pktlen
    end
    subtree:add(f_sensor_id, buffer(offset, 2))
    offset = offset + 2





    -- Fixed-length field: timestamp (4 bytes)
    if offset + 4 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated timestamp")
        return pktlen
    end
    subtree:add(f_timestamp, buffer(offset, 4))
    offset = offset + 4





    -- Fixed-length field: value (4 bytes)
    if offset + 4 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated value")
        return pktlen
    end
    subtree:add(f_value, buffer(offset, 4))
    offset = offset + 4





    -- Fixed-length field: checksum (1 bytes)
    if offset + 1 > pktlen then
        subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Truncated checksum")
        return pktlen
    end
    subtree:add(f_checksum, buffer(offset, 1))
    offset = offset + 1



    return offset
end

-- Protocol registration

-- Register on UDP port 12345
local udp_table = DissectorTable.get("udp.port")
udp_table:add(12345, sensor_proto_proto)
