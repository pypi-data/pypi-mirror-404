-- Wireshark dissector for unknown proprietary protocol
-- Generated by Oscura reverse engineering framework
-- Sync pattern: 0xAA55

unknown_proto = Proto("unknown", "Unknown Proprietary Protocol")

-- Fields
local f_sync = ProtoField.uint16("unknown.sync", "Sync", base.HEX)
local f_length = ProtoField.uint16("unknown.length", "Length", base.DEC)
local f_type = ProtoField.uint8("unknown.type", "Type", base.HEX)
local f_payload = ProtoField.bytes("unknown.payload", "Payload")
local f_crc = ProtoField.uint16("unknown.crc", "CRC", base.HEX)

unknown_proto.fields = {f_sync, f_length, f_type, f_payload, f_crc}

-- Message type names
local msg_types = {
    [0x10] = "STATUS",
    [0x20] = "SENSOR_DATA",
    [0x30] = "COMMAND",
    [0x40] = "RESPONSE",
    [0x50] = "ERROR",
}}

function unknown_proto.dissector(buffer, pinfo, tree)
    local length = buffer:len()
    if length < 7 then return end

    pinfo.cols.protocol = unknown_proto.name
    local subtree = tree:add(unknown_proto, buffer(), "Unknown Protocol Data")

    -- Parse fields
    subtree:add(f_sync, buffer(0, 2))
    subtree:add(f_length, buffer(2, 2))
    local msg_type = buffer(4, 1):uint()
    subtree:add(f_type, buffer(4, 1))

    -- Add type name to info
    local type_name = msg_types[msg_type] or "UNKNOWN"
    pinfo.cols.info = string.format("Type: %s (0x%02X)", type_name, msg_type)

    -- Payload
    local payload_len = length - 7
    if payload_len > 0 then
        subtree:add(f_payload, buffer(5, payload_len))
    end

    -- CRC
    subtree:add(f_crc, buffer(length - 2, 2))
end

-- Register dissector
local udp_port = DissectorTable.get("udp.port")
udp_port:add(12345, unknown_proto)
