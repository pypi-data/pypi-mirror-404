{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MARGARITA","text":"<p>MARGARITA is a lightweight templating tool for building prompt and markdown templates with metadata, context, and simple control flow.</p> <p>Key features</p> <ul> <li>Simple variable substitution with JSON contexts</li> <li>Template metadata for task information</li> <li>Conditionals and loops for dynamic sections</li> <li>Include files to compose templates across multiple fragments</li> <li>CLI for rendering and metadata inspection (<code>margarita render</code>, <code>margarita metadata</code>)</li> </ul> <p>Quick example</p> <p>Create <code>hello.mg</code> containing:</p> <pre><code>Hello, {{name}}!\n</code></pre> <p>Render with a JSON context:</p> <pre><code>margarita render hello.mg -c '{\"name\": \"World\"}'\n</code></pre> <p>Rendered result</p> <p>Given the template above and the context <code>{\"name\": \"World\"}</code>, the rendered output will be:</p> <pre><code>Hello, World!\n</code></pre> <p>See also: <code>Getting Started</code>, <code>Language Reference</code> pages (Contexts, Metadata, Conditionals, Loops, Include Files).</p>"},{"location":"basic/","title":"Basic Python Usage","text":"<p>First, import the necessary components:</p> <pre><code>from pathlib import Path\nfrom margarita.parser import Parser\nfrom margarita.renderer import Renderer\n</code></pre> <p>Render a template programmatically:</p> <pre><code># Define your template\ntemplate = \"\"\"\n&lt;&lt;\nYou are a helpful assistant.\n\n### This is markdown like syntax and supports markdown features.\nI'm a list of things:\n- Item 1\n- Item 2\n- Item 3\n\nYou can insert variables with the dollar sign\nTask: ${task}\n&gt;&gt;\n\n&lt;&lt; Markdown can be in a single line like this too &gt;&gt;\n\n// Comments are supported like this and ignored during rendering\n// Conditional blocks are supported\nif context:\n    &lt;&lt;\n    Context:\n        ${context}\n    &gt;&gt;\n\n// Loops are supported\nfor item in items:\n    &lt;&lt; Item=${item} &gt;&gt;\n\"\"\"\n\n# Parse the template\nparser = Parser()\nmetadata, nodes = parser.parse(template)\n\n# Create a renderer with context\nrenderer = Renderer(context={\n    \"task\": \"Summarize the key points\",\n    \"context\": \"User is researching AI agents\"\n})\n\n# Render the output\nprompt = renderer.render(nodes)\nprint(prompt)\n</code></pre>"},{"location":"conditionals/","title":"Conditionals","text":"<p>Use conditionals to render sections conditionally based on context values.</p> <p>Syntax</p> <pre><code>if subscribed:\n    &lt;&lt; Thanks for subscribing, ${name}! &gt;&gt;\nelse:\n    &lt;&lt;&lt; Please consider subscribing. &gt;&gt;\n</code></pre> <p>Rendered results</p> <ul> <li>When <code>subscribed</code> is true and <code>name</code> is <code>Dana</code>:</li> </ul> <pre><code>Thanks for subscribing, Dana!\n</code></pre> <ul> <li>When <code>subscribed</code> is false or missing:</li> </ul> <pre><code>Please consider subscribing.\n</code></pre> <p>Notes</p> <ul> <li>Conditions evaluate truthiness: missing, false, empty, or null values are treated as false.</li> <li>You can reference nested values with dotted paths, e.g. <code>user.active</code>.</li> <li>There is no support for complex expressions \u2014 stick to presence and simple boolean checks.</li> </ul> <p>Tip: Use <code>margarita metadata</code> or a dry render to ensure required context keys are present before running in production.</p>"},{"location":"contexts/","title":"Contexts","text":"<p>Contexts are plain JSON objects that supply variables to templates. Keys map to template variables and can include nested objects and arrays.</p> <p>Example context</p> <pre><code>{\n  \"name\": \"Batman\",\n  \"user\": { \"id\": 42, \"active\": true },\n  \"items\": [\"a\", \"b\", \"c\"]\n}\n</code></pre> <p>Rendered result</p> <p>Given the following template:</p> <pre><code>&lt;&lt;\nHello, ${name}! (id=${user.id}, active=${user.active})\n&gt;&gt;\n</code></pre> <p>Rendering with the example context produces:</p> <pre><code>Hello, Batman! (id=42, active=True)\n</code></pre> <p>See also: <code>Metadata</code> page for template header metadata and usage.</p> <p>Behavior and precedence</p> <ul> <li>CLI <code>-c</code> (inline JSON) and <code>-f</code> (context file) override auto-detected context files.</li> <li>When rendering a single template, MARGARITA looks for a sibling <code>.json</code> file with the same base name.</li> <li>Metadata is parsed from the template and can be shown with <code>margarita render --show-metadata</code> or <code>margarita metadata</code>.</li> </ul> <p>Tip: Keep contexts explicit and small; prefer using a context file in CI to ensure reproducible renders.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>Run the following command to install MARGARITA via pip:</p> <p>A minimal walkthrough to render your first MARGARITA template.</p> <ol> <li>Create a template file <code>greeting.mg</code>:</li> </ol> <pre><code>&lt;&lt;\nHello, ${name}!\n&gt;&gt;\n</code></pre> <ol> <li>Provide a context (JSON) either inline or in a file <code>greeting.json</code>:</li> </ol> <pre><code>{\"name\": \"Batman\"}\n</code></pre> <ol> <li>Render the template with the CLI:</li> </ol> <pre><code>margarita render greeting.mg -f greeting.json\n</code></pre> <p>Rendered result</p> <p>Using the template and context above the output will be:</p> <pre><code>Hello, Batman!\n</code></pre> <p>Alternate options</p> <ul> <li>Pass context as a JSON string: <code>-c '{\"name\": \"Bob\"}'</code></li> <li>Render a directory of <code>.mg</code> files: <code>margarita render templates/ -o output/</code></li> <li>Inspect template metadata before rendering: <code>margarita render template.mg --show-metadata</code></li> </ul> <p>Tip: When rendering a single file, MARGARITA will auto-detect a same-name <code>.json</code> file (e.g. <code>greeting.json</code>) if no context is supplied. </p>"},{"location":"include_files/","title":"Include Files","text":"<p>Reuse template fragments using <code>[[ file ]]</code>. Includes are resolved relative to the including template's directory.</p> <p>Example</p> <pre><code>// filename: header.mg\n&lt;&lt;This is the header content.&gt;&gt;\n</code></pre> <pre><code>// filename: page.mg\n[[ header ]]\n&lt;&lt;\n# Page Title\n\nContent goes here using the same context.\n&gt;&gt;\n</code></pre> <p>Rendered result</p> <p>When rendering <code>page.mg</code>, the output will include the header content followed by the page body:</p> <pre><code>This is the header content.\n\n# Page Title\n\nContent goes here using the same context.\n</code></pre> <p>Behavior</p> <ul> <li>Included files have access to the same rendering context as the parent template.</li> <li>Paths are resolved relative to the parent template's directory (the CLI and renderer set <code>base_path</code>).</li> <li>Avoid circular includes; they can cause infinite loops or errors.</li> </ul>"},{"location":"include_files/#using-includes-in-python-api","title":"Using Includes in Python API","text":"<p>When using MARGARITA programmatically, you must set the <code>base_path</code> when creating the renderer. All include paths are resolved relative to this base path, not relative to the file doing the including.</p> <pre><code>from pathlib import Path\nfrom margarita.parser import Parser\nfrom margarita.renderer import Renderer\n\n# Parse your template\nparser = Parser()\ntemplate = '[[ header ]]\\n\\nMain content here.'\n_, nodes = parser.parse(template)\n\n# Set base_path - all includes resolve from here\nrenderer = Renderer(\n    context={\"title\": \"My Page\"},\n    base_path=Path(\"./templates\")  # header.mg will be loaded from ./templates/header.mg\n)\n\noutput = renderer.render(nodes)\n</code></pre> <p>Important: Even in nested includes, all paths are from <code>base_path</code>. If <code>snippets/section.mg</code> includes another file, it must use the full path from <code>base_path</code>:</p> <pre><code>[[ snippets/subsection ]]  {# NOT just \"subsection\" #}\n</code></pre> <p>See the Using Includes page for comprehensive examples and patterns.</p> <p>Tip: Use includes for headers, footers, and small shared components to keep templates DRY and maintainable.</p>"},{"location":"includes/","title":"Using Includes in Python API","text":"<p>MARGARITA's include functionality allows you to compose templates from reusable snippets, making it easy to build modular, maintainable prompt libraries.</p>"},{"location":"includes/#basic-include-usage","title":"Basic Include Usage","text":"<p>Margarita supports including other template files using the <code>[[ filename ]]</code> syntax. When the renderer encounters this directive, it loads and renders the specified file, inserting its content into the current template.</p> <p>You can also pass parameters to the included template by specifying them as key-value pairs:</p> <pre><code>//filename: main.mg\nWelcome to the system!\n[[ header is_admin=True show_menu=False ]]\n</code></pre> <pre><code>//filename: header.mg\nUser Admin Status: ${is_admin}\nMenu Visible: ${show_menu}\n</code></pre> <p>This will render as:</p> <pre><code>Welcome to the system!\nUser Admin Status: True\nMenu Visible: False\n</code></pre>"},{"location":"includes/#supported-parameter-types","title":"Supported Parameter Types","text":"<p>Currently, we only support string or boolean parameters. </p>"},{"location":"includes/#setting-up-the-renderer","title":"Setting Up the Renderer","text":"<p>The key to using includes is setting the <code>base_path</code> parameter when creating a <code>Renderer</code>. This tells MARGARITA where to resolve relative include paths:</p> <pre><code>from pathlib import Path\nfrom margarita.parser import Parser\nfrom margarita.renderer import Renderer\n\n# Define base path for includes\ntemplate_dir = Path(\"./templates\")\n\n# Parse your main template\nparser = Parser()\ntemplate_content = \"\"\"\n[[ header ]]\n\nMain content here.\n\n[[ footer ]]\n\"\"\"\n\nmetadata, nodes = parser.parse(template_content)\n\n# Create renderer with base_path\nrenderer = Renderer(\n    context={\"app_name\": \"MyApp\"},\n    base_path=template_dir\n)\n\n# Render - includes will be resolved relative to base_path\noutput = renderer.render(nodes)\n</code></pre>"},{"location":"includes/#nested-includes","title":"Nested Includes","text":"<p>Includes can reference other includes, creating a hierarchy of snippets. Important: All include paths are always resolved relative to the <code>base_path</code> set in the renderer, not relative to the file doing the including.</p>"},{"location":"includes/#understanding-base-path-resolution","title":"Understanding Base Path Resolution","text":"<p>Given this directory structure:</p> <pre><code>templates/\n  main.mg\n  snippets/\n    complete_prompt.mg\n    header_section.mg\n    system_role.mg\n    safety_guidelines.mg\n    body_section.mg\n    footer_section.mg\n</code></pre> <p>templates/snippets/complete_prompt.mg: <pre><code>[[ snippets/header_section ]]\n\n[[ snippets/body_section ]]\n\n[[ snippets/footer_section ]]\n</code></pre></p> <p>templates/snippets/header_section.mg: <pre><code>[[ snippets/system_role ]]\n\n[[ snippets/safety_guidelines ]]\n</code></pre></p> <p>Notice that even though <code>header_section.mg</code> is in the <code>snippets/</code> directory, it still uses <code>\"snippets/system_role.mg\"</code> in its include statement, not just <code>\"system_role.mg\"</code>. This is because all paths are resolved from <code>base_path</code>.</p>"},{"location":"includes/#practical-tip-organizing-nested-structures","title":"Practical Tip: Organizing Nested Structures","text":"<p>Use consistent path prefixes to make nested includes clear:</p> <pre><code>templates/\n  prompts/\n    agent/\n      researcher.mg    -&gt; includes \"components/agent/...\"\n      analyzer.mg      -&gt; includes \"components/agent/...\"\n  components/\n    agent/\n      role.mg          -&gt; includes \"atoms/agent/...\"\n      tools.mg         -&gt; includes \"atoms/agent/...\"\n  atoms/\n    agent/\n      identity.mg\n      capabilities.mg\n</code></pre> <p>This structure makes it obvious that all includes use the full path from <code>templates/</code>.</p>"},{"location":"includes/#real-world-example-multi-agent-system","title":"Real-World Example: Multi-Agent System","text":"<pre><code>//filename: prompts/agent/researcher.mg\nYou are a Researcher Agent.\n\nYou have access to the following tools:\n- Web Search\n- Database Query\n\nOutput your findings in a structured report.\n</code></pre> <pre><code>//filename: prompts/agent/analyzer.mg\nYou are an Analyzer Agent. You analyze data provided by other agents.\n\nUse statistical methods and visualization tools to derive insights.\n</code></pre> <pre><code>//filename: agent_router.mg\n\nif type == \"researcher\":\n    [[ prompts/agent/researcher ]]\nelif type == \"analyzer\":\n    [[ prompts/agent/analyzer ]]\nelse:\n    &lt;&lt;You are a General Agent. Adapt to any task given.&gt;&gt;\n</code></pre> <pre><code>from pathlib import Path\nfrom margarita.parser import Parser\nfrom margarita.renderer import Renderer\n\n# Define base path for includes\ntemplate_dir = Path(\"./templates\")\n\n# Parse your main template\nparser = Parser()\ntemplate_content = \"\"\"[[ agent_router ]]\"\"\"\nmetadata, nodes = parser.parse(template_content)\n\n# Create renderer with base_path\nrenderer = Renderer(\n    context={\"type\": \"researcher\"},\n    base_path=template_dir\n)\n</code></pre>"},{"location":"jetbrains_plugin/","title":"Margarita JetBrains Plugin","text":"<p>This page documents the Margarita JetBrains plugin (source and releases: https://github.com/Banyango/margarita-jetbrains-plugin). It provides IDE integration for Margarita files inside JetBrains IDEs (IntelliJ IDEA, PyCharm, CLion, WebStorm, etc.).</p> <p>Note: This page is a general README-style guide. For authoritative and up-to-date details (release downloads, exact features, license), see the plugin repository: https://github.com/Banyango/margarita-jetbrains-plugin</p>"},{"location":"jetbrains_plugin/#quick-overview","title":"Quick overview","text":"<p>The Margarita JetBrains plugin adds first-class support for the Margarita language and related file types in JetBrains IDEs. Typical features provided by language plugins include:</p> <ul> <li>Syntax highlighting for Margarita source files</li> <li>File type association (e.g. .mg or .margarita files)</li> <li>Basic code completion and templates</li> <li>Run/debug configurations or integration for running Margarita scripts inside the IDE</li> <li>Project templates or file templates for starting new Margarita projects</li> </ul>"},{"location":"loops/","title":"Loops","text":"<p>Render lists and repeat sections using <code>for</code> loops.</p> <p>Syntax</p> <pre><code>&lt;&lt; # Items &gt;&gt;\nfor item in items\n    &lt;&lt;\n    - {{item}}\n    &gt;&gt;\n</code></pre> <p>Example context</p> <pre><code>{ \"items\": [\"apple\", \"banana\", \"cherry\"] }\n</code></pre> <p>Rendered result</p> <p>Using the example context the rendered output will be:</p> <pre><code># Items\n\n- apple\n- banana\n- cherry\n</code></pre> <p>Notes</p> <ul> <li>The loop variable (<code>item</code> above) is whatever identifier you declare in the <code>for</code> statement.</li> <li><code>items</code> must be an array in the provided context.</li> <li>Nested loops are supported by composing loop blocks.</li> </ul> <p>Tip: Prepare and validate list data in the context rather than trying to transform large datasets inside the template.</p>"},{"location":"mcp/","title":"MCP","text":"<p>Margarita has an MCP server that allows you to serve rendered prompts.</p> <p>Check it out here</p>"},{"location":"metadata/","title":"Metadata","text":"<p>Templates may declare metadata at the top using <code>@key: value</code> lines. This metadata can hold task information, ownership, or any other small key/value pairs that help describe the template's purpose.</p> <p>Example</p> <pre><code>---\ntask: greeting\nowner: docs-team\nversion: 2.0\n---\n\n&lt;&lt;\nHello, ${name}!\n&gt;&gt;\n</code></pre> <p>Behavior and precedence</p> <ul> <li>CLI <code>-c</code> (inline JSON) and <code>-f</code> (context file) override auto-detected context files.</li> <li>When rendering a single template, MARGARITA looks for a sibling <code>.json</code> file with the same base name.</li> <li>Metadata is parsed from the template and can be shown with <code>margarita render --show-metadata</code> or <code>margarita metadata</code>.</li> </ul> <p>Usage notes</p> <ul> <li>Use metadata for small, human-facing descriptors (task, owner, tags), not for large structured data \u2014 keep heavy data in context files.</li> <li>Metadata values are strings parsed from the template header lines; treat them as descriptive only.</li> </ul> <p>See also: <code>Contexts</code> page for context structure and examples.</p>"},{"location":"use-in-agents/","title":"Using MARGARITA in Agentic Loops","text":"<p>MARGARITA's dynamic rendering capabilities make it ideal for use in agentic AI workflows where prompts need to be generated, modified, and refined through multiple iterations.</p>"},{"location":"use-in-agents/#why-margarita-for-agents","title":"Why MARGARITA for Agents?","text":"<p>Agentic systems often need to:</p> <ul> <li>Generate prompts dynamically based on changing context</li> <li>Iterate through multiple LLM calls with evolving state</li> <li>Maintain structured, versioned prompt templates</li> <li>Compose complex prompts from reusable components</li> </ul>"},{"location":"use-in-agents/#agentic-loop-example","title":"Agentic Loop Example","text":"<p>Here's a practical example of using MARGARITA in a multi-step agent workflow:</p> <pre><code>from pathlib import Path\nfrom margarita.parser import Parser\nfrom margarita.renderer import Renderer\n\n\nclass ResearchAgent:\n    def __init__(self, template_dir: Path):\n        self.template_dir = template_dir\n        self.parser = Parser()\n        self.conversation_history = []\n\n    def render_prompt(self, template_name: str, context: dict) -&gt; str:\n        \"\"\"Render a template with the given context.\"\"\"\n        template_path = self.template_dir / template_name\n        template_content = template_path.read_text()\n\n        _, nodes = self.parser.parse(template_content)\n        renderer = Renderer(\n            context=context,\n            base_path=self.template_dir\n        )\n        return renderer.render(nodes)\n\n    def research_loop(self, topic: str, max_iterations: int = 3):\n        \"\"\"Execute a research loop with iterative refinement.\"\"\"\n        findings = []\n\n        for iteration in range(max_iterations):\n            # Render the research prompt\n            prompt = self.render_prompt(\"research.mg\", {\n                \"topic\": topic,\n                \"iteration\": iteration + 1,\n                \"previous_findings\": findings,\n                \"history\": self.conversation_history\n            })\n\n            # Call your LLM (pseudo-code)\n            response = self.call_llm(prompt)\n\n            # Store findings\n            findings.append({\n                \"iteration\": iteration + 1,\n                \"query\": topic,\n                \"result\": response\n            })\n\n            # Update conversation history\n            self.conversation_history.append({\n                \"role\": \"assistant\",\n                \"content\": response\n            })\n\n            # Check if we should continue\n            if self.should_stop(response):\n                break\n\n        # Generate final summary\n        summary_prompt = self.render_prompt(\"summary.mg\", {\n            \"topic\": topic,\n            \"findings\": findings,\n            \"total_iterations\": len(findings)\n        })\n\n        return self.call_llm(summary_prompt)\n\n    def call_llm(self, prompt: str) -&gt; str:\n        \"\"\"Call your LLM API (implement with your preferred provider).\"\"\"\n        # Example: OpenAI, Anthropic, local model, etc.\n        pass\n\n    def should_stop(self, response: str) -&gt; bool:\n        \"\"\"Determine if the research loop should stop.\"\"\"\n        # Implement your stopping logic\n        return \"COMPLETE\" in response\n</code></pre>"},{"location":"use-in-agents/#template-examples","title":"Template Examples","text":""},{"location":"use-in-agents/#researchmg","title":"research.mg","text":"<pre><code>---\nname: research-prompt\nversion: 1.0.0\ndescription: Iterative research prompt for agent loops\n---\n&lt;&lt;\nYou are a research assistant conducting iteration ${iteration} of your research.\n\nTopic: ${topic}\n&gt;&gt;\n\nif previous_findings:\n    &lt;&lt;\n    ## Previous Findings\n    &gt;&gt;\n    for finding in previous_findings:\n        &lt;&lt;\n        ### Iteration ${finding.iteration}\n        ${finding.result}\n        &gt;&gt;\n\nif history:\n    &lt;&lt;## Conversation History&gt;&gt;\n    for message in history:\n        &lt;&lt;\n        **${message.role}**: ${message.content}\n        &gt;&gt;\n&lt;&lt; ## Your Task &gt;&gt;\n\nContinue researching this topic. Build upon previous findings and provide new insights.\nWhen your research is complete, include the word COMPLETE in your response.\n</code></pre>"},{"location":"use-in-agents/#summarymg","title":"summary.mg","text":"<pre><code>---\nname: summary-prompt\nversion: 1.0.0\ndescription: Generate final summary from research findings\n---\n&lt;&lt;\n# Research Summary\n\nTopic: ${topic}\nTotal Iterations: ${total_iterations}\n\n## All Findings\n&gt;&gt;\n\nfor finding in findings\n    &lt;&lt;\n    ### Research Phase ${finding.iteration}\n\n    **Query**: ${finding.query}\n\n    **Results**:\n    ${finding.result}\n    &gt;&gt;\n&lt;&lt;\n## Your Task\n\nSynthesize all the above findings into a coherent, comprehensive summary.\nHighlight key insights and actionable takeaways.\n&gt;&gt;\n</code></pre>"},{"location":"use-in-agents/#dynamic-context-updates","title":"Dynamic Context Updates","text":"<p>MARGARITA's renderer allows you to update context dynamically within your agent loop:</p> <pre><code># Initial context\ncontext = {\n    \"user_query\": \"Explain quantum computing\",\n    \"difficulty\": \"intermediate\",\n    \"previous_attempts\": []\n}\n\n# Parse template once\nparser = Parser()\n_, nodes = parser.parse(template_content)\n\n# Agent loop with evolving context\nfor i in range(5):\n    # Create renderer with current context\n    renderer = Renderer(context=context, base_path=Path(\".\"))\n    prompt = renderer.render(nodes)\n\n    # Get LLM response\n    response = call_llm(prompt)\n\n    # Update context for next iteration\n    context[\"previous_attempts\"].append({\n        \"attempt\": i + 1,\n        \"response\": response\n    })\n\n    # Adjust difficulty based on response quality\n    if \"too simple\" in response.lower():\n        context[\"difficulty\"] = \"advanced\"\n    elif \"too complex\" in response.lower():\n        context[\"difficulty\"] = \"beginner\"\n</code></pre>"},{"location":"variables/","title":"Variables","text":"<p>You can use variables in your templates to insert dynamic content based on the provided context.</p> <p><code>Syntax ${var_name}</code></p> <p>var_name will need to correspond to a key in the context JSON provided during rendering or a variable that was passed in from an include statement.</p> <pre><code>You are a AI Farming assistant who has ${count} Tractors.\n</code></pre>"}]}