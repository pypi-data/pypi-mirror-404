# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AsgProfileMetadata',
    'AsgProfileMinionTag',
    'AsgProfileNetworkInterface',
    'AsgProfileNetworkInterfaceMetadata',
    'AsgProfileTag',
    'AsgProfileTaint',
    'AsgProfileVolume',
    'AwsApigatewayEventIntegration',
    'AwsAppautoscalingPolicyStepScalingPolicyConfiguration',
    'AwsAppautoscalingPolicyStepScalingPolicyConfigurationStepAdjustment',
    'AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfiguration',
    'AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification',
    'AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimension',
    'AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification',
    'AwsBatchComputeEnvironmentComputeResources',
    'AwsBatchComputeEnvironmentComputeResourcesEc2Configuration',
    'AwsBatchComputeEnvironmentComputeResourcesLaunchTemplate',
    'AwsBatchJobDefinitionRetryStrategy',
    'AwsBatchJobDefinitionRetryStrategyEvaluateOnExit',
    'AwsBatchJobDefinitionTimeout',
    'AwsBatchSchedulingPolicyFairSharePolicy',
    'AwsBatchSchedulingPolicyFairSharePolicyShareDistribution',
    'AwsCloudfrontDistributionCustomErrorResponse',
    'AwsCloudfrontDistributionDefaultCacheBehavior',
    'AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValues',
    'AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValuesCookies',
    'AwsCloudfrontDistributionDefaultCacheBehaviorFunctionAssociation',
    'AwsCloudfrontDistributionDefaultCacheBehaviorLambdaFunctionAssociation',
    'AwsCloudfrontDistributionLoggingConfig',
    'AwsCloudfrontDistributionOrderedCacheBehavior',
    'AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValues',
    'AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValuesCookies',
    'AwsCloudfrontDistributionOrderedCacheBehaviorFunctionAssociation',
    'AwsCloudfrontDistributionOrderedCacheBehaviorLambdaFunctionAssociation',
    'AwsCloudfrontDistributionOrigin',
    'AwsCloudfrontDistributionOriginCustomHeader',
    'AwsCloudfrontDistributionOriginCustomOriginConfig',
    'AwsCloudfrontDistributionOriginGroup',
    'AwsCloudfrontDistributionOriginGroupFailoverCriteria',
    'AwsCloudfrontDistributionOriginGroupMember',
    'AwsCloudfrontDistributionOriginOriginShield',
    'AwsCloudfrontDistributionOriginS3OriginConfig',
    'AwsCloudfrontDistributionRestrictions',
    'AwsCloudfrontDistributionRestrictionsGeoRestriction',
    'AwsCloudfrontDistributionViewerCertificate',
    'AwsCloudwatchEventRuleTag',
    'AwsCloudwatchMetricAlarmDimension',
    'AwsDynamodbTableV2Attribute',
    'AwsDynamodbTableV2GlobalSecondaryIndex',
    'AwsDynamodbTableV2KeySchema',
    'AwsDynamodbTableV2LocalSecondaryIndex',
    'AwsDynamodbTableV2ServerSideEncryption',
    'AwsDynamodbTableV2Tag',
    'AwsDynamodbTableV2Ttl',
    'AwsEfsFileSystemLifecyclePolicy',
    'AwsEfsFileSystemMountTarget',
    'AwsEfsFileSystemTag',
    'AwsEfsLifecyclePolicyLifecyclePolicy',
    'AwsElasticsearchClusterConfig',
    'AwsElasticsearchClusterConfigColdStorageOptions',
    'AwsElasticsearchEbsOption',
    'AwsElasticsearchEncryptAtRest',
    'AwsElasticsearchSnapshotOption',
    'AwsElasticsearchVpcOption',
    'AwsHostMetadata',
    'AwsHostMinionTag',
    'AwsHostNetworkInterface',
    'AwsHostNetworkInterfaceMetadata',
    'AwsHostTag',
    'AwsHostTaint',
    'AwsHostVolume',
    'AwsLambdaFunctionDeadLetterConfig',
    'AwsLambdaFunctionEnvironment',
    'AwsLambdaFunctionEventConfigDestinationConfig',
    'AwsLambdaFunctionEventConfigDestinationConfigOnFailure',
    'AwsLambdaFunctionEventConfigDestinationConfigOnSuccess',
    'AwsLambdaFunctionImageConfig',
    'AwsLambdaFunctionTracingConfig',
    'AwsLaunchTemplateBlockDeviceMapping',
    'AwsLaunchTemplateBlockDeviceMappingEbs',
    'AwsLbListenerRuleAction',
    'AwsLbListenerRuleActionAuthenticateCognito',
    'AwsLbListenerRuleActionAuthenticateOidc',
    'AwsLbListenerRuleActionFixedResponse',
    'AwsLbListenerRuleActionForward',
    'AwsLbListenerRuleActionForwardStickiness',
    'AwsLbListenerRuleActionForwardTargetGroup',
    'AwsLbListenerRuleActionRedirect',
    'AwsLbListenerRuleCondition',
    'AwsLbListenerRuleConditionHostHeader',
    'AwsLbListenerRuleConditionHttpHeader',
    'AwsLbListenerRuleConditionHttpRequestMethod',
    'AwsLbListenerRuleConditionPathPattern',
    'AwsLbListenerRuleConditionQueryString',
    'AwsLbListenerRuleConditionSourceIp',
    'AwsLbListenerRuleTag',
    'AwsLbTargetGroupHealthCheck',
    'AwsLoadBalancerListenerCertificate',
    'AwsLoadBalancerListenerDefaultAction',
    'AwsLoadBalancerListenerDefaultActionFixedResponse',
    'AwsLoadBalancerListenerDefaultActionForward',
    'AwsLoadBalancerListenerDefaultActionRedirect',
    'AwsLoadBalancerTag',
    'AwsMwaaEnvironmentLastUpdated',
    'AwsMwaaEnvironmentLastUpdatedError',
    'AwsMwaaEnvironmentLoggingConfiguration',
    'AwsMwaaEnvironmentLoggingConfigurationDagProcessingLogs',
    'AwsMwaaEnvironmentLoggingConfigurationSchedulerLogs',
    'AwsMwaaEnvironmentLoggingConfigurationTaskLogs',
    'AwsMwaaEnvironmentLoggingConfigurationWebserverLogs',
    'AwsMwaaEnvironmentLoggingConfigurationWorkerLogs',
    'AwsSqsQueueDeadLetterQueueConfiguration',
    'AwsTargetGroupAttributesAttribute',
    'AwsTimestreamwriteDatabaseAllTag',
    'AwsTimestreamwriteDatabaseTag',
    'AwsTimestreamwriteTableAllTag',
    'AwsTimestreamwriteTableMagneticStoreWriteProperties',
    'AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation',
    'AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration',
    'AwsTimestreamwriteTableRetentionProperties',
    'AwsTimestreamwriteTableTag',
    'AzureAvailabilitySetVirtualMachine',
    'AzureCosmosDbAccountBackupPolicy',
    'AzureCosmosDbAccountCapability',
    'AzureCosmosDbAccountConsistencyPolicy',
    'AzureCosmosDbAccountGeoLocation',
    'AzureCosmosDbAccountVirtualNetworkRule',
    'AzureK8NodePoolNodeLabel',
    'AzureK8NodePoolScalePriority',
    'AzureK8sClusterActiveDirectoryConfig',
    'AzureMssqlDatabaseSku',
    'AzureMssqlElasticpoolSku',
    'AzureMssqlServerActiveDirectoryAdministrator',
    'AzurePrivateEndpointPrivateLinkServiceConnection',
    'AzureVaultBackupPolicyBackup',
    'AzureVaultBackupPolicyRetentionDaily',
    'AzureVaultBackupPolicyRetentionMonthly',
    'AzureVaultBackupPolicyRetentionWeekly',
    'AzureVaultBackupPolicyRetentionYearly',
    'AzureVirtualMachineMinionTag',
    'AzureVirtualMachineScaleSetBootDiagnostics',
    'AzureVirtualMachineScaleSetExtension',
    'AzureVirtualMachineScaleSetIdentity',
    'AzureVirtualMachineScaleSetNetworkProfile',
    'AzureVirtualMachineScaleSetNetworkProfileDnsSettings',
    'AzureVirtualMachineScaleSetNetworkProfileIpConfiguration',
    'AzureVirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration',
    'AzureVirtualMachineScaleSetOsProfile',
    'AzureVirtualMachineScaleSetOsProfileLinuxConfig',
    'AzureVirtualMachineScaleSetOsProfileLinuxConfigSshKey',
    'AzureVirtualMachineScaleSetOsProfileSecret',
    'AzureVirtualMachineScaleSetOsProfileSecretVaultCertificate',
    'AzureVirtualMachineScaleSetOsProfileWindowsConfig',
    'AzureVirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig',
    'AzureVirtualMachineScaleSetOsProfileWindowsConfigWinrm',
    'AzureVirtualMachineScaleSetPlan',
    'AzureVirtualMachineScaleSetRollingUpgradePolicy',
    'AzureVirtualMachineScaleSetSku',
    'AzureVirtualMachineScaleSetStorageProfileDataDisk',
    'AzureVirtualMachineScaleSetStorageProfileImageReference',
    'AzureVirtualMachineScaleSetStorageProfileOsDisk',
    'AzureVirtualMachineTag',
    'AzureVirtualMachineVolume',
    'AzureVmMaintenanceConfigurationWindow',
    'ByohTag',
    'DuploServiceInitContainerDockerImage',
    'DuploServiceLbconfigsLbconfig',
    'DuploServiceLbconfigsLbconfigExtraSelectorLabel',
    'DuploServiceLbconfigsLbconfigHealthCheck',
    'DuploServiceTag',
    'EcacheInstanceLogDeliveryConfiguration',
    'EcsServiceCapacityProviderStrategy',
    'EcsServiceDeploymentConfiguration',
    'EcsServiceDeploymentConfigurationAlarm',
    'EcsServiceLoadBalancer',
    'EcsServiceLoadBalancerHealthCheckConfig',
    'EcsServicePlacementConstraint',
    'EcsServicePlacementStrategy',
    'EcsTaskDefinitionInferenceAccelerator',
    'EcsTaskDefinitionPlacementConstraint',
    'EcsTaskDefinitionProxyConfiguration',
    'EcsTaskDefinitionRequiresAttribute',
    'EcsTaskDefinitionRuntimePlatform',
    'EcsTaskDefinitionTag',
    'GcpCloudFunctionEventTrigger',
    'GcpCloudFunctionHttpsTrigger',
    'GcpInfraMaintenanceWindowExclusion',
    'GcpInfraMaintenanceWindowRecurringWindow',
    'GcpInfraSecurityRulePortsAndProtocol',
    'GcpNodePoolAccelerator',
    'GcpNodePoolAcceleratorGpuDriverInstallationConfig',
    'GcpNodePoolAcceleratorGpuSharingConfig',
    'GcpNodePoolLinuxNodeConfig',
    'GcpNodePoolNodePoolLoggingConfig',
    'GcpNodePoolTaint',
    'GcpNodePoolUpgradeSetting',
    'GcpNodePoolUpgradeSettingBlueGreenSetting',
    'GcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicy',
    'GcpSchedulerJobAppEngineTarget',
    'GcpSchedulerJobAppEngineTargetRouting',
    'GcpSchedulerJobHttpTarget',
    'GcpSchedulerJobHttpTargetOauthToken',
    'GcpSchedulerJobHttpTargetOidcToken',
    'GcpSchedulerJobPubsubTarget',
    'GcpSqlDatabaseInstanceDatabaseFlag',
    'GcpStorageBucketV2DefaultEncryption',
    'GcpTenantSecurityRulePortsAndProtocol',
    'InfrastructureAllSetting',
    'InfrastructureCustomData',
    'InfrastructureOnpremCustomData',
    'InfrastructureOnpremEksConfig',
    'InfrastructurePrivateSubnet',
    'InfrastructurePrivateSubnetTag',
    'InfrastructurePublicSubnet',
    'InfrastructurePublicSubnetTag',
    'InfrastructureSecurityGroup',
    'InfrastructureSecurityGroupRule',
    'InfrastructureSetting',
    'InfrastructureSettingCustomData',
    'InfrastructureSettingSetting',
    'K8HelmReleaseChart',
    'K8IngressLbconfig',
    'K8IngressRule',
    'K8IngressTl',
    'K8PersistentVolumeClaimSpec',
    'K8PersistentVolumeClaimSpecResources',
    'K8SecretProviderClassSecretObject',
    'K8SecretProviderClassSecretObjectData',
    'K8StorageClassAllowedTopologies',
    'K8StorageClassAllowedTopologiesMatchLabelExpression',
    'K8sCronJobMetadata',
    'K8sCronJobSpec',
    'K8sCronJobSpecJobTemplate',
    'K8sCronJobSpecJobTemplateMetadata',
    'K8sCronJobSpecJobTemplateSpec',
    'K8sCronJobSpecJobTemplateSpecSelector',
    'K8sCronJobSpecJobTemplateSpecSelectorMatchExpression',
    'K8sCronJobSpecJobTemplateSpecTemplate',
    'K8sCronJobSpecJobTemplateSpecTemplateMetadata',
    'K8sCronJobSpecJobTemplateSpecTemplateSpec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinity',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinity',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinity',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinity',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainer',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnv',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFrom',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFrom',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycle',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStart',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStop',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbe',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpc',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerPort',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbe',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpc',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerResources',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContext',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilities',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptions',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfile',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbe',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpc',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMount',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfig',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOption',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecHostAlias',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecret',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainer',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnv',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFrom',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFrom',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycle',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStart',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStop',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbe',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpc',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPort',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbe',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpc',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResources',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContext',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilities',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptions',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfile',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbe',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpc',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGet',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocket',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMount',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGate',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContext',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptions',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfile',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctl',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecToleration',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraint',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelector',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpression',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolume',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStore',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDisk',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFile',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFs',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinder',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMap',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItem',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsi',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApi',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItem',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDir',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeral',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplate',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadata',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResources',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFc',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolume',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlocker',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDisk',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepo',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfs',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPath',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsi',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocal',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfs',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaim',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDisk',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjected',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSource',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMap',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItem',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApi',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItem',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecret',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItem',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountToken',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyte',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbd',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRef',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecret',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItem',
    'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolume',
    'K8sJobMetadata',
    'K8sJobSpec',
    'K8sJobSpecSelector',
    'K8sJobSpecSelectorMatchExpression',
    'K8sJobSpecTemplate',
    'K8sJobSpecTemplateMetadata',
    'K8sJobSpecTemplateSpec',
    'K8sJobSpecTemplateSpecAffinity',
    'K8sJobSpecTemplateSpecAffinityNodeAffinity',
    'K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression',
    'K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm',
    'K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression',
    'K8sJobSpecTemplateSpecAffinityPodAffinity',
    'K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression',
    'K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression',
    'K8sJobSpecTemplateSpecAffinityPodAntiAffinity',
    'K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression',
    'K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression',
    'K8sJobSpecTemplateSpecContainer',
    'K8sJobSpecTemplateSpecContainerEnv',
    'K8sJobSpecTemplateSpecContainerEnvFrom',
    'K8sJobSpecTemplateSpecContainerEnvFromConfigMapRef',
    'K8sJobSpecTemplateSpecContainerEnvFromSecretRef',
    'K8sJobSpecTemplateSpecContainerEnvValueFrom',
    'K8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRef',
    'K8sJobSpecTemplateSpecContainerEnvValueFromFieldRef',
    'K8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRef',
    'K8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRef',
    'K8sJobSpecTemplateSpecContainerLifecycle',
    'K8sJobSpecTemplateSpecContainerLifecyclePostStart',
    'K8sJobSpecTemplateSpecContainerLifecyclePostStartExec',
    'K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGet',
    'K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocket',
    'K8sJobSpecTemplateSpecContainerLifecyclePreStop',
    'K8sJobSpecTemplateSpecContainerLifecyclePreStopExec',
    'K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGet',
    'K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocket',
    'K8sJobSpecTemplateSpecContainerLivenessProbe',
    'K8sJobSpecTemplateSpecContainerLivenessProbeExec',
    'K8sJobSpecTemplateSpecContainerLivenessProbeGrpc',
    'K8sJobSpecTemplateSpecContainerLivenessProbeHttpGet',
    'K8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecContainerLivenessProbeTcpSocket',
    'K8sJobSpecTemplateSpecContainerPort',
    'K8sJobSpecTemplateSpecContainerReadinessProbe',
    'K8sJobSpecTemplateSpecContainerReadinessProbeExec',
    'K8sJobSpecTemplateSpecContainerReadinessProbeGrpc',
    'K8sJobSpecTemplateSpecContainerReadinessProbeHttpGet',
    'K8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecContainerReadinessProbeTcpSocket',
    'K8sJobSpecTemplateSpecContainerResources',
    'K8sJobSpecTemplateSpecContainerSecurityContext',
    'K8sJobSpecTemplateSpecContainerSecurityContextCapabilities',
    'K8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptions',
    'K8sJobSpecTemplateSpecContainerSecurityContextSeccompProfile',
    'K8sJobSpecTemplateSpecContainerStartupProbe',
    'K8sJobSpecTemplateSpecContainerStartupProbeExec',
    'K8sJobSpecTemplateSpecContainerStartupProbeGrpc',
    'K8sJobSpecTemplateSpecContainerStartupProbeHttpGet',
    'K8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecContainerStartupProbeTcpSocket',
    'K8sJobSpecTemplateSpecContainerVolumeMount',
    'K8sJobSpecTemplateSpecDnsConfig',
    'K8sJobSpecTemplateSpecDnsConfigOption',
    'K8sJobSpecTemplateSpecHostAlias',
    'K8sJobSpecTemplateSpecImagePullSecret',
    'K8sJobSpecTemplateSpecInitContainer',
    'K8sJobSpecTemplateSpecInitContainerEnv',
    'K8sJobSpecTemplateSpecInitContainerEnvFrom',
    'K8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRef',
    'K8sJobSpecTemplateSpecInitContainerEnvFromSecretRef',
    'K8sJobSpecTemplateSpecInitContainerEnvValueFrom',
    'K8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef',
    'K8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRef',
    'K8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef',
    'K8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRef',
    'K8sJobSpecTemplateSpecInitContainerLifecycle',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePostStart',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePostStartExec',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGet',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocket',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePreStop',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePreStopExec',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGet',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocket',
    'K8sJobSpecTemplateSpecInitContainerLivenessProbe',
    'K8sJobSpecTemplateSpecInitContainerLivenessProbeExec',
    'K8sJobSpecTemplateSpecInitContainerLivenessProbeGrpc',
    'K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGet',
    'K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocket',
    'K8sJobSpecTemplateSpecInitContainerPort',
    'K8sJobSpecTemplateSpecInitContainerReadinessProbe',
    'K8sJobSpecTemplateSpecInitContainerReadinessProbeExec',
    'K8sJobSpecTemplateSpecInitContainerReadinessProbeGrpc',
    'K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGet',
    'K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocket',
    'K8sJobSpecTemplateSpecInitContainerResources',
    'K8sJobSpecTemplateSpecInitContainerSecurityContext',
    'K8sJobSpecTemplateSpecInitContainerSecurityContextCapabilities',
    'K8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptions',
    'K8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfile',
    'K8sJobSpecTemplateSpecInitContainerStartupProbe',
    'K8sJobSpecTemplateSpecInitContainerStartupProbeExec',
    'K8sJobSpecTemplateSpecInitContainerStartupProbeGrpc',
    'K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGet',
    'K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader',
    'K8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocket',
    'K8sJobSpecTemplateSpecInitContainerVolumeMount',
    'K8sJobSpecTemplateSpecReadinessGate',
    'K8sJobSpecTemplateSpecSecurityContext',
    'K8sJobSpecTemplateSpecSecurityContextSeLinuxOptions',
    'K8sJobSpecTemplateSpecSecurityContextSeccompProfile',
    'K8sJobSpecTemplateSpecSecurityContextSysctl',
    'K8sJobSpecTemplateSpecToleration',
    'K8sJobSpecTemplateSpecTopologySpreadConstraint',
    'K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelector',
    'K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpression',
    'K8sJobSpecTemplateSpecVolume',
    'K8sJobSpecTemplateSpecVolumeAwsElasticBlockStore',
    'K8sJobSpecTemplateSpecVolumeAzureDisk',
    'K8sJobSpecTemplateSpecVolumeAzureFile',
    'K8sJobSpecTemplateSpecVolumeCephFs',
    'K8sJobSpecTemplateSpecVolumeCephFsSecretRef',
    'K8sJobSpecTemplateSpecVolumeCinder',
    'K8sJobSpecTemplateSpecVolumeConfigMap',
    'K8sJobSpecTemplateSpecVolumeConfigMapItem',
    'K8sJobSpecTemplateSpecVolumeCsi',
    'K8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRef',
    'K8sJobSpecTemplateSpecVolumeDownwardApi',
    'K8sJobSpecTemplateSpecVolumeDownwardApiItem',
    'K8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRef',
    'K8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef',
    'K8sJobSpecTemplateSpecVolumeEmptyDir',
    'K8sJobSpecTemplateSpecVolumeEphemeral',
    'K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplate',
    'K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadata',
    'K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec',
    'K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResources',
    'K8sJobSpecTemplateSpecVolumeFc',
    'K8sJobSpecTemplateSpecVolumeFlexVolume',
    'K8sJobSpecTemplateSpecVolumeFlexVolumeSecretRef',
    'K8sJobSpecTemplateSpecVolumeFlocker',
    'K8sJobSpecTemplateSpecVolumeGcePersistentDisk',
    'K8sJobSpecTemplateSpecVolumeGitRepo',
    'K8sJobSpecTemplateSpecVolumeGlusterfs',
    'K8sJobSpecTemplateSpecVolumeHostPath',
    'K8sJobSpecTemplateSpecVolumeIscsi',
    'K8sJobSpecTemplateSpecVolumeLocal',
    'K8sJobSpecTemplateSpecVolumeNfs',
    'K8sJobSpecTemplateSpecVolumePersistentVolumeClaim',
    'K8sJobSpecTemplateSpecVolumePhotonPersistentDisk',
    'K8sJobSpecTemplateSpecVolumeProjected',
    'K8sJobSpecTemplateSpecVolumeProjectedSource',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMap',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItem',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApi',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItem',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceSecret',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceSecretItem',
    'K8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountToken',
    'K8sJobSpecTemplateSpecVolumeQuobyte',
    'K8sJobSpecTemplateSpecVolumeRbd',
    'K8sJobSpecTemplateSpecVolumeRbdSecretRef',
    'K8sJobSpecTemplateSpecVolumeSecret',
    'K8sJobSpecTemplateSpecVolumeSecretItem',
    'K8sJobSpecTemplateSpecVolumeVsphereVolume',
    'OciContainerengineNodePoolInitialNodeLabel',
    'OciContainerengineNodePoolNode',
    'OciContainerengineNodePoolNodeConfigDetails',
    'OciContainerengineNodePoolNodeConfigDetailsPlacementConfig',
    'OciContainerengineNodePoolNodeShapeConfig',
    'OciContainerengineNodePoolNodeSourceDetails',
    'OtherAgentsAgent',
    'PlanCertificatesCertificate',
    'PlanConfigsConfig',
    'PlanImagesImage',
    'PlanImagesImageTag',
    'PlanKmsV2Km',
    'PlanKmsV2KmsKey',
    'PlanSettingsAllMetadata',
    'PlanSettingsDnsSetting',
    'PlanSettingsMetadata',
    'PlanWafV2Waf',
    'RdsInstancePerformanceInsights',
    'RdsInstanceV2ScalingConfiguration',
    'RdsReadReplicaPerformanceInsights',
    'RdsReadReplicaV2ScalingConfiguration',
    'S3BucketDefaultEncryption',
    'S3BucketReplicationRule',
    'S3BucketTag',
    'TenantConfigMetadata',
    'TenantConfigSetting',
    'TenantKmsKm',
    'TenantKmsUnspecifiedKmsKey',
    'TenantPolicy',
    'TenantSecretTag',
    'TenantTag',
    'GetAsgProfilesAsgProfileResult',
    'GetAsgProfilesAsgProfileMetadataResult',
    'GetAsgProfilesAsgProfileMinionTagResult',
    'GetAsgProfilesAsgProfileNetworkInterfaceResult',
    'GetAsgProfilesAsgProfileNetworkInterfaceMetadataResult',
    'GetAsgProfilesAsgProfileTagResult',
    'GetAsgProfilesAsgProfileTaintResult',
    'GetAsgProfilesAsgProfileVolumeResult',
    'GetAwsLbListenersListenerResult',
    'GetAwsLbListenersListenerCertificateResult',
    'GetAwsLbListenersListenerDefaultActionResult',
    'GetAwsLbTargetGroupsTargetGroupResult',
    'GetAwsLbTargetGroupsTargetGroupHealthCheckResult',
    'GetAwsLbTargetGroupsTargetGroupHealthCheckMatcherResult',
    'GetAwsSsmParametersParameterResult',
    'GetAzureAvailabilitySetVirtualMachineResult',
    'GetAzureCosmosDbAccountBackupPolicyResult',
    'GetAzureCosmosDbAccountCapabilityResult',
    'GetAzureCosmosDbAccountConsistencyPolicyResult',
    'GetAzureCosmosDbAccountGeoLocationResult',
    'GetAzureCosmosDbAccountVirtualNetworkRuleResult',
    'GetDuploServiceLbconfigsServiceResult',
    'GetDuploServiceLbconfigsServiceLbconfigResult',
    'GetDuploServiceLbconfigsServiceLbconfigExtraSelectorLabelResult',
    'GetDuploServiceLbconfigsServiceLbconfigHealthCheckResult',
    'GetDuploServiceParamsResultResult',
    'GetDuploServiceTagResult',
    'GetDuploServicesServiceResult',
    'GetDuploServicesServiceTagResult',
    'GetEcsServiceCapacityProviderStrategyResult',
    'GetEcsServiceDeploymentConfigurationResult',
    'GetEcsServiceDeploymentConfigurationAlarmResult',
    'GetEcsServiceLoadBalancerResult',
    'GetEcsServiceLoadBalancerHealthCheckConfigResult',
    'GetEcsServicePlacementConstraintResult',
    'GetEcsServicePlacementStrategyResult',
    'GetEcsServicesServiceResult',
    'GetEcsServicesServiceCapacityProviderStrategyResult',
    'GetEcsServicesServiceDeploymentConfigurationResult',
    'GetEcsServicesServiceDeploymentConfigurationAlarmResult',
    'GetEcsServicesServiceLoadBalancerResult',
    'GetEcsServicesServiceLoadBalancerHealthCheckConfigResult',
    'GetEcsServicesServicePlacementConstraintResult',
    'GetEcsServicesServicePlacementStrategyResult',
    'GetEcsTaskDefinitionInferenceAcceleratorResult',
    'GetEcsTaskDefinitionPlacementConstraintResult',
    'GetEcsTaskDefinitionProxyConfigurationResult',
    'GetEcsTaskDefinitionRequiresAttributeResult',
    'GetEcsTaskDefinitionRuntimePlatformResult',
    'GetEcsTaskDefinitionTagResult',
    'GetEcsTaskDefinitionsTaskDefinitionResult',
    'GetEmrClusterDataResult',
    'GetGcpFirestoresFirestoreResult',
    'GetGcpNodePoolAcceleratorResult',
    'GetGcpNodePoolAcceleratorGpuDriverInstallationConfigResult',
    'GetGcpNodePoolAcceleratorGpuSharingConfigResult',
    'GetGcpNodePoolLinuxNodeConfigResult',
    'GetGcpNodePoolNodePoolLoggingConfigResult',
    'GetGcpNodePoolTaintResult',
    'GetGcpNodePoolUpgradeSettingResult',
    'GetGcpNodePoolUpgradeSettingBlueGreenSettingResult',
    'GetGcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyResult',
    'GetGcpNodePoolsNodePoolResult',
    'GetGcpNodePoolsNodePoolAcceleratorResult',
    'GetGcpNodePoolsNodePoolAcceleratorGpuDriverInstallationConfigResult',
    'GetGcpNodePoolsNodePoolAcceleratorGpuSharingConfigResult',
    'GetGcpNodePoolsNodePoolLinuxNodeConfigResult',
    'GetGcpNodePoolsNodePoolNodePoolLoggingConfigResult',
    'GetGcpNodePoolsNodePoolTaintResult',
    'GetGcpNodePoolsNodePoolUpgradeSettingResult',
    'GetGcpNodePoolsNodePoolUpgradeSettingBlueGreenSettingResult',
    'GetGcpNodePoolsNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyResult',
    'GetGcpSqlDatabaseInstancesDatabaseResult',
    'GetInfrastructurePrivateSubnetResult',
    'GetInfrastructurePrivateSubnetTagResult',
    'GetInfrastructurePublicSubnetResult',
    'GetInfrastructurePublicSubnetTagResult',
    'GetInfrastructureSecurityGroupResult',
    'GetInfrastructureSecurityGroupRuleResult',
    'GetInfrastructuresDataResult',
    'GetK8ConfigMapsConfigMapResult',
    'GetK8SecretsSecretResult',
    'GetK8sCronJobMetadataResult',
    'GetK8sCronJobSpecResult',
    'GetK8sCronJobSpecJobTemplateResult',
    'GetK8sCronJobSpecJobTemplateMetadataResult',
    'GetK8sCronJobSpecJobTemplateSpecResult',
    'GetK8sCronJobSpecJobTemplateSpecSelectorResult',
    'GetK8sCronJobSpecJobTemplateSpecSelectorMatchExpressionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateMetadataResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycleResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpcResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerPortResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpcResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResourcesResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilitiesResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptionsResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfileResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpcResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMountResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOptionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecHostAliasResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecretResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycleResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpcResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPortResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpcResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResourcesResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilitiesResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfileResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpcResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocketResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMountResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGateResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptionsResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfileResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctlResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecTolerationResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStoreResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDiskResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFileResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinderResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItemResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDirResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFcResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlockerResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDiskResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepoResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfsResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPathResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsiResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocalResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfsResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaimResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDiskResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItemResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItemResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyteResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRefResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItemResult',
    'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolumeResult',
    'GetK8sJobMetadataResult',
    'GetK8sJobSpecResult',
    'GetK8sJobSpecSelectorResult',
    'GetK8sJobSpecSelectorMatchExpressionResult',
    'GetK8sJobSpecTemplateResult',
    'GetK8sJobSpecTemplateMetadataResult',
    'GetK8sJobSpecTemplateSpecResult',
    'GetK8sJobSpecTemplateSpecAffinityResult',
    'GetK8sJobSpecTemplateSpecAffinityNodeAffinityResult',
    'GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult',
    'GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult',
    'GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult',
    'GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAffinityResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult',
    'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult',
    'GetK8sJobSpecTemplateSpecContainerResult',
    'GetK8sJobSpecTemplateSpecContainerEnvResult',
    'GetK8sJobSpecTemplateSpecContainerEnvFromResult',
    'GetK8sJobSpecTemplateSpecContainerEnvFromConfigMapRefResult',
    'GetK8sJobSpecTemplateSpecContainerEnvFromSecretRefResult',
    'GetK8sJobSpecTemplateSpecContainerEnvValueFromResult',
    'GetK8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefResult',
    'GetK8sJobSpecTemplateSpecContainerEnvValueFromFieldRefResult',
    'GetK8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRefResult',
    'GetK8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRefResult',
    'GetK8sJobSpecTemplateSpecContainerLifecycleResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePostStartResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePostStartExecResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocketResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePreStopResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePreStopExecResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocketResult',
    'GetK8sJobSpecTemplateSpecContainerLivenessProbeResult',
    'GetK8sJobSpecTemplateSpecContainerLivenessProbeExecResult',
    'GetK8sJobSpecTemplateSpecContainerLivenessProbeGrpcResult',
    'GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetResult',
    'GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecContainerLivenessProbeTcpSocketResult',
    'GetK8sJobSpecTemplateSpecContainerPortResult',
    'GetK8sJobSpecTemplateSpecContainerReadinessProbeResult',
    'GetK8sJobSpecTemplateSpecContainerReadinessProbeExecResult',
    'GetK8sJobSpecTemplateSpecContainerReadinessProbeGrpcResult',
    'GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetResult',
    'GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecContainerReadinessProbeTcpSocketResult',
    'GetK8sJobSpecTemplateSpecContainerResourcesResult',
    'GetK8sJobSpecTemplateSpecContainerSecurityContextResult',
    'GetK8sJobSpecTemplateSpecContainerSecurityContextCapabilitiesResult',
    'GetK8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptionsResult',
    'GetK8sJobSpecTemplateSpecContainerSecurityContextSeccompProfileResult',
    'GetK8sJobSpecTemplateSpecContainerStartupProbeResult',
    'GetK8sJobSpecTemplateSpecContainerStartupProbeExecResult',
    'GetK8sJobSpecTemplateSpecContainerStartupProbeGrpcResult',
    'GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetResult',
    'GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecContainerStartupProbeTcpSocketResult',
    'GetK8sJobSpecTemplateSpecContainerVolumeMountResult',
    'GetK8sJobSpecTemplateSpecDnsConfigResult',
    'GetK8sJobSpecTemplateSpecDnsConfigOptionResult',
    'GetK8sJobSpecTemplateSpecHostAliasResult',
    'GetK8sJobSpecTemplateSpecImagePullSecretResult',
    'GetK8sJobSpecTemplateSpecInitContainerResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvFromResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRefResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvFromSecretRefResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRefResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefResult',
    'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecycleResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartExecResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopExecResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketResult',
    'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeResult',
    'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeExecResult',
    'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeGrpcResult',
    'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetResult',
    'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocketResult',
    'GetK8sJobSpecTemplateSpecInitContainerPortResult',
    'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeResult',
    'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeExecResult',
    'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeGrpcResult',
    'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetResult',
    'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocketResult',
    'GetK8sJobSpecTemplateSpecInitContainerResourcesResult',
    'GetK8sJobSpecTemplateSpecInitContainerSecurityContextResult',
    'GetK8sJobSpecTemplateSpecInitContainerSecurityContextCapabilitiesResult',
    'GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsResult',
    'GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfileResult',
    'GetK8sJobSpecTemplateSpecInitContainerStartupProbeResult',
    'GetK8sJobSpecTemplateSpecInitContainerStartupProbeExecResult',
    'GetK8sJobSpecTemplateSpecInitContainerStartupProbeGrpcResult',
    'GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetResult',
    'GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderResult',
    'GetK8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocketResult',
    'GetK8sJobSpecTemplateSpecInitContainerVolumeMountResult',
    'GetK8sJobSpecTemplateSpecReadinessGateResult',
    'GetK8sJobSpecTemplateSpecSecurityContextResult',
    'GetK8sJobSpecTemplateSpecSecurityContextSeLinuxOptionsResult',
    'GetK8sJobSpecTemplateSpecSecurityContextSeccompProfileResult',
    'GetK8sJobSpecTemplateSpecSecurityContextSysctlResult',
    'GetK8sJobSpecTemplateSpecTolerationResult',
    'GetK8sJobSpecTemplateSpecTopologySpreadConstraintResult',
    'GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorResult',
    'GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionResult',
    'GetK8sJobSpecTemplateSpecVolumeResult',
    'GetK8sJobSpecTemplateSpecVolumeAwsElasticBlockStoreResult',
    'GetK8sJobSpecTemplateSpecVolumeAzureDiskResult',
    'GetK8sJobSpecTemplateSpecVolumeAzureFileResult',
    'GetK8sJobSpecTemplateSpecVolumeCephFsResult',
    'GetK8sJobSpecTemplateSpecVolumeCephFsSecretRefResult',
    'GetK8sJobSpecTemplateSpecVolumeCinderResult',
    'GetK8sJobSpecTemplateSpecVolumeConfigMapResult',
    'GetK8sJobSpecTemplateSpecVolumeConfigMapItemResult',
    'GetK8sJobSpecTemplateSpecVolumeCsiResult',
    'GetK8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRefResult',
    'GetK8sJobSpecTemplateSpecVolumeDownwardApiResult',
    'GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResult',
    'GetK8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRefResult',
    'GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefResult',
    'GetK8sJobSpecTemplateSpecVolumeEmptyDirResult',
    'GetK8sJobSpecTemplateSpecVolumeEphemeralResult',
    'GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateResult',
    'GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataResult',
    'GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResult',
    'GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesResult',
    'GetK8sJobSpecTemplateSpecVolumeFcResult',
    'GetK8sJobSpecTemplateSpecVolumeFlexVolumeResult',
    'GetK8sJobSpecTemplateSpecVolumeFlexVolumeSecretRefResult',
    'GetK8sJobSpecTemplateSpecVolumeFlockerResult',
    'GetK8sJobSpecTemplateSpecVolumeGcePersistentDiskResult',
    'GetK8sJobSpecTemplateSpecVolumeGitRepoResult',
    'GetK8sJobSpecTemplateSpecVolumeGlusterfsResult',
    'GetK8sJobSpecTemplateSpecVolumeHostPathResult',
    'GetK8sJobSpecTemplateSpecVolumeIscsiResult',
    'GetK8sJobSpecTemplateSpecVolumeLocalResult',
    'GetK8sJobSpecTemplateSpecVolumeNfsResult',
    'GetK8sJobSpecTemplateSpecVolumePersistentVolumeClaimResult',
    'GetK8sJobSpecTemplateSpecVolumePhotonPersistentDiskResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItemResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretItemResult',
    'GetK8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenResult',
    'GetK8sJobSpecTemplateSpecVolumeQuobyteResult',
    'GetK8sJobSpecTemplateSpecVolumeRbdResult',
    'GetK8sJobSpecTemplateSpecVolumeRbdSecretRefResult',
    'GetK8sJobSpecTemplateSpecVolumeSecretResult',
    'GetK8sJobSpecTemplateSpecVolumeSecretItemResult',
    'GetK8sJobSpecTemplateSpecVolumeVsphereVolumeResult',
    'GetNativeHostImageTagResult',
    'GetNativeHostImagesImageResult',
    'GetNativeHostImagesImageTagResult',
    'GetNativeHostsHostResult',
    'GetNativeHostsHostMetadataResult',
    'GetNativeHostsHostMinionTagResult',
    'GetNativeHostsHostNetworkInterfaceResult',
    'GetNativeHostsHostNetworkInterfaceMetadataResult',
    'GetNativeHostsHostTagResult',
    'GetNativeHostsHostTaintResult',
    'GetNativeHostsHostVolumeResult',
    'GetPlanCertificateResult',
    'GetPlanCertificatesCertificateResult',
    'GetPlanConfigResult',
    'GetPlanImageResult',
    'GetPlanImageTagResult',
    'GetPlanImagesImageResult',
    'GetPlanImagesImageTagResult',
    'GetPlanKmsKeyResult',
    'GetPlanKmsKeyDataResult',
    'GetPlanKmsKeyV2KmsKeyResult',
    'GetPlanKubernetesConfigResult',
    'GetPlanMetadataResult',
    'GetPlanNatGatewaysNatGatewayResult',
    'GetPlanNatGatewaysNatGatewayAddressResult',
    'GetPlanNatGatewaysNatGatewayTagResult',
    'GetPlanSettingsDnsSettingResult',
    'GetPlanSettingsMetadataResult',
    'GetPlanWafInfoResult',
    'GetPlanWafsDataResult',
    'GetPlanWafsV2WafResult',
    'GetPlansDataResult',
    'GetPlansDataCertificateResult',
    'GetPlansDataConfigResult',
    'GetPlansDataImageResult',
    'GetPlansDataImageTagResult',
    'GetPlansDataKmsKeyResult',
    'GetPlansDataKubernetesConfigResult',
    'GetPlansDataMetadataResult',
    'GetPlansDataWafInfoResult',
    'GetSystemFeaturesAppConfigResult',
    'GetSystemFeaturesEksVersionResult',
    'GetTenantAwsKmsKeysKeyResult',
    'GetTenantConfigMetadataResult',
    'GetTenantPolicyResult',
    'GetTenantSecretTagResult',
    'GetTenantSecretsSecretResult',
    'GetTenantSecretsSecretTagResult',
    'GetTenantTagResult',
    'GetTenantsTenantResult',
    'GetTenantsTenantPolicyResult',
    'GetTenantsTenantTagResult',
]

@pulumi.output_type
class AsgProfileMetadata(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AsgProfileMinionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AsgProfileNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatePublicIp":
            suggest = "associate_public_ip"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AsgProfileNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AsgProfileNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AsgProfileNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_public_ip: Optional[bool] = None,
                 device_index: Optional[int] = None,
                 groups: Optional[Sequence[str]] = None,
                 metadatas: Optional[Sequence['outputs.AsgProfileNetworkInterfaceMetadata']] = None,
                 network_interface_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param bool associate_public_ip: Whether or not to associate a public IP with the newly created ENI.  Cannot be specified if `network_interface_id` is specified.
        :param int device_index: The device index to pass to AWS for attaching the ENI.  Starts at zero.
        :param str network_interface_id: The ID of an ENI to attach to this host.  Cannot be specified if `subnet_id` or `associate_public_ip` is specified.
        :param str subnet_id: The ID of a subnet in which to create a new ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        if associate_public_ip is not None:
            pulumi.set(__self__, "associate_public_ip", associate_public_ip)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associatePublicIp")
    def associate_public_ip(self) -> Optional[bool]:
        """
        Whether or not to associate a public IP with the newly created ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        return pulumi.get(self, "associate_public_ip")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[int]:
        """
        The device index to pass to AWS for attaching the ENI.  Starts at zero.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.AsgProfileNetworkInterfaceMetadata']]:
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of an ENI to attach to this host.  Cannot be specified if `subnet_id` or `associate_public_ip` is specified.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of a subnet in which to create a new ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AsgProfileNetworkInterfaceMetadata(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AsgProfileTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AsgProfileTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str effect: Update strategy of the node. Effect types <br>      - NoSchedule<br>     - PreferNoSchedule<br>     - NoExecute
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Update strategy of the node. Effect types <br>      - NoSchedule<br>     - PreferNoSchedule<br>     - NoExecute
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AsgProfileVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AsgProfileVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AsgProfileVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AsgProfileVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 iops: Optional[int] = None,
                 name: Optional[str] = None,
                 size: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Whether the volume should be deleted when the instance is terminated.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether the volume should be deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AwsApigatewayEventIntegration(dict):
    def __init__(__self__, *,
                 type: str,
                 uri: str,
                 timeout: Optional[int] = None):
        """
        :param str type: Integration input's type. Valid values are `HTTP` (for HTTP backends), `MOCK` (not calling any real backend), `AWS` (for AWS services), `AWS_PROXY` (for Lambda proxy integration) and `HTTP_PROXY` (for HTTP proxy integration).
        :param str uri: Input's URI. Required if type is `AWS`, `AWS_PROXY`, `HTTP` or `HTTP_PROXY`. For AWS integrations, the URI should be of the form `arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}`. `region`, `subdomain` and `service` are used to determine the right endpoint.
        :param int timeout: Custom timeout between 50 and 300,000 milliseconds.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Integration input's type. Valid values are `HTTP` (for HTTP backends), `MOCK` (not calling any real backend), `AWS` (for AWS services), `AWS_PROXY` (for Lambda proxy integration) and `HTTP_PROXY` (for HTTP proxy integration).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Input's URI. Required if type is `AWS`, `AWS_PROXY`, `HTTP` or `HTTP_PROXY`. For AWS integrations, the URI should be of the form `arn:aws:apigateway:{region}:{subdomain.service|service}:{path|action}/{service_api}`. `region`, `subdomain` and `service` are used to determine the right endpoint.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Custom timeout between 50 and 300,000 milliseconds.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AwsAppautoscalingPolicyStepScalingPolicyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adjustmentType":
            suggest = "adjustment_type"
        elif key == "metricAggregationType":
            suggest = "metric_aggregation_type"
        elif key == "minAdjustmentMagnitude":
            suggest = "min_adjustment_magnitude"
        elif key == "stepAdjustments":
            suggest = "step_adjustments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAppautoscalingPolicyStepScalingPolicyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAppautoscalingPolicyStepScalingPolicyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAppautoscalingPolicyStepScalingPolicyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adjustment_type: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 metric_aggregation_type: Optional[str] = None,
                 min_adjustment_magnitude: Optional[int] = None,
                 step_adjustments: Optional[Sequence['outputs.AwsAppautoscalingPolicyStepScalingPolicyConfigurationStepAdjustment']] = None):
        """
        :param str adjustment_type: Specifies whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are `ChangeInCapacity`, `ExactCapacity`, and `PercentChangeInCapacity`.
        :param int cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        :param str metric_aggregation_type: The aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
        :param int min_adjustment_magnitude: The minimum number to adjust your scalable dimension as a result of a scaling activity. If the adjustment type is PercentChangeInCapacity, the scaling policy changes the scalable dimension of the scalable target by this amount.
        :param Sequence['AwsAppautoscalingPolicyStepScalingPolicyConfigurationStepAdjustmentArgs'] step_adjustments: A set of adjustments that manage scaling.
        """
        if adjustment_type is not None:
            pulumi.set(__self__, "adjustment_type", adjustment_type)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if metric_aggregation_type is not None:
            pulumi.set(__self__, "metric_aggregation_type", metric_aggregation_type)
        if min_adjustment_magnitude is not None:
            pulumi.set(__self__, "min_adjustment_magnitude", min_adjustment_magnitude)
        if step_adjustments is not None:
            pulumi.set(__self__, "step_adjustments", step_adjustments)

    @property
    @pulumi.getter(name="adjustmentType")
    def adjustment_type(self) -> Optional[str]:
        """
        Specifies whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are `ChangeInCapacity`, `ExactCapacity`, and `PercentChangeInCapacity`.
        """
        return pulumi.get(self, "adjustment_type")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter(name="metricAggregationType")
    def metric_aggregation_type(self) -> Optional[str]:
        """
        The aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
        """
        return pulumi.get(self, "metric_aggregation_type")

    @property
    @pulumi.getter(name="minAdjustmentMagnitude")
    def min_adjustment_magnitude(self) -> Optional[int]:
        """
        The minimum number to adjust your scalable dimension as a result of a scaling activity. If the adjustment type is PercentChangeInCapacity, the scaling policy changes the scalable dimension of the scalable target by this amount.
        """
        return pulumi.get(self, "min_adjustment_magnitude")

    @property
    @pulumi.getter(name="stepAdjustments")
    def step_adjustments(self) -> Optional[Sequence['outputs.AwsAppautoscalingPolicyStepScalingPolicyConfigurationStepAdjustment']]:
        """
        A set of adjustments that manage scaling.
        """
        return pulumi.get(self, "step_adjustments")


@pulumi.output_type
class AwsAppautoscalingPolicyStepScalingPolicyConfigurationStepAdjustment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scalingAdjustment":
            suggest = "scaling_adjustment"
        elif key == "metricIntervalLowerBound":
            suggest = "metric_interval_lower_bound"
        elif key == "metricIntervalUpperBound":
            suggest = "metric_interval_upper_bound"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAppautoscalingPolicyStepScalingPolicyConfigurationStepAdjustment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAppautoscalingPolicyStepScalingPolicyConfigurationStepAdjustment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAppautoscalingPolicyStepScalingPolicyConfigurationStepAdjustment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scaling_adjustment: int,
                 metric_interval_lower_bound: Optional[str] = None,
                 metric_interval_upper_bound: Optional[str] = None):
        """
        :param int scaling_adjustment: The number of members by which to scale, when the adjustment bounds are breached.
        :param str metric_interval_lower_bound: The lower bound for the difference between the alarm threshold and the CloudWatch metric.
        :param str metric_interval_upper_bound: The upper bound for the difference between the alarm threshold and the CloudWatch metric.
        """
        pulumi.set(__self__, "scaling_adjustment", scaling_adjustment)
        if metric_interval_lower_bound is not None:
            pulumi.set(__self__, "metric_interval_lower_bound", metric_interval_lower_bound)
        if metric_interval_upper_bound is not None:
            pulumi.set(__self__, "metric_interval_upper_bound", metric_interval_upper_bound)

    @property
    @pulumi.getter(name="scalingAdjustment")
    def scaling_adjustment(self) -> int:
        """
        The number of members by which to scale, when the adjustment bounds are breached.
        """
        return pulumi.get(self, "scaling_adjustment")

    @property
    @pulumi.getter(name="metricIntervalLowerBound")
    def metric_interval_lower_bound(self) -> Optional[str]:
        """
        The lower bound for the difference between the alarm threshold and the CloudWatch metric.
        """
        return pulumi.get(self, "metric_interval_lower_bound")

    @property
    @pulumi.getter(name="metricIntervalUpperBound")
    def metric_interval_upper_bound(self) -> Optional[str]:
        """
        The upper bound for the difference between the alarm threshold and the CloudWatch metric.
        """
        return pulumi.get(self, "metric_interval_upper_bound")


@pulumi.output_type
class AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValue":
            suggest = "target_value"
        elif key == "customizedMetricSpecification":
            suggest = "customized_metric_specification"
        elif key == "disableScaleIn":
            suggest = "disable_scale_in"
        elif key == "predefinedMetricSpecification":
            suggest = "predefined_metric_specification"
        elif key == "scaleInCooldown":
            suggest = "scale_in_cooldown"
        elif key == "scaleOutCooldown":
            suggest = "scale_out_cooldown"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_value: float,
                 customized_metric_specification: Optional['outputs.AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification'] = None,
                 disable_scale_in: Optional[bool] = None,
                 predefined_metric_specification: Optional['outputs.AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification'] = None,
                 scale_in_cooldown: Optional[int] = None,
                 scale_out_cooldown: Optional[int] = None):
        """
        :param float target_value: The target value for the metric.
        :param bool disable_scale_in: Indicates whether scale in by the target tracking policy is disabled. Defaults to `false`.
        :param int scale_in_cooldown: The amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
        :param int scale_out_cooldown: The amount of time, in seconds, after a scale out activity completes before another scale out activity can start.
        """
        pulumi.set(__self__, "target_value", target_value)
        if customized_metric_specification is not None:
            pulumi.set(__self__, "customized_metric_specification", customized_metric_specification)
        if disable_scale_in is not None:
            pulumi.set(__self__, "disable_scale_in", disable_scale_in)
        if predefined_metric_specification is not None:
            pulumi.set(__self__, "predefined_metric_specification", predefined_metric_specification)
        if scale_in_cooldown is not None:
            pulumi.set(__self__, "scale_in_cooldown", scale_in_cooldown)
        if scale_out_cooldown is not None:
            pulumi.set(__self__, "scale_out_cooldown", scale_out_cooldown)

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> float:
        """
        The target value for the metric.
        """
        return pulumi.get(self, "target_value")

    @property
    @pulumi.getter(name="customizedMetricSpecification")
    def customized_metric_specification(self) -> Optional['outputs.AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification']:
        return pulumi.get(self, "customized_metric_specification")

    @property
    @pulumi.getter(name="disableScaleIn")
    def disable_scale_in(self) -> Optional[bool]:
        """
        Indicates whether scale in by the target tracking policy is disabled. Defaults to `false`.
        """
        return pulumi.get(self, "disable_scale_in")

    @property
    @pulumi.getter(name="predefinedMetricSpecification")
    def predefined_metric_specification(self) -> Optional['outputs.AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification']:
        return pulumi.get(self, "predefined_metric_specification")

    @property
    @pulumi.getter(name="scaleInCooldown")
    def scale_in_cooldown(self) -> Optional[int]:
        """
        The amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
        """
        return pulumi.get(self, "scale_in_cooldown")

    @property
    @pulumi.getter(name="scaleOutCooldown")
    def scale_out_cooldown(self) -> Optional[int]:
        """
        The amount of time, in seconds, after a scale out activity completes before another scale out activity can start.
        """
        return pulumi.get(self, "scale_out_cooldown")


@pulumi.output_type
class AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 statistic: str,
                 dimensions: Optional[Sequence['outputs.AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimension']] = None,
                 unit: Optional[str] = None):
        """
        :param str metric_name: The name of the metric.
        :param str namespace: The namespace of the metric.
        :param str statistic: The statistic of the metric. Valid values: `Average`, `Minimum`, `Maximum`, `SampleCount`, and `Sum`.
        :param str unit: The unit of the metric.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "statistic", statistic)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace of the metric.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def statistic(self) -> str:
        """
        The statistic of the metric. Valid values: `Average`, `Minimum`, `Maximum`, `SampleCount`, and `Sum`.
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit of the metric.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the dimension.
        :param str value: Value of the dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the dimension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the dimension.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsAppautoscalingPolicyTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        """
        :param str predefined_metric_type: The metric type.
        :param str resource_label: Reserved for future use. Must be less than or equal to 1023 characters in length.
        """
        pulumi.set(__self__, "predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            pulumi.set(__self__, "resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        """
        The metric type.
        """
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        """
        Reserved for future use. Must be less than or equal to 1023 characters in length.
        """
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class AwsBatchComputeEnvironmentComputeResources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxVcpus":
            suggest = "max_vcpus"
        elif key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "bidPercentage":
            suggest = "bid_percentage"
        elif key == "desiredVcpus":
            suggest = "desired_vcpus"
        elif key == "ec2Configuration":
            suggest = "ec2_configuration"
        elif key == "ec2KeyPair":
            suggest = "ec2_key_pair"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "instanceRole":
            suggest = "instance_role"
        elif key == "instanceTypes":
            suggest = "instance_types"
        elif key == "launchTemplate":
            suggest = "launch_template"
        elif key == "minVcpus":
            suggest = "min_vcpus"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "spotIamFleetRole":
            suggest = "spot_iam_fleet_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsBatchComputeEnvironmentComputeResources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsBatchComputeEnvironmentComputeResources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsBatchComputeEnvironmentComputeResources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_vcpus: int,
                 type: str,
                 allocation_strategy: Optional[str] = None,
                 bid_percentage: Optional[int] = None,
                 desired_vcpus: Optional[int] = None,
                 ec2_configuration: Optional['outputs.AwsBatchComputeEnvironmentComputeResourcesEc2Configuration'] = None,
                 ec2_key_pair: Optional[str] = None,
                 image_id: Optional[str] = None,
                 instance_role: Optional[str] = None,
                 instance_types: Optional[Sequence[str]] = None,
                 launch_template: Optional['outputs.AwsBatchComputeEnvironmentComputeResourcesLaunchTemplate'] = None,
                 min_vcpus: Optional[int] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 spot_iam_fleet_role: Optional[str] = None,
                 subnets: Optional[Sequence[str]] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        :param int max_vcpus: The maximum number of EC2 vCPUs that an environment can reach.
        :param str type: The type of compute environment. Valid items are `EC2`, `SPOT`, `FARGATE` or `FARGATE_SPOT`.
        :param str allocation_strategy: The allocation strategy to use for the compute resource in case not enough instances of the best fitting instance type can be allocated. Available allocation_strategy - `BEST_FIT_PROGRESSIVE`, `SPOT_CAPACITY_OPTIMIZED`, `BEST_FIT`, `SPOT_PRICE_CAPACITY_OPTIMIZED`
        :param int bid_percentage: Integer of maximum percentage that a Spot Instance price can be when compared with the On-Demand price for that instance type before instances are launched.
        :param int desired_vcpus: The desired number of EC2 vCPUS in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        :param 'AwsBatchComputeEnvironmentComputeResourcesEc2ConfigurationArgs' ec2_configuration: Provides information used to select Amazon Machine Images (AMIs) for EC2 instances in the compute environment.
        :param str ec2_key_pair: The EC2 key pair that is used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        :param str image_id: The Amazon Machine Image (AMI) ID used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified. (Deprecated, use ec2_configuration `image_id_override` instead)
        :param str instance_role: The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        :param Sequence[str] instance_types: A list of instance types that may be launched. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        :param 'AwsBatchComputeEnvironmentComputeResourcesLaunchTemplateArgs' launch_template: The launch template to use for your compute resources. See details below. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        :param int min_vcpus: The minimum number of EC2 vCPUs that an environment should maintain. For `EC2` or `SPOT` compute environments, if the parameter is not explicitly defined, a `0` default value will be set. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        :param Sequence[str] security_group_ids: A list of EC2 security group that are associated with instances launched in the compute environment. This parameter is required for Fargate compute environments.
        :param str spot_iam_fleet_role: The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment. This parameter is required for SPOT compute environments. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        :param Sequence[str] subnets: A list of VPC subnets into which the compute resources are launched.
        :param Mapping[str, str] tags: Key-value map of resource tags.
        """
        pulumi.set(__self__, "max_vcpus", max_vcpus)
        pulumi.set(__self__, "type", type)
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if bid_percentage is not None:
            pulumi.set(__self__, "bid_percentage", bid_percentage)
        if desired_vcpus is not None:
            pulumi.set(__self__, "desired_vcpus", desired_vcpus)
        if ec2_configuration is not None:
            pulumi.set(__self__, "ec2_configuration", ec2_configuration)
        if ec2_key_pair is not None:
            pulumi.set(__self__, "ec2_key_pair", ec2_key_pair)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_role is not None:
            pulumi.set(__self__, "instance_role", instance_role)
        if instance_types is not None:
            pulumi.set(__self__, "instance_types", instance_types)
        if launch_template is not None:
            pulumi.set(__self__, "launch_template", launch_template)
        if min_vcpus is not None:
            pulumi.set(__self__, "min_vcpus", min_vcpus)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if spot_iam_fleet_role is not None:
            pulumi.set(__self__, "spot_iam_fleet_role", spot_iam_fleet_role)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="maxVcpus")
    def max_vcpus(self) -> int:
        """
        The maximum number of EC2 vCPUs that an environment can reach.
        """
        return pulumi.get(self, "max_vcpus")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of compute environment. Valid items are `EC2`, `SPOT`, `FARGATE` or `FARGATE_SPOT`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[str]:
        """
        The allocation strategy to use for the compute resource in case not enough instances of the best fitting instance type can be allocated. Available allocation_strategy - `BEST_FIT_PROGRESSIVE`, `SPOT_CAPACITY_OPTIMIZED`, `BEST_FIT`, `SPOT_PRICE_CAPACITY_OPTIMIZED`
        """
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="bidPercentage")
    def bid_percentage(self) -> Optional[int]:
        """
        Integer of maximum percentage that a Spot Instance price can be when compared with the On-Demand price for that instance type before instances are launched.
        """
        return pulumi.get(self, "bid_percentage")

    @property
    @pulumi.getter(name="desiredVcpus")
    def desired_vcpus(self) -> Optional[int]:
        """
        The desired number of EC2 vCPUS in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        """
        return pulumi.get(self, "desired_vcpus")

    @property
    @pulumi.getter(name="ec2Configuration")
    def ec2_configuration(self) -> Optional['outputs.AwsBatchComputeEnvironmentComputeResourcesEc2Configuration']:
        """
        Provides information used to select Amazon Machine Images (AMIs) for EC2 instances in the compute environment.
        """
        return pulumi.get(self, "ec2_configuration")

    @property
    @pulumi.getter(name="ec2KeyPair")
    def ec2_key_pair(self) -> Optional[str]:
        """
        The EC2 key pair that is used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        """
        return pulumi.get(self, "ec2_key_pair")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        The Amazon Machine Image (AMI) ID used for instances launched in the compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified. (Deprecated, use ec2_configuration `image_id_override` instead)
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceRole")
    def instance_role(self) -> Optional[str]:
        """
        The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        """
        return pulumi.get(self, "instance_role")

    @property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Optional[Sequence[str]]:
        """
        A list of instance types that may be launched. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        """
        return pulumi.get(self, "instance_types")

    @property
    @pulumi.getter(name="launchTemplate")
    def launch_template(self) -> Optional['outputs.AwsBatchComputeEnvironmentComputeResourcesLaunchTemplate']:
        """
        The launch template to use for your compute resources. See details below. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        """
        return pulumi.get(self, "launch_template")

    @property
    @pulumi.getter(name="minVcpus")
    def min_vcpus(self) -> Optional[int]:
        """
        The minimum number of EC2 vCPUs that an environment should maintain. For `EC2` or `SPOT` compute environments, if the parameter is not explicitly defined, a `0` default value will be set. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        """
        return pulumi.get(self, "min_vcpus")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        A list of EC2 security group that are associated with instances launched in the compute environment. This parameter is required for Fargate compute environments.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="spotIamFleetRole")
    def spot_iam_fleet_role(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment. This parameter is required for SPOT compute environments. This parameter isn't applicable to jobs running on Fargate resources, and shouldn't be specified.
        """
        return pulumi.get(self, "spot_iam_fleet_role")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        """
        A list of VPC subnets into which the compute resources are launched.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Key-value map of resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsBatchComputeEnvironmentComputeResourcesEc2Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageIdOverride":
            suggest = "image_id_override"
        elif key == "imageType":
            suggest = "image_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsBatchComputeEnvironmentComputeResourcesEc2Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsBatchComputeEnvironmentComputeResourcesEc2Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsBatchComputeEnvironmentComputeResourcesEc2Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_id_override: Optional[str] = None,
                 image_type: Optional[str] = None):
        """
        :param str image_id_override: The AMI ID used for instances launched in the compute environment that match the image type. This setting overrides the `image_id` argument in the `compute_resources` block.
        :param str image_type: The image type to match with the instance type to select an AMI.
        """
        if image_id_override is not None:
            pulumi.set(__self__, "image_id_override", image_id_override)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)

    @property
    @pulumi.getter(name="imageIdOverride")
    def image_id_override(self) -> Optional[str]:
        """
        The AMI ID used for instances launched in the compute environment that match the image type. This setting overrides the `image_id` argument in the `compute_resources` block.
        """
        return pulumi.get(self, "image_id_override")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[str]:
        """
        The image type to match with the instance type to select an AMI.
        """
        return pulumi.get(self, "image_type")


@pulumi.output_type
class AwsBatchComputeEnvironmentComputeResourcesLaunchTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsBatchComputeEnvironmentComputeResourcesLaunchTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsBatchComputeEnvironmentComputeResourcesLaunchTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsBatchComputeEnvironmentComputeResourcesLaunchTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str launch_template_id: ID of the launch template. You must specify either the launch template ID or launch template name in the request, but not both.
        :param str launch_template_name: Name of the launch template.
        :param str version: The version number of the launch template. Default: The default version of the launch template.
        """
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        """
        ID of the launch template. You must specify either the launch template ID or launch template name in the request, but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        """
        Name of the launch template.
        """
        return pulumi.get(self, "launch_template_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version number of the launch template. Default: The default version of the launch template.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AwsBatchJobDefinitionRetryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluateOnExits":
            suggest = "evaluate_on_exits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsBatchJobDefinitionRetryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsBatchJobDefinitionRetryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsBatchJobDefinitionRetryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attempts: Optional[int] = None,
                 evaluate_on_exits: Optional[Sequence['outputs.AwsBatchJobDefinitionRetryStrategyEvaluateOnExit']] = None):
        """
        :param int attempts: The number of times to move a job to the RUNNABLE status. You may specify between `1` and `10` attempts.
        :param Sequence['AwsBatchJobDefinitionRetryStrategyEvaluateOnExitArgs'] evaluate_on_exits: The evaluate on exit conditions under which the job should be retried or failed. If this parameter is specified, then the attempts parameter must also be specified. You may specify up to 5 configuration blocks.
        """
        if attempts is not None:
            pulumi.set(__self__, "attempts", attempts)
        if evaluate_on_exits is not None:
            pulumi.set(__self__, "evaluate_on_exits", evaluate_on_exits)

    @property
    @pulumi.getter
    def attempts(self) -> Optional[int]:
        """
        The number of times to move a job to the RUNNABLE status. You may specify between `1` and `10` attempts.
        """
        return pulumi.get(self, "attempts")

    @property
    @pulumi.getter(name="evaluateOnExits")
    def evaluate_on_exits(self) -> Optional[Sequence['outputs.AwsBatchJobDefinitionRetryStrategyEvaluateOnExit']]:
        """
        The evaluate on exit conditions under which the job should be retried or failed. If this parameter is specified, then the attempts parameter must also be specified. You may specify up to 5 configuration blocks.
        """
        return pulumi.get(self, "evaluate_on_exits")


@pulumi.output_type
class AwsBatchJobDefinitionRetryStrategyEvaluateOnExit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onExitCode":
            suggest = "on_exit_code"
        elif key == "onReason":
            suggest = "on_reason"
        elif key == "onStatusReason":
            suggest = "on_status_reason"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsBatchJobDefinitionRetryStrategyEvaluateOnExit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsBatchJobDefinitionRetryStrategyEvaluateOnExit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsBatchJobDefinitionRetryStrategyEvaluateOnExit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 on_exit_code: Optional[str] = None,
                 on_reason: Optional[str] = None,
                 on_status_reason: Optional[str] = None):
        """
        :param str action: Specifies the action to take if all of the specified conditions are met. The values are not case sensitive. Valid values: `RETRY`, `EXIT`.
        :param str on_exit_code: A glob pattern to match against the decimal representation of the exit code returned for a job.
        :param str on_reason: A glob pattern to match against the reason returned for a job.
        :param str on_status_reason: A glob pattern to match against the status reason returned for a job.
        """
        pulumi.set(__self__, "action", action)
        if on_exit_code is not None:
            pulumi.set(__self__, "on_exit_code", on_exit_code)
        if on_reason is not None:
            pulumi.set(__self__, "on_reason", on_reason)
        if on_status_reason is not None:
            pulumi.set(__self__, "on_status_reason", on_status_reason)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Specifies the action to take if all of the specified conditions are met. The values are not case sensitive. Valid values: `RETRY`, `EXIT`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="onExitCode")
    def on_exit_code(self) -> Optional[str]:
        """
        A glob pattern to match against the decimal representation of the exit code returned for a job.
        """
        return pulumi.get(self, "on_exit_code")

    @property
    @pulumi.getter(name="onReason")
    def on_reason(self) -> Optional[str]:
        """
        A glob pattern to match against the reason returned for a job.
        """
        return pulumi.get(self, "on_reason")

    @property
    @pulumi.getter(name="onStatusReason")
    def on_status_reason(self) -> Optional[str]:
        """
        A glob pattern to match against the status reason returned for a job.
        """
        return pulumi.get(self, "on_status_reason")


@pulumi.output_type
class AwsBatchJobDefinitionTimeout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attemptDurationSeconds":
            suggest = "attempt_duration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsBatchJobDefinitionTimeout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsBatchJobDefinitionTimeout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsBatchJobDefinitionTimeout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attempt_duration_seconds: Optional[int] = None):
        """
        :param int attempt_duration_seconds: The time duration in seconds after which AWS Batch terminates your jobs if they have not finished. The minimum value for the timeout is `60`seconds.
        """
        if attempt_duration_seconds is not None:
            pulumi.set(__self__, "attempt_duration_seconds", attempt_duration_seconds)

    @property
    @pulumi.getter(name="attemptDurationSeconds")
    def attempt_duration_seconds(self) -> Optional[int]:
        """
        The time duration in seconds after which AWS Batch terminates your jobs if they have not finished. The minimum value for the timeout is `60`seconds.
        """
        return pulumi.get(self, "attempt_duration_seconds")


@pulumi.output_type
class AwsBatchSchedulingPolicyFairSharePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeReservation":
            suggest = "compute_reservation"
        elif key == "shareDecaySeconds":
            suggest = "share_decay_seconds"
        elif key == "shareDistributions":
            suggest = "share_distributions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsBatchSchedulingPolicyFairSharePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsBatchSchedulingPolicyFairSharePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsBatchSchedulingPolicyFairSharePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_reservation: Optional[int] = None,
                 share_decay_seconds: Optional[int] = None,
                 share_distributions: Optional[Sequence['outputs.AwsBatchSchedulingPolicyFairSharePolicyShareDistribution']] = None):
        """
        :param int compute_reservation: A value used to reserve some of the available maximum vCPU for fair share identifiers that have not yet been used.
        :param int share_decay_seconds: The time period to use to calculate a fair share percentage for each fair share identifier in use, in seconds.
        :param Sequence['AwsBatchSchedulingPolicyFairSharePolicyShareDistributionArgs'] share_distributions: One or more share distribution blocks which define the weights for the fair share identifiers for the fair share policy.
        """
        if compute_reservation is not None:
            pulumi.set(__self__, "compute_reservation", compute_reservation)
        if share_decay_seconds is not None:
            pulumi.set(__self__, "share_decay_seconds", share_decay_seconds)
        if share_distributions is not None:
            pulumi.set(__self__, "share_distributions", share_distributions)

    @property
    @pulumi.getter(name="computeReservation")
    def compute_reservation(self) -> Optional[int]:
        """
        A value used to reserve some of the available maximum vCPU for fair share identifiers that have not yet been used.
        """
        return pulumi.get(self, "compute_reservation")

    @property
    @pulumi.getter(name="shareDecaySeconds")
    def share_decay_seconds(self) -> Optional[int]:
        """
        The time period to use to calculate a fair share percentage for each fair share identifier in use, in seconds.
        """
        return pulumi.get(self, "share_decay_seconds")

    @property
    @pulumi.getter(name="shareDistributions")
    def share_distributions(self) -> Optional[Sequence['outputs.AwsBatchSchedulingPolicyFairSharePolicyShareDistribution']]:
        """
        One or more share distribution blocks which define the weights for the fair share identifiers for the fair share policy.
        """
        return pulumi.get(self, "share_distributions")


@pulumi.output_type
class AwsBatchSchedulingPolicyFairSharePolicyShareDistribution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shareIdentifier":
            suggest = "share_identifier"
        elif key == "weightFactor":
            suggest = "weight_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsBatchSchedulingPolicyFairSharePolicyShareDistribution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsBatchSchedulingPolicyFairSharePolicyShareDistribution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsBatchSchedulingPolicyFairSharePolicyShareDistribution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 share_identifier: str,
                 weight_factor: Optional[float] = None):
        """
        :param str share_identifier: A fair share identifier or fair share identifier prefix.
        :param float weight_factor: The weight factor for the fair share identifier.
        """
        pulumi.set(__self__, "share_identifier", share_identifier)
        if weight_factor is not None:
            pulumi.set(__self__, "weight_factor", weight_factor)

    @property
    @pulumi.getter(name="shareIdentifier")
    def share_identifier(self) -> str:
        """
        A fair share identifier or fair share identifier prefix.
        """
        return pulumi.get(self, "share_identifier")

    @property
    @pulumi.getter(name="weightFactor")
    def weight_factor(self) -> Optional[float]:
        """
        The weight factor for the fair share identifier.
        """
        return pulumi.get(self, "weight_factor")


@pulumi.output_type
class AwsCloudfrontDistributionCustomErrorResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorCachingMinTtl":
            suggest = "error_caching_min_ttl"
        elif key == "responseCode":
            suggest = "response_code"
        elif key == "responsePagePath":
            suggest = "response_page_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionCustomErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionCustomErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionCustomErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: int,
                 error_caching_min_ttl: Optional[int] = None,
                 response_code: Optional[int] = None,
                 response_page_path: Optional[str] = None):
        pulumi.set(__self__, "error_code", error_code)
        if error_caching_min_ttl is not None:
            pulumi.set(__self__, "error_caching_min_ttl", error_caching_min_ttl)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if response_page_path is not None:
            pulumi.set(__self__, "response_page_path", response_page_path)

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> int:
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorCachingMinTtl")
    def error_caching_min_ttl(self) -> Optional[int]:
        return pulumi.get(self, "error_caching_min_ttl")

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[int]:
        return pulumi.get(self, "response_code")

    @property
    @pulumi.getter(name="responsePagePath")
    def response_page_path(self) -> Optional[str]:
        return pulumi.get(self, "response_page_path")


@pulumi.output_type
class AwsCloudfrontDistributionDefaultCacheBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "cachedMethods":
            suggest = "cached_methods"
        elif key == "targetOriginId":
            suggest = "target_origin_id"
        elif key == "viewerProtocolPolicy":
            suggest = "viewer_protocol_policy"
        elif key == "cachePolicyId":
            suggest = "cache_policy_id"
        elif key == "defaultTtl":
            suggest = "default_ttl"
        elif key == "fieldLevelEncryptionId":
            suggest = "field_level_encryption_id"
        elif key == "forwardedValues":
            suggest = "forwarded_values"
        elif key == "functionAssociations":
            suggest = "function_associations"
        elif key == "lambdaFunctionAssociations":
            suggest = "lambda_function_associations"
        elif key == "maxTtl":
            suggest = "max_ttl"
        elif key == "minTtl":
            suggest = "min_ttl"
        elif key == "originRequestPolicyId":
            suggest = "origin_request_policy_id"
        elif key == "realtimeLogConfigArn":
            suggest = "realtime_log_config_arn"
        elif key == "responseHeadersPolicyId":
            suggest = "response_headers_policy_id"
        elif key == "smoothStreaming":
            suggest = "smooth_streaming"
        elif key == "trustedKeyGroups":
            suggest = "trusted_key_groups"
        elif key == "trustedSigners":
            suggest = "trusted_signers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionDefaultCacheBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[str],
                 cached_methods: Sequence[str],
                 target_origin_id: str,
                 viewer_protocol_policy: str,
                 cache_policy_id: Optional[str] = None,
                 compress: Optional[bool] = None,
                 default_ttl: Optional[int] = None,
                 field_level_encryption_id: Optional[str] = None,
                 forwarded_values: Optional['outputs.AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValues'] = None,
                 function_associations: Optional[Sequence['outputs.AwsCloudfrontDistributionDefaultCacheBehaviorFunctionAssociation']] = None,
                 lambda_function_associations: Optional[Sequence['outputs.AwsCloudfrontDistributionDefaultCacheBehaviorLambdaFunctionAssociation']] = None,
                 max_ttl: Optional[int] = None,
                 min_ttl: Optional[int] = None,
                 origin_request_policy_id: Optional[str] = None,
                 realtime_log_config_arn: Optional[str] = None,
                 response_headers_policy_id: Optional[str] = None,
                 smooth_streaming: Optional[bool] = None,
                 trusted_key_groups: Optional[Sequence[str]] = None,
                 trusted_signers: Optional[Sequence[str]] = None):
        """
        :param str cache_policy_id: \\n\\n						
               | Policy name                                                                                                                                                                                  | Policy Id                            |
               |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|
               | Amplify                                                | 2e54312d-136d-493c-8eb9-b001f22f67d2 |
               | CachingDisabled                               | 4135ea2d-6df8-44a3-9df3-4b5a84be39ad |
               | CachingOptimized                                    | 658327ea-f89d-4fab-a63d-7e88639e58f6 |
               | CachingOptimizedForUncompressedObjects | b2884449-e4de-46a7-ac36-70bc7f1ddd6d |
               | Elemental-MediaPackage                            | 08627262-05a9-4f76-9ded-b50ca2e3a84f |
               \\n\\n
        :param bool compress: Defaults to `false`.
        :param int default_ttl: default time to live: Not required when cache*policy*id is set
        :param int max_ttl: Maximum time to live: Not required when cache*policy*id is set
        :param int min_ttl: Minimum time to live: Not required when cache*policy*id is set Defaults to `0`.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if forwarded_values is not None:
            pulumi.set(__self__, "forwarded_values", forwarded_values)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if min_ttl is not None:
            pulumi.set(__self__, "min_ttl", min_ttl)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if smooth_streaming is not None:
            pulumi.set(__self__, "smooth_streaming", smooth_streaming)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)
        if trusted_signers is not None:
            pulumi.set(__self__, "trusted_signers", trusted_signers)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> Sequence[str]:
        return pulumi.get(self, "cached_methods")

    @property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> str:
        return pulumi.get(self, "target_origin_id")

    @property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> str:
        return pulumi.get(self, "viewer_protocol_policy")

    @property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[str]:
        """
        \\n\\n						
        | Policy name                                                                                                                                                                                  | Policy Id                            |
        |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------|
        | Amplify                                                | 2e54312d-136d-493c-8eb9-b001f22f67d2 |
        | CachingDisabled                               | 4135ea2d-6df8-44a3-9df3-4b5a84be39ad |
        | CachingOptimized                                    | 658327ea-f89d-4fab-a63d-7e88639e58f6 |
        | CachingOptimizedForUncompressedObjects | b2884449-e4de-46a7-ac36-70bc7f1ddd6d |
        | Elemental-MediaPackage                            | 08627262-05a9-4f76-9ded-b50ca2e3a84f |
        \\n\\n
        """
        return pulumi.get(self, "cache_policy_id")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[int]:
        """
        default time to live: Not required when cache*policy*id is set
        """
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[str]:
        return pulumi.get(self, "field_level_encryption_id")

    @property
    @pulumi.getter(name="forwardedValues")
    def forwarded_values(self) -> Optional['outputs.AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValues']:
        return pulumi.get(self, "forwarded_values")

    @property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[Sequence['outputs.AwsCloudfrontDistributionDefaultCacheBehaviorFunctionAssociation']]:
        return pulumi.get(self, "function_associations")

    @property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[Sequence['outputs.AwsCloudfrontDistributionDefaultCacheBehaviorLambdaFunctionAssociation']]:
        return pulumi.get(self, "lambda_function_associations")

    @property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[int]:
        """
        Maximum time to live: Not required when cache*policy*id is set
        """
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> Optional[int]:
        """
        Minimum time to live: Not required when cache*policy*id is set Defaults to `0`.
        """
        return pulumi.get(self, "min_ttl")

    @property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[str]:
        return pulumi.get(self, "origin_request_policy_id")

    @property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[str]:
        return pulumi.get(self, "realtime_log_config_arn")

    @property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[str]:
        return pulumi.get(self, "response_headers_policy_id")

    @property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> Optional[bool]:
        return pulumi.get(self, "smooth_streaming")

    @property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "trusted_key_groups")

    @property
    @pulumi.getter(name="trustedSigners")
    def trusted_signers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "trusted_signers")


@pulumi.output_type
class AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "queryStringCacheKeys":
            suggest = "query_string_cache_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookies: 'outputs.AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValuesCookies',
                 query_string: bool,
                 headers: Optional[Sequence[str]] = None,
                 query_string_cache_keys: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] headers: headers: Not required when cache*policy*id is set
        :param Sequence[str] query_string_cache_keys: query*string*cache*keys: Not required when cache*policy_id is set
        """
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "query_string", query_string)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_string_cache_keys is not None:
            pulumi.set(__self__, "query_string_cache_keys", query_string_cache_keys)

    @property
    @pulumi.getter
    def cookies(self) -> 'outputs.AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValuesCookies':
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> bool:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        """
        headers: Not required when cache*policy*id is set
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="queryStringCacheKeys")
    def query_string_cache_keys(self) -> Optional[Sequence[str]]:
        """
        query*string*cache*keys: Not required when cache*policy_id is set
        """
        return pulumi.get(self, "query_string_cache_keys")


@pulumi.output_type
class AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValuesCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistedNames":
            suggest = "whitelisted_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValuesCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValuesCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehaviorForwardedValuesCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward: str,
                 whitelisted_names: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "forward", forward)
        if whitelisted_names is not None:
            pulumi.set(__self__, "whitelisted_names", whitelisted_names)

    @property
    @pulumi.getter
    def forward(self) -> str:
        return pulumi.get(self, "forward")

    @property
    @pulumi.getter(name="whitelistedNames")
    def whitelisted_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "whitelisted_names")


@pulumi.output_type
class AwsCloudfrontDistributionDefaultCacheBehaviorFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionDefaultCacheBehaviorFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: str,
                 function_arn: str):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> str:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class AwsCloudfrontDistributionDefaultCacheBehaviorLambdaFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "lambdaArn":
            suggest = "lambda_arn"
        elif key == "includeBody":
            suggest = "include_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionDefaultCacheBehaviorLambdaFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionDefaultCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: str,
                 lambda_arn: str,
                 include_body: Optional[bool] = None):
        """
        :param bool include_body: Defaults to `false`.
        """
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> str:
        return pulumi.get(self, "lambda_arn")

    @property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "include_body")


@pulumi.output_type
class AwsCloudfrontDistributionLoggingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeCookies":
            suggest = "include_cookies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionLoggingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionLoggingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionLoggingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 include_cookies: Optional[bool] = None,
                 prefix: Optional[str] = None):
        """
        :param bool include_cookies: Defaults to `false`.
        :param str prefix: Defaults to ``.
        """
        pulumi.set(__self__, "bucket", bucket)
        if include_cookies is not None:
            pulumi.set(__self__, "include_cookies", include_cookies)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="includeCookies")
    def include_cookies(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "include_cookies")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Defaults to ``.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class AwsCloudfrontDistributionOrderedCacheBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "cachedMethods":
            suggest = "cached_methods"
        elif key == "pathPattern":
            suggest = "path_pattern"
        elif key == "targetOriginId":
            suggest = "target_origin_id"
        elif key == "viewerProtocolPolicy":
            suggest = "viewer_protocol_policy"
        elif key == "cachePolicyId":
            suggest = "cache_policy_id"
        elif key == "defaultTtl":
            suggest = "default_ttl"
        elif key == "fieldLevelEncryptionId":
            suggest = "field_level_encryption_id"
        elif key == "forwardedValues":
            suggest = "forwarded_values"
        elif key == "functionAssociations":
            suggest = "function_associations"
        elif key == "lambdaFunctionAssociations":
            suggest = "lambda_function_associations"
        elif key == "maxTtl":
            suggest = "max_ttl"
        elif key == "minTtl":
            suggest = "min_ttl"
        elif key == "originRequestPolicyId":
            suggest = "origin_request_policy_id"
        elif key == "realtimeLogConfigArn":
            suggest = "realtime_log_config_arn"
        elif key == "responseHeadersPolicyId":
            suggest = "response_headers_policy_id"
        elif key == "smoothStreaming":
            suggest = "smooth_streaming"
        elif key == "trustedKeyGroups":
            suggest = "trusted_key_groups"
        elif key == "trustedSigners":
            suggest = "trusted_signers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOrderedCacheBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[str],
                 cached_methods: Sequence[str],
                 path_pattern: str,
                 target_origin_id: str,
                 viewer_protocol_policy: str,
                 cache_policy_id: Optional[str] = None,
                 compress: Optional[bool] = None,
                 default_ttl: Optional[int] = None,
                 field_level_encryption_id: Optional[str] = None,
                 forwarded_values: Optional['outputs.AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValues'] = None,
                 function_associations: Optional[Sequence['outputs.AwsCloudfrontDistributionOrderedCacheBehaviorFunctionAssociation']] = None,
                 lambda_function_associations: Optional[Sequence['outputs.AwsCloudfrontDistributionOrderedCacheBehaviorLambdaFunctionAssociation']] = None,
                 max_ttl: Optional[int] = None,
                 min_ttl: Optional[int] = None,
                 origin_request_policy_id: Optional[str] = None,
                 realtime_log_config_arn: Optional[str] = None,
                 response_headers_policy_id: Optional[str] = None,
                 smooth_streaming: Optional[bool] = None,
                 trusted_key_groups: Optional[Sequence[str]] = None,
                 trusted_signers: Optional[Sequence[str]] = None):
        """
        :param bool compress: Defaults to `false`.
        :param int min_ttl: Defaults to `0`.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "cached_methods", cached_methods)
        pulumi.set(__self__, "path_pattern", path_pattern)
        pulumi.set(__self__, "target_origin_id", target_origin_id)
        pulumi.set(__self__, "viewer_protocol_policy", viewer_protocol_policy)
        if cache_policy_id is not None:
            pulumi.set(__self__, "cache_policy_id", cache_policy_id)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if field_level_encryption_id is not None:
            pulumi.set(__self__, "field_level_encryption_id", field_level_encryption_id)
        if forwarded_values is not None:
            pulumi.set(__self__, "forwarded_values", forwarded_values)
        if function_associations is not None:
            pulumi.set(__self__, "function_associations", function_associations)
        if lambda_function_associations is not None:
            pulumi.set(__self__, "lambda_function_associations", lambda_function_associations)
        if max_ttl is not None:
            pulumi.set(__self__, "max_ttl", max_ttl)
        if min_ttl is not None:
            pulumi.set(__self__, "min_ttl", min_ttl)
        if origin_request_policy_id is not None:
            pulumi.set(__self__, "origin_request_policy_id", origin_request_policy_id)
        if realtime_log_config_arn is not None:
            pulumi.set(__self__, "realtime_log_config_arn", realtime_log_config_arn)
        if response_headers_policy_id is not None:
            pulumi.set(__self__, "response_headers_policy_id", response_headers_policy_id)
        if smooth_streaming is not None:
            pulumi.set(__self__, "smooth_streaming", smooth_streaming)
        if trusted_key_groups is not None:
            pulumi.set(__self__, "trusted_key_groups", trusted_key_groups)
        if trusted_signers is not None:
            pulumi.set(__self__, "trusted_signers", trusted_signers)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="cachedMethods")
    def cached_methods(self) -> Sequence[str]:
        return pulumi.get(self, "cached_methods")

    @property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> str:
        return pulumi.get(self, "path_pattern")

    @property
    @pulumi.getter(name="targetOriginId")
    def target_origin_id(self) -> str:
        return pulumi.get(self, "target_origin_id")

    @property
    @pulumi.getter(name="viewerProtocolPolicy")
    def viewer_protocol_policy(self) -> str:
        return pulumi.get(self, "viewer_protocol_policy")

    @property
    @pulumi.getter(name="cachePolicyId")
    def cache_policy_id(self) -> Optional[str]:
        return pulumi.get(self, "cache_policy_id")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[int]:
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="fieldLevelEncryptionId")
    def field_level_encryption_id(self) -> Optional[str]:
        return pulumi.get(self, "field_level_encryption_id")

    @property
    @pulumi.getter(name="forwardedValues")
    def forwarded_values(self) -> Optional['outputs.AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValues']:
        return pulumi.get(self, "forwarded_values")

    @property
    @pulumi.getter(name="functionAssociations")
    def function_associations(self) -> Optional[Sequence['outputs.AwsCloudfrontDistributionOrderedCacheBehaviorFunctionAssociation']]:
        return pulumi.get(self, "function_associations")

    @property
    @pulumi.getter(name="lambdaFunctionAssociations")
    def lambda_function_associations(self) -> Optional[Sequence['outputs.AwsCloudfrontDistributionOrderedCacheBehaviorLambdaFunctionAssociation']]:
        return pulumi.get(self, "lambda_function_associations")

    @property
    @pulumi.getter(name="maxTtl")
    def max_ttl(self) -> Optional[int]:
        return pulumi.get(self, "max_ttl")

    @property
    @pulumi.getter(name="minTtl")
    def min_ttl(self) -> Optional[int]:
        """
        Defaults to `0`.
        """
        return pulumi.get(self, "min_ttl")

    @property
    @pulumi.getter(name="originRequestPolicyId")
    def origin_request_policy_id(self) -> Optional[str]:
        return pulumi.get(self, "origin_request_policy_id")

    @property
    @pulumi.getter(name="realtimeLogConfigArn")
    def realtime_log_config_arn(self) -> Optional[str]:
        return pulumi.get(self, "realtime_log_config_arn")

    @property
    @pulumi.getter(name="responseHeadersPolicyId")
    def response_headers_policy_id(self) -> Optional[str]:
        return pulumi.get(self, "response_headers_policy_id")

    @property
    @pulumi.getter(name="smoothStreaming")
    def smooth_streaming(self) -> Optional[bool]:
        return pulumi.get(self, "smooth_streaming")

    @property
    @pulumi.getter(name="trustedKeyGroups")
    def trusted_key_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "trusted_key_groups")

    @property
    @pulumi.getter(name="trustedSigners")
    def trusted_signers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "trusted_signers")


@pulumi.output_type
class AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "queryStringCacheKeys":
            suggest = "query_string_cache_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookies: 'outputs.AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValuesCookies',
                 query_string: bool,
                 headers: Optional[Sequence[str]] = None,
                 query_string_cache_keys: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "query_string", query_string)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_string_cache_keys is not None:
            pulumi.set(__self__, "query_string_cache_keys", query_string_cache_keys)

    @property
    @pulumi.getter
    def cookies(self) -> 'outputs.AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValuesCookies':
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> bool:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="queryStringCacheKeys")
    def query_string_cache_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "query_string_cache_keys")


@pulumi.output_type
class AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValuesCookies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistedNames":
            suggest = "whitelisted_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValuesCookies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValuesCookies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehaviorForwardedValuesCookies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward: str,
                 whitelisted_names: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "forward", forward)
        if whitelisted_names is not None:
            pulumi.set(__self__, "whitelisted_names", whitelisted_names)

    @property
    @pulumi.getter
    def forward(self) -> str:
        return pulumi.get(self, "forward")

    @property
    @pulumi.getter(name="whitelistedNames")
    def whitelisted_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "whitelisted_names")


@pulumi.output_type
class AwsCloudfrontDistributionOrderedCacheBehaviorFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOrderedCacheBehaviorFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehaviorFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: str,
                 function_arn: str):
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_arn", function_arn)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> str:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class AwsCloudfrontDistributionOrderedCacheBehaviorLambdaFunctionAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"
        elif key == "lambdaArn":
            suggest = "lambda_arn"
        elif key == "includeBody":
            suggest = "include_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOrderedCacheBehaviorLambdaFunctionAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOrderedCacheBehaviorLambdaFunctionAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: str,
                 lambda_arn: str,
                 include_body: Optional[bool] = None):
        """
        :param bool include_body: Defaults to `false`.
        """
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        if include_body is not None:
            pulumi.set(__self__, "include_body", include_body)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> str:
        return pulumi.get(self, "lambda_arn")

    @property
    @pulumi.getter(name="includeBody")
    def include_body(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "include_body")


@pulumi.output_type
class AwsCloudfrontDistributionOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainName":
            suggest = "domain_name"
        elif key == "originId":
            suggest = "origin_id"
        elif key == "connectionAttempts":
            suggest = "connection_attempts"
        elif key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "customHeaders":
            suggest = "custom_headers"
        elif key == "customOriginConfig":
            suggest = "custom_origin_config"
        elif key == "originPath":
            suggest = "origin_path"
        elif key == "originShield":
            suggest = "origin_shield"
        elif key == "s3OriginConfig":
            suggest = "s3_origin_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name: str,
                 origin_id: str,
                 connection_attempts: Optional[int] = None,
                 connection_timeout: Optional[int] = None,
                 custom_headers: Optional[Sequence['outputs.AwsCloudfrontDistributionOriginCustomHeader']] = None,
                 custom_origin_config: Optional['outputs.AwsCloudfrontDistributionOriginCustomOriginConfig'] = None,
                 origin_path: Optional[str] = None,
                 origin_shield: Optional['outputs.AwsCloudfrontDistributionOriginOriginShield'] = None,
                 s3_origin_config: Optional['outputs.AwsCloudfrontDistributionOriginS3OriginConfig'] = None):
        """
        :param int connection_attempts: Defaults to `3`.
        :param int connection_timeout: Defaults to `10`.
        :param str origin_path: Defaults to ``.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "origin_id", origin_id)
        if connection_attempts is not None:
            pulumi.set(__self__, "connection_attempts", connection_attempts)
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if custom_origin_config is not None:
            pulumi.set(__self__, "custom_origin_config", custom_origin_config)
        if origin_path is not None:
            pulumi.set(__self__, "origin_path", origin_path)
        if origin_shield is not None:
            pulumi.set(__self__, "origin_shield", origin_shield)
        if s3_origin_config is not None:
            pulumi.set(__self__, "s3_origin_config", s3_origin_config)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> str:
        return pulumi.get(self, "origin_id")

    @property
    @pulumi.getter(name="connectionAttempts")
    def connection_attempts(self) -> Optional[int]:
        """
        Defaults to `3`.
        """
        return pulumi.get(self, "connection_attempts")

    @property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[int]:
        """
        Defaults to `10`.
        """
        return pulumi.get(self, "connection_timeout")

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[Sequence['outputs.AwsCloudfrontDistributionOriginCustomHeader']]:
        return pulumi.get(self, "custom_headers")

    @property
    @pulumi.getter(name="customOriginConfig")
    def custom_origin_config(self) -> Optional['outputs.AwsCloudfrontDistributionOriginCustomOriginConfig']:
        return pulumi.get(self, "custom_origin_config")

    @property
    @pulumi.getter(name="originPath")
    def origin_path(self) -> Optional[str]:
        """
        Defaults to ``.
        """
        return pulumi.get(self, "origin_path")

    @property
    @pulumi.getter(name="originShield")
    def origin_shield(self) -> Optional['outputs.AwsCloudfrontDistributionOriginOriginShield']:
        return pulumi.get(self, "origin_shield")

    @property
    @pulumi.getter(name="s3OriginConfig")
    def s3_origin_config(self) -> Optional['outputs.AwsCloudfrontDistributionOriginS3OriginConfig']:
        return pulumi.get(self, "s3_origin_config")


@pulumi.output_type
class AwsCloudfrontDistributionOriginCustomHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsCloudfrontDistributionOriginCustomOriginConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originProtocolPolicy":
            suggest = "origin_protocol_policy"
        elif key == "originSslProtocols":
            suggest = "origin_ssl_protocols"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "originKeepaliveTimeout":
            suggest = "origin_keepalive_timeout"
        elif key == "originReadTimeout":
            suggest = "origin_read_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOriginCustomOriginConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOriginCustomOriginConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOriginCustomOriginConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_protocol_policy: str,
                 origin_ssl_protocols: Sequence[str],
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 origin_keepalive_timeout: Optional[int] = None,
                 origin_read_timeout: Optional[int] = None):
        """
        :param int http_port: Defaults to `80`.
        :param int https_port: Defaults to `443`.
        :param int origin_keepalive_timeout: Defaults to `5`.
        :param int origin_read_timeout: Defaults to `30`.
        """
        pulumi.set(__self__, "origin_protocol_policy", origin_protocol_policy)
        pulumi.set(__self__, "origin_ssl_protocols", origin_ssl_protocols)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if origin_keepalive_timeout is not None:
            pulumi.set(__self__, "origin_keepalive_timeout", origin_keepalive_timeout)
        if origin_read_timeout is not None:
            pulumi.set(__self__, "origin_read_timeout", origin_read_timeout)

    @property
    @pulumi.getter(name="originProtocolPolicy")
    def origin_protocol_policy(self) -> str:
        return pulumi.get(self, "origin_protocol_policy")

    @property
    @pulumi.getter(name="originSslProtocols")
    def origin_ssl_protocols(self) -> Sequence[str]:
        return pulumi.get(self, "origin_ssl_protocols")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        Defaults to `80`.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        Defaults to `443`.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="originKeepaliveTimeout")
    def origin_keepalive_timeout(self) -> Optional[int]:
        """
        Defaults to `5`.
        """
        return pulumi.get(self, "origin_keepalive_timeout")

    @property
    @pulumi.getter(name="originReadTimeout")
    def origin_read_timeout(self) -> Optional[int]:
        """
        Defaults to `30`.
        """
        return pulumi.get(self, "origin_read_timeout")


@pulumi.output_type
class AwsCloudfrontDistributionOriginGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverCriteria":
            suggest = "failover_criteria"
        elif key == "originId":
            suggest = "origin_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOriginGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOriginGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOriginGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_criteria: 'outputs.AwsCloudfrontDistributionOriginGroupFailoverCriteria',
                 members: Sequence['outputs.AwsCloudfrontDistributionOriginGroupMember'],
                 origin_id: str):
        pulumi.set(__self__, "failover_criteria", failover_criteria)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "origin_id", origin_id)

    @property
    @pulumi.getter(name="failoverCriteria")
    def failover_criteria(self) -> 'outputs.AwsCloudfrontDistributionOriginGroupFailoverCriteria':
        return pulumi.get(self, "failover_criteria")

    @property
    @pulumi.getter
    def members(self) -> Sequence['outputs.AwsCloudfrontDistributionOriginGroupMember']:
        return pulumi.get(self, "members")

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> str:
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class AwsCloudfrontDistributionOriginGroupFailoverCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOriginGroupFailoverCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOriginGroupFailoverCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOriginGroupFailoverCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_codes: Sequence[int]):
        pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence[int]:
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class AwsCloudfrontDistributionOriginGroupMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originId":
            suggest = "origin_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOriginGroupMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOriginGroupMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOriginGroupMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_id: str):
        pulumi.set(__self__, "origin_id", origin_id)

    @property
    @pulumi.getter(name="originId")
    def origin_id(self) -> str:
        return pulumi.get(self, "origin_id")


@pulumi.output_type
class AwsCloudfrontDistributionOriginOriginShield(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originShieldRegion":
            suggest = "origin_shield_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOriginOriginShield. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOriginOriginShield.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOriginOriginShield.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 origin_shield_region: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "origin_shield_region", origin_shield_region)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="originShieldRegion")
    def origin_shield_region(self) -> str:
        return pulumi.get(self, "origin_shield_region")


@pulumi.output_type
class AwsCloudfrontDistributionOriginS3OriginConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originAccessIdentity":
            suggest = "origin_access_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionOriginS3OriginConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionOriginS3OriginConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionOriginS3OriginConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_access_identity: Optional[str] = None):
        """
        :param str origin_access_identity: The CloudFront origin access identity to associate with the origin. This is used to restrict access to the S3 bucket. Duplo assigns this automatically when the "use*origin*access_identity" is set to true. Any explicit value set here will be ignored and duplo created oai will be used.
        """
        if origin_access_identity is not None:
            pulumi.set(__self__, "origin_access_identity", origin_access_identity)

    @property
    @pulumi.getter(name="originAccessIdentity")
    def origin_access_identity(self) -> Optional[str]:
        """
        The CloudFront origin access identity to associate with the origin. This is used to restrict access to the S3 bucket. Duplo assigns this automatically when the "use*origin*access_identity" is set to true. Any explicit value set here will be ignored and duplo created oai will be used.
        """
        return pulumi.get(self, "origin_access_identity")


@pulumi.output_type
class AwsCloudfrontDistributionRestrictions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoRestriction":
            suggest = "geo_restriction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionRestrictions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionRestrictions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionRestrictions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_restriction: 'outputs.AwsCloudfrontDistributionRestrictionsGeoRestriction'):
        pulumi.set(__self__, "geo_restriction", geo_restriction)

    @property
    @pulumi.getter(name="geoRestriction")
    def geo_restriction(self) -> 'outputs.AwsCloudfrontDistributionRestrictionsGeoRestriction':
        return pulumi.get(self, "geo_restriction")


@pulumi.output_type
class AwsCloudfrontDistributionRestrictionsGeoRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionType":
            suggest = "restriction_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionRestrictionsGeoRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionRestrictionsGeoRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionRestrictionsGeoRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restriction_type: str,
                 locations: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "restriction_type", restriction_type)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter(name="restrictionType")
    def restriction_type(self) -> str:
        return pulumi.get(self, "restriction_type")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "locations")


@pulumi.output_type
class AwsCloudfrontDistributionViewerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acmCertificateArn":
            suggest = "acm_certificate_arn"
        elif key == "cloudfrontDefaultCertificate":
            suggest = "cloudfront_default_certificate"
        elif key == "iamCertificateId":
            suggest = "iam_certificate_id"
        elif key == "minimumProtocolVersion":
            suggest = "minimum_protocol_version"
        elif key == "sslSupportMethod":
            suggest = "ssl_support_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCloudfrontDistributionViewerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCloudfrontDistributionViewerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCloudfrontDistributionViewerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acm_certificate_arn: Optional[str] = None,
                 cloudfront_default_certificate: Optional[bool] = None,
                 iam_certificate_id: Optional[str] = None,
                 minimum_protocol_version: Optional[str] = None,
                 ssl_support_method: Optional[str] = None):
        """
        :param str minimum_protocol_version: Defaults to `TLSv1.2_2021`.
        :param str ssl_support_method: Defaults to `sni-only`.
        """
        if acm_certificate_arn is not None:
            pulumi.set(__self__, "acm_certificate_arn", acm_certificate_arn)
        if cloudfront_default_certificate is not None:
            pulumi.set(__self__, "cloudfront_default_certificate", cloudfront_default_certificate)
        if iam_certificate_id is not None:
            pulumi.set(__self__, "iam_certificate_id", iam_certificate_id)
        if minimum_protocol_version is not None:
            pulumi.set(__self__, "minimum_protocol_version", minimum_protocol_version)
        if ssl_support_method is not None:
            pulumi.set(__self__, "ssl_support_method", ssl_support_method)

    @property
    @pulumi.getter(name="acmCertificateArn")
    def acm_certificate_arn(self) -> Optional[str]:
        return pulumi.get(self, "acm_certificate_arn")

    @property
    @pulumi.getter(name="cloudfrontDefaultCertificate")
    def cloudfront_default_certificate(self) -> Optional[bool]:
        return pulumi.get(self, "cloudfront_default_certificate")

    @property
    @pulumi.getter(name="iamCertificateId")
    def iam_certificate_id(self) -> Optional[str]:
        return pulumi.get(self, "iam_certificate_id")

    @property
    @pulumi.getter(name="minimumProtocolVersion")
    def minimum_protocol_version(self) -> Optional[str]:
        """
        Defaults to `TLSv1.2_2021`.
        """
        return pulumi.get(self, "minimum_protocol_version")

    @property
    @pulumi.getter(name="sslSupportMethod")
    def ssl_support_method(self) -> Optional[str]:
        """
        Defaults to `sni-only`.
        """
        return pulumi.get(self, "ssl_support_method")


@pulumi.output_type
class AwsCloudwatchEventRuleTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsCloudwatchMetricAlarmDimension(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsDynamodbTableV2Attribute(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: The name of the attribute
        :param str type: Attribute type, which must be a scalar type: `S`, `N`, or `B` for (S)tring, (N)umber or (B)inary data
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the attribute
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Attribute type, which must be a scalar type: `S`, `N`, or `B` for (S)tring, (N)umber or (B)inary data
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AwsDynamodbTableV2GlobalSecondaryIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashKey":
            suggest = "hash_key"
        elif key == "projectionType":
            suggest = "projection_type"
        elif key == "nonKeyAttributes":
            suggest = "non_key_attributes"
        elif key == "rangeKey":
            suggest = "range_key"
        elif key == "readCapacity":
            suggest = "read_capacity"
        elif key == "writeCapacity":
            suggest = "write_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDynamodbTableV2GlobalSecondaryIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDynamodbTableV2GlobalSecondaryIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDynamodbTableV2GlobalSecondaryIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_key: str,
                 name: str,
                 projection_type: str,
                 non_key_attributes: Optional[Sequence[str]] = None,
                 range_key: Optional[str] = None,
                 read_capacity: Optional[int] = None,
                 write_capacity: Optional[int] = None):
        """
        :param str hash_key: The name of the hash key in the index; must be defined as an attribute in the resource.
        :param str name: The name of the index.
        :param str projection_type: One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects just the hash and range key into the index, and `INCLUDE` projects only the keys specified in the `non_key_attributes` parameter.
        :param Sequence[str] non_key_attributes: Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
        :param str range_key: The name of the range key; must be defined.
        :param int read_capacity: The number of read units for this index. Must be set if `billing_mode` is set to `PROVISIONED`.
        :param int write_capacity: The number of write units for this index. Must be set if `billing_mode` is set to `PROVISIONED`.
        """
        pulumi.set(__self__, "hash_key", hash_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "projection_type", projection_type)
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        if range_key is not None:
            pulumi.set(__self__, "range_key", range_key)
        if read_capacity is not None:
            pulumi.set(__self__, "read_capacity", read_capacity)
        if write_capacity is not None:
            pulumi.set(__self__, "write_capacity", write_capacity)

    @property
    @pulumi.getter(name="hashKey")
    def hash_key(self) -> str:
        """
        The name of the hash key in the index; must be defined as an attribute in the resource.
        """
        return pulumi.get(self, "hash_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> str:
        """
        One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects just the hash and range key into the index, and `INCLUDE` projects only the keys specified in the `non_key_attributes` parameter.
        """
        return pulumi.get(self, "projection_type")

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[Sequence[str]]:
        """
        Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
        """
        return pulumi.get(self, "non_key_attributes")

    @property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> Optional[str]:
        """
        The name of the range key; must be defined.
        """
        return pulumi.get(self, "range_key")

    @property
    @pulumi.getter(name="readCapacity")
    def read_capacity(self) -> Optional[int]:
        """
        The number of read units for this index. Must be set if `billing_mode` is set to `PROVISIONED`.
        """
        return pulumi.get(self, "read_capacity")

    @property
    @pulumi.getter(name="writeCapacity")
    def write_capacity(self) -> Optional[int]:
        """
        The number of write units for this index. Must be set if `billing_mode` is set to `PROVISIONED`.
        """
        return pulumi.get(self, "write_capacity")


@pulumi.output_type
class AwsDynamodbTableV2KeySchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "keyType":
            suggest = "key_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDynamodbTableV2KeySchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDynamodbTableV2KeySchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDynamodbTableV2KeySchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 key_type: str):
        """
        :param str attribute_name: The name of the attribute
        :param str key_type: Applicable key types are `HASH` or `RANGE`.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "key_type", key_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the attribute
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> str:
        """
        Applicable key types are `HASH` or `RANGE`.
        """
        return pulumi.get(self, "key_type")


@pulumi.output_type
class AwsDynamodbTableV2LocalSecondaryIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashKey":
            suggest = "hash_key"
        elif key == "projectionType":
            suggest = "projection_type"
        elif key == "rangeKey":
            suggest = "range_key"
        elif key == "nonKeyAttributes":
            suggest = "non_key_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDynamodbTableV2LocalSecondaryIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDynamodbTableV2LocalSecondaryIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDynamodbTableV2LocalSecondaryIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_key: str,
                 name: str,
                 projection_type: str,
                 range_key: str,
                 non_key_attributes: Optional[Sequence[str]] = None):
        """
        :param str hash_key: The name of the hash key in the index; must be defined as an attribute in the resource.
        :param str name: The name of the index.
        :param str projection_type: One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects just the hash and range key into the index, and `INCLUDE` projects only the keys specified in the `non_key_attributes` parameter.
        :param str range_key: The name of the range key; must be defined.
        :param Sequence[str] non_key_attributes: Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
        """
        pulumi.set(__self__, "hash_key", hash_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "projection_type", projection_type)
        pulumi.set(__self__, "range_key", range_key)
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)

    @property
    @pulumi.getter(name="hashKey")
    def hash_key(self) -> str:
        """
        The name of the hash key in the index; must be defined as an attribute in the resource.
        """
        return pulumi.get(self, "hash_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> str:
        """
        One of `ALL`, `INCLUDE` or `KEYS_ONLY` where `ALL` projects every attribute into the index, `KEYS_ONLY` projects just the hash and range key into the index, and `INCLUDE` projects only the keys specified in the `non_key_attributes` parameter.
        """
        return pulumi.get(self, "projection_type")

    @property
    @pulumi.getter(name="rangeKey")
    def range_key(self) -> str:
        """
        The name of the range key; must be defined.
        """
        return pulumi.get(self, "range_key")

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[Sequence[str]]:
        """
        Only required with `INCLUDE` as a projection type; a list of attributes to project into the index. These do not need to be defined as attributes on the table.
        """
        return pulumi.get(self, "non_key_attributes")


@pulumi.output_type
class AwsDynamodbTableV2ServerSideEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDynamodbTableV2ServerSideEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDynamodbTableV2ServerSideEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDynamodbTableV2ServerSideEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 kms_key_arn: Optional[str] = None):
        """
        :param bool enabled: Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK).
        :param str kms_key_arn: The ARN of the CMK that should be used for the AWS KMS encryption.
        """
        pulumi.set(__self__, "enabled", enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether or not to enable encryption at rest using an AWS managed KMS customer master key (CMK).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        The ARN of the CMK that should be used for the AWS KMS encryption.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class AwsDynamodbTableV2Tag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsDynamodbTableV2Ttl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsDynamodbTableV2Ttl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsDynamodbTableV2Ttl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsDynamodbTableV2Ttl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: str,
                 enabled: bool):
        """
        :param str attribute_name: The name of the attribute that will be stored in the ttl timestamp
        :param bool enabled: Status of the ttl
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        The name of the attribute that will be stored in the ttl timestamp
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Status of the ttl
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AwsEfsFileSystemLifecyclePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transitionToArchive":
            suggest = "transition_to_archive"
        elif key == "transitionToIa":
            suggest = "transition_to_ia"
        elif key == "transitionToPrimaryStorageClass":
            suggest = "transition_to_primary_storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEfsFileSystemLifecyclePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEfsFileSystemLifecyclePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEfsFileSystemLifecyclePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transition_to_archive: Optional[str] = None,
                 transition_to_ia: Optional[str] = None,
                 transition_to_primary_storage_class: Optional[str] = None):
        """
        :param str transition_to_archive: Indicates how long it takes to transition files to the archive storage class. Requires transition*to*ia, Elastic Throughput and General Purpose performance mode. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`
        :param str transition_to_ia: Indicates how long it takes to transition files to the IA storage class. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`
        :param str transition_to_primary_storage_class: Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: `AFTER_1_ACCESS`
        """
        if transition_to_archive is not None:
            pulumi.set(__self__, "transition_to_archive", transition_to_archive)
        if transition_to_ia is not None:
            pulumi.set(__self__, "transition_to_ia", transition_to_ia)
        if transition_to_primary_storage_class is not None:
            pulumi.set(__self__, "transition_to_primary_storage_class", transition_to_primary_storage_class)

    @property
    @pulumi.getter(name="transitionToArchive")
    def transition_to_archive(self) -> Optional[str]:
        """
        Indicates how long it takes to transition files to the archive storage class. Requires transition*to*ia, Elastic Throughput and General Purpose performance mode. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`
        """
        return pulumi.get(self, "transition_to_archive")

    @property
    @pulumi.getter(name="transitionToIa")
    def transition_to_ia(self) -> Optional[str]:
        """
        Indicates how long it takes to transition files to the IA storage class. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`
        """
        return pulumi.get(self, "transition_to_ia")

    @property
    @pulumi.getter(name="transitionToPrimaryStorageClass")
    def transition_to_primary_storage_class(self) -> Optional[str]:
        """
        Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: `AFTER_1_ACCESS`
        """
        return pulumi.get(self, "transition_to_primary_storage_class")


@pulumi.output_type
class AwsEfsFileSystemMountTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "lifecycleState":
            suggest = "lifecycle_state"
        elif key == "mountTargetId":
            suggest = "mount_target_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEfsFileSystemMountTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEfsFileSystemMountTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEfsFileSystemMountTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 lifecycle_state: Optional[str] = None,
                 mount_target_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if lifecycle_state is not None:
            pulumi.set(__self__, "lifecycle_state", lifecycle_state)
        if mount_target_id is not None:
            pulumi.set(__self__, "mount_target_id", mount_target_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> Optional[str]:
        return pulumi.get(self, "lifecycle_state")

    @property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> Optional[str]:
        return pulumi.get(self, "mount_target_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AwsEfsFileSystemTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsEfsLifecyclePolicyLifecyclePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transitionToArchive":
            suggest = "transition_to_archive"
        elif key == "transitionToIa":
            suggest = "transition_to_ia"
        elif key == "transitionToPrimaryStorageClass":
            suggest = "transition_to_primary_storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsEfsLifecyclePolicyLifecyclePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsEfsLifecyclePolicyLifecyclePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsEfsLifecyclePolicyLifecyclePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transition_to_archive: Optional[str] = None,
                 transition_to_ia: Optional[str] = None,
                 transition_to_primary_storage_class: Optional[str] = None):
        """
        :param str transition_to_archive: Indicates how long it takes to transition files to the archive storage class. Requires transition*to*ia, Elastic Throughput and General Purpose performance mode. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`
        :param str transition_to_ia: Indicates how long it takes to transition files to the IA storage class. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`
        :param str transition_to_primary_storage_class: Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: `AFTER_1_ACCESS`
        """
        if transition_to_archive is not None:
            pulumi.set(__self__, "transition_to_archive", transition_to_archive)
        if transition_to_ia is not None:
            pulumi.set(__self__, "transition_to_ia", transition_to_ia)
        if transition_to_primary_storage_class is not None:
            pulumi.set(__self__, "transition_to_primary_storage_class", transition_to_primary_storage_class)

    @property
    @pulumi.getter(name="transitionToArchive")
    def transition_to_archive(self) -> Optional[str]:
        """
        Indicates how long it takes to transition files to the archive storage class. Requires transition*to*ia, Elastic Throughput and General Purpose performance mode. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`
        """
        return pulumi.get(self, "transition_to_archive")

    @property
    @pulumi.getter(name="transitionToIa")
    def transition_to_ia(self) -> Optional[str]:
        """
        Indicates how long it takes to transition files to the IA storage class. Valid values: `AFTER_1_DAY`, `AFTER_7_DAYS`, `AFTER_14_DAYS`, `AFTER_30_DAYS`, `AFTER_60_DAYS`, or `AFTER_90_DAYS`
        """
        return pulumi.get(self, "transition_to_ia")

    @property
    @pulumi.getter(name="transitionToPrimaryStorageClass")
    def transition_to_primary_storage_class(self) -> Optional[str]:
        """
        Describes the policy used to transition a file from infequent access storage to primary storage. Valid values: `AFTER_1_ACCESS`
        """
        return pulumi.get(self, "transition_to_primary_storage_class")


@pulumi.output_type
class AwsElasticsearchClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coldStorageOptions":
            suggest = "cold_storage_options"
        elif key == "dedicatedMasterCount":
            suggest = "dedicated_master_count"
        elif key == "dedicatedMasterEnabled":
            suggest = "dedicated_master_enabled"
        elif key == "dedicatedMasterType":
            suggest = "dedicated_master_type"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "multiAzWithStandbyEnabled":
            suggest = "multi_az_with_standby_enabled"
        elif key == "warmCount":
            suggest = "warm_count"
        elif key == "warmEnabled":
            suggest = "warm_enabled"
        elif key == "warmType":
            suggest = "warm_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticsearchClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticsearchClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticsearchClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cold_storage_options: Optional['outputs.AwsElasticsearchClusterConfigColdStorageOptions'] = None,
                 dedicated_master_count: Optional[int] = None,
                 dedicated_master_enabled: Optional[bool] = None,
                 dedicated_master_type: Optional[str] = None,
                 instance_count: Optional[int] = None,
                 instance_type: Optional[str] = None,
                 multi_az_with_standby_enabled: Optional[bool] = None,
                 warm_count: Optional[int] = None,
                 warm_enabled: Optional[bool] = None,
                 warm_type: Optional[str] = None):
        """
        :param int dedicated_master_count: Defaults to `0`.
        :param bool dedicated_master_enabled: Defaults to `false`.
        :param str dedicated_master_type: Defaults to `t2.small.elasticsearch`.
        :param int instance_count: Defaults to `1`.
        :param str instance_type: Defaults to `t2.small.elasticsearch`.
        """
        if cold_storage_options is not None:
            pulumi.set(__self__, "cold_storage_options", cold_storage_options)
        if dedicated_master_count is not None:
            pulumi.set(__self__, "dedicated_master_count", dedicated_master_count)
        if dedicated_master_enabled is not None:
            pulumi.set(__self__, "dedicated_master_enabled", dedicated_master_enabled)
        if dedicated_master_type is not None:
            pulumi.set(__self__, "dedicated_master_type", dedicated_master_type)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if multi_az_with_standby_enabled is not None:
            pulumi.set(__self__, "multi_az_with_standby_enabled", multi_az_with_standby_enabled)
        if warm_count is not None:
            pulumi.set(__self__, "warm_count", warm_count)
        if warm_enabled is not None:
            pulumi.set(__self__, "warm_enabled", warm_enabled)
        if warm_type is not None:
            pulumi.set(__self__, "warm_type", warm_type)

    @property
    @pulumi.getter(name="coldStorageOptions")
    def cold_storage_options(self) -> Optional['outputs.AwsElasticsearchClusterConfigColdStorageOptions']:
        return pulumi.get(self, "cold_storage_options")

    @property
    @pulumi.getter(name="dedicatedMasterCount")
    def dedicated_master_count(self) -> Optional[int]:
        """
        Defaults to `0`.
        """
        return pulumi.get(self, "dedicated_master_count")

    @property
    @pulumi.getter(name="dedicatedMasterEnabled")
    def dedicated_master_enabled(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "dedicated_master_enabled")

    @property
    @pulumi.getter(name="dedicatedMasterType")
    def dedicated_master_type(self) -> Optional[str]:
        """
        Defaults to `t2.small.elasticsearch`.
        """
        return pulumi.get(self, "dedicated_master_type")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[int]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        Defaults to `t2.small.elasticsearch`.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="multiAzWithStandbyEnabled")
    def multi_az_with_standby_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "multi_az_with_standby_enabled")

    @property
    @pulumi.getter(name="warmCount")
    def warm_count(self) -> Optional[int]:
        return pulumi.get(self, "warm_count")

    @property
    @pulumi.getter(name="warmEnabled")
    def warm_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "warm_enabled")

    @property
    @pulumi.getter(name="warmType")
    def warm_type(self) -> Optional[str]:
        return pulumi.get(self, "warm_type")


@pulumi.output_type
class AwsElasticsearchClusterConfigColdStorageOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AwsElasticsearchEbsOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsEnabled":
            suggest = "ebs_enabled"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticsearchEbsOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticsearchEbsOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticsearchEbsOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ebs_enabled: Optional[bool] = None,
                 iops: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        if ebs_enabled is not None:
            pulumi.set(__self__, "ebs_enabled", ebs_enabled)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="ebsEnabled")
    def ebs_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "ebs_enabled")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AwsElasticsearchEncryptAtRest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "kmsKeyName":
            suggest = "kms_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticsearchEncryptAtRest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticsearchEncryptAtRest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticsearchEncryptAtRest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 kms_key_name: Optional[str] = None):
        """
        :param str kms_key_id: The ID of a KMS key to use with the ElasticSearch instance.
        :param str kms_key_name: The name of a KMS key to use with the ElasticSearch instance.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ID of a KMS key to use with the ElasticSearch instance.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[str]:
        """
        The name of a KMS key to use with the ElasticSearch instance.
        """
        return pulumi.get(self, "kms_key_name")


@pulumi.output_type
class AwsElasticsearchSnapshotOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automatedSnapshotStartHour":
            suggest = "automated_snapshot_start_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticsearchSnapshotOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticsearchSnapshotOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticsearchSnapshotOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated_snapshot_start_hour: int):
        pulumi.set(__self__, "automated_snapshot_start_hour", automated_snapshot_start_hour)

    @property
    @pulumi.getter(name="automatedSnapshotStartHour")
    def automated_snapshot_start_hour(self) -> int:
        return pulumi.get(self, "automated_snapshot_start_hour")


@pulumi.output_type
class AwsElasticsearchVpcOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsElasticsearchVpcOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsElasticsearchVpcOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsElasticsearchVpcOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zones: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class AwsHostMetadata(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsHostMinionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsHostNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatePublicIp":
            suggest = "associate_public_ip"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsHostNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsHostNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsHostNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_public_ip: Optional[bool] = None,
                 device_index: Optional[int] = None,
                 groups: Optional[Sequence[str]] = None,
                 metadatas: Optional[Sequence['outputs.AwsHostNetworkInterfaceMetadata']] = None,
                 network_interface_id: Optional[str] = None,
                 subnet_id: Optional[str] = None):
        """
        :param bool associate_public_ip: Whether or not to associate a public IP with the newly created ENI.  Cannot be specified if `network_interface_id` is specified.
        :param int device_index: The device index to pass to AWS for attaching the ENI.  Starts at zero.
        :param str network_interface_id: The ID of an ENI to attach to this host.  Cannot be specified if `subnet_id` or `associate_public_ip` is specified.
        :param str subnet_id: The ID of a subnet in which to create a new ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        if associate_public_ip is not None:
            pulumi.set(__self__, "associate_public_ip", associate_public_ip)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associatePublicIp")
    def associate_public_ip(self) -> Optional[bool]:
        """
        Whether or not to associate a public IP with the newly created ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        return pulumi.get(self, "associate_public_ip")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[int]:
        """
        The device index to pass to AWS for attaching the ENI.  Starts at zero.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.AwsHostNetworkInterfaceMetadata']]:
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of an ENI to attach to this host.  Cannot be specified if `subnet_id` or `associate_public_ip` is specified.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of a subnet in which to create a new ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AwsHostNetworkInterfaceMetadata(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsHostTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsHostTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str effect: Update strategy of the node. Effect types <br>      - NoSchedule<br>     - PreferNoSchedule<br>     - NoExecute
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Update strategy of the node. Effect types <br>      - NoSchedule<br>     - PreferNoSchedule<br>     - NoExecute
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsHostVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsHostVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsHostVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsHostVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 iops: Optional[int] = None,
                 name: Optional[str] = None,
                 size: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Whether the volume should be deleted when the instance is terminated.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether the volume should be deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AwsLambdaFunctionDeadLetterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLambdaFunctionDeadLetterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLambdaFunctionDeadLetterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLambdaFunctionDeadLetterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_arn: Optional[str] = None):
        """
        :param str target_arn: ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        if target_arn is not None:
            pulumi.set(__self__, "target_arn", target_arn)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[str]:
        """
        ARN of an SNS topic or SQS queue to notify when an invocation fails.
        """
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class AwsLambdaFunctionEnvironment(dict):
    def __init__(__self__, *,
                 variables: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] variables: Map of environment variables that are accessible from the function code during execution.
        """
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def variables(self) -> Optional[Mapping[str, str]]:
        """
        Map of environment variables that are accessible from the function code during execution.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class AwsLambdaFunctionEventConfigDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"
        elif key == "onSuccess":
            suggest = "on_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLambdaFunctionEventConfigDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLambdaFunctionEventConfigDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLambdaFunctionEventConfigDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.AwsLambdaFunctionEventConfigDestinationConfigOnFailure'] = None,
                 on_success: Optional['outputs.AwsLambdaFunctionEventConfigDestinationConfigOnSuccess'] = None):
        """
        :param 'AwsLambdaFunctionEventConfigDestinationConfigOnFailureArgs' on_failure: Configured destination for failed asynchronous invocations
        :param 'AwsLambdaFunctionEventConfigDestinationConfigOnSuccessArgs' on_success: Configured destination for successful asynchronous invocations
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_success is not None:
            pulumi.set(__self__, "on_success", on_success)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.AwsLambdaFunctionEventConfigDestinationConfigOnFailure']:
        """
        Configured destination for failed asynchronous invocations
        """
        return pulumi.get(self, "on_failure")

    @property
    @pulumi.getter(name="onSuccess")
    def on_success(self) -> Optional['outputs.AwsLambdaFunctionEventConfigDestinationConfigOnSuccess']:
        """
        Configured destination for successful asynchronous invocations
        """
        return pulumi.get(self, "on_success")


@pulumi.output_type
class AwsLambdaFunctionEventConfigDestinationConfigOnFailure(dict):
    def __init__(__self__, *,
                 destination: str):
        """
        :param str destination: The AWS ARN of the destination resource
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        The AWS ARN of the destination resource
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class AwsLambdaFunctionEventConfigDestinationConfigOnSuccess(dict):
    def __init__(__self__, *,
                 destination: str):
        """
        :param str destination: The AWS ARN of the destination resource
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        The AWS ARN of the destination resource
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class AwsLambdaFunctionImageConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoints":
            suggest = "entry_points"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLambdaFunctionImageConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLambdaFunctionImageConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLambdaFunctionImageConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None,
                 entry_points: Optional[Sequence[str]] = None,
                 working_directory: Optional[str] = None):
        """
        :param Sequence[str] commands: The command that is passed to the container.
        :param Sequence[str] entry_points: The entry point that is passed to the container.
        :param str working_directory: The working directory that is passed to the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if entry_points is not None:
            pulumi.set(__self__, "entry_points", entry_points)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        The command that is passed to the container.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="entryPoints")
    def entry_points(self) -> Optional[Sequence[str]]:
        """
        The entry point that is passed to the container.
        """
        return pulumi.get(self, "entry_points")

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[str]:
        """
        The working directory that is passed to the container.
        """
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class AwsLambdaFunctionTracingConfig(dict):
    def __init__(__self__, *,
                 mode: str):
        """
        :param str mode: Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`.
        """
        pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        Whether to sample and trace a subset of incoming requests with AWS X-Ray. Valid values are `PassThrough` and `Active`.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AwsLaunchTemplateBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLaunchTemplateBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 ebs: Optional['outputs.AwsLaunchTemplateBlockDeviceMappingEbs'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: The name of the device to mount
        :param 'AwsLaunchTemplateBlockDeviceMappingEbsArgs' ebs: Configure EBS volume properties.
        :param str no_device: Suppresses the specified device included in the AMI's block device mapping.
        :param str virtual_name: The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        The name of the device to mount
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.AwsLaunchTemplateBlockDeviceMappingEbs']:
        """
        Configure EBS volume properties.
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        """
        Suppresses the specified device included in the AMI's block device mapping.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class AwsLaunchTemplateBlockDeviceMappingEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeInitializationRate":
            suggest = "volume_initialization_rate"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLaunchTemplateBlockDeviceMappingEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLaunchTemplateBlockDeviceMappingEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLaunchTemplateBlockDeviceMappingEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_initialization_rate: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Whether the volume should be destroyed on instance termination Defaults to `true`.
        :param bool encrypted: Enables EBS encryption on the volume. Cannot be used with snapshot_id Defaults to `false`.
        :param int iops: The amount of provisioned IOPS. This must be set with a volume_type of 'io1/io2/gp3'
        :param str kms_key_id: The ARN of the KMS Key to use when encrypting the volume (if encrypted is true).
        :param str snapshot_id: The Snapshot ID to mount. Should not be used if encrypted is true
        :param int throughput: The throughput to provision for a 'gp3' volume in MiB/s. Minumum value of 125 and maximum of 1000.
        :param int volume_initialization_rate: The volume initialization rate in MiB/s, with a minimum of 100 MiB/s and maximum of 300 MiB/s.
        :param int volume_size: The size of the volume in gigabytes.\\n
               								gp2 and gp3: 1 - 16,384 GiB\\n+
               								io1: 4 - 16,384 GiB
               								io2: 4 - 65,536 GiB
               								st1 and sc1: 125 - 16,384 GiB
               								standard: 1 - 1024 GiB
        :param str volume_type: The volume type. Can be one of standard, gp2, gp3, io1, io2, sc1 or st1
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_initialization_rate is not None:
            pulumi.set(__self__, "volume_initialization_rate", volume_initialization_rate)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Whether the volume should be destroyed on instance termination Defaults to `true`.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Enables EBS encryption on the volume. Cannot be used with snapshot_id Defaults to `false`.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The amount of provisioned IOPS. This must be set with a volume_type of 'io1/io2/gp3'
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ARN of the KMS Key to use when encrypting the volume (if encrypted is true).
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The Snapshot ID to mount. Should not be used if encrypted is true
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        The throughput to provision for a 'gp3' volume in MiB/s. Minumum value of 125 and maximum of 1000.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeInitializationRate")
    def volume_initialization_rate(self) -> Optional[int]:
        """
        The volume initialization rate in MiB/s, with a minimum of 100 MiB/s and maximum of 300 MiB/s.
        """
        return pulumi.get(self, "volume_initialization_rate")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        The size of the volume in gigabytes.\\n
        								gp2 and gp3: 1 - 16,384 GiB\\n+
        								io1: 4 - 16,384 GiB
        								io2: 4 - 65,536 GiB
        								st1 and sc1: 125 - 16,384 GiB
        								standard: 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The volume type. Can be one of standard, gp2, gp3, io1, io2, sc1 or st1
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AwsLbListenerRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateCognito":
            suggest = "authenticate_cognito"
        elif key == "authenticateOidc":
            suggest = "authenticate_oidc"
        elif key == "fixedResponse":
            suggest = "fixed_response"
        elif key == "targetGroupArn":
            suggest = "target_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbListenerRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbListenerRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbListenerRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 authenticate_cognito: Optional['outputs.AwsLbListenerRuleActionAuthenticateCognito'] = None,
                 authenticate_oidc: Optional['outputs.AwsLbListenerRuleActionAuthenticateOidc'] = None,
                 fixed_response: Optional['outputs.AwsLbListenerRuleActionFixedResponse'] = None,
                 forward: Optional['outputs.AwsLbListenerRuleActionForward'] = None,
                 order: Optional[int] = None,
                 redirect: Optional['outputs.AwsLbListenerRuleActionRedirect'] = None,
                 target_group_arn: Optional[str] = None):
        """
        :param str type: The type of routing action. Valid values are `redirect`, `forward`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`
        :param 'AwsLbListenerRuleActionAuthenticateCognitoArgs' authenticate_cognito: Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
        :param 'AwsLbListenerRuleActionAuthenticateOidcArgs' authenticate_oidc: Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
        :param 'AwsLbListenerRuleActionFixedResponseArgs' fixed_response: Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
        :param 'AwsLbListenerRuleActionForwardArgs' forward: Information for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `target_group_arn` attribute, you can specify only one target group.
        :param 'AwsLbListenerRuleActionRedirectArgs' redirect: Information for creating a redirect action. Required if `type` is `redirect`.
        :param str target_group_arn: The ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
        """
        pulumi.set(__self__, "type", type)
        if authenticate_cognito is not None:
            pulumi.set(__self__, "authenticate_cognito", authenticate_cognito)
        if authenticate_oidc is not None:
            pulumi.set(__self__, "authenticate_oidc", authenticate_oidc)
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of routing action. Valid values are `redirect`, `forward`, `fixed-response`, `authenticate-cognito` and `authenticate-oidc`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="authenticateCognito")
    def authenticate_cognito(self) -> Optional['outputs.AwsLbListenerRuleActionAuthenticateCognito']:
        """
        Information for creating an authenticate action using Cognito. Required if `type` is `authenticate-cognito`.
        """
        return pulumi.get(self, "authenticate_cognito")

    @property
    @pulumi.getter(name="authenticateOidc")
    def authenticate_oidc(self) -> Optional['outputs.AwsLbListenerRuleActionAuthenticateOidc']:
        """
        Information for creating an authenticate action using OIDC. Required if `type` is `authenticate-oidc`.
        """
        return pulumi.get(self, "authenticate_oidc")

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional['outputs.AwsLbListenerRuleActionFixedResponse']:
        """
        Information for creating an action that returns a custom HTTP response. Required if `type` is `fixed-response`.
        """
        return pulumi.get(self, "fixed_response")

    @property
    @pulumi.getter
    def forward(self) -> Optional['outputs.AwsLbListenerRuleActionForward']:
        """
        Information for creating an action that distributes requests among one or more target groups. Specify only if `type` is `forward`. If you specify both `forward` block and `target_group_arn` attribute, you can specify only one target group.
        """
        return pulumi.get(self, "forward")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.AwsLbListenerRuleActionRedirect']:
        """
        Information for creating a redirect action. Required if `type` is `redirect`.
        """
        return pulumi.get(self, "redirect")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[str]:
        """
        The ARN of the Target Group to which to route traffic. Specify only if `type` is `forward` and you want to route to a single target group. To route to one or more target groups, use a `forward` block instead.
        """
        return pulumi.get(self, "target_group_arn")


@pulumi.output_type
class AwsLbListenerRuleActionAuthenticateCognito(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userPoolArn":
            suggest = "user_pool_arn"
        elif key == "userPoolClientId":
            suggest = "user_pool_client_id"
        elif key == "userPoolDomain":
            suggest = "user_pool_domain"
        elif key == "authenticationRequestExtraParams":
            suggest = "authentication_request_extra_params"
        elif key == "onUnauthenticatedRequest":
            suggest = "on_unauthenticated_request"
        elif key == "sessionCookieName":
            suggest = "session_cookie_name"
        elif key == "sessionTimeout":
            suggest = "session_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbListenerRuleActionAuthenticateCognito. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbListenerRuleActionAuthenticateCognito.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbListenerRuleActionAuthenticateCognito.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_pool_arn: str,
                 user_pool_client_id: str,
                 user_pool_domain: str,
                 authentication_request_extra_params: Optional[Mapping[str, str]] = None,
                 on_unauthenticated_request: Optional[str] = None,
                 scope: Optional[str] = None,
                 session_cookie_name: Optional[str] = None,
                 session_timeout: Optional[int] = None):
        """
        :param str user_pool_arn: The ARN of the Cognito user pool.
        :param str user_pool_client_id: The ID of the Cognito user pool client.
        :param str user_pool_domain: The domain prefix or fully-qualified domain name of the Cognito user pool.
        :param Mapping[str, str] authentication_request_extra_params: The query parameters to include in the redirect request to the authorization endpoint.
        :param str on_unauthenticated_request: The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`.
        :param str scope: The set of user claims to be requested from the IdP. Defaults to `openid`.
        :param str session_cookie_name: The name of the cookie used to maintain session information. Defaults to `AWSELBAuthSessionCookie`.
        :param int session_timeout: The maximum duration of the authentication session, in seconds. Defaults to `604800`.
        """
        pulumi.set(__self__, "user_pool_arn", user_pool_arn)
        pulumi.set(__self__, "user_pool_client_id", user_pool_client_id)
        pulumi.set(__self__, "user_pool_domain", user_pool_domain)
        if authentication_request_extra_params is not None:
            pulumi.set(__self__, "authentication_request_extra_params", authentication_request_extra_params)
        if on_unauthenticated_request is not None:
            pulumi.set(__self__, "on_unauthenticated_request", on_unauthenticated_request)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if session_cookie_name is not None:
            pulumi.set(__self__, "session_cookie_name", session_cookie_name)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)

    @property
    @pulumi.getter(name="userPoolArn")
    def user_pool_arn(self) -> str:
        """
        The ARN of the Cognito user pool.
        """
        return pulumi.get(self, "user_pool_arn")

    @property
    @pulumi.getter(name="userPoolClientId")
    def user_pool_client_id(self) -> str:
        """
        The ID of the Cognito user pool client.
        """
        return pulumi.get(self, "user_pool_client_id")

    @property
    @pulumi.getter(name="userPoolDomain")
    def user_pool_domain(self) -> str:
        """
        The domain prefix or fully-qualified domain name of the Cognito user pool.
        """
        return pulumi.get(self, "user_pool_domain")

    @property
    @pulumi.getter(name="authenticationRequestExtraParams")
    def authentication_request_extra_params(self) -> Optional[Mapping[str, str]]:
        """
        The query parameters to include in the redirect request to the authorization endpoint.
        """
        return pulumi.get(self, "authentication_request_extra_params")

    @property
    @pulumi.getter(name="onUnauthenticatedRequest")
    def on_unauthenticated_request(self) -> Optional[str]:
        """
        The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`.
        """
        return pulumi.get(self, "on_unauthenticated_request")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The set of user claims to be requested from the IdP. Defaults to `openid`.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sessionCookieName")
    def session_cookie_name(self) -> Optional[str]:
        """
        The name of the cookie used to maintain session information. Defaults to `AWSELBAuthSessionCookie`.
        """
        return pulumi.get(self, "session_cookie_name")

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[int]:
        """
        The maximum duration of the authentication session, in seconds. Defaults to `604800`.
        """
        return pulumi.get(self, "session_timeout")


@pulumi.output_type
class AwsLbListenerRuleActionAuthenticateOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"
        elif key == "authenticationRequestExtraParams":
            suggest = "authentication_request_extra_params"
        elif key == "onUnauthenticatedRequest":
            suggest = "on_unauthenticated_request"
        elif key == "sessionCookieName":
            suggest = "session_cookie_name"
        elif key == "sessionTimeout":
            suggest = "session_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbListenerRuleActionAuthenticateOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbListenerRuleActionAuthenticateOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbListenerRuleActionAuthenticateOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: str,
                 client_id: str,
                 client_secret: str,
                 issuer: str,
                 token_endpoint: str,
                 user_info_endpoint: str,
                 authentication_request_extra_params: Optional[Mapping[str, str]] = None,
                 on_unauthenticated_request: Optional[str] = None,
                 scope: Optional[str] = None,
                 session_cookie_name: Optional[str] = None,
                 session_timeout: Optional[int] = None):
        """
        :param str authorization_endpoint: The authorization endpoint of the IdP.
        :param str client_id: The OAuth 2.0 client identifier.
        :param str client_secret: The OAuth 2.0 client secret.
        :param str issuer: The OIDC issuer identifier of the IdP.
        :param str token_endpoint: The token endpoint of the IdP.
        :param str user_info_endpoint: The user info endpoint of the IdP.
        :param Mapping[str, str] authentication_request_extra_params: The query parameters to include in the redirect request to the authorization endpoint. Max: 10
        :param str on_unauthenticated_request: The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`.
        :param str scope: The set of user claims to be requested from the IdP. Defaults to `openid`.
        :param str session_cookie_name: The name of the cookie used to maintain session information. Defaults to `AWSELBAuthSessionCookie`.
        :param int session_timeout: The maximum duration of the authentication session, in seconds. Defaults to `604800`.
        """
        pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)
        if authentication_request_extra_params is not None:
            pulumi.set(__self__, "authentication_request_extra_params", authentication_request_extra_params)
        if on_unauthenticated_request is not None:
            pulumi.set(__self__, "on_unauthenticated_request", on_unauthenticated_request)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if session_cookie_name is not None:
            pulumi.set(__self__, "session_cookie_name", session_cookie_name)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> str:
        """
        The authorization endpoint of the IdP.
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OAuth 2.0 client identifier.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The OAuth 2.0 client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def issuer(self) -> str:
        """
        The OIDC issuer identifier of the IdP.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> str:
        """
        The token endpoint of the IdP.
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> str:
        """
        The user info endpoint of the IdP.
        """
        return pulumi.get(self, "user_info_endpoint")

    @property
    @pulumi.getter(name="authenticationRequestExtraParams")
    def authentication_request_extra_params(self) -> Optional[Mapping[str, str]]:
        """
        The query parameters to include in the redirect request to the authorization endpoint. Max: 10
        """
        return pulumi.get(self, "authentication_request_extra_params")

    @property
    @pulumi.getter(name="onUnauthenticatedRequest")
    def on_unauthenticated_request(self) -> Optional[str]:
        """
        The behavior if the user is not authenticated. Valid values: `deny`, `allow` and `authenticate`.
        """
        return pulumi.get(self, "on_unauthenticated_request")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The set of user claims to be requested from the IdP. Defaults to `openid`.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="sessionCookieName")
    def session_cookie_name(self) -> Optional[str]:
        """
        The name of the cookie used to maintain session information. Defaults to `AWSELBAuthSessionCookie`.
        """
        return pulumi.get(self, "session_cookie_name")

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[int]:
        """
        The maximum duration of the authentication session, in seconds. Defaults to `604800`.
        """
        return pulumi.get(self, "session_timeout")


@pulumi.output_type
class AwsLbListenerRuleActionFixedResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbListenerRuleActionFixedResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbListenerRuleActionFixedResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbListenerRuleActionFixedResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: str,
                 message_body: Optional[str] = None,
                 status_code: Optional[str] = None):
        """
        :param str content_type: The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`
        :param str message_body: The message body.
        :param str status_code: The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
        """
        pulumi.set(__self__, "content_type", content_type)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The content type. Valid values are `text/plain`, `text/css`, `text/html`, `application/javascript` and `application/json`
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[str]:
        """
        The message body.
        """
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[str]:
        """
        The HTTP response code. Valid values are `2XX`, `4XX`, or `5XX`.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class AwsLbListenerRuleActionForward(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroups":
            suggest = "target_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbListenerRuleActionForward. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbListenerRuleActionForward.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbListenerRuleActionForward.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_groups: Sequence['outputs.AwsLbListenerRuleActionForwardTargetGroup'],
                 stickiness: Optional['outputs.AwsLbListenerRuleActionForwardStickiness'] = None):
        pulumi.set(__self__, "target_groups", target_groups)
        if stickiness is not None:
            pulumi.set(__self__, "stickiness", stickiness)

    @property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Sequence['outputs.AwsLbListenerRuleActionForwardTargetGroup']:
        return pulumi.get(self, "target_groups")

    @property
    @pulumi.getter
    def stickiness(self) -> Optional['outputs.AwsLbListenerRuleActionForwardStickiness']:
        return pulumi.get(self, "stickiness")


@pulumi.output_type
class AwsLbListenerRuleActionForwardStickiness(dict):
    def __init__(__self__, *,
                 duration: int,
                 enabled: Optional[bool] = None):
        """
        :param int duration: The time period, in seconds, during which requests from a client should be routed to the same target group.
        :param bool enabled: Indicates whether target group stickiness is enabled. Defaults to `false`.
        """
        pulumi.set(__self__, "duration", duration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        The time period, in seconds, during which requests from a client should be routed to the same target group.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether target group stickiness is enabled. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AwsLbListenerRuleActionForwardTargetGroup(dict):
    def __init__(__self__, *,
                 arn: str,
                 weight: Optional[int] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the target group.
        :param int weight: The weight. The range is 0 to 999. Defaults to `1`.
        """
        pulumi.set(__self__, "arn", arn)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the target group.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The weight. The range is 0 to 999. Defaults to `1`.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AwsLbListenerRuleActionRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbListenerRuleActionRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbListenerRuleActionRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbListenerRuleActionRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: str,
                 host: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 protocol: Optional[str] = None,
                 query: Optional[str] = None):
        """
        :param str status_code: The HTTP redirect code. The redirect is either permanent or temporary
        :param str host: The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
        :param str path: The absolute path, starting with the leading "/". Defaults to `/#{path}`.
        :param str port: The port. Specify a value from `1` to `65535`. Defaults to `#{port}`.
        :param str protocol: The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
        :param str query: The query parameters, URL-encoded when necessary. Defaults to `#{query}`.
        """
        pulumi.set(__self__, "status_code", status_code)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        The HTTP redirect code. The redirect is either permanent or temporary
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The hostname. This component is not percent-encoded. The hostname can contain `#{host}`. Defaults to `#{host}`.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The absolute path, starting with the leading "/". Defaults to `/#{path}`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        The port. Specify a value from `1` to `65535`. Defaults to `#{port}`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol. Valid values are `HTTP`, `HTTPS`, or `#{protocol}`. Defaults to `#{protocol}`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The query parameters, URL-encoded when necessary. Defaults to `#{query}`.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class AwsLbListenerRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostHeader":
            suggest = "host_header"
        elif key == "httpHeader":
            suggest = "http_header"
        elif key == "httpRequestMethod":
            suggest = "http_request_method"
        elif key == "pathPattern":
            suggest = "path_pattern"
        elif key == "queryStrings":
            suggest = "query_strings"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbListenerRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbListenerRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbListenerRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_header: Optional['outputs.AwsLbListenerRuleConditionHostHeader'] = None,
                 http_header: Optional['outputs.AwsLbListenerRuleConditionHttpHeader'] = None,
                 http_request_method: Optional['outputs.AwsLbListenerRuleConditionHttpRequestMethod'] = None,
                 path_pattern: Optional['outputs.AwsLbListenerRuleConditionPathPattern'] = None,
                 query_strings: Optional[Sequence['outputs.AwsLbListenerRuleConditionQueryString']] = None,
                 source_ip: Optional['outputs.AwsLbListenerRuleConditionSourceIp'] = None):
        """
        :param 'AwsLbListenerRuleConditionHttpHeaderArgs' http_header: HTTP headers to match.
        :param 'AwsLbListenerRuleConditionHttpRequestMethodArgs' http_request_method: Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters.
        :param 'AwsLbListenerRuleConditionPathPatternArgs' path_pattern: Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters.
        :param Sequence['AwsLbListenerRuleConditionQueryStringArgs'] query_strings: Query strings to match.
        :param 'AwsLbListenerRuleConditionSourceIpArgs' source_ip: Contains a single `values` item which is a list of source IP CIDR notations to match.
        """
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if http_header is not None:
            pulumi.set(__self__, "http_header", http_header)
        if http_request_method is not None:
            pulumi.set(__self__, "http_request_method", http_request_method)
        if path_pattern is not None:
            pulumi.set(__self__, "path_pattern", path_pattern)
        if query_strings is not None:
            pulumi.set(__self__, "query_strings", query_strings)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional['outputs.AwsLbListenerRuleConditionHostHeader']:
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="httpHeader")
    def http_header(self) -> Optional['outputs.AwsLbListenerRuleConditionHttpHeader']:
        """
        HTTP headers to match.
        """
        return pulumi.get(self, "http_header")

    @property
    @pulumi.getter(name="httpRequestMethod")
    def http_request_method(self) -> Optional['outputs.AwsLbListenerRuleConditionHttpRequestMethod']:
        """
        Contains a single `values` item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters.
        """
        return pulumi.get(self, "http_request_method")

    @property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> Optional['outputs.AwsLbListenerRuleConditionPathPattern']:
        """
        Contains a single `values` item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters.
        """
        return pulumi.get(self, "path_pattern")

    @property
    @pulumi.getter(name="queryStrings")
    def query_strings(self) -> Optional[Sequence['outputs.AwsLbListenerRuleConditionQueryString']]:
        """
        Query strings to match.
        """
        return pulumi.get(self, "query_strings")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional['outputs.AwsLbListenerRuleConditionSourceIp']:
        """
        Contains a single `values` item which is a list of source IP CIDR notations to match.
        """
        return pulumi.get(self, "source_ip")


@pulumi.output_type
class AwsLbListenerRuleConditionHostHeader(dict):
    def __init__(__self__, *,
                 values: Sequence[str]):
        """
        :param Sequence[str] values: Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters.
        """
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Contains a single `values` item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AwsLbListenerRuleConditionHttpHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaderName":
            suggest = "http_header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbListenerRuleConditionHttpHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbListenerRuleConditionHttpHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbListenerRuleConditionHttpHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_header_name: str,
                 values: Sequence[str]):
        """
        :param str http_header_name: Name of HTTP header to search. The maximum size is 40 characters.
        :param Sequence[str] values: List of header value patterns to match. Maximum size of each pattern is 128 characters.
        """
        pulumi.set(__self__, "http_header_name", http_header_name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="httpHeaderName")
    def http_header_name(self) -> str:
        """
        Name of HTTP header to search. The maximum size is 40 characters.
        """
        return pulumi.get(self, "http_header_name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of header value patterns to match. Maximum size of each pattern is 128 characters.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AwsLbListenerRuleConditionHttpRequestMethod(dict):
    def __init__(__self__, *,
                 values: Sequence[str]):
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AwsLbListenerRuleConditionPathPattern(dict):
    def __init__(__self__, *,
                 values: Sequence[str]):
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AwsLbListenerRuleConditionQueryString(dict):
    def __init__(__self__, *,
                 value: str,
                 key: Optional[str] = None):
        """
        :param str value: Query string value pattern to match.
        :param str key: Query string key pattern to match.
        """
        pulumi.set(__self__, "value", value)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Query string value pattern to match.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Query string key pattern to match.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class AwsLbListenerRuleConditionSourceIp(dict):
    def __init__(__self__, *,
                 values: Sequence[str]):
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AwsLbListenerRuleTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsLbTargetGroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLbTargetGroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLbTargetGroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLbTargetGroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 healthy_threshold: Optional[int] = None,
                 interval: Optional[int] = None,
                 matcher: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 protocol: Optional[str] = None,
                 timeout: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param bool enabled: Whether health checks are enabled. Defaults to `true`.
        :param int healthy_threshold: Number of consecutive health checks successes required before considering an unhealthy target healthy. Defaults to `3`.
        :param int interval: Approximate amount of time, in seconds, between health checks of an individual target. Minimum value 5 seconds, Maximum value 300 seconds. For lambda target groups, it needs to be greater as the `timeout` of the underlying `lambda`. Defaults to `30`.
        :param str matcher: Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "200,202" for HTTP(s) or "0,12" for GRPC) or a range of values (for example, "200-299" or "0-99"). Required for HTTP/HTTPS/GRPC ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS/GRPC) not Network Load Balancers (i.e., TCP).
        :param str path: Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
        :param str port: Port to use to connect with the target. Valid values are either ports 1-65535, or traffic-port. Defaults to `traffic-port`.
        :param str protocol: Protocol to use to connect with the target. Defaults to HTTP. Not applicable when target_type is lambda Defaults to `HTTP`.
        :param int timeout: Amount of time, in seconds, during which no response means a failed health check.
        :param int unhealthy_threshold: Number of consecutive health check failures required before considering the target unhealthy. Defaults to `3`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether health checks are enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive health checks successes required before considering an unhealthy target healthy. Defaults to `3`.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Approximate amount of time, in seconds, between health checks of an individual target. Minimum value 5 seconds, Maximum value 300 seconds. For lambda target groups, it needs to be greater as the `timeout` of the underlying `lambda`. Defaults to `30`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def matcher(self) -> Optional[str]:
        """
        Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "200,202" for HTTP(s) or "0,12" for GRPC) or a range of values (for example, "200-299" or "0-99"). Required for HTTP/HTTPS/GRPC ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS/GRPC) not Network Load Balancers (i.e., TCP).
        """
        return pulumi.get(self, "matcher")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port to use to connect with the target. Valid values are either ports 1-65535, or traffic-port. Defaults to `traffic-port`.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol to use to connect with the target. Defaults to HTTP. Not applicable when target_type is lambda Defaults to `HTTP`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Amount of time, in seconds, during which no response means a failed health check.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive health check failures required before considering the target unhealthy. Defaults to `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class AwsLoadBalancerListenerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLoadBalancerListenerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLoadBalancerListenerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLoadBalancerListenerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_default: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        return pulumi.get(self, "is_default")


@pulumi.output_type
class AwsLoadBalancerListenerDefaultAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedResponse":
            suggest = "fixed_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLoadBalancerListenerDefaultAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLoadBalancerListenerDefaultAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLoadBalancerListenerDefaultAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_response: Optional['outputs.AwsLoadBalancerListenerDefaultActionFixedResponse'] = None,
                 forward: Optional['outputs.AwsLoadBalancerListenerDefaultActionForward'] = None,
                 redirect: Optional['outputs.AwsLoadBalancerListenerDefaultActionRedirect'] = None):
        if fixed_response is not None:
            pulumi.set(__self__, "fixed_response", fixed_response)
        if forward is not None:
            pulumi.set(__self__, "forward", forward)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @property
    @pulumi.getter(name="fixedResponse")
    def fixed_response(self) -> Optional['outputs.AwsLoadBalancerListenerDefaultActionFixedResponse']:
        return pulumi.get(self, "fixed_response")

    @property
    @pulumi.getter
    def forward(self) -> Optional['outputs.AwsLoadBalancerListenerDefaultActionForward']:
        return pulumi.get(self, "forward")

    @property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.AwsLoadBalancerListenerDefaultActionRedirect']:
        return pulumi.get(self, "redirect")


@pulumi.output_type
class AwsLoadBalancerListenerDefaultActionFixedResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLoadBalancerListenerDefaultActionFixedResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLoadBalancerListenerDefaultActionFixedResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLoadBalancerListenerDefaultActionFixedResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[str] = None,
                 message_body: Optional[str] = None,
                 status_code: Optional[str] = None):
        """
        :param str content_type: Defaults to `text/plain`.
        :param str status_code: Defaults to `200`.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        Defaults to `text/plain`.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[str]:
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[str]:
        """
        Defaults to `200`.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class AwsLoadBalancerListenerDefaultActionForward(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroupArn":
            suggest = "target_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLoadBalancerListenerDefaultActionForward. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLoadBalancerListenerDefaultActionForward.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLoadBalancerListenerDefaultActionForward.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_group_arn: str):
        pulumi.set(__self__, "target_group_arn", target_group_arn)

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> str:
        return pulumi.get(self, "target_group_arn")


@pulumi.output_type
class AwsLoadBalancerListenerDefaultActionRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsLoadBalancerListenerDefaultActionRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsLoadBalancerListenerDefaultActionRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsLoadBalancerListenerDefaultActionRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: str,
                 protocol: str,
                 status_code: str,
                 host: Optional[str] = None,
                 path: Optional[str] = None,
                 query: Optional[str] = None):
        """
        :param str host: Defaults to `#{host}`.
        :param str path: Defaults to `/#{path}`.
        :param str query: Defaults to `#{query}`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status_code", status_code)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def port(self) -> str:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Defaults to `#{host}`.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Defaults to `/#{path}`.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Defaults to `#{query}`.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class AwsLoadBalancerTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsMwaaEnvironmentLastUpdated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMwaaEnvironmentLastUpdated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMwaaEnvironmentLastUpdated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMwaaEnvironmentLastUpdated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 errors: Optional[Sequence['outputs.AwsMwaaEnvironmentLastUpdatedError']] = None,
                 status: Optional[str] = None):
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.AwsMwaaEnvironmentLastUpdatedError']]:
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class AwsMwaaEnvironmentLastUpdatedError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMwaaEnvironmentLastUpdatedError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMwaaEnvironmentLastUpdatedError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMwaaEnvironmentLastUpdatedError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: Optional[str] = None,
                 error_message: Optional[str] = None):
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[str]:
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        return pulumi.get(self, "error_message")


@pulumi.output_type
class AwsMwaaEnvironmentLoggingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dagProcessingLogs":
            suggest = "dag_processing_logs"
        elif key == "schedulerLogs":
            suggest = "scheduler_logs"
        elif key == "taskLogs":
            suggest = "task_logs"
        elif key == "webserverLogs":
            suggest = "webserver_logs"
        elif key == "workerLogs":
            suggest = "worker_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMwaaEnvironmentLoggingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMwaaEnvironmentLoggingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMwaaEnvironmentLoggingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dag_processing_logs: Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationDagProcessingLogs'] = None,
                 scheduler_logs: Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationSchedulerLogs'] = None,
                 task_logs: Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationTaskLogs'] = None,
                 webserver_logs: Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationWebserverLogs'] = None,
                 worker_logs: Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationWorkerLogs'] = None):
        if dag_processing_logs is not None:
            pulumi.set(__self__, "dag_processing_logs", dag_processing_logs)
        if scheduler_logs is not None:
            pulumi.set(__self__, "scheduler_logs", scheduler_logs)
        if task_logs is not None:
            pulumi.set(__self__, "task_logs", task_logs)
        if webserver_logs is not None:
            pulumi.set(__self__, "webserver_logs", webserver_logs)
        if worker_logs is not None:
            pulumi.set(__self__, "worker_logs", worker_logs)

    @property
    @pulumi.getter(name="dagProcessingLogs")
    def dag_processing_logs(self) -> Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationDagProcessingLogs']:
        return pulumi.get(self, "dag_processing_logs")

    @property
    @pulumi.getter(name="schedulerLogs")
    def scheduler_logs(self) -> Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationSchedulerLogs']:
        return pulumi.get(self, "scheduler_logs")

    @property
    @pulumi.getter(name="taskLogs")
    def task_logs(self) -> Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationTaskLogs']:
        return pulumi.get(self, "task_logs")

    @property
    @pulumi.getter(name="webserverLogs")
    def webserver_logs(self) -> Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationWebserverLogs']:
        return pulumi.get(self, "webserver_logs")

    @property
    @pulumi.getter(name="workerLogs")
    def worker_logs(self) -> Optional['outputs.AwsMwaaEnvironmentLoggingConfigurationWorkerLogs']:
        return pulumi.get(self, "worker_logs")


@pulumi.output_type
class AwsMwaaEnvironmentLoggingConfigurationDagProcessingLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logLevel":
            suggest = "log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMwaaEnvironmentLoggingConfigurationDagProcessingLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationDagProcessingLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationDagProcessingLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 log_level: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")


@pulumi.output_type
class AwsMwaaEnvironmentLoggingConfigurationSchedulerLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logLevel":
            suggest = "log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMwaaEnvironmentLoggingConfigurationSchedulerLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationSchedulerLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationSchedulerLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 log_level: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")


@pulumi.output_type
class AwsMwaaEnvironmentLoggingConfigurationTaskLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logLevel":
            suggest = "log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMwaaEnvironmentLoggingConfigurationTaskLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationTaskLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationTaskLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 log_level: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")


@pulumi.output_type
class AwsMwaaEnvironmentLoggingConfigurationWebserverLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logLevel":
            suggest = "log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMwaaEnvironmentLoggingConfigurationWebserverLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationWebserverLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationWebserverLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 log_level: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")


@pulumi.output_type
class AwsMwaaEnvironmentLoggingConfigurationWorkerLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logLevel":
            suggest = "log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsMwaaEnvironmentLoggingConfigurationWorkerLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationWorkerLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsMwaaEnvironmentLoggingConfigurationWorkerLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 log_level: Optional[str] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")


@pulumi.output_type
class AwsSqsQueueDeadLetterQueueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMessageReceiveAttempts":
            suggest = "max_message_receive_attempts"
        elif key == "targetSqsDlqName":
            suggest = "target_sqs_dlq_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSqsQueueDeadLetterQueueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSqsQueueDeadLetterQueueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSqsQueueDeadLetterQueueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_message_receive_attempts: int,
                 target_sqs_dlq_name: str):
        """
        :param int max_message_receive_attempts: Maximum number of processing attempts for a given message before it is moved to the dead letter queue
        :param str target_sqs_dlq_name: Name of the SQS queue meant to be the target dead letter queue for this SQS resource (queues must belong to same tenant)
        """
        pulumi.set(__self__, "max_message_receive_attempts", max_message_receive_attempts)
        pulumi.set(__self__, "target_sqs_dlq_name", target_sqs_dlq_name)

    @property
    @pulumi.getter(name="maxMessageReceiveAttempts")
    def max_message_receive_attempts(self) -> int:
        """
        Maximum number of processing attempts for a given message before it is moved to the dead letter queue
        """
        return pulumi.get(self, "max_message_receive_attempts")

    @property
    @pulumi.getter(name="targetSqsDlqName")
    def target_sqs_dlq_name(self) -> str:
        """
        Name of the SQS queue meant to be the target dead letter queue for this SQS resource (queues must belong to same tenant)
        """
        return pulumi.get(self, "target_sqs_dlq_name")


@pulumi.output_type
class AwsTargetGroupAttributesAttribute(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsTimestreamwriteDatabaseAllTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsTimestreamwriteDatabaseTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsTimestreamwriteTableAllTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AwsTimestreamwriteTableMagneticStoreWriteProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableMagneticStoreWrites":
            suggest = "enable_magnetic_store_writes"
        elif key == "magneticStoreRejectedDataLocation":
            suggest = "magnetic_store_rejected_data_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsTimestreamwriteTableMagneticStoreWriteProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsTimestreamwriteTableMagneticStoreWriteProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsTimestreamwriteTableMagneticStoreWriteProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_magnetic_store_writes: Optional[bool] = None,
                 magnetic_store_rejected_data_location: Optional['outputs.AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation'] = None):
        """
        :param bool enable_magnetic_store_writes: A flag to enable magnetic store writes. Defaults to `false`.
        :param 'AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationArgs' magnetic_store_rejected_data_location: The location to write error reports for records rejected asynchronously during magnetic store writes.
        """
        if enable_magnetic_store_writes is not None:
            pulumi.set(__self__, "enable_magnetic_store_writes", enable_magnetic_store_writes)
        if magnetic_store_rejected_data_location is not None:
            pulumi.set(__self__, "magnetic_store_rejected_data_location", magnetic_store_rejected_data_location)

    @property
    @pulumi.getter(name="enableMagneticStoreWrites")
    def enable_magnetic_store_writes(self) -> Optional[bool]:
        """
        A flag to enable magnetic store writes. Defaults to `false`.
        """
        return pulumi.get(self, "enable_magnetic_store_writes")

    @property
    @pulumi.getter(name="magneticStoreRejectedDataLocation")
    def magnetic_store_rejected_data_location(self) -> Optional['outputs.AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation']:
        """
        The location to write error reports for records rejected asynchronously during magnetic store writes.
        """
        return pulumi.get(self, "magnetic_store_rejected_data_location")


@pulumi.output_type
class AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Configuration":
            suggest = "s3_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_configuration: Optional['outputs.AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration'] = None):
        """
        :param 'AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3ConfigurationArgs' s3_configuration: Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes.
        """
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional['outputs.AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration']:
        """
        Configuration of an S3 location to write error reports for records rejected, asynchronously, during magnetic store writes.
        """
        return pulumi.get(self, "s3_configuration")


@pulumi.output_type
class AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "encryptionOption":
            suggest = "encryption_option"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "objectKeyPrefix":
            suggest = "object_key_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsTimestreamwriteTableMagneticStoreWritePropertiesMagneticStoreRejectedDataLocationS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 encryption_option: Optional[str] = None,
                 kms_key_id: Optional[str] = None,
                 object_key_prefix: Optional[str] = None):
        """
        :param str bucket_name: Bucket name of the customer S3 bucket.
        :param str encryption_option: Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key. Valid values are `SSE_KMS` and `SSE_S3`.
        :param str kms_key_id: KMS key arn for the customer s3 location when encrypting with a KMS managed key.
        :param str object_key_prefix: Object key prefix for the customer S3 location.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if encryption_option is not None:
            pulumi.set(__self__, "encryption_option", encryption_option)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if object_key_prefix is not None:
            pulumi.set(__self__, "object_key_prefix", object_key_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        Bucket name of the customer S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> Optional[str]:
        """
        Encryption option for the customer s3 location. Options are S3 server side encryption with an S3-managed key or KMS managed key. Valid values are `SSE_KMS` and `SSE_S3`.
        """
        return pulumi.get(self, "encryption_option")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        KMS key arn for the customer s3 location when encrypting with a KMS managed key.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="objectKeyPrefix")
    def object_key_prefix(self) -> Optional[str]:
        """
        Object key prefix for the customer S3 location.
        """
        return pulumi.get(self, "object_key_prefix")


@pulumi.output_type
class AwsTimestreamwriteTableRetentionProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "magneticStoreRetentionPeriodInDays":
            suggest = "magnetic_store_retention_period_in_days"
        elif key == "memoryStoreRetentionPeriodInHours":
            suggest = "memory_store_retention_period_in_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsTimestreamwriteTableRetentionProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsTimestreamwriteTableRetentionProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsTimestreamwriteTableRetentionProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 magnetic_store_retention_period_in_days: int,
                 memory_store_retention_period_in_hours: int):
        """
        :param int magnetic_store_retention_period_in_days: The duration for which data must be stored in the magnetic store. Minimum value of 1. Maximum value of 73000.
        :param int memory_store_retention_period_in_hours: The duration for which data must be stored in the memory store. Minimum value of 1. Maximum value of 8766.
        """
        pulumi.set(__self__, "magnetic_store_retention_period_in_days", magnetic_store_retention_period_in_days)
        pulumi.set(__self__, "memory_store_retention_period_in_hours", memory_store_retention_period_in_hours)

    @property
    @pulumi.getter(name="magneticStoreRetentionPeriodInDays")
    def magnetic_store_retention_period_in_days(self) -> int:
        """
        The duration for which data must be stored in the magnetic store. Minimum value of 1. Maximum value of 73000.
        """
        return pulumi.get(self, "magnetic_store_retention_period_in_days")

    @property
    @pulumi.getter(name="memoryStoreRetentionPeriodInHours")
    def memory_store_retention_period_in_hours(self) -> int:
        """
        The duration for which data must be stored in the memory store. Minimum value of 1. Maximum value of 8766.
        """
        return pulumi.get(self, "memory_store_retention_period_in_hours")


@pulumi.output_type
class AwsTimestreamwriteTableTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureAvailabilitySetVirtualMachine(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class AzureCosmosDbAccountBackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupInterval":
            suggest = "backup_interval"
        elif key == "backupRetentionInterval":
            suggest = "backup_retention_interval"
        elif key == "backupStorageRedundancy":
            suggest = "backup_storage_redundancy"
        elif key == "continuousModeTier":
            suggest = "continuous_mode_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCosmosDbAccountBackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCosmosDbAccountBackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCosmosDbAccountBackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_interval: Optional[int] = None,
                 backup_retention_interval: Optional[int] = None,
                 backup_storage_redundancy: Optional[str] = None,
                 continuous_mode_tier: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param int backup_interval: Backup interval in minutes. Can be configured when type is set to Periodic
        :param int backup_retention_interval: Backup retention interval in hours
        :param str backup_storage_redundancy: Backup storage redundancy type. Valid values are Geo, Local, Zone. Defaults to Geo.
        :param str continuous_mode_tier: The continuous mode tier for the Cosmos DB account. This is only applicable if the backup policy type is Continuous.
        :param str type: The type of backup. Possible values are Periodic and Continuous
               					>  **Note:**:
               					> Update from Periodic to Continuous type is allowed. To change from Periodic to Continuous resource need to be recreated Defaults to `Periodic`.
        """
        if backup_interval is not None:
            pulumi.set(__self__, "backup_interval", backup_interval)
        if backup_retention_interval is not None:
            pulumi.set(__self__, "backup_retention_interval", backup_retention_interval)
        if backup_storage_redundancy is not None:
            pulumi.set(__self__, "backup_storage_redundancy", backup_storage_redundancy)
        if continuous_mode_tier is not None:
            pulumi.set(__self__, "continuous_mode_tier", continuous_mode_tier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="backupInterval")
    def backup_interval(self) -> Optional[int]:
        """
        Backup interval in minutes. Can be configured when type is set to Periodic
        """
        return pulumi.get(self, "backup_interval")

    @property
    @pulumi.getter(name="backupRetentionInterval")
    def backup_retention_interval(self) -> Optional[int]:
        """
        Backup retention interval in hours
        """
        return pulumi.get(self, "backup_retention_interval")

    @property
    @pulumi.getter(name="backupStorageRedundancy")
    def backup_storage_redundancy(self) -> Optional[str]:
        """
        Backup storage redundancy type. Valid values are Geo, Local, Zone. Defaults to Geo.
        """
        return pulumi.get(self, "backup_storage_redundancy")

    @property
    @pulumi.getter(name="continuousModeTier")
    def continuous_mode_tier(self) -> Optional[str]:
        """
        The continuous mode tier for the Cosmos DB account. This is only applicable if the backup policy type is Continuous.
        """
        return pulumi.get(self, "continuous_mode_tier")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of backup. Possible values are Periodic and Continuous
        					>  **Note:**:
        					> Update from Periodic to Continuous type is allowed. To change from Periodic to Continuous resource need to be recreated Defaults to `Periodic`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AzureCosmosDbAccountCapability(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the Cosmos DB capability, for example, 'EnableServerless'.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Cosmos DB capability, for example, 'EnableServerless'.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AzureCosmosDbAccountConsistencyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultConsistencyLevel":
            suggest = "default_consistency_level"
        elif key == "maxIntervalInSeconds":
            suggest = "max_interval_in_seconds"
        elif key == "maxStalenessPrefix":
            suggest = "max_staleness_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCosmosDbAccountConsistencyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCosmosDbAccountConsistencyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCosmosDbAccountConsistencyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_consistency_level: Optional[str] = None,
                 max_interval_in_seconds: Optional[int] = None,
                 max_staleness_prefix: Optional[int] = None):
        """
        :param str default_consistency_level: Specify the default consistency level and configuration settings of the Cosmos DB account. Possible values include: 'Eventual', 'Session', 'BoundedStaleness','Strong', 'ConsistentPrefix'
        :param int max_interval_in_seconds: When used with the 'Bounded Staleness' consistency level, this value represents the time amount of staleness (in seconds) tolerated. The accepted range for this value is 5 - 86400 (1 day). Required when consistency_level is set to BoundedStaleness.
        :param int max_staleness_prefix: When used with the 'Bounded Staleness' consistency level, this value represents the number of stale requests tolerated. The accepted range for this value is 10  2147483647. Defaults to 100. Required when 'consistency_level' is set to 'BoundedStaleness'
        """
        if default_consistency_level is not None:
            pulumi.set(__self__, "default_consistency_level", default_consistency_level)
        if max_interval_in_seconds is not None:
            pulumi.set(__self__, "max_interval_in_seconds", max_interval_in_seconds)
        if max_staleness_prefix is not None:
            pulumi.set(__self__, "max_staleness_prefix", max_staleness_prefix)

    @property
    @pulumi.getter(name="defaultConsistencyLevel")
    def default_consistency_level(self) -> Optional[str]:
        """
        Specify the default consistency level and configuration settings of the Cosmos DB account. Possible values include: 'Eventual', 'Session', 'BoundedStaleness','Strong', 'ConsistentPrefix'
        """
        return pulumi.get(self, "default_consistency_level")

    @property
    @pulumi.getter(name="maxIntervalInSeconds")
    def max_interval_in_seconds(self) -> Optional[int]:
        """
        When used with the 'Bounded Staleness' consistency level, this value represents the time amount of staleness (in seconds) tolerated. The accepted range for this value is 5 - 86400 (1 day). Required when consistency_level is set to BoundedStaleness.
        """
        return pulumi.get(self, "max_interval_in_seconds")

    @property
    @pulumi.getter(name="maxStalenessPrefix")
    def max_staleness_prefix(self) -> Optional[int]:
        """
        When used with the 'Bounded Staleness' consistency level, this value represents the number of stale requests tolerated. The accepted range for this value is 10  2147483647. Defaults to 100. Required when 'consistency_level' is set to 'BoundedStaleness'
        """
        return pulumi.get(self, "max_staleness_prefix")


@pulumi.output_type
class AzureCosmosDbAccountGeoLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverPriority":
            suggest = "failover_priority"
        elif key == "locationName":
            suggest = "location_name"
        elif key == "isZoneRedundant":
            suggest = "is_zone_redundant"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCosmosDbAccountGeoLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCosmosDbAccountGeoLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCosmosDbAccountGeoLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_priority: int,
                 location_name: str,
                 is_zone_redundant: Optional[bool] = None):
        """
        :param int failover_priority: The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists. Changing this causes the location to be re-provisioned and cannot be changed for the location with failover priority 0
        :param str location_name: The name of the Azure region to host replicated data
        :param bool is_zone_redundant: Should zone redundancy be enabled for this region? Defaults to `false`.
        """
        pulumi.set(__self__, "failover_priority", failover_priority)
        pulumi.set(__self__, "location_name", location_name)
        if is_zone_redundant is not None:
            pulumi.set(__self__, "is_zone_redundant", is_zone_redundant)

    @property
    @pulumi.getter(name="failoverPriority")
    def failover_priority(self) -> int:
        """
        The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists. Changing this causes the location to be re-provisioned and cannot be changed for the location with failover priority 0
        """
        return pulumi.get(self, "failover_priority")

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> str:
        """
        The name of the Azure region to host replicated data
        """
        return pulumi.get(self, "location_name")

    @property
    @pulumi.getter(name="isZoneRedundant")
    def is_zone_redundant(self) -> Optional[bool]:
        """
        Should zone redundancy be enabled for this region? Defaults to `false`.
        """
        return pulumi.get(self, "is_zone_redundant")


@pulumi.output_type
class AzureCosmosDbAccountVirtualNetworkRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "ignoreMissingVnetServiceEndpoint":
            suggest = "ignore_missing_vnet_service_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCosmosDbAccountVirtualNetworkRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCosmosDbAccountVirtualNetworkRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCosmosDbAccountVirtualNetworkRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str,
                 ignore_missing_vnet_service_endpoint: Optional[bool] = None):
        """
        :param str subnet_id: The ID of the subnet to allow access to this CosmosDB account. This should be in the format /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        :param bool ignore_missing_vnet_service_endpoint: If set to true, the specified subnet will be added as a virtual network rule even if its CosmosDB service endpoint is not active Defaults to `false`.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ignore_missing_vnet_service_endpoint is not None:
            pulumi.set(__self__, "ignore_missing_vnet_service_endpoint", ignore_missing_vnet_service_endpoint)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet to allow access to this CosmosDB account. This should be in the format /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="ignoreMissingVnetServiceEndpoint")
    def ignore_missing_vnet_service_endpoint(self) -> Optional[bool]:
        """
        If set to true, the specified subnet will be added as a virtual network rule even if its CosmosDB service endpoint is not active Defaults to `false`.
        """
        return pulumi.get(self, "ignore_missing_vnet_service_endpoint")


@pulumi.output_type
class AzureK8NodePoolNodeLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureK8NodePoolScalePriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evictionPolicy":
            suggest = "eviction_policy"
        elif key == "spotMaxPrice":
            suggest = "spot_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureK8NodePoolScalePriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureK8NodePoolScalePriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureK8NodePoolScalePriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eviction_policy: Optional[str] = None,
                 priority: Optional[str] = None,
                 spot_max_price: Optional[float] = None):
        """
        :param str eviction_policy: eviction policies Delete/Deallocate. Default value is Delete
        :param str priority: priority levels Regular/Spot
        :param float spot_max_price: for spot VMs sets the maximum price you're willing to pay, controlling costs, while priority.spot determines the scaling order of spot VM pools.
        """
        if eviction_policy is not None:
            pulumi.set(__self__, "eviction_policy", eviction_policy)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if spot_max_price is not None:
            pulumi.set(__self__, "spot_max_price", spot_max_price)

    @property
    @pulumi.getter(name="evictionPolicy")
    def eviction_policy(self) -> Optional[str]:
        """
        eviction policies Delete/Deallocate. Default value is Delete
        """
        return pulumi.get(self, "eviction_policy")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        priority levels Regular/Spot
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> Optional[float]:
        """
        for spot VMs sets the maximum price you're willing to pay, controlling costs, while priority.spot determines the scaling order of spot VM pools.
        """
        return pulumi.get(self, "spot_max_price")


@pulumi.output_type
class AzureK8sClusterActiveDirectoryConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adTenantId":
            suggest = "ad_tenant_id"
        elif key == "adminGroupObjectIds":
            suggest = "admin_group_object_ids"
        elif key == "enableAd":
            suggest = "enable_ad"
        elif key == "enableRbac":
            suggest = "enable_rbac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureK8sClusterActiveDirectoryConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureK8sClusterActiveDirectoryConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureK8sClusterActiveDirectoryConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_tenant_id: str,
                 admin_group_object_ids: Optional[Sequence[str]] = None,
                 enable_ad: Optional[bool] = None,
                 enable_rbac: Optional[bool] = None):
        """
        :param str ad_tenant_id: The Azure Active Directory tenant ID.
        :param Sequence[str] admin_group_object_ids: List of Azure AD group object IDs that have admin access to the AKS cluster.
        :param bool enable_ad: Enable Azure Active Directory integration. Defaults to `false`.
        :param bool enable_rbac: Enable Azure RBAC for Kubernetes authorization. Defaults to `false`.
        """
        pulumi.set(__self__, "ad_tenant_id", ad_tenant_id)
        if admin_group_object_ids is not None:
            pulumi.set(__self__, "admin_group_object_ids", admin_group_object_ids)
        if enable_ad is not None:
            pulumi.set(__self__, "enable_ad", enable_ad)
        if enable_rbac is not None:
            pulumi.set(__self__, "enable_rbac", enable_rbac)

    @property
    @pulumi.getter(name="adTenantId")
    def ad_tenant_id(self) -> str:
        """
        The Azure Active Directory tenant ID.
        """
        return pulumi.get(self, "ad_tenant_id")

    @property
    @pulumi.getter(name="adminGroupObjectIds")
    def admin_group_object_ids(self) -> Optional[Sequence[str]]:
        """
        List of Azure AD group object IDs that have admin access to the AKS cluster.
        """
        return pulumi.get(self, "admin_group_object_ids")

    @property
    @pulumi.getter(name="enableAd")
    def enable_ad(self) -> Optional[bool]:
        """
        Enable Azure Active Directory integration. Defaults to `false`.
        """
        return pulumi.get(self, "enable_ad")

    @property
    @pulumi.getter(name="enableRbac")
    def enable_rbac(self) -> Optional[bool]:
        """
        Enable Azure RBAC for Kubernetes authorization. Defaults to `false`.
        """
        return pulumi.get(self, "enable_rbac")


@pulumi.output_type
class AzureMssqlDatabaseSku(dict):
    def __init__(__self__, *,
                 capacity: int,
                 name: str,
                 tier: Optional[str] = None):
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        return pulumi.get(self, "tier")


@pulumi.output_type
class AzureMssqlElasticpoolSku(dict):
    def __init__(__self__, *,
                 capacity: int,
                 name: str,
                 tier: Optional[str] = None):
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        return pulumi.get(self, "tier")


@pulumi.output_type
class AzureMssqlServerActiveDirectoryAdministrator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "adAuthenticationOnly":
            suggest = "ad_authentication_only"
        elif key == "administratorType":
            suggest = "administrator_type"
        elif key == "principalType":
            suggest = "principal_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMssqlServerActiveDirectoryAdministrator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMssqlServerActiveDirectoryAdministrator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMssqlServerActiveDirectoryAdministrator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login: str,
                 object_id: str,
                 tenant_id: str,
                 ad_authentication_only: Optional[bool] = None,
                 administrator_type: Optional[str] = None,
                 principal_type: Optional[str] = None):
        """
        :param str login: The login name of the principal to set as the server administrator
        :param str object_id: The ID of the principal to set as the server administrator
        :param str tenant_id: The Azure Tenant ID
        :param bool ad_authentication_only: Specifies whether only AD Users and administrators can be used to login (`true`) or also local database users (`false`).
        :param str administrator_type: Implicitly inferred. Valid value ActiveDirectory
        :param str principal_type: Specify the type of the principal: `User`, `Group`, or `Application`
        """
        pulumi.set(__self__, "login", login)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if ad_authentication_only is not None:
            pulumi.set(__self__, "ad_authentication_only", ad_authentication_only)
        if administrator_type is not None:
            pulumi.set(__self__, "administrator_type", administrator_type)
        if principal_type is not None:
            pulumi.set(__self__, "principal_type", principal_type)

    @property
    @pulumi.getter
    def login(self) -> str:
        """
        The login name of the principal to set as the server administrator
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        The ID of the principal to set as the server administrator
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Azure Tenant ID
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="adAuthenticationOnly")
    def ad_authentication_only(self) -> Optional[bool]:
        """
        Specifies whether only AD Users and administrators can be used to login (`true`) or also local database users (`false`).
        """
        return pulumi.get(self, "ad_authentication_only")

    @property
    @pulumi.getter(name="administratorType")
    def administrator_type(self) -> Optional[str]:
        """
        Implicitly inferred. Valid value ActiveDirectory
        """
        return pulumi.get(self, "administrator_type")

    @property
    @pulumi.getter(name="principalType")
    def principal_type(self) -> Optional[str]:
        """
        Specify the type of the principal: `User`, `Group`, or `Application`
        """
        return pulumi.get(self, "principal_type")


@pulumi.output_type
class AzurePrivateEndpointPrivateLinkServiceConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "privateConnectionResourceId":
            suggest = "private_connection_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzurePrivateEndpointPrivateLinkServiceConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzurePrivateEndpointPrivateLinkServiceConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzurePrivateEndpointPrivateLinkServiceConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[str],
                 name: str,
                 private_connection_resource_id: str):
        """
        :param str name: Specifies the Name of the Private Service Connection.
        :param str private_connection_resource_id: The ID of the Private Link Enabled Remote Resource which this Private Endpoint should be connected to.
        """
        pulumi.set(__self__, "group_ids", group_ids)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_connection_resource_id", private_connection_resource_id)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the Name of the Private Service Connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateConnectionResourceId")
    def private_connection_resource_id(self) -> str:
        """
        The ID of the Private Link Enabled Remote Resource which this Private Endpoint should be connected to.
        """
        return pulumi.get(self, "private_connection_resource_id")


@pulumi.output_type
class AzureVaultBackupPolicyBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hourDuration":
            suggest = "hour_duration"
        elif key == "hourInterval":
            suggest = "hour_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVaultBackupPolicyBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVaultBackupPolicyBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVaultBackupPolicyBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency: str,
                 time: str,
                 hour_duration: Optional[int] = None,
                 hour_interval: Optional[int] = None,
                 weekdays: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "time", time)
        if hour_duration is not None:
            pulumi.set(__self__, "hour_duration", hour_duration)
        if hour_interval is not None:
            pulumi.set(__self__, "hour_interval", hour_interval)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def frequency(self) -> str:
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def time(self) -> str:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter(name="hourDuration")
    def hour_duration(self) -> Optional[int]:
        return pulumi.get(self, "hour_duration")

    @property
    @pulumi.getter(name="hourInterval")
    def hour_interval(self) -> Optional[int]:
        return pulumi.get(self, "hour_interval")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class AzureVaultBackupPolicyRetentionDaily(dict):
    def __init__(__self__, *,
                 count: int):
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")


@pulumi.output_type
class AzureVaultBackupPolicyRetentionMonthly(dict):
    def __init__(__self__, *,
                 count: int,
                 weekdays: Sequence[str],
                 weeks: Sequence[str]):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "weekdays", weekdays)
        pulumi.set(__self__, "weeks", weeks)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def weekdays(self) -> Sequence[str]:
        return pulumi.get(self, "weekdays")

    @property
    @pulumi.getter
    def weeks(self) -> Sequence[str]:
        return pulumi.get(self, "weeks")


@pulumi.output_type
class AzureVaultBackupPolicyRetentionWeekly(dict):
    def __init__(__self__, *,
                 count: int,
                 weekdays: Sequence[str]):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def weekdays(self) -> Sequence[str]:
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class AzureVaultBackupPolicyRetentionYearly(dict):
    def __init__(__self__, *,
                 count: int,
                 months: Sequence[str],
                 weekdays: Sequence[str],
                 weeks: Sequence[str]):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "months", months)
        pulumi.set(__self__, "weekdays", weekdays)
        pulumi.set(__self__, "weeks", weeks)

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def months(self) -> Sequence[str]:
        return pulumi.get(self, "months")

    @property
    @pulumi.getter
    def weekdays(self) -> Sequence[str]:
        return pulumi.get(self, "weekdays")

    @property
    @pulumi.getter
    def weeks(self) -> Sequence[str]:
        return pulumi.get(self, "weeks")


@pulumi.output_type
class AzureVirtualMachineMinionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureVirtualMachineScaleSetBootDiagnostics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageUri":
            suggest = "storage_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetBootDiagnostics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetBootDiagnostics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetBootDiagnostics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_uri: str,
                 enabled: Optional[bool] = None):
        """
        :param str storage_uri: Blob endpoint for the storage account to hold the virtual machine's diagnostic files.
        :param bool enabled: Whether to enable boot diagnostics for the virtual machine. Defaults to `true`.
        """
        pulumi.set(__self__, "storage_uri", storage_uri)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> str:
        """
        Blob endpoint for the storage account to hold the virtual machine's diagnostic files.
        """
        return pulumi.get(self, "storage_uri")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable boot diagnostics for the virtual machine. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AzureVirtualMachineScaleSetExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeHandlerVersion":
            suggest = "type_handler_version"
        elif key == "autoUpgradeMinorVersion":
            suggest = "auto_upgrade_minor_version"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "provisionAfterExtensions":
            suggest = "provision_after_extensions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 publisher: str,
                 type: str,
                 type_handler_version: str,
                 auto_upgrade_minor_version: Optional[bool] = None,
                 protected_settings: Optional[str] = None,
                 provision_after_extensions: Optional[Sequence[str]] = None,
                 settings: Optional[str] = None):
        """
        :param str name: Specifies the name of the extension.
        :param str publisher: The publisher of the extension, available publishers can be found by using the Azure CLI..
        :param str type: The type of extension, available types for a publisher can be found using the Azure CLI.
        :param str type_handler_version: Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        :param bool auto_upgrade_minor_version: Specifies whether or not to use the latest minor version available.
        :param str protected_settings: The protected_settings passed to the extension, like settings, these are specified as a JSON object in a string.
        :param Sequence[str] provision_after_extensions: Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
        :param str settings: The settings passed to the extension, these are specified as a JSON object in a string.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_handler_version", type_handler_version)
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if provision_after_extensions is not None:
            pulumi.set(__self__, "provision_after_extensions", provision_after_extensions)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the extension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        The publisher of the extension, available publishers can be found by using the Azure CLI..
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of extension, available types for a publisher can be found using the Azure CLI.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> str:
        """
        Specifies the version of the extension to use, available versions can be found using the Azure CLI.
        """
        return pulumi.get(self, "type_handler_version")

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[bool]:
        """
        Specifies whether or not to use the latest minor version available.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[str]:
        """
        The protected_settings passed to the extension, like settings, these are specified as a JSON object in a string.
        """
        return pulumi.get(self, "protected_settings")

    @property
    @pulumi.getter(name="provisionAfterExtensions")
    def provision_after_extensions(self) -> Optional[Sequence[str]]:
        """
        Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
        """
        return pulumi.get(self, "provision_after_extensions")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        The settings passed to the extension, these are specified as a JSON object in a string.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class AzureVirtualMachineScaleSetIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityIds":
            suggest = "identity_ids"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identity_ids: Optional[Sequence[str]] = None,
                 principal_id: Optional[str] = None):
        """
        :param str type: Specifies the identity type to be assigned to the scale set. Allowable values are `SystemAssigned` and `UserAssigned`.
        :param Sequence[str] identity_ids: Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.
        """
        pulumi.set(__self__, "type", type)
        if identity_ids is not None:
            pulumi.set(__self__, "identity_ids", identity_ids)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the identity type to be assigned to the scale set. Allowable values are `SystemAssigned` and `UserAssigned`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="identityIds")
    def identity_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.
        """
        return pulumi.get(self, "identity_ids")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[str]:
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class AzureVirtualMachineScaleSetNetworkProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfigurations":
            suggest = "ip_configurations"
        elif key == "acceleratedNetworking":
            suggest = "accelerated_networking"
        elif key == "dnsSettings":
            suggest = "dns_settings"
        elif key == "ipForwarding":
            suggest = "ip_forwarding"
        elif key == "networkSecurityGroupId":
            suggest = "network_security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetNetworkProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetNetworkProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetNetworkProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configurations: Sequence['outputs.AzureVirtualMachineScaleSetNetworkProfileIpConfiguration'],
                 name: str,
                 primary: bool,
                 accelerated_networking: Optional[bool] = None,
                 dns_settings: Optional['outputs.AzureVirtualMachineScaleSetNetworkProfileDnsSettings'] = None,
                 ip_forwarding: Optional[bool] = None,
                 network_security_group_id: Optional[str] = None):
        """
        :param str name: Specifies the name of the network interface configuration.
        :param bool primary: Indicates whether network interfaces created from the network interface configuration will be the primary NIC of the VM.
        :param bool accelerated_networking: Specifies whether to enable accelerated networking or not. Defaults to `false`.
        :param bool ip_forwarding: Whether IP forwarding is enabled on this NIC. Defaults to `false`.
        :param str network_security_group_id: Specifies the identifier for the network security group.
        """
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary", primary)
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if dns_settings is not None:
            pulumi.set(__self__, "dns_settings", dns_settings)
        if ip_forwarding is not None:
            pulumi.set(__self__, "ip_forwarding", ip_forwarding)
        if network_security_group_id is not None:
            pulumi.set(__self__, "network_security_group_id", network_security_group_id)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.AzureVirtualMachineScaleSetNetworkProfileIpConfiguration']:
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the network interface configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        Indicates whether network interfaces created from the network interface configuration will be the primary NIC of the VM.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[bool]:
        """
        Specifies whether to enable accelerated networking or not. Defaults to `false`.
        """
        return pulumi.get(self, "accelerated_networking")

    @property
    @pulumi.getter(name="dnsSettings")
    def dns_settings(self) -> Optional['outputs.AzureVirtualMachineScaleSetNetworkProfileDnsSettings']:
        return pulumi.get(self, "dns_settings")

    @property
    @pulumi.getter(name="ipForwarding")
    def ip_forwarding(self) -> Optional[bool]:
        """
        Whether IP forwarding is enabled on this NIC. Defaults to `false`.
        """
        return pulumi.get(self, "ip_forwarding")

    @property
    @pulumi.getter(name="networkSecurityGroupId")
    def network_security_group_id(self) -> Optional[str]:
        """
        Specifies the identifier for the network security group.
        """
        return pulumi.get(self, "network_security_group_id")


@pulumi.output_type
class AzureVirtualMachineScaleSetNetworkProfileDnsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetNetworkProfileDnsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetNetworkProfileDnsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetNetworkProfileDnsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_servers: Sequence[str]):
        """
        :param Sequence[str] dns_servers: Specifies an array of dns servers.
        """
        pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        Specifies an array of dns servers.
        """
        return pulumi.get(self, "dns_servers")


@pulumi.output_type
class AzureVirtualMachineScaleSetNetworkProfileIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "applicationGatewayBackendAddressPoolIds":
            suggest = "application_gateway_backend_address_pool_ids"
        elif key == "applicationSecurityGroupIds":
            suggest = "application_security_group_ids"
        elif key == "loadBalancerBackendAddressPoolIds":
            suggest = "load_balancer_backend_address_pool_ids"
        elif key == "loadBalancerInboundNatRulesIds":
            suggest = "load_balancer_inbound_nat_rules_ids"
        elif key == "publicIpAddressConfiguration":
            suggest = "public_ip_address_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetNetworkProfileIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetNetworkProfileIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetNetworkProfileIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 subnet_id: str,
                 application_gateway_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 application_security_group_ids: Optional[Sequence[str]] = None,
                 load_balancer_backend_address_pool_ids: Optional[Sequence[str]] = None,
                 load_balancer_inbound_nat_rules_ids: Optional[Sequence[str]] = None,
                 primary: Optional[bool] = None,
                 public_ip_address_configuration: Optional['outputs.AzureVirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration'] = None):
        """
        :param str name: Specifies name of the IP configuration.
        :param str subnet_id: Specifies the identifier of the subnet.
        :param Sequence[str] application_gateway_backend_address_pool_ids: Specifies an array of references to backend address pools of application gateways.
        :param Sequence[str] application_security_group_ids: Specifies up to 20 application security group IDs.
        :param Sequence[str] load_balancer_backend_address_pool_ids: Specifies an array of references to backend address pools of load balancers.
        :param Sequence[str] load_balancer_inbound_nat_rules_ids: Specifies an array of references to inbound NAT pools for load balancers.
        :param bool primary: Specifies if this ip_configuration is the primary one.
        :param 'AzureVirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfigurationArgs' public_ip_address_configuration: Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if application_gateway_backend_address_pool_ids is not None:
            pulumi.set(__self__, "application_gateway_backend_address_pool_ids", application_gateway_backend_address_pool_ids)
        if application_security_group_ids is not None:
            pulumi.set(__self__, "application_security_group_ids", application_security_group_ids)
        if load_balancer_backend_address_pool_ids is not None:
            pulumi.set(__self__, "load_balancer_backend_address_pool_ids", load_balancer_backend_address_pool_ids)
        if load_balancer_inbound_nat_rules_ids is not None:
            pulumi.set(__self__, "load_balancer_inbound_nat_rules_ids", load_balancer_inbound_nat_rules_ids)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if public_ip_address_configuration is not None:
            pulumi.set(__self__, "public_ip_address_configuration", public_ip_address_configuration)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies name of the IP configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Specifies the identifier of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPoolIds")
    def application_gateway_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies an array of references to backend address pools of application gateways.
        """
        return pulumi.get(self, "application_gateway_backend_address_pool_ids")

    @property
    @pulumi.getter(name="applicationSecurityGroupIds")
    def application_security_group_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies up to 20 application security group IDs.
        """
        return pulumi.get(self, "application_security_group_ids")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPoolIds")
    def load_balancer_backend_address_pool_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies an array of references to backend address pools of load balancers.
        """
        return pulumi.get(self, "load_balancer_backend_address_pool_ids")

    @property
    @pulumi.getter(name="loadBalancerInboundNatRulesIds")
    def load_balancer_inbound_nat_rules_ids(self) -> Optional[Sequence[str]]:
        """
        Specifies an array of references to inbound NAT pools for load balancers.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules_ids")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Specifies if this ip_configuration is the primary one.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="publicIpAddressConfiguration")
    def public_ip_address_configuration(self) -> Optional['outputs.AzureVirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration']:
        """
        Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration.
        """
        return pulumi.get(self, "public_ip_address_configuration")


@pulumi.output_type
class AzureVirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNameLabel":
            suggest = "domain_name_label"
        elif key == "idleTimeout":
            suggest = "idle_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name_label: str,
                 idle_timeout: int,
                 name: str):
        """
        :param str domain_name_label: The domain name label for the dns settings.
        :param int idle_timeout: The idle timeout in minutes. This value must be between 4 and 30.
        :param str name: The name of the public ip address configuration.
        """
        pulumi.set(__self__, "domain_name_label", domain_name_label)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> str:
        """
        The domain name label for the dns settings.
        """
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> int:
        """
        The idle timeout in minutes. This value must be between 4 and 30.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the public ip address configuration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AzureVirtualMachineScaleSetOsProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsername":
            suggest = "admin_username"
        elif key == "computerNamePrefix":
            suggest = "computer_name_prefix"
        elif key == "adminPassword":
            suggest = "admin_password"
        elif key == "customData":
            suggest = "custom_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetOsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetOsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetOsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_username: str,
                 computer_name_prefix: str,
                 admin_password: Optional[str] = None,
                 custom_data: Optional[str] = None):
        """
        :param str admin_username: Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
        :param str computer_name_prefix: Specifies the computer name prefix for all of the virtual machines in the scale set.
        :param str admin_password: Specifies the administrator password to use for all the instances of virtual machines in a scale set.
        :param str custom_data: Specifies custom data to supply to the machine. On linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk.
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "computer_name_prefix", computer_name_prefix)
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> str:
        """
        Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="computerNamePrefix")
    def computer_name_prefix(self) -> str:
        """
        Specifies the computer name prefix for all of the virtual machines in the scale set.
        """
        return pulumi.get(self, "computer_name_prefix")

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        Specifies the administrator password to use for all the instances of virtual machines in a scale set.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[str]:
        """
        Specifies custom data to supply to the machine. On linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk.
        """
        return pulumi.get(self, "custom_data")


@pulumi.output_type
class AzureVirtualMachineScaleSetOsProfileLinuxConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disablePasswordAuthentication":
            suggest = "disable_password_authentication"
        elif key == "sshKeys":
            suggest = "ssh_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetOsProfileLinuxConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetOsProfileLinuxConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetOsProfileLinuxConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_password_authentication: Optional[bool] = None,
                 ssh_keys: Optional[Sequence['outputs.AzureVirtualMachineScaleSetOsProfileLinuxConfigSshKey']] = None):
        """
        :param bool disable_password_authentication: Specifies whether password authentication should be disabled. Defaults to `false`.
        :param Sequence['AzureVirtualMachineScaleSetOsProfileLinuxConfigSshKeyArgs'] ssh_keys: Specifies a collection of `path` and `key_data` to be placed on the virtual machine.
        """
        if disable_password_authentication is not None:
            pulumi.set(__self__, "disable_password_authentication", disable_password_authentication)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)

    @property
    @pulumi.getter(name="disablePasswordAuthentication")
    def disable_password_authentication(self) -> Optional[bool]:
        """
        Specifies whether password authentication should be disabled. Defaults to `false`.
        """
        return pulumi.get(self, "disable_password_authentication")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence['outputs.AzureVirtualMachineScaleSetOsProfileLinuxConfigSshKey']]:
        """
        Specifies a collection of `path` and `key_data` to be placed on the virtual machine.
        """
        return pulumi.get(self, "ssh_keys")


@pulumi.output_type
class AzureVirtualMachineScaleSetOsProfileLinuxConfigSshKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyData":
            suggest = "key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetOsProfileLinuxConfigSshKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetOsProfileLinuxConfigSshKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetOsProfileLinuxConfigSshKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 key_data: Optional[str] = None):
        pulumi.set(__self__, "path", path)
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[str]:
        return pulumi.get(self, "key_data")


@pulumi.output_type
class AzureVirtualMachineScaleSetOsProfileSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceVaultId":
            suggest = "source_vault_id"
        elif key == "vaultCertificates":
            suggest = "vault_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetOsProfileSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetOsProfileSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetOsProfileSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_vault_id: str,
                 vault_certificates: Optional[Sequence['outputs.AzureVirtualMachineScaleSetOsProfileSecretVaultCertificate']] = None):
        """
        :param str source_vault_id: Specifies the key vault to use.
        :param Sequence['AzureVirtualMachineScaleSetOsProfileSecretVaultCertificateArgs'] vault_certificates: A collection of Vault Certificates as documented below.
        """
        pulumi.set(__self__, "source_vault_id", source_vault_id)
        if vault_certificates is not None:
            pulumi.set(__self__, "vault_certificates", vault_certificates)

    @property
    @pulumi.getter(name="sourceVaultId")
    def source_vault_id(self) -> str:
        """
        Specifies the key vault to use.
        """
        return pulumi.get(self, "source_vault_id")

    @property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> Optional[Sequence['outputs.AzureVirtualMachineScaleSetOsProfileSecretVaultCertificate']]:
        """
        A collection of Vault Certificates as documented below.
        """
        return pulumi.get(self, "vault_certificates")


@pulumi.output_type
class AzureVirtualMachineScaleSetOsProfileSecretVaultCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"
        elif key == "certificateStore":
            suggest = "certificate_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetOsProfileSecretVaultCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetOsProfileSecretVaultCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetOsProfileSecretVaultCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_url: str,
                 certificate_store: Optional[str] = None):
        """
        :param str certificate_url: It is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be `data`, `dataType` and `password`.
        :param str certificate_store: Specifies the certificate store on the Virtual Machine where the certificate should be added to.
        """
        pulumi.set(__self__, "certificate_url", certificate_url)
        if certificate_store is not None:
            pulumi.set(__self__, "certificate_store", certificate_store)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> str:
        """
        It is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be `data`, `dataType` and `password`.
        """
        return pulumi.get(self, "certificate_url")

    @property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> Optional[str]:
        """
        Specifies the certificate store on the Virtual Machine where the certificate should be added to.
        """
        return pulumi.get(self, "certificate_store")


@pulumi.output_type
class AzureVirtualMachineScaleSetOsProfileWindowsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalUnattendConfigs":
            suggest = "additional_unattend_configs"
        elif key == "enableAutomaticUpgrades":
            suggest = "enable_automatic_upgrades"
        elif key == "provisionVmAgent":
            suggest = "provision_vm_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetOsProfileWindowsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetOsProfileWindowsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetOsProfileWindowsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_unattend_configs: Optional[Sequence['outputs.AzureVirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig']] = None,
                 enable_automatic_upgrades: Optional[bool] = None,
                 provision_vm_agent: Optional[bool] = None,
                 winrms: Optional[Sequence['outputs.AzureVirtualMachineScaleSetOsProfileWindowsConfigWinrm']] = None):
        """
        :param bool enable_automatic_upgrades: Indicates whether virtual machines in the scale set are enabled for automatic updates.
        :param bool provision_vm_agent: Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
        """
        if additional_unattend_configs is not None:
            pulumi.set(__self__, "additional_unattend_configs", additional_unattend_configs)
        if enable_automatic_upgrades is not None:
            pulumi.set(__self__, "enable_automatic_upgrades", enable_automatic_upgrades)
        if provision_vm_agent is not None:
            pulumi.set(__self__, "provision_vm_agent", provision_vm_agent)
        if winrms is not None:
            pulumi.set(__self__, "winrms", winrms)

    @property
    @pulumi.getter(name="additionalUnattendConfigs")
    def additional_unattend_configs(self) -> Optional[Sequence['outputs.AzureVirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig']]:
        return pulumi.get(self, "additional_unattend_configs")

    @property
    @pulumi.getter(name="enableAutomaticUpgrades")
    def enable_automatic_upgrades(self) -> Optional[bool]:
        """
        Indicates whether virtual machines in the scale set are enabled for automatic updates.
        """
        return pulumi.get(self, "enable_automatic_upgrades")

    @property
    @pulumi.getter(name="provisionVmAgent")
    def provision_vm_agent(self) -> Optional[bool]:
        """
        Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
        """
        return pulumi.get(self, "provision_vm_agent")

    @property
    @pulumi.getter
    def winrms(self) -> Optional[Sequence['outputs.AzureVirtualMachineScaleSetOsProfileWindowsConfigWinrm']]:
        return pulumi.get(self, "winrms")


@pulumi.output_type
class AzureVirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pass":
            suggest = "pass_"
        elif key == "settingName":
            suggest = "setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component: str,
                 content: str,
                 pass_: str,
                 setting_name: str):
        """
        :param str component: Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        :param str content: Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        :param str pass_: Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        :param str setting_name: Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "pass_", pass_)
        pulumi.set(__self__, "setting_name", setting_name)

    @property
    @pulumi.getter
    def component(self) -> str:
        """
        Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="pass")
    def pass_(self) -> str:
        """
        Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
        """
        return pulumi.get(self, "pass_")

    @property
    @pulumi.getter(name="settingName")
    def setting_name(self) -> str:
        """
        Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
        """
        return pulumi.get(self, "setting_name")


@pulumi.output_type
class AzureVirtualMachineScaleSetOsProfileWindowsConfigWinrm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetOsProfileWindowsConfigWinrm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetOsProfileWindowsConfigWinrm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetOsProfileWindowsConfigWinrm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 certificate_url: Optional[str] = None):
        """
        :param str protocol: Specifies the protocol of listener.
        :param str certificate_url: Specifies URL of the certificate with which new Virtual Machines is provisioned.
        """
        pulumi.set(__self__, "protocol", protocol)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Specifies the protocol of listener.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[str]:
        """
        Specifies URL of the certificate with which new Virtual Machines is provisioned.
        """
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class AzureVirtualMachineScaleSetPlan(dict):
    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str):
        """
        :param str name: Specifies the name of the image from the marketplace.
        :param str product: Specifies the product of the image from the marketplace.
        :param str publisher: Specifies the publisher of the image.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the name of the image from the marketplace.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        Specifies the product of the image from the marketplace.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Specifies the publisher of the image.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class AzureVirtualMachineScaleSetRollingUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBatchInstancePercent":
            suggest = "max_batch_instance_percent"
        elif key == "maxUnhealthyInstancePercent":
            suggest = "max_unhealthy_instance_percent"
        elif key == "maxUnhealthyUpgradedInstancePercent":
            suggest = "max_unhealthy_upgraded_instance_percent"
        elif key == "pauseTimeBetweenBatches":
            suggest = "pause_time_between_batches"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetRollingUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetRollingUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetRollingUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_batch_instance_percent: Optional[int] = None,
                 max_unhealthy_instance_percent: Optional[int] = None,
                 max_unhealthy_upgraded_instance_percent: Optional[int] = None,
                 pause_time_between_batches: Optional[str] = None):
        """
        :param int max_batch_instance_percent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade. Defaults to `20`.
        :param int max_unhealthy_instance_percent: The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy. Defaults to `20`.
        :param int max_unhealthy_upgraded_instance_percent: The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. Defaults to `20`.
        :param str pause_time_between_batches: The wait time between completing the update for all virtual machines in one batch and starting the next batch. Defaults to `PT0S`.
        """
        if max_batch_instance_percent is not None:
            pulumi.set(__self__, "max_batch_instance_percent", max_batch_instance_percent)
        if max_unhealthy_instance_percent is not None:
            pulumi.set(__self__, "max_unhealthy_instance_percent", max_unhealthy_instance_percent)
        if max_unhealthy_upgraded_instance_percent is not None:
            pulumi.set(__self__, "max_unhealthy_upgraded_instance_percent", max_unhealthy_upgraded_instance_percent)
        if pause_time_between_batches is not None:
            pulumi.set(__self__, "pause_time_between_batches", pause_time_between_batches)

    @property
    @pulumi.getter(name="maxBatchInstancePercent")
    def max_batch_instance_percent(self) -> Optional[int]:
        """
        The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade. Defaults to `20`.
        """
        return pulumi.get(self, "max_batch_instance_percent")

    @property
    @pulumi.getter(name="maxUnhealthyInstancePercent")
    def max_unhealthy_instance_percent(self) -> Optional[int]:
        """
        The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy. Defaults to `20`.
        """
        return pulumi.get(self, "max_unhealthy_instance_percent")

    @property
    @pulumi.getter(name="maxUnhealthyUpgradedInstancePercent")
    def max_unhealthy_upgraded_instance_percent(self) -> Optional[int]:
        """
        The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. Defaults to `20`.
        """
        return pulumi.get(self, "max_unhealthy_upgraded_instance_percent")

    @property
    @pulumi.getter(name="pauseTimeBetweenBatches")
    def pause_time_between_batches(self) -> Optional[str]:
        """
        The wait time between completing the update for all virtual machines in one batch and starting the next batch. Defaults to `PT0S`.
        """
        return pulumi.get(self, "pause_time_between_batches")


@pulumi.output_type
class AzureVirtualMachineScaleSetSku(dict):
    def __init__(__self__, *,
                 capacity: int,
                 name: str,
                 tier: Optional[str] = None):
        """
        :param int capacity: Specifies the number of virtual machines in the scale set.
        :param str name: Specifies the size of virtual machines in a scale set.
        :param str tier: Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Specifies the number of virtual machines in the scale set.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specifies the size of virtual machines in a scale set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class AzureVirtualMachineScaleSetStorageProfileDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createOption":
            suggest = "create_option"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "managedDiskType":
            suggest = "managed_disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetStorageProfileDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetStorageProfileDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetStorageProfileDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_option: str,
                 lun: int,
                 caching: Optional[str] = None,
                 disk_size_gb: Optional[int] = None,
                 managed_disk_type: Optional[str] = None):
        """
        :param str create_option: Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
        :param int lun: Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
        :param str caching: Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        :param int disk_size_gb: Specifies the size of the disk in GB. This element is required when creating an empty disk. Defaults to `128`.
        :param str managed_disk_type: Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
        """
        pulumi.set(__self__, "create_option", create_option)
        pulumi.set(__self__, "lun", lun)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> str:
        """
        Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
        """
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter
    def caching(self) -> Optional[str]:
        """
        Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[int]:
        """
        Specifies the size of the disk in GB. This element is required when creating an empty disk. Defaults to `128`.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[str]:
        """
        Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
        """
        return pulumi.get(self, "managed_disk_type")


@pulumi.output_type
class AzureVirtualMachineScaleSetStorageProfileImageReference(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 offer: Optional[str] = None,
                 publisher: Optional[str] = None,
                 sku: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str id: Specifies the ID of the (custom) image to use to create the virtual machine scale set.
        :param str offer: Specifies the offer of the image used to create the virtual machines.
        :param str publisher: Specifies the publisher of the image used to create the virtual machines.
        :param str sku: Specifies the SKU of the image used to create the virtual machines.
        :param str version: Specifies the version of the image used to create the virtual machines.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if offer is not None:
            pulumi.set(__self__, "offer", offer)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Specifies the ID of the (custom) image to use to create the virtual machine scale set.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def offer(self) -> Optional[str]:
        """
        Specifies the offer of the image used to create the virtual machines.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Specifies the publisher of the image used to create the virtual machines.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        Specifies the SKU of the image used to create the virtual machines.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Specifies the version of the image used to create the virtual machines.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AzureVirtualMachineScaleSetStorageProfileOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createOption":
            suggest = "create_option"
        elif key == "managedDiskType":
            suggest = "managed_disk_type"
        elif key == "osType":
            suggest = "os_type"
        elif key == "vhdContainers":
            suggest = "vhd_containers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineScaleSetStorageProfileOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineScaleSetStorageProfileOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineScaleSetStorageProfileOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching: Optional[str] = None,
                 create_option: Optional[str] = None,
                 image: Optional[str] = None,
                 managed_disk_type: Optional[str] = None,
                 name: Optional[str] = None,
                 os_type: Optional[str] = None,
                 vhd_containers: Optional[Sequence[str]] = None):
        """
        :param str caching: Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        :param str create_option: Specifies how the virtual machine should be created. The only possible option is `FromImage`.
        :param str image: Specifies the blob uri for user image. A virtual machine scale set creates an os disk in the same container as the user image.
        :param str managed_disk_type: Specifies the type of managed disk to create. Value you must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`. Cannot be used when `vhd_containers` or `image` is specified.
        :param str name: Specifies the disk name. Must be specified when using unmanaged disk ('managed*disk*type' property not set).
        :param str os_type: Specifies the operating system Type, valid values are `windows`, `linux`.
        :param Sequence[str] vhd_containers: Specifies the vhd uri. Cannot be used when `image` or `managed_disk_type` is specified.
        """
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if create_option is not None:
            pulumi.set(__self__, "create_option", create_option)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if managed_disk_type is not None:
            pulumi.set(__self__, "managed_disk_type", managed_disk_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if vhd_containers is not None:
            pulumi.set(__self__, "vhd_containers", vhd_containers)

    @property
    @pulumi.getter
    def caching(self) -> Optional[str]:
        """
        Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
        """
        return pulumi.get(self, "caching")

    @property
    @pulumi.getter(name="createOption")
    def create_option(self) -> Optional[str]:
        """
        Specifies how the virtual machine should be created. The only possible option is `FromImage`.
        """
        return pulumi.get(self, "create_option")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Specifies the blob uri for user image. A virtual machine scale set creates an os disk in the same container as the user image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="managedDiskType")
    def managed_disk_type(self) -> Optional[str]:
        """
        Specifies the type of managed disk to create. Value you must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`. Cannot be used when `vhd_containers` or `image` is specified.
        """
        return pulumi.get(self, "managed_disk_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Specifies the disk name. Must be specified when using unmanaged disk ('managed*disk*type' property not set).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[str]:
        """
        Specifies the operating system Type, valid values are `windows`, `linux`.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="vhdContainers")
    def vhd_containers(self) -> Optional[Sequence[str]]:
        """
        Specifies the vhd uri. Cannot be used when `image` or `managed_disk_type` is specified.
        """
        return pulumi.get(self, "vhd_containers")


@pulumi.output_type
class AzureVirtualMachineTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AzureVirtualMachineVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVirtualMachineVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVirtualMachineVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVirtualMachineVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iops: Optional[int] = None,
                 name: Optional[str] = None,
                 size: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_type: Optional[str] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class AzureVmMaintenanceConfigurationWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "expirationTime":
            suggest = "expiration_time"
        elif key == "recurEvery":
            suggest = "recur_every"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureVmMaintenanceConfigurationWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureVmMaintenanceConfigurationWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureVmMaintenanceConfigurationWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: str,
                 time_zone: str,
                 duration: Optional[str] = None,
                 expiration_time: Optional[str] = None,
                 recur_every: Optional[str] = None):
        """
        :param str start_time: Effective start date of the maintenance window in YYYY-MM-DD HH:MM format.
        :param str time_zone: The timezone on which maintenance should be scheduled.
        :param str duration: The duration of the maintenance window in HH:mm format. Should be less than or equal to 3 Hrs
        :param str expiration_time: Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
        :param str recur_every: he rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
        """
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if recur_every is not None:
            pulumi.set(__self__, "recur_every", recur_every)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Effective start date of the maintenance window in YYYY-MM-DD HH:MM format.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        The timezone on which maintenance should be scheduled.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        The duration of the maintenance window in HH:mm format. Should be less than or equal to 3 Hrs
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[str]:
        """
        Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
        """
        return pulumi.get(self, "expiration_time")

    @property
    @pulumi.getter(name="recurEvery")
    def recur_every(self) -> Optional[str]:
        """
        he rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
        """
        return pulumi.get(self, "recur_every")


@pulumi.output_type
class ByohTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DuploServiceInitContainerDockerImage(dict):
    def __init__(__self__, *,
                 image: str,
                 name: str):
        """
        :param str image: Init container docker image.
        :param str name: Init container name.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        Init container docker image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Init container name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DuploServiceLbconfigsLbconfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lbType":
            suggest = "lb_type"
        elif key == "allowGlobalAccess":
            suggest = "allow_global_access"
        elif key == "backendConfigTimeoutSec":
            suggest = "backend_config_timeout_sec"
        elif key == "backendProtocolVersion":
            suggest = "backend_protocol_version"
        elif key == "certificateArn":
            suggest = "certificate_arn"
        elif key == "cloudName":
            suggest = "cloud_name"
        elif key == "customCidrs":
            suggest = "custom_cidrs"
        elif key == "dnsName":
            suggest = "dns_name"
        elif key == "externalPort":
            suggest = "external_port"
        elif key == "externalTrafficPolicy":
            suggest = "external_traffic_policy"
        elif key == "extraSelectorLabels":
            suggest = "extra_selector_labels"
        elif key == "frontendIp":
            suggest = "frontend_ip"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "healthCheckUrl":
            suggest = "health_check_url"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "hostPort":
            suggest = "host_port"
        elif key == "isInfraDeployment":
            suggest = "is_infra_deployment"
        elif key == "isInternal":
            suggest = "is_internal"
        elif key == "isNative":
            suggest = "is_native"
        elif key == "replicationControllerName":
            suggest = "replication_controller_name"
        elif key == "setIngressHealthCheck":
            suggest = "set_ingress_health_check"
        elif key == "skipHttpToHttps":
            suggest = "skip_http_to_https"
        elif key == "targetGroupArn":
            suggest = "target_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DuploServiceLbconfigsLbconfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DuploServiceLbconfigsLbconfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DuploServiceLbconfigsLbconfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lb_type: int,
                 port: str,
                 protocol: str,
                 allow_global_access: Optional[bool] = None,
                 backend_config_timeout_sec: Optional[int] = None,
                 backend_protocol_version: Optional[str] = None,
                 certificate_arn: Optional[str] = None,
                 cloud_name: Optional[str] = None,
                 custom_cidrs: Optional[Sequence[str]] = None,
                 dns_name: Optional[str] = None,
                 external_port: Optional[int] = None,
                 external_traffic_policy: Optional[str] = None,
                 extra_selector_labels: Optional[Sequence['outputs.DuploServiceLbconfigsLbconfigExtraSelectorLabel']] = None,
                 frontend_ip: Optional[str] = None,
                 health_check: Optional['outputs.DuploServiceLbconfigsLbconfigHealthCheck'] = None,
                 health_check_url: Optional[str] = None,
                 host_name: Optional[str] = None,
                 host_port: Optional[int] = None,
                 index: Optional[int] = None,
                 is_infra_deployment: Optional[bool] = None,
                 is_internal: Optional[bool] = None,
                 is_native: Optional[bool] = None,
                 name: Optional[str] = None,
                 replication_controller_name: Optional[str] = None,
                 set_ingress_health_check: Optional[bool] = None,
                 skip_http_to_https: Optional[bool] = None,
                 target_group_arn: Optional[str] = None):
        """
        :param int lb_type: The numerical index of the type of load balancer configuration to create.
               Should be one of:
               
                  - `0` : ELB (Classic Load Balancer)
                  - `1` : ALB (Application Load Balancer)
                  - `2` : Health-check Only (No Load Balancer)
                  - `3` : K8S Service w/ Cluster IP (No Load Balancer)
                  - `4` : K8S Service w/ Node Port (No Load Balancer)
                  - `5` : Azure Shared Application Gateway
                  - `6` : NLB (Network Load Balancer)
                  - `7` : Target Group Only
        :param str port: The backend port associated with this load balancer configuration.
        :param str protocol: The backend protocol associated with this load balancer configuration.
               Supported protocol based on lb_type:
               
               	- `0 (ELB)`: HTTP, HTTPS, TCP, UDP
               	- `1 (ALB)` : HTTP, HTTPS
               	- `3 (K8S Service w/ Cluster IP)`: TCP, UDP
               	- `4 (K8S Service w/ Node Port)` : TCP, UDP
               	- `5 (Azure Shared Application Gateway)`: HTTP, HTTPS
               	- `6 (NLB)` : TCP, UDP, TLS
               	- `7 (Target Group Only)` : HTTP, HTTPS, TCP, UDP, TLS
        :param bool allow_global_access: Applicable for internal lb.
        :param int backend_config_timeout_sec: The number of seconds to wait for the backend to send a response. Must be at least 1. Applicable only for GCP.
        :param str backend_protocol_version: Is used for communication between the load balancer and the target instances. This field is used to set protocol version for ALB load balancer. Only applicable when protocol is HTTP or HTTPS. The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1
        :param str certificate_arn: The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        :param str cloud_name: The name of the cloud load balancer (if applicable).
        :param Sequence[str] custom_cidrs: Specify CIDR Values. This is applicable only for Network Load Balancer if `lb_type` is `6`.
        :param str dns_name: The DNS name of the cloud load balancer (if applicable).
        :param int external_port: The frontend port associated with this load balancer configuration. Required if `lb_type` is not `7`.
        :param str external_traffic_policy: Only for K8S Node Port (`lb_type = 4`) or load balancers in Kubernetes.  Set the kubernetes service `externalTrafficPolicy` attribute.
        :param Sequence['DuploServiceLbconfigsLbconfigExtraSelectorLabelArgs'] extra_selector_labels: Only for K8S services or load balancers in Kubernetes.  Sets an additional selector label to narrow which pods can receive traffic.
        :param 'DuploServiceLbconfigsLbconfigHealthCheckArgs' health_check: Health Check configuration block.
        :param str health_check_url: The health check URL to associate with this load balancer configuration.
        :param str host_name: (Azure Only) Set only if Azure Shared Application Gateway is used (`lb_type = 5`).
        :param int host_port: The automatically assigned host port.
        :param int index: The load balancer Index.
        :param bool is_internal: Whether or not to create an internal load balancer.
        :param bool is_native: Set to true if the service for which the load balancer is being created is hosted on a docker native host, which is managed directly by DuploCloud, or false if the service is hosted on a cloud-provided platform like EKS, AKS, GKE, ECS, etc. The `get_native_hosts` data source lists the native hosts in a DuploCloud Tenant
        :param str name: The name of the duplo service.
        :param str replication_controller_name: The name of the duplo service.
        :param bool set_ingress_health_check: Only for K8S services or load balancers in Kubernetes.  Set to `true` to set health check annotations for ingress.
        :param bool skip_http_to_https: Skip http to https.
        :param str target_group_arn: The ARN of the Target Group to which to route traffic.
        """
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if allow_global_access is not None:
            pulumi.set(__self__, "allow_global_access", allow_global_access)
        if backend_config_timeout_sec is not None:
            pulumi.set(__self__, "backend_config_timeout_sec", backend_config_timeout_sec)
        if backend_protocol_version is not None:
            pulumi.set(__self__, "backend_protocol_version", backend_protocol_version)
        if certificate_arn is not None:
            pulumi.set(__self__, "certificate_arn", certificate_arn)
        if cloud_name is not None:
            pulumi.set(__self__, "cloud_name", cloud_name)
        if custom_cidrs is not None:
            pulumi.set(__self__, "custom_cidrs", custom_cidrs)
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if external_port is not None:
            pulumi.set(__self__, "external_port", external_port)
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if extra_selector_labels is not None:
            pulumi.set(__self__, "extra_selector_labels", extra_selector_labels)
        if frontend_ip is not None:
            pulumi.set(__self__, "frontend_ip", frontend_ip)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if health_check_url is not None:
            pulumi.set(__self__, "health_check_url", health_check_url)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if is_infra_deployment is not None:
            pulumi.set(__self__, "is_infra_deployment", is_infra_deployment)
        if is_internal is not None:
            pulumi.set(__self__, "is_internal", is_internal)
        if is_native is not None:
            pulumi.set(__self__, "is_native", is_native)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if replication_controller_name is not None:
            pulumi.set(__self__, "replication_controller_name", replication_controller_name)
        if set_ingress_health_check is not None:
            pulumi.set(__self__, "set_ingress_health_check", set_ingress_health_check)
        if skip_http_to_https is not None:
            pulumi.set(__self__, "skip_http_to_https", skip_http_to_https)
        if target_group_arn is not None:
            pulumi.set(__self__, "target_group_arn", target_group_arn)

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        The numerical index of the type of load balancer configuration to create.
        Should be one of:

           - `0` : ELB (Classic Load Balancer)
           - `1` : ALB (Application Load Balancer)
           - `2` : Health-check Only (No Load Balancer)
           - `3` : K8S Service w/ Cluster IP (No Load Balancer)
           - `4` : K8S Service w/ Node Port (No Load Balancer)
           - `5` : Azure Shared Application Gateway
           - `6` : NLB (Network Load Balancer)
           - `7` : Target Group Only
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        The backend port associated with this load balancer configuration.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The backend protocol associated with this load balancer configuration.
        Supported protocol based on lb_type:

        	- `0 (ELB)`: HTTP, HTTPS, TCP, UDP
        	- `1 (ALB)` : HTTP, HTTPS
        	- `3 (K8S Service w/ Cluster IP)`: TCP, UDP
        	- `4 (K8S Service w/ Node Port)` : TCP, UDP
        	- `5 (Azure Shared Application Gateway)`: HTTP, HTTPS
        	- `6 (NLB)` : TCP, UDP, TLS
        	- `7 (Target Group Only)` : HTTP, HTTPS, TCP, UDP, TLS
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="allowGlobalAccess")
    def allow_global_access(self) -> Optional[bool]:
        """
        Applicable for internal lb.
        """
        return pulumi.get(self, "allow_global_access")

    @property
    @pulumi.getter(name="backendConfigTimeoutSec")
    def backend_config_timeout_sec(self) -> Optional[int]:
        """
        The number of seconds to wait for the backend to send a response. Must be at least 1. Applicable only for GCP.
        """
        return pulumi.get(self, "backend_config_timeout_sec")

    @property
    @pulumi.getter(name="backendProtocolVersion")
    def backend_protocol_version(self) -> Optional[str]:
        """
        Is used for communication between the load balancer and the target instances. This field is used to set protocol version for ALB load balancer. Only applicable when protocol is HTTP or HTTPS. The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1
        """
        return pulumi.get(self, "backend_protocol_version")

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> Optional[str]:
        """
        The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter(name="cloudName")
    def cloud_name(self) -> Optional[str]:
        """
        The name of the cloud load balancer (if applicable).
        """
        return pulumi.get(self, "cloud_name")

    @property
    @pulumi.getter(name="customCidrs")
    def custom_cidrs(self) -> Optional[Sequence[str]]:
        """
        Specify CIDR Values. This is applicable only for Network Load Balancer if `lb_type` is `6`.
        """
        return pulumi.get(self, "custom_cidrs")

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        The DNS name of the cloud load balancer (if applicable).
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> Optional[int]:
        """
        The frontend port associated with this load balancer configuration. Required if `lb_type` is not `7`.
        """
        return pulumi.get(self, "external_port")

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[str]:
        """
        Only for K8S Node Port (`lb_type = 4`) or load balancers in Kubernetes.  Set the kubernetes service `externalTrafficPolicy` attribute.
        """
        return pulumi.get(self, "external_traffic_policy")

    @property
    @pulumi.getter(name="extraSelectorLabels")
    def extra_selector_labels(self) -> Optional[Sequence['outputs.DuploServiceLbconfigsLbconfigExtraSelectorLabel']]:
        """
        Only for K8S services or load balancers in Kubernetes.  Sets an additional selector label to narrow which pods can receive traffic.
        """
        return pulumi.get(self, "extra_selector_labels")

    @property
    @pulumi.getter(name="frontendIp")
    def frontend_ip(self) -> Optional[str]:
        return pulumi.get(self, "frontend_ip")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.DuploServiceLbconfigsLbconfigHealthCheck']:
        """
        Health Check configuration block.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="healthCheckUrl")
    def health_check_url(self) -> Optional[str]:
        """
        The health check URL to associate with this load balancer configuration.
        """
        return pulumi.get(self, "health_check_url")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[str]:
        """
        (Azure Only) Set only if Azure Shared Application Gateway is used (`lb_type = 5`).
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        The automatically assigned host port.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        """
        The load balancer Index.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="isInfraDeployment")
    def is_infra_deployment(self) -> Optional[bool]:
        return pulumi.get(self, "is_infra_deployment")

    @property
    @pulumi.getter(name="isInternal")
    def is_internal(self) -> Optional[bool]:
        """
        Whether or not to create an internal load balancer.
        """
        return pulumi.get(self, "is_internal")

    @property
    @pulumi.getter(name="isNative")
    def is_native(self) -> Optional[bool]:
        """
        Set to true if the service for which the load balancer is being created is hosted on a docker native host, which is managed directly by DuploCloud, or false if the service is hosted on a cloud-provided platform like EKS, AKS, GKE, ECS, etc. The `get_native_hosts` data source lists the native hosts in a DuploCloud Tenant
        """
        return pulumi.get(self, "is_native")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the duplo service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="replicationControllerName")
    def replication_controller_name(self) -> Optional[str]:
        """
        The name of the duplo service.
        """
        return pulumi.get(self, "replication_controller_name")

    @property
    @pulumi.getter(name="setIngressHealthCheck")
    def set_ingress_health_check(self) -> Optional[bool]:
        """
        Only for K8S services or load balancers in Kubernetes.  Set to `true` to set health check annotations for ingress.
        """
        return pulumi.get(self, "set_ingress_health_check")

    @property
    @pulumi.getter(name="skipHttpToHttps")
    def skip_http_to_https(self) -> Optional[bool]:
        """
        Skip http to https.
        """
        return pulumi.get(self, "skip_http_to_https")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> Optional[str]:
        """
        The ARN of the Target Group to which to route traffic.
        """
        return pulumi.get(self, "target_group_arn")


@pulumi.output_type
class DuploServiceLbconfigsLbconfigExtraSelectorLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DuploServiceLbconfigsLbconfigHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcSuccessCodes":
            suggest = "grpc_success_codes"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "httpSuccessCodes":
            suggest = "http_success_codes"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DuploServiceLbconfigsLbconfigHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DuploServiceLbconfigsLbconfigHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DuploServiceLbconfigsLbconfigHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_success_codes: Optional[str] = None,
                 healthy_threshold: Optional[int] = None,
                 http_success_codes: Optional[str] = None,
                 interval: Optional[int] = None,
                 timeout: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param str grpc_success_codes: Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "0,12" for GRPC) or a range of values (for example, "0-99"). Required for GRPC ALB. Only applies to Application Load Balancers (i.e., GRPC) not Network Load Balancers (i.e., TCP).
        :param int healthy_threshold: Number of consecutive health checks successes required before considering an unhealthy target healthy.
        :param str http_success_codes: Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "200,202" for HTTP(s)) or a range of values (for example, "200-299"). Required for HTTP/HTTPS ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS) not Network Load Balancers (i.e., TCP).
        :param int interval: Approximate amount of time, in seconds, between health checks of an individual target. Minimum value 5 seconds, Maximum value 300 seconds.
        :param int timeout: Amount of time, in seconds, during which no response means a failed health check.
        :param int unhealthy_threshold: Number of consecutive health check failures required before considering the target unhealthy.
        """
        if grpc_success_codes is not None:
            pulumi.set(__self__, "grpc_success_codes", grpc_success_codes)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if http_success_codes is not None:
            pulumi.set(__self__, "http_success_codes", http_success_codes)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="grpcSuccessCodes")
    def grpc_success_codes(self) -> Optional[str]:
        """
        Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "0,12" for GRPC) or a range of values (for example, "0-99"). Required for GRPC ALB. Only applies to Application Load Balancers (i.e., GRPC) not Network Load Balancers (i.e., TCP).
        """
        return pulumi.get(self, "grpc_success_codes")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive health checks successes required before considering an unhealthy target healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter(name="httpSuccessCodes")
    def http_success_codes(self) -> Optional[str]:
        """
        Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "200,202" for HTTP(s)) or a range of values (for example, "200-299"). Required for HTTP/HTTPS ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS) not Network Load Balancers (i.e., TCP).
        """
        return pulumi.get(self, "http_success_codes")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Approximate amount of time, in seconds, between health checks of an individual target. Minimum value 5 seconds, Maximum value 300 seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Amount of time, in seconds, during which no response means a failed health check.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive health check failures required before considering the target unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class DuploServiceTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class EcacheInstanceLogDeliveryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationType":
            suggest = "destination_type"
        elif key == "logFormat":
            suggest = "log_format"
        elif key == "logType":
            suggest = "log_type"
        elif key == "logGroup":
            suggest = "log_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcacheInstanceLogDeliveryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcacheInstanceLogDeliveryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcacheInstanceLogDeliveryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_type: str,
                 log_format: str,
                 log_type: str,
                 log_group: Optional[str] = None):
        """
        :param str destination_type: destination type : must be cloudwatch-logs.
        :param str log_format: log_format: Value must be one of the ['json', 'text']
        :param str log_type: log_type: Value must be one of the ['slow-log', 'engine-log']
        :param str log_group: cloudwatch log_group
        """
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "log_type", log_type)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> str:
        """
        destination type : must be cloudwatch-logs.
        """
        return pulumi.get(self, "destination_type")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> str:
        """
        log_format: Value must be one of the ['json', 'text']
        """
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> str:
        """
        log_type: Value must be one of the ['slow-log', 'engine-log']
        """
        return pulumi.get(self, "log_type")

    @property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[str]:
        """
        cloudwatch log_group
        """
        return pulumi.get(self, "log_group")


@pulumi.output_type
class EcsServiceCapacityProviderStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityProvider":
            suggest = "capacity_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsServiceCapacityProviderStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsServiceCapacityProviderStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsServiceCapacityProviderStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_provider: str,
                 base: Optional[int] = None,
                 weight: Optional[int] = None):
        """
        :param str capacity_provider: Name of the capacity provider. Should be one of:
                	- FARGATE
                	- FARGATE_SPOT
                	- ASG fullname: Used when asg created with agent platform ECS
        :param int base: The number of tasks, at a minimum, to run on the specified capacity provider.
        :param int weight: The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> str:
        """
        Name of the capacity provider. Should be one of:
         	- FARGATE
         	- FARGATE_SPOT
         	- ASG fullname: Used when asg created with agent platform ECS
        """
        return pulumi.get(self, "capacity_provider")

    @property
    @pulumi.getter
    def base(self) -> Optional[int]:
        """
        The number of tasks, at a minimum, to run on the specified capacity provider.
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class EcsServiceDeploymentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCircuitBreaker":
            suggest = "enable_circuit_breaker"
        elif key == "maximumPercent":
            suggest = "maximum_percent"
        elif key == "minimumHealthyPercent":
            suggest = "minimum_healthy_percent"
        elif key == "rollbackCircuitBreaker":
            suggest = "rollback_circuit_breaker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsServiceDeploymentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsServiceDeploymentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsServiceDeploymentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarms: Optional[Sequence['outputs.EcsServiceDeploymentConfigurationAlarm']] = None,
                 enable_circuit_breaker: Optional[bool] = None,
                 maximum_percent: Optional[int] = None,
                 minimum_healthy_percent: Optional[int] = None,
                 rollback_circuit_breaker: Optional[bool] = None):
        """
        :param bool enable_circuit_breaker: Enables ECS deployment circuit breaker to stop deployments on failures.
        :param int maximum_percent: Specifies the maximum percentage of tasks that can run at once during a deployment.
        :param int minimum_healthy_percent: Specifies the minimum percentage of tasks that must remain in the RUNNING state during a deployment
        :param bool rollback_circuit_breaker: Enables automatic rollback when the circuit breaker detects a failed deployment.
        """
        if alarms is not None:
            pulumi.set(__self__, "alarms", alarms)
        if enable_circuit_breaker is not None:
            pulumi.set(__self__, "enable_circuit_breaker", enable_circuit_breaker)
        if maximum_percent is not None:
            pulumi.set(__self__, "maximum_percent", maximum_percent)
        if minimum_healthy_percent is not None:
            pulumi.set(__self__, "minimum_healthy_percent", minimum_healthy_percent)
        if rollback_circuit_breaker is not None:
            pulumi.set(__self__, "rollback_circuit_breaker", rollback_circuit_breaker)

    @property
    @pulumi.getter
    def alarms(self) -> Optional[Sequence['outputs.EcsServiceDeploymentConfigurationAlarm']]:
        return pulumi.get(self, "alarms")

    @property
    @pulumi.getter(name="enableCircuitBreaker")
    def enable_circuit_breaker(self) -> Optional[bool]:
        """
        Enables ECS deployment circuit breaker to stop deployments on failures.
        """
        return pulumi.get(self, "enable_circuit_breaker")

    @property
    @pulumi.getter(name="maximumPercent")
    def maximum_percent(self) -> Optional[int]:
        """
        Specifies the maximum percentage of tasks that can run at once during a deployment.
        """
        return pulumi.get(self, "maximum_percent")

    @property
    @pulumi.getter(name="minimumHealthyPercent")
    def minimum_healthy_percent(self) -> Optional[int]:
        """
        Specifies the minimum percentage of tasks that must remain in the RUNNING state during a deployment
        """
        return pulumi.get(self, "minimum_healthy_percent")

    @property
    @pulumi.getter(name="rollbackCircuitBreaker")
    def rollback_circuit_breaker(self) -> Optional[bool]:
        """
        Enables automatic rollback when the circuit breaker detects a failed deployment.
        """
        return pulumi.get(self, "rollback_circuit_breaker")


@pulumi.output_type
class EcsServiceDeploymentConfigurationAlarm(dict):
    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 names: Optional[Sequence[str]] = None,
                 rollback: Optional[bool] = None):
        """
        :param bool enable: Enables or disables CloudWatch alarm monitoring during deployments.
        :param Sequence[str] names: Names of CloudWatch alarms that ECS monitors during deployments.
        :param bool rollback: Automatically rolls back the deployment if any configured CloudWatch alarm enters ALARM state.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if names is not None:
            pulumi.set(__self__, "names", names)
        if rollback is not None:
            pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        Enables or disables CloudWatch alarm monitoring during deployments.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[str]]:
        """
        Names of CloudWatch alarms that ECS monitors during deployments.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def rollback(self) -> Optional[bool]:
        """
        Automatically rolls back the deployment if any configured CloudWatch alarm enters ALARM state.
        """
        return pulumi.get(self, "rollback")


@pulumi.output_type
class EcsServiceLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalPort":
            suggest = "external_port"
        elif key == "lbType":
            suggest = "lb_type"
        elif key == "targetGroupCount":
            suggest = "target_group_count"
        elif key == "backendProtocol":
            suggest = "backend_protocol"
        elif key == "backendProtocolVersion":
            suggest = "backend_protocol_version"
        elif key == "certificateArn":
            suggest = "certificate_arn"
        elif key == "dropInvalidHeaders":
            suggest = "drop_invalid_headers"
        elif key == "enableAccessLogs":
            suggest = "enable_access_logs"
        elif key == "healthCheckConfig":
            suggest = "health_check_config"
        elif key == "healthCheckUrl":
            suggest = "health_check_url"
        elif key == "httpToHttpsRedirect":
            suggest = "http_to_https_redirect"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "isInternal":
            suggest = "is_internal"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "loadBalancerName":
            suggest = "load_balancer_name"
        elif key == "replicationControllerName":
            suggest = "replication_controller_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsServiceLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsServiceLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsServiceLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_port: int,
                 lb_type: int,
                 port: str,
                 protocol: str,
                 target_group_count: int,
                 backend_protocol: Optional[str] = None,
                 backend_protocol_version: Optional[str] = None,
                 certificate_arn: Optional[str] = None,
                 drop_invalid_headers: Optional[bool] = None,
                 enable_access_logs: Optional[bool] = None,
                 health_check_config: Optional['outputs.EcsServiceLoadBalancerHealthCheckConfig'] = None,
                 health_check_url: Optional[str] = None,
                 http_to_https_redirect: Optional[bool] = None,
                 idle_timeout: Optional[int] = None,
                 index: Optional[int] = None,
                 is_internal: Optional[bool] = None,
                 load_balancer_arn: Optional[str] = None,
                 load_balancer_name: Optional[str] = None,
                 replication_controller_name: Optional[str] = None,
                 webaclid: Optional[str] = None):
        """
        :param int external_port: The frontend port associated with this load balancer configuration.
        :param int lb_type: The numerical index of the type of load balancer configuration to create.
               Should be one of:
               
                  - `0` : ELB (Classic Load Balancer)
                  - `1` : ALB (Application Load Balancer)
                  - `2` : Health-check Only (No Load Balancer)
        :param str port: The backend port associated with this load balancer configuration.
        :param str protocol: The frontend protocol associated with this load balancer configuration.
        :param int target_group_count: Number of Load Balancer target group to associate with the service.
        :param str backend_protocol: The backend protocol associated with this load balancer configuration.
        :param str backend_protocol_version: The backend protocol version associated with this load balancer configuration.
        :param str certificate_arn: The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        :param bool drop_invalid_headers: Whether or not to drop invalid HTTP headers received by the load balancer.
        :param bool enable_access_logs: Whether or not to enable access logs.  When enabled, Duplo will send access logs to a centralized S3 bucket per plan
        :param 'EcsServiceLoadBalancerHealthCheckConfigArgs' health_check_config: Health check configuration for this load balancer.
        :param str health_check_url: The health check URL to associate with this load balancer configuration.
        :param bool http_to_https_redirect: Whether or not the load balancer should redirect HTTP to HTTPS.
        :param int idle_timeout: The time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`.
        :param int index: The load balancer Index.
        :param bool is_internal: Whether or not to create an internal load balancer.
        :param str load_balancer_arn: The load balancer ARN.
        :param str load_balancer_name: The load balancer name.
        :param str webaclid: The ARN of a web application firewall to associate this load balancer.
        """
        pulumi.set(__self__, "external_port", external_port)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "target_group_count", target_group_count)
        if backend_protocol is not None:
            pulumi.set(__self__, "backend_protocol", backend_protocol)
        if backend_protocol_version is not None:
            pulumi.set(__self__, "backend_protocol_version", backend_protocol_version)
        if certificate_arn is not None:
            pulumi.set(__self__, "certificate_arn", certificate_arn)
        if drop_invalid_headers is not None:
            pulumi.set(__self__, "drop_invalid_headers", drop_invalid_headers)
        if enable_access_logs is not None:
            pulumi.set(__self__, "enable_access_logs", enable_access_logs)
        if health_check_config is not None:
            pulumi.set(__self__, "health_check_config", health_check_config)
        if health_check_url is not None:
            pulumi.set(__self__, "health_check_url", health_check_url)
        if http_to_https_redirect is not None:
            pulumi.set(__self__, "http_to_https_redirect", http_to_https_redirect)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if is_internal is not None:
            pulumi.set(__self__, "is_internal", is_internal)
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if load_balancer_name is not None:
            pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        if replication_controller_name is not None:
            pulumi.set(__self__, "replication_controller_name", replication_controller_name)
        if webaclid is not None:
            pulumi.set(__self__, "webaclid", webaclid)

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> int:
        """
        The frontend port associated with this load balancer configuration.
        """
        return pulumi.get(self, "external_port")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        The numerical index of the type of load balancer configuration to create.
        Should be one of:

           - `0` : ELB (Classic Load Balancer)
           - `1` : ALB (Application Load Balancer)
           - `2` : Health-check Only (No Load Balancer)
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        The backend port associated with this load balancer configuration.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The frontend protocol associated with this load balancer configuration.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetGroupCount")
    def target_group_count(self) -> int:
        """
        Number of Load Balancer target group to associate with the service.
        """
        return pulumi.get(self, "target_group_count")

    @property
    @pulumi.getter(name="backendProtocol")
    @_utilities.deprecated("""Use 'backend_protocol_version' instead.""")
    def backend_protocol(self) -> Optional[str]:
        """
        The backend protocol associated with this load balancer configuration.
        """
        return pulumi.get(self, "backend_protocol")

    @property
    @pulumi.getter(name="backendProtocolVersion")
    def backend_protocol_version(self) -> Optional[str]:
        """
        The backend protocol version associated with this load balancer configuration.
        """
        return pulumi.get(self, "backend_protocol_version")

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> Optional[str]:
        """
        The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter(name="dropInvalidHeaders")
    def drop_invalid_headers(self) -> Optional[bool]:
        """
        Whether or not to drop invalid HTTP headers received by the load balancer.
        """
        return pulumi.get(self, "drop_invalid_headers")

    @property
    @pulumi.getter(name="enableAccessLogs")
    def enable_access_logs(self) -> Optional[bool]:
        """
        Whether or not to enable access logs.  When enabled, Duplo will send access logs to a centralized S3 bucket per plan
        """
        return pulumi.get(self, "enable_access_logs")

    @property
    @pulumi.getter(name="healthCheckConfig")
    def health_check_config(self) -> Optional['outputs.EcsServiceLoadBalancerHealthCheckConfig']:
        """
        Health check configuration for this load balancer.
        """
        return pulumi.get(self, "health_check_config")

    @property
    @pulumi.getter(name="healthCheckUrl")
    def health_check_url(self) -> Optional[str]:
        """
        The health check URL to associate with this load balancer configuration.
        """
        return pulumi.get(self, "health_check_url")

    @property
    @pulumi.getter(name="httpToHttpsRedirect")
    def http_to_https_redirect(self) -> Optional[bool]:
        """
        Whether or not the load balancer should redirect HTTP to HTTPS.
        """
        return pulumi.get(self, "http_to_https_redirect")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[int]:
        """
        The time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        """
        The load balancer Index.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="isInternal")
    def is_internal(self) -> Optional[bool]:
        """
        Whether or not to create an internal load balancer.
        """
        return pulumi.get(self, "is_internal")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[str]:
        """
        The load balancer ARN.
        """
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> Optional[str]:
        """
        The load balancer name.
        """
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter(name="replicationControllerName")
    def replication_controller_name(self) -> Optional[str]:
        return pulumi.get(self, "replication_controller_name")

    @property
    @pulumi.getter
    def webaclid(self) -> Optional[str]:
        """
        The ARN of a web application firewall to associate this load balancer.
        """
        return pulumi.get(self, "webaclid")


@pulumi.output_type
class EcsServiceLoadBalancerHealthCheckConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grpcSuccessCode":
            suggest = "grpc_success_code"
        elif key == "healthCheckIntervalSeconds":
            suggest = "health_check_interval_seconds"
        elif key == "healthCheckTimeoutSeconds":
            suggest = "health_check_timeout_seconds"
        elif key == "healthyThresholdCount":
            suggest = "healthy_threshold_count"
        elif key == "httpSuccessCode":
            suggest = "http_success_code"
        elif key == "unhealthyThresholdCount":
            suggest = "unhealthy_threshold_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsServiceLoadBalancerHealthCheckConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsServiceLoadBalancerHealthCheckConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsServiceLoadBalancerHealthCheckConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc_success_code: Optional[str] = None,
                 health_check_interval_seconds: Optional[int] = None,
                 health_check_timeout_seconds: Optional[int] = None,
                 healthy_threshold_count: Optional[int] = None,
                 http_success_code: Optional[str] = None,
                 unhealthy_threshold_count: Optional[int] = None):
        if grpc_success_code is not None:
            pulumi.set(__self__, "grpc_success_code", grpc_success_code)
        if health_check_interval_seconds is not None:
            pulumi.set(__self__, "health_check_interval_seconds", health_check_interval_seconds)
        if health_check_timeout_seconds is not None:
            pulumi.set(__self__, "health_check_timeout_seconds", health_check_timeout_seconds)
        if healthy_threshold_count is not None:
            pulumi.set(__self__, "healthy_threshold_count", healthy_threshold_count)
        if http_success_code is not None:
            pulumi.set(__self__, "http_success_code", http_success_code)
        if unhealthy_threshold_count is not None:
            pulumi.set(__self__, "unhealthy_threshold_count", unhealthy_threshold_count)

    @property
    @pulumi.getter(name="grpcSuccessCode")
    def grpc_success_code(self) -> Optional[str]:
        return pulumi.get(self, "grpc_success_code")

    @property
    @pulumi.getter(name="healthCheckIntervalSeconds")
    def health_check_interval_seconds(self) -> Optional[int]:
        return pulumi.get(self, "health_check_interval_seconds")

    @property
    @pulumi.getter(name="healthCheckTimeoutSeconds")
    def health_check_timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "health_check_timeout_seconds")

    @property
    @pulumi.getter(name="healthyThresholdCount")
    def healthy_threshold_count(self) -> Optional[int]:
        return pulumi.get(self, "healthy_threshold_count")

    @property
    @pulumi.getter(name="httpSuccessCode")
    def http_success_code(self) -> Optional[str]:
        return pulumi.get(self, "http_success_code")

    @property
    @pulumi.getter(name="unhealthyThresholdCount")
    def unhealthy_threshold_count(self) -> Optional[int]:
        return pulumi.get(self, "unhealthy_threshold_count")


@pulumi.output_type
class EcsServicePlacementConstraint(dict):
    def __init__(__self__, *,
                 type: str,
                 expression: Optional[str] = None):
        """
        :param str type: Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`
        :param str expression: Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class EcsServicePlacementStrategy(dict):
    def __init__(__self__, *,
                 type: str,
                 field: Optional[str] = None):
        """
        :param str type: Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
        :param str field: For the spread placement strategy, valid values are instanceId, or any platform or custom attribute that is applied to a container instance. For the binpack type, valid values are memory and cpu. For the random type, this attribute is not needed. For more information, see [PlacementStrategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html)
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        For the spread placement strategy, valid values are instanceId, or any platform or custom attribute that is applied to a container instance. For the binpack type, valid values are memory and cpu. For the random type, this attribute is not needed. For more information, see [PlacementStrategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html)
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class EcsTaskDefinitionInferenceAccelerator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "deviceType":
            suggest = "device_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsTaskDefinitionInferenceAccelerator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsTaskDefinitionInferenceAccelerator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsTaskDefinitionInferenceAccelerator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 device_type: str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "device_type", device_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> str:
        return pulumi.get(self, "device_type")


@pulumi.output_type
class EcsTaskDefinitionPlacementConstraint(dict):
    def __init__(__self__, *,
                 type: str,
                 expression: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")


@pulumi.output_type
class EcsTaskDefinitionProxyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsTaskDefinitionProxyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsTaskDefinitionProxyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsTaskDefinitionProxyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 properties: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: Defaults to `APPMESH`.
        """
        pulumi.set(__self__, "container_name", container_name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defaults to `APPMESH`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EcsTaskDefinitionRequiresAttribute(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class EcsTaskDefinitionRuntimePlatform(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuArchitecture":
            suggest = "cpu_architecture"
        elif key == "operatingSystemFamily":
            suggest = "operating_system_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EcsTaskDefinitionRuntimePlatform. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EcsTaskDefinitionRuntimePlatform.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EcsTaskDefinitionRuntimePlatform.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_architecture: str,
                 operating_system_family: str):
        """
        :param str cpu_architecture: Valid values are 'X86_64','ARM64'
        :param str operating_system_family: Valid values are \\n\\nFor FARGATE: 'LINUX','WINDOWS*SERVER*2019*FULL','WINDOWS*SERVER*2019*CORE','WINDOWS*SERVER*2022*FULL','WINDOWS*SERVER*2022*CORE'
        """
        pulumi.set(__self__, "cpu_architecture", cpu_architecture)
        pulumi.set(__self__, "operating_system_family", operating_system_family)

    @property
    @pulumi.getter(name="cpuArchitecture")
    def cpu_architecture(self) -> str:
        """
        Valid values are 'X86_64','ARM64'
        """
        return pulumi.get(self, "cpu_architecture")

    @property
    @pulumi.getter(name="operatingSystemFamily")
    def operating_system_family(self) -> str:
        """
        Valid values are \\n\\nFor FARGATE: 'LINUX','WINDOWS*SERVER*2019*FULL','WINDOWS*SERVER*2019*CORE','WINDOWS*SERVER*2022*FULL','WINDOWS*SERVER*2022*CORE'
        """
        return pulumi.get(self, "operating_system_family")


@pulumi.output_type
class EcsTaskDefinitionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GcpCloudFunctionEventTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpCloudFunctionEventTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpCloudFunctionEventTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpCloudFunctionEventTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: str,
                 resource: Optional[str] = None,
                 service: Optional[str] = None):
        """
        :param str event_type: The type of event that will trigger the function
        :param str resource: The resource that will trigger the function
        :param str service: The service that will trigger the function
        """
        pulumi.set(__self__, "event_type", event_type)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        The type of event that will trigger the function
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource that will trigger the function
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The service that will trigger the function
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GcpCloudFunctionHttpsTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityLevel":
            suggest = "security_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpCloudFunctionHttpsTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpCloudFunctionHttpsTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpCloudFunctionHttpsTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 security_level: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool enabled: Must be set to `true`.
        :param str security_level: The security level of the HTTPS trigger
        :param str url: The URL of the HTTPS trigger
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Must be set to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        The security level of the HTTPS trigger
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the HTTPS trigger
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GcpInfraMaintenanceWindowExclusion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpInfraMaintenanceWindowExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpInfraMaintenanceWindowExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpInfraMaintenanceWindowExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 start_time: str,
                 scope: Optional[str] = None):
        """
        :param str scope: The scope of automatic upgrades to restrict in the exclusion window. One of: NO*UPGRADES | NO*MINOR*UPGRADES | NO*MINOR*OR*NODE_UPGRADES Defaults to `NO_UPGRADES`.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The scope of automatic upgrades to restrict in the exclusion window. One of: NO*UPGRADES | NO*MINOR*UPGRADES | NO*MINOR*OR*NODE_UPGRADES Defaults to `NO_UPGRADES`.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GcpInfraMaintenanceWindowRecurringWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpInfraMaintenanceWindowRecurringWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpInfraMaintenanceWindowRecurringWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpInfraMaintenanceWindowRecurringWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 recurrence: str,
                 start_time: str):
        """
        :param str recurrence: Specify recurrence in RFC5545 RRULE format, to specify when this recurs.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "recurrence", recurrence)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def recurrence(self) -> str:
        """
        Specify recurrence in RFC5545 RRULE format, to specify when this recurs.
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GcpInfraSecurityRulePortsAndProtocol(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceProtocol":
            suggest = "service_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpInfraSecurityRulePortsAndProtocol. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpInfraSecurityRulePortsAndProtocol.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpInfraSecurityRulePortsAndProtocol.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_protocol: str,
                 ports: Optional[Sequence[str]] = None):
        """
        :param str service_protocol: The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        :param Sequence[str] ports: The list of ports to which this rule applies. This field is only applicable for UDP, TCP and SCTP protocol. To apply all ports dont specify the field
        """
        pulumi.set(__self__, "service_protocol", service_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="serviceProtocol")
    def service_protocol(self) -> str:
        """
        The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        """
        return pulumi.get(self, "service_protocol")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        The list of ports to which this rule applies. This field is only applicable for UDP, TCP and SCTP protocol. To apply all ports dont specify the field
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class GcpNodePoolAccelerator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorType":
            suggest = "accelerator_type"
        elif key == "gpuDriverInstallationConfigs":
            suggest = "gpu_driver_installation_configs"
        elif key == "gpuPartitionSize":
            suggest = "gpu_partition_size"
        elif key == "gpuSharingConfigs":
            suggest = "gpu_sharing_configs"
        elif key == "maxTimeSharedClientsPerGpu":
            suggest = "max_time_shared_clients_per_gpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpNodePoolAccelerator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpNodePoolAccelerator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpNodePoolAccelerator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional[str] = None,
                 accelerator_type: Optional[str] = None,
                 gpu_driver_installation_configs: Optional[Sequence['outputs.GcpNodePoolAcceleratorGpuDriverInstallationConfig']] = None,
                 gpu_partition_size: Optional[str] = None,
                 gpu_sharing_configs: Optional[Sequence['outputs.GcpNodePoolAcceleratorGpuSharingConfig']] = None,
                 max_time_shared_clients_per_gpu: Optional[str] = None):
        """
        :param str accelerator_count: The number of the accelerator cards exposed to an instance.
        :param str accelerator_type: The accelerator type resource name.
        :param str gpu_partition_size: Size of partitions to create on the GPU
        :param str max_time_shared_clients_per_gpu: The number of time-shared GPU resources to expose for each physical GPU.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_type is not None:
            pulumi.set(__self__, "accelerator_type", accelerator_type)
        if gpu_driver_installation_configs is not None:
            pulumi.set(__self__, "gpu_driver_installation_configs", gpu_driver_installation_configs)
        if gpu_partition_size is not None:
            pulumi.set(__self__, "gpu_partition_size", gpu_partition_size)
        if gpu_sharing_configs is not None:
            pulumi.set(__self__, "gpu_sharing_configs", gpu_sharing_configs)
        if max_time_shared_clients_per_gpu is not None:
            pulumi.set(__self__, "max_time_shared_clients_per_gpu", max_time_shared_clients_per_gpu)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[str]:
        """
        The number of the accelerator cards exposed to an instance.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> Optional[str]:
        """
        The accelerator type resource name.
        """
        return pulumi.get(self, "accelerator_type")

    @property
    @pulumi.getter(name="gpuDriverInstallationConfigs")
    def gpu_driver_installation_configs(self) -> Optional[Sequence['outputs.GcpNodePoolAcceleratorGpuDriverInstallationConfig']]:
        return pulumi.get(self, "gpu_driver_installation_configs")

    @property
    @pulumi.getter(name="gpuPartitionSize")
    def gpu_partition_size(self) -> Optional[str]:
        """
        Size of partitions to create on the GPU
        """
        return pulumi.get(self, "gpu_partition_size")

    @property
    @pulumi.getter(name="gpuSharingConfigs")
    def gpu_sharing_configs(self) -> Optional[Sequence['outputs.GcpNodePoolAcceleratorGpuSharingConfig']]:
        return pulumi.get(self, "gpu_sharing_configs")

    @property
    @pulumi.getter(name="maxTimeSharedClientsPerGpu")
    def max_time_shared_clients_per_gpu(self) -> Optional[str]:
        """
        The number of time-shared GPU resources to expose for each physical GPU.
        """
        return pulumi.get(self, "max_time_shared_clients_per_gpu")


@pulumi.output_type
class GcpNodePoolAcceleratorGpuDriverInstallationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gpuDriverVersion":
            suggest = "gpu_driver_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpNodePoolAcceleratorGpuDriverInstallationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpNodePoolAcceleratorGpuDriverInstallationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpNodePoolAcceleratorGpuDriverInstallationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gpu_driver_version: Optional[str] = None):
        if gpu_driver_version is not None:
            pulumi.set(__self__, "gpu_driver_version", gpu_driver_version)

    @property
    @pulumi.getter(name="gpuDriverVersion")
    def gpu_driver_version(self) -> Optional[str]:
        return pulumi.get(self, "gpu_driver_version")


@pulumi.output_type
class GcpNodePoolAcceleratorGpuSharingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gpuSharingStrategy":
            suggest = "gpu_sharing_strategy"
        elif key == "maxSharedClientsPerGpu":
            suggest = "max_shared_clients_per_gpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpNodePoolAcceleratorGpuSharingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpNodePoolAcceleratorGpuSharingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpNodePoolAcceleratorGpuSharingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gpu_sharing_strategy: Optional[str] = None,
                 max_shared_clients_per_gpu: Optional[str] = None):
        """
        :param str gpu_sharing_strategy: The configuration for GPU sharing options.
        :param str max_shared_clients_per_gpu: The max number of containers that can share a physical GPU.
        """
        if gpu_sharing_strategy is not None:
            pulumi.set(__self__, "gpu_sharing_strategy", gpu_sharing_strategy)
        if max_shared_clients_per_gpu is not None:
            pulumi.set(__self__, "max_shared_clients_per_gpu", max_shared_clients_per_gpu)

    @property
    @pulumi.getter(name="gpuSharingStrategy")
    def gpu_sharing_strategy(self) -> Optional[str]:
        """
        The configuration for GPU sharing options.
        """
        return pulumi.get(self, "gpu_sharing_strategy")

    @property
    @pulumi.getter(name="maxSharedClientsPerGpu")
    def max_shared_clients_per_gpu(self) -> Optional[str]:
        """
        The max number of containers that can share a physical GPU.
        """
        return pulumi.get(self, "max_shared_clients_per_gpu")


@pulumi.output_type
class GcpNodePoolLinuxNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cgroupMode":
            suggest = "cgroup_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpNodePoolLinuxNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpNodePoolLinuxNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpNodePoolLinuxNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cgroup_mode: Optional[str] = None,
                 sysctls: Optional[Mapping[str, str]] = None):
        """
        :param str cgroup_mode: cgroupMode specifies the cgroup mode to be used on the node.
        :param Mapping[str, str] sysctls: The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.
        """
        if cgroup_mode is not None:
            pulumi.set(__self__, "cgroup_mode", cgroup_mode)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter(name="cgroupMode")
    def cgroup_mode(self) -> Optional[str]:
        """
        cgroupMode specifies the cgroup mode to be used on the node.
        """
        return pulumi.get(self, "cgroup_mode")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Mapping[str, str]]:
        """
        The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.
        """
        return pulumi.get(self, "sysctls")


@pulumi.output_type
class GcpNodePoolNodePoolLoggingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "variantConfig":
            suggest = "variant_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpNodePoolNodePoolLoggingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpNodePoolNodePoolLoggingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpNodePoolNodePoolLoggingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 variant_config: Optional[Mapping[str, str]] = None):
        if variant_config is not None:
            pulumi.set(__self__, "variant_config", variant_config)

    @property
    @pulumi.getter(name="variantConfig")
    def variant_config(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "variant_config")


@pulumi.output_type
class GcpNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Update strategy of the node pool. Supported effect's are : 
               	- EFFECT_UNSPECIFIED 
               	- NO_SCHEDULE 
               	- PREFER_NO_SCHEDULE
               	- NO_EXECUTE
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Update strategy of the node pool. Supported effect's are : 
        	- EFFECT_UNSPECIFIED 
        	- NO_SCHEDULE 
        	- PREFER_NO_SCHEDULE
        	- NO_EXECUTE
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GcpNodePoolUpgradeSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blueGreenSettings":
            suggest = "blue_green_settings"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpNodePoolUpgradeSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpNodePoolUpgradeSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpNodePoolUpgradeSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blue_green_settings: Optional[Sequence['outputs.GcpNodePoolUpgradeSettingBlueGreenSetting']] = None,
                 max_surge: Optional[int] = None,
                 max_unavailable: Optional[int] = None,
                 strategy: Optional[str] = None):
        """
        :param int max_surge: The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process.
        :param int max_unavailable: The maximum number of nodes that can be simultaneously unavailable during the upgrade process. A node is considered available if its status is Ready
        :param str strategy: Update strategy of the node pool.
        """
        if blue_green_settings is not None:
            pulumi.set(__self__, "blue_green_settings", blue_green_settings)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="blueGreenSettings")
    def blue_green_settings(self) -> Optional[Sequence['outputs.GcpNodePoolUpgradeSettingBlueGreenSetting']]:
        return pulumi.get(self, "blue_green_settings")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[int]:
        """
        The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process.
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        The maximum number of nodes that can be simultaneously unavailable during the upgrade process. A node is considered available if its status is Ready
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        Update strategy of the node pool.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GcpNodePoolUpgradeSettingBlueGreenSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolSoakDuration":
            suggest = "node_pool_soak_duration"
        elif key == "standardRolloutPolicies":
            suggest = "standard_rollout_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpNodePoolUpgradeSettingBlueGreenSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpNodePoolUpgradeSettingBlueGreenSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpNodePoolUpgradeSettingBlueGreenSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_soak_duration: Optional[str] = None,
                 standard_rollout_policies: Optional[Sequence['outputs.GcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicy']] = None):
        """
        :param str node_pool_soak_duration: Note: The node_pool_soak_duration should not be used along with standard_rollout_policy
        :param Sequence['GcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyArgs'] standard_rollout_policies: Note: The standard_rollout_policy should not be used along with node_pool_soak_duration
        """
        if node_pool_soak_duration is not None:
            pulumi.set(__self__, "node_pool_soak_duration", node_pool_soak_duration)
        if standard_rollout_policies is not None:
            pulumi.set(__self__, "standard_rollout_policies", standard_rollout_policies)

    @property
    @pulumi.getter(name="nodePoolSoakDuration")
    def node_pool_soak_duration(self) -> Optional[str]:
        """
        Note: The node_pool_soak_duration should not be used along with standard_rollout_policy
        """
        return pulumi.get(self, "node_pool_soak_duration")

    @property
    @pulumi.getter(name="standardRolloutPolicies")
    def standard_rollout_policies(self) -> Optional[Sequence['outputs.GcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicy']]:
        """
        Note: The standard_rollout_policy should not be used along with node_pool_soak_duration
        """
        return pulumi.get(self, "standard_rollout_policies")


@pulumi.output_type
class GcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchNodeCount":
            suggest = "batch_node_count"
        elif key == "batchPercentage":
            suggest = "batch_percentage"
        elif key == "batchSoakDuration":
            suggest = "batch_soak_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_node_count: Optional[int] = None,
                 batch_percentage: Optional[float] = None,
                 batch_soak_duration: Optional[str] = None):
        """
        :param int batch_node_count: Note: The batch_node_count should not be used along with batch_percentage
        :param float batch_percentage: Note: The batch_percentage should not be used along with batch_node_count
        """
        if batch_node_count is not None:
            pulumi.set(__self__, "batch_node_count", batch_node_count)
        if batch_percentage is not None:
            pulumi.set(__self__, "batch_percentage", batch_percentage)
        if batch_soak_duration is not None:
            pulumi.set(__self__, "batch_soak_duration", batch_soak_duration)

    @property
    @pulumi.getter(name="batchNodeCount")
    def batch_node_count(self) -> Optional[int]:
        """
        Note: The batch_node_count should not be used along with batch_percentage
        """
        return pulumi.get(self, "batch_node_count")

    @property
    @pulumi.getter(name="batchPercentage")
    def batch_percentage(self) -> Optional[float]:
        """
        Note: The batch_percentage should not be used along with batch_node_count
        """
        return pulumi.get(self, "batch_percentage")

    @property
    @pulumi.getter(name="batchSoakDuration")
    def batch_soak_duration(self) -> Optional[str]:
        return pulumi.get(self, "batch_soak_duration")


@pulumi.output_type
class GcpSchedulerJobAppEngineTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeUri":
            suggest = "relative_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSchedulerJobAppEngineTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSchedulerJobAppEngineTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSchedulerJobAppEngineTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 relative_uri: str,
                 body: Optional[str] = None,
                 headers: Optional[Mapping[str, str]] = None,
                 routing: Optional['outputs.GcpSchedulerJobAppEngineTargetRouting'] = None):
        """
        :param str method: The HTTP method to use.
        :param str relative_uri: The relative URI.
        :param str body: The HTTP request body to send.
        :param Mapping[str, str] headers: The HTTP headers to send.
        :param 'GcpSchedulerJobAppEngineTargetRoutingArgs' routing: Specifies App Engine routing.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "relative_uri", relative_uri)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if routing is not None:
            pulumi.set(__self__, "routing", routing)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="relativeUri")
    def relative_uri(self) -> str:
        """
        The relative URI.
        """
        return pulumi.get(self, "relative_uri")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The HTTP request body to send.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        """
        The HTTP headers to send.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def routing(self) -> Optional['outputs.GcpSchedulerJobAppEngineTargetRouting']:
        """
        Specifies App Engine routing.
        """
        return pulumi.get(self, "routing")


@pulumi.output_type
class GcpSchedulerJobAppEngineTargetRouting(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 instance: Optional[str] = None,
                 service: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str host: The App Engine host.
        :param str instance: The App Engine instance.
        :param str service: The App Engine service.
        :param str version: The App Engine service version.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The App Engine host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        The App Engine instance.
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The App Engine service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The App Engine service version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GcpSchedulerJobHttpTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauthToken":
            suggest = "oauth_token"
        elif key == "oidcToken":
            suggest = "oidc_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSchedulerJobHttpTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSchedulerJobHttpTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSchedulerJobHttpTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: str,
                 uri: str,
                 body: Optional[str] = None,
                 headers: Optional[Mapping[str, str]] = None,
                 oauth_token: Optional['outputs.GcpSchedulerJobHttpTargetOauthToken'] = None,
                 oidc_token: Optional['outputs.GcpSchedulerJobHttpTargetOidcToken'] = None):
        """
        :param str method: The HTTP method to use.
        :param str uri: The request URI.
        :param str body: The HTTP request body to send.
        :param Mapping[str, str] headers: The HTTP headers to send.
        :param 'GcpSchedulerJobHttpTargetOauthTokenArgs' oauth_token: Specifies OAuth authentication.
        :param 'GcpSchedulerJobHttpTargetOidcTokenArgs' oidc_token: Specifies OIDC authentication.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "uri", uri)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if oauth_token is not None:
            pulumi.set(__self__, "oauth_token", oauth_token)
        if oidc_token is not None:
            pulumi.set(__self__, "oidc_token", oidc_token)

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The request URI.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The HTTP request body to send.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        """
        The HTTP headers to send.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="oauthToken")
    def oauth_token(self) -> Optional['outputs.GcpSchedulerJobHttpTargetOauthToken']:
        """
        Specifies OAuth authentication.
        """
        return pulumi.get(self, "oauth_token")

    @property
    @pulumi.getter(name="oidcToken")
    def oidc_token(self) -> Optional['outputs.GcpSchedulerJobHttpTargetOidcToken']:
        """
        Specifies OIDC authentication.
        """
        return pulumi.get(self, "oidc_token")


@pulumi.output_type
class GcpSchedulerJobHttpTargetOauthToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountEmail":
            suggest = "service_account_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSchedulerJobHttpTargetOauthToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSchedulerJobHttpTargetOauthToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSchedulerJobHttpTargetOauthToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 scope: Optional[str] = None,
                 service_account_email: Optional[str] = None):
        """
        :param bool enabled: Must be set to `true`. Defaults to `true`.
        :param str scope: The OAuth token scope.
        :param str service_account_email: The OAuth token service account email.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if service_account_email is not None:
            pulumi.set(__self__, "service_account_email", service_account_email)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Must be set to `true`. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The OAuth token scope.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> Optional[str]:
        """
        The OAuth token service account email.
        """
        return pulumi.get(self, "service_account_email")


@pulumi.output_type
class GcpSchedulerJobHttpTargetOidcToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountEmail":
            suggest = "service_account_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSchedulerJobHttpTargetOidcToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSchedulerJobHttpTargetOidcToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSchedulerJobHttpTargetOidcToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audience: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 service_account_email: Optional[str] = None):
        """
        :param str audience: The OIDC token audience.
        :param bool enabled: Must be set to `true`. Defaults to `true`.
        :param str service_account_email: The OIDC token service account email.
        """
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if service_account_email is not None:
            pulumi.set(__self__, "service_account_email", service_account_email)

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        The OIDC token audience.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Must be set to `true`. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> Optional[str]:
        """
        The OIDC token service account email.
        """
        return pulumi.get(self, "service_account_email")


@pulumi.output_type
class GcpSchedulerJobPubsubTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicName":
            suggest = "topic_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSchedulerJobPubsubTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSchedulerJobPubsubTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSchedulerJobPubsubTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_name: str,
                 attributes: Optional[Mapping[str, str]] = None,
                 data: Optional[str] = None):
        """
        :param str topic_name: The name of the topic to target
        :param Mapping[str, str] attributes: The attributes to send to the pubsub target.
        :param str data: The data to send to the pubsub topic.
        """
        pulumi.set(__self__, "topic_name", topic_name)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if data is not None:
            pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> str:
        """
        The name of the topic to target
        """
        return pulumi.get(self, "topic_name")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        The attributes to send to the pubsub target.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        The data to send to the pubsub topic.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class GcpSqlDatabaseInstanceDatabaseFlag(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the database flag.
        :param str value: The value of the database flag.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the database flag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the database flag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GcpStorageBucketV2DefaultEncryption(dict):
    def __init__(__self__, *,
                 method: Optional[str] = None):
        """
        :param str method: Default encryption method.  Must be one of: `None`, `Sse`, `AwsKms`, `TenantKms`. Defaults to `Sse`.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Default encryption method.  Must be one of: `None`, `Sse`, `AwsKms`, `TenantKms`. Defaults to `Sse`.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class GcpTenantSecurityRulePortsAndProtocol(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceProtocol":
            suggest = "service_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpTenantSecurityRulePortsAndProtocol. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpTenantSecurityRulePortsAndProtocol.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpTenantSecurityRulePortsAndProtocol.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_protocol: str,
                 ports: Optional[Sequence[str]] = None):
        """
        :param str service_protocol: The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        :param Sequence[str] ports: The list of ports to which this rule applies. This field is only applicable for UDP, TCP and SCTP protocol. To apply all ports dont specify the field
        """
        pulumi.set(__self__, "service_protocol", service_protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="serviceProtocol")
    def service_protocol(self) -> str:
        """
        The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, sctp, ipip, all), or the IP protocol number.
        """
        return pulumi.get(self, "service_protocol")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        The list of ports to which this rule applies. This field is only applicable for UDP, TCP and SCTP protocol. To apply all ports dont specify the field
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class InfrastructureAllSetting(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InfrastructureCustomData(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InfrastructureOnpremCustomData(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InfrastructureOnpremEksConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingressSecurityGroupIds":
            suggest = "ingress_security_group_ids"
        elif key == "privateSubnets":
            suggest = "private_subnets"
        elif key == "publicSubnets":
            suggest = "public_subnets"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructureOnpremEksConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructureOnpremEksConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructureOnpremEksConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingress_security_group_ids: Sequence[str],
                 private_subnets: Sequence[str],
                 public_subnets: Sequence[str],
                 vpc_id: str):
        """
        :param Sequence[str] ingress_security_group_ids: The security group IDs
        :param Sequence[str] private_subnets: The private subnets for the VPC.
        :param Sequence[str] public_subnets: The public subnets for the VPC.
        :param str vpc_id: The the ID of a Virtual Private Cloud
        """
        pulumi.set(__self__, "ingress_security_group_ids", ingress_security_group_ids)
        pulumi.set(__self__, "private_subnets", private_subnets)
        pulumi.set(__self__, "public_subnets", public_subnets)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="ingressSecurityGroupIds")
    def ingress_security_group_ids(self) -> Sequence[str]:
        """
        The security group IDs
        """
        return pulumi.get(self, "ingress_security_group_ids")

    @property
    @pulumi.getter(name="privateSubnets")
    def private_subnets(self) -> Sequence[str]:
        """
        The private subnets for the VPC.
        """
        return pulumi.get(self, "private_subnets")

    @property
    @pulumi.getter(name="publicSubnets")
    def public_subnets(self) -> Sequence[str]:
        """
        The public subnets for the VPC.
        """
        return pulumi.get(self, "public_subnets")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The the ID of a Virtual Private Cloud
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class InfrastructurePrivateSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructurePrivateSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructurePrivateSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructurePrivateSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.InfrastructurePrivateSubnetTag']] = None,
                 type: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str cidr_block: The subnet CIDR block.
        :param str id: The subnet ID.
        :param str name: The subnet name.
        :param Sequence['InfrastructurePrivateSubnetTagArgs'] tags: The subnet's tags.
        :param str type: The type of subnet.  Will be one of: `"public"` or `"private"`.
        :param str zone: The Duplo zone that the subnet resides in.  Will be one of:  `"A"`, `"B"`, `"C"`, or `"D"`
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The subnet CIDR block.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The subnet name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.InfrastructurePrivateSubnetTag']]:
        """
        The subnet's tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of subnet.  Will be one of: `"public"` or `"private"`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The Duplo zone that the subnet resides in.  Will be one of:  `"A"`, `"B"`, `"C"`, or `"D"`
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class InfrastructurePrivateSubnetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InfrastructurePublicSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructurePublicSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructurePublicSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructurePublicSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.InfrastructurePublicSubnetTag']] = None,
                 type: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str cidr_block: The subnet CIDR block.
        :param str id: The subnet ID.
        :param str name: The subnet name.
        :param Sequence['InfrastructurePublicSubnetTagArgs'] tags: The subnet's tags.
        :param str type: The type of subnet.  Will be one of: `"public"` or `"private"`.
        :param str zone: The Duplo zone that the subnet resides in.  Will be one of:  `"A"`, `"B"`, `"C"`, or `"D"`
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[str]:
        """
        The subnet CIDR block.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The subnet name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.InfrastructurePublicSubnetTag']]:
        """
        The subnet's tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of subnet.  Will be one of: `"public"` or `"private"`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The Duplo zone that the subnet resides in.  Will be one of:  `"A"`, `"B"`, `"C"`, or `"D"`
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class InfrastructurePublicSubnetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InfrastructureSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructureSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructureSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructureSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 rules: Optional[Sequence['outputs.InfrastructureSecurityGroupRule']] = None,
                 type: Optional[str] = None):
        """
        :param str id: The security group ID.
        :param str name: The security group name.
        :param Sequence['InfrastructureSecurityGroupRuleArgs'] rules: Security group rules
        :param str type: The type of security group.  Will be one of: `"host"` or `"lb"`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The security group ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The security group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.InfrastructureSecurityGroupRule']]:
        """
        Security group rules
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of security group.  Will be one of: `"host"` or `"lb"`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InfrastructureSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRuleType":
            suggest = "destination_rule_type"
        elif key == "sourceAddressPrefix":
            suggest = "source_address_prefix"
        elif key == "sourcePortRange":
            suggest = "source_port_range"
        elif key == "sourceRuleType":
            suggest = "source_rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructureSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructureSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructureSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 destination_rule_type: Optional[int] = None,
                 direction: Optional[str] = None,
                 priority: Optional[int] = None,
                 protocol: Optional[str] = None,
                 source_address_prefix: Optional[str] = None,
                 source_port_range: Optional[str] = None,
                 source_rule_type: Optional[int] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if destination_rule_type is not None:
            pulumi.set(__self__, "destination_rule_type", destination_rule_type)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_address_prefix is not None:
            pulumi.set(__self__, "source_address_prefix", source_address_prefix)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)
        if source_rule_type is not None:
            pulumi.set(__self__, "source_rule_type", source_rule_type)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="destinationRuleType")
    def destination_rule_type(self) -> Optional[int]:
        return pulumi.get(self, "destination_rule_type")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddressPrefix")
    def source_address_prefix(self) -> Optional[str]:
        return pulumi.get(self, "source_address_prefix")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[str]:
        return pulumi.get(self, "source_port_range")

    @property
    @pulumi.getter(name="sourceRuleType")
    def source_rule_type(self) -> Optional[int]:
        return pulumi.get(self, "source_rule_type")


@pulumi.output_type
class InfrastructureSetting(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InfrastructureSettingCustomData(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InfrastructureSettingSetting(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class K8HelmReleaseChart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceName":
            suggest = "source_name"
        elif key == "reconcileStrategy":
            suggest = "reconcile_strategy"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8HelmReleaseChart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8HelmReleaseChart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8HelmReleaseChart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 source_name: str,
                 version: str,
                 interval: Optional[str] = None,
                 reconcile_strategy: Optional[str] = None,
                 source_type: Optional[str] = None):
        """
        :param str name: Provide unique name for the helm chart.
        :param str source_name: The name of the source, referred from helm repository resource.
        :param str version: The helm chart version
        :param str interval: The interval associated to helm chart Defaults to `5m0s`.
        :param str reconcile_strategy: The reconcile strategy should be chosen from ChartVersion or Revision. No new chart artifact is produced on updates to the source unless the version is changed in HelmRepository. Use `Revision` to produce new chart artifact on change in source revision. Defaults to `ChartVersion`.
        :param str source_type: The helm chart source, currently only HelmRepository as source is supported Defaults to `HelmRepository`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_name", source_name)
        pulumi.set(__self__, "version", version)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if reconcile_strategy is not None:
            pulumi.set(__self__, "reconcile_strategy", reconcile_strategy)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Provide unique name for the helm chart.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        The name of the source, referred from helm repository resource.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The helm chart version
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        The interval associated to helm chart Defaults to `5m0s`.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="reconcileStrategy")
    def reconcile_strategy(self) -> Optional[str]:
        """
        The reconcile strategy should be chosen from ChartVersion or Revision. No new chart artifact is produced on updates to the source unless the version is changed in HelmRepository. Use `Revision` to produce new chart artifact on change in source revision. Defaults to `ChartVersion`.
        """
        return pulumi.get(self, "reconcile_strategy")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[str]:
        """
        The helm chart source, currently only HelmRepository as source is supported Defaults to `HelmRepository`.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class K8IngressLbconfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsPrefix":
            suggest = "dns_prefix"
        elif key == "isInternal":
            suggest = "is_internal"
        elif key == "certificateArn":
            suggest = "certificate_arn"
        elif key == "certificateArns":
            suggest = "certificate_arns"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "portOverride":
            suggest = "port_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8IngressLbconfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8IngressLbconfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8IngressLbconfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_prefix: str,
                 is_internal: bool,
                 certificate_arn: Optional[str] = None,
                 certificate_arns: Optional[Sequence[str]] = None,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 port_override: Optional[str] = None):
        """
        :param str dns_prefix: The DNS prefix to expose services using Route53 domain.
        :param bool is_internal: Whether or not to create an internal load balancer.
        :param str certificate_arn: The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS. This field has been deprecated use certificate_arns
        :param Sequence[str] certificate_arns: The list of ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        :param int http_port: HTTP Listener Port.
        :param int https_port: HTTPS Listener Port.
        :param str port_override: Port override for the load balancer. Currently supported for Azure
        """
        pulumi.set(__self__, "dns_prefix", dns_prefix)
        pulumi.set(__self__, "is_internal", is_internal)
        if certificate_arn is not None:
            pulumi.set(__self__, "certificate_arn", certificate_arn)
        if certificate_arns is not None:
            pulumi.set(__self__, "certificate_arns", certificate_arns)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if port_override is not None:
            pulumi.set(__self__, "port_override", port_override)

    @property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> str:
        """
        The DNS prefix to expose services using Route53 domain.
        """
        return pulumi.get(self, "dns_prefix")

    @property
    @pulumi.getter(name="isInternal")
    def is_internal(self) -> bool:
        """
        Whether or not to create an internal load balancer.
        """
        return pulumi.get(self, "is_internal")

    @property
    @pulumi.getter(name="certificateArn")
    @_utilities.deprecated("""This field has been deprecated use certificate_arns""")
    def certificate_arn(self) -> Optional[str]:
        """
        The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS. This field has been deprecated use certificate_arns
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter(name="certificateArns")
    def certificate_arns(self) -> Optional[Sequence[str]]:
        """
        The list of ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        """
        return pulumi.get(self, "certificate_arns")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        HTTP Listener Port.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        HTTPS Listener Port.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="portOverride")
    def port_override(self) -> Optional[str]:
        """
        Port override for the load balancer. Currently supported for Azure
        """
        return pulumi.get(self, "port_override")


@pulumi.output_type
class K8IngressRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathType":
            suggest = "path_type"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "portName":
            suggest = "port_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8IngressRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8IngressRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8IngressRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 path_type: str,
                 service_name: str,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 port_name: Optional[str] = None):
        """
        :param str path: Specify the path (for e.g. /api /v1/api/) to do a path base routing. If host is specified then both path and host should be match for the incoming request.
        :param str path_type: Type of the path to be used.
        :param str service_name: Name of the kubernetes service which Ingress will use as backend to serve the request.
        :param str host: If a host is provided (for e.g. example, foo.bar.com), the rules apply to that host.
        :param int port: Port from the kubernetes service that ingress will use as backend port to serve the requests.
        :param str port_name: Port name from the kubernetes service that ingress will use as backend port to serve the requests.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "path_type", path_type)
        pulumi.set(__self__, "service_name", service_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Specify the path (for e.g. /api /v1/api/) to do a path base routing. If host is specified then both path and host should be match for the incoming request.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="pathType")
    def path_type(self) -> str:
        """
        Type of the path to be used.
        """
        return pulumi.get(self, "path_type")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Name of the kubernetes service which Ingress will use as backend to serve the request.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        If a host is provided (for e.g. example, foo.bar.com), the rules apply to that host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port from the kubernetes service that ingress will use as backend port to serve the requests.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Port name from the kubernetes service that ingress will use as backend port to serve the requests.
        """
        return pulumi.get(self, "port_name")


@pulumi.output_type
class K8IngressTl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8IngressTl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8IngressTl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8IngressTl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[str],
                 secret_name: str):
        """
        :param Sequence[str] hosts: The list of hosts included in the TLS certificate. Each value in this list must match the name(s) specified in the TLS secret. If not specified, it defaults to the wildcard host setting for the load balancer controller managing this Ingress.
        :param str secret_name: The name of the secret used to terminate TLS traffic on port 443. This field is optional, enabling TLS routing based solely on the SNI hostname. If the SNI host in a listener conflicts with the 'Host' header in an IngressRule, the SNI host is used for termination, while the 'Host' header value is used for routing.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def hosts(self) -> Sequence[str]:
        """
        The list of hosts included in the TLS certificate. Each value in this list must match the name(s) specified in the TLS secret. If not specified, it defaults to the wildcard host setting for the load balancer controller managing this Ingress.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the secret used to terminate TLS traffic on port 443. This field is optional, enabling TLS routing based solely on the SNI hostname. If the SNI host in a listener conflicts with the 'Host' header in an IngressRule, the SNI host is used for termination, while the 'Host' header value is used for routing.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class K8PersistentVolumeClaimSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessModes":
            suggest = "access_modes"
        elif key == "storageClassName":
            suggest = "storage_class_name"
        elif key == "volumeMode":
            suggest = "volume_mode"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8PersistentVolumeClaimSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8PersistentVolumeClaimSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8PersistentVolumeClaimSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_modes: Sequence[str],
                 resources: 'outputs.K8PersistentVolumeClaimSpecResources',
                 storage_class_name: Optional[str] = None,
                 volume_mode: Optional[str] = None,
                 volume_name: Optional[str] = None):
        """
        :param Sequence[str] access_modes: A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        :param 'K8PersistentVolumeClaimSpecResourcesArgs' resources: A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        :param str storage_class_name: Name of the storage class requested by the claim
        :param str volume_mode: Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        :param str volume_name: The binding reference to the PersistentVolume backing this claim.
        """
        pulumi.set(__self__, "access_modes", access_modes)
        pulumi.set(__self__, "resources", resources)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Sequence[str]:
        """
        A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.K8PersistentVolumeClaimSpecResources':
        """
        A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[str]:
        """
        Name of the storage class requested by the claim
        """
        return pulumi.get(self, "storage_class_name")

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[str]:
        """
        Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        """
        return pulumi.get(self, "volume_mode")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[str]:
        """
        The binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class K8PersistentVolumeClaimSpecResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] limits: Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        :param Mapping[str, str] requests: Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class K8SecretProviderClassSecretObject(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 annotations: Optional[Mapping[str, str]] = None,
                 datas: Optional[Sequence['outputs.K8SecretProviderClassSecretObjectData']] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        :param str name: Name of the secret object.
        :param str type: Type of the secret object.
        :param Mapping[str, str] annotations: An unstructured key value map stored with the secret object that may be used to store arbitrary metadata.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the service.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if datas is not None:
            pulumi.set(__self__, "datas", datas)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the secret object.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the secret object.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the secret object that may be used to store arbitrary metadata.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def datas(self) -> Optional[Sequence['outputs.K8SecretProviderClassSecretObjectData']]:
        return pulumi.get(self, "datas")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the service.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class K8SecretProviderClassSecretObjectData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectName":
            suggest = "object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8SecretProviderClassSecretObjectData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8SecretProviderClassSecretObjectData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8SecretProviderClassSecretObjectData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 object_name: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "object_name", object_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="objectName")
    def object_name(self) -> str:
        return pulumi.get(self, "object_name")


@pulumi.output_type
class K8StorageClassAllowedTopologies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchLabelExpressions":
            suggest = "match_label_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8StorageClassAllowedTopologies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8StorageClassAllowedTopologies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8StorageClassAllowedTopologies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_label_expressions: Optional[Sequence['outputs.K8StorageClassAllowedTopologiesMatchLabelExpression']] = None):
        """
        :param Sequence['K8StorageClassAllowedTopologiesMatchLabelExpressionArgs'] match_label_expressions: A list of topology selector requirements by labels.
        """
        if match_label_expressions is not None:
            pulumi.set(__self__, "match_label_expressions", match_label_expressions)

    @property
    @pulumi.getter(name="matchLabelExpressions")
    def match_label_expressions(self) -> Optional[Sequence['outputs.K8StorageClassAllowedTopologiesMatchLabelExpression']]:
        """
        A list of topology selector requirements by labels.
        """
        return pulumi.get(self, "match_label_expressions")


@pulumi.output_type
class K8StorageClassAllowedTopologiesMatchLabelExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param Sequence[str] values: An array of string values. One value must match the label to be selected.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. One value must match the label to be selected.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generateName":
            suggest = "generate_name"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 generate_name: Optional[str] = None,
                 generation: Optional[int] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the cronjob that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the cronjob. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the cronjob, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace defines the space within which name of the cronjob must be unique.
        :param str resource_version: An opaque value that represents the internal version of this cronjob that can be used by clients to determine when cronjob has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this cronjob. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)
        if generation is not None:
            pulumi.set(__self__, "generation", generation)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the cronjob that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")

    @property
    @pulumi.getter
    def generation(self) -> Optional[int]:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the cronjob. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cronjob, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace defines the space within which name of the cronjob must be unique.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        An opaque value that represents the internal version of this cronjob that can be used by clients to determine when cronjob has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The unique in time and space value for this cronjob. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class K8sCronJobSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobTemplate":
            suggest = "job_template"
        elif key == "concurrencyPolicy":
            suggest = "concurrency_policy"
        elif key == "failedJobsHistoryLimit":
            suggest = "failed_jobs_history_limit"
        elif key == "startingDeadlineSeconds":
            suggest = "starting_deadline_seconds"
        elif key == "successfulJobsHistoryLimit":
            suggest = "successful_jobs_history_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_template: 'outputs.K8sCronJobSpecJobTemplate',
                 schedule: str,
                 concurrency_policy: Optional[str] = None,
                 failed_jobs_history_limit: Optional[int] = None,
                 starting_deadline_seconds: Optional[int] = None,
                 successful_jobs_history_limit: Optional[int] = None,
                 suspend: Optional[bool] = None):
        """
        :param 'K8sCronJobSpecJobTemplateArgs' job_template: Describes the pod that will be created when executing a cron job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param str schedule: Cron format string, e.g. 0 * * * * or @hourly, as schedule time of its jobs to be created and executed.
        :param str concurrency_policy: Specifies how to treat concurrent executions of a Job. Defaults to Allow. Defaults to `Allow`.
        :param int failed_jobs_history_limit: The number of failed finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1. Defaults to `1`.
        :param int starting_deadline_seconds: Optional deadline in seconds for starting the job if it misses scheduled time for any reason. Missed jobs executions will be counted as failed ones. Defaults to `0`.
        :param int successful_jobs_history_limit: The number of successful finished jobs to retain. Defaults to 3. Defaults to `3`.
        :param bool suspend: This flag tells the controller to suspend subsequent executions, it does not apply to already started executions. Defaults to false. Defaults to `false`.
        """
        pulumi.set(__self__, "job_template", job_template)
        pulumi.set(__self__, "schedule", schedule)
        if concurrency_policy is not None:
            pulumi.set(__self__, "concurrency_policy", concurrency_policy)
        if failed_jobs_history_limit is not None:
            pulumi.set(__self__, "failed_jobs_history_limit", failed_jobs_history_limit)
        if starting_deadline_seconds is not None:
            pulumi.set(__self__, "starting_deadline_seconds", starting_deadline_seconds)
        if successful_jobs_history_limit is not None:
            pulumi.set(__self__, "successful_jobs_history_limit", successful_jobs_history_limit)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter(name="jobTemplate")
    def job_template(self) -> 'outputs.K8sCronJobSpecJobTemplate':
        """
        Describes the pod that will be created when executing a cron job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "job_template")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        Cron format string, e.g. 0 * * * * or @hourly, as schedule time of its jobs to be created and executed.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="concurrencyPolicy")
    def concurrency_policy(self) -> Optional[str]:
        """
        Specifies how to treat concurrent executions of a Job. Defaults to Allow. Defaults to `Allow`.
        """
        return pulumi.get(self, "concurrency_policy")

    @property
    @pulumi.getter(name="failedJobsHistoryLimit")
    def failed_jobs_history_limit(self) -> Optional[int]:
        """
        The number of failed finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1. Defaults to `1`.
        """
        return pulumi.get(self, "failed_jobs_history_limit")

    @property
    @pulumi.getter(name="startingDeadlineSeconds")
    def starting_deadline_seconds(self) -> Optional[int]:
        """
        Optional deadline in seconds for starting the job if it misses scheduled time for any reason. Missed jobs executions will be counted as failed ones. Defaults to `0`.
        """
        return pulumi.get(self, "starting_deadline_seconds")

    @property
    @pulumi.getter(name="successfulJobsHistoryLimit")
    def successful_jobs_history_limit(self) -> Optional[int]:
        """
        The number of successful finished jobs to retain. Defaults to 3. Defaults to `3`.
        """
        return pulumi.get(self, "successful_jobs_history_limit")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        """
        This flag tells the controller to suspend subsequent executions, it does not apply to already started executions. Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "suspend")


@pulumi.output_type
class K8sCronJobSpecJobTemplate(dict):
    def __init__(__self__, *,
                 spec: 'outputs.K8sCronJobSpecJobTemplateSpec',
                 metadata: Optional['outputs.K8sCronJobSpecJobTemplateMetadata'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecArgs' spec: Specification of the desired behavior of the job
        :param 'K8sCronJobSpecJobTemplateMetadataArgs' metadata: Standard jobTemplateSpec's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        pulumi.set(__self__, "spec", spec)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.K8sCronJobSpecJobTemplateSpec':
        """
        Specification of the desired behavior of the job
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.K8sCronJobSpecJobTemplateMetadata']:
        """
        Standard jobTemplateSpec's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class K8sCronJobSpecJobTemplateMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generateName":
            suggest = "generate_name"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 generate_name: Optional[str] = None,
                 generation: Optional[int] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the jobTemplateSpec that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the jobTemplateSpec. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the jobTemplateSpec, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str resource_version: An opaque value that represents the internal version of this jobTemplateSpec that can be used by clients to determine when jobTemplateSpec has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this jobTemplateSpec. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)
        if generation is not None:
            pulumi.set(__self__, "generation", generation)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the jobTemplateSpec that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")

    @property
    @pulumi.getter
    def generation(self) -> Optional[int]:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the jobTemplateSpec. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the jobTemplateSpec, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        An opaque value that represents the internal version of this jobTemplateSpec that can be used by clients to determine when jobTemplateSpec has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The unique in time and space value for this jobTemplateSpec. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDeadlineSeconds":
            suggest = "active_deadline_seconds"
        elif key == "backoffLimit":
            suggest = "backoff_limit"
        elif key == "completionMode":
            suggest = "completion_mode"
        elif key == "manualSelector":
            suggest = "manual_selector"
        elif key == "ttlSecondsAfterFinished":
            suggest = "ttl_seconds_after_finished"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: 'outputs.K8sCronJobSpecJobTemplateSpecTemplate',
                 active_deadline_seconds: Optional[int] = None,
                 backoff_limit: Optional[int] = None,
                 completion_mode: Optional[str] = None,
                 completions: Optional[int] = None,
                 manual_selector: Optional[bool] = None,
                 parallelism: Optional[int] = None,
                 selector: Optional['outputs.K8sCronJobSpecJobTemplateSpecSelector'] = None,
                 ttl_seconds_after_finished: Optional[str] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateArgs' template: Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param int active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        :param int backoff_limit: Specifies the number of retries before marking this job failed. Defaults to 6 Defaults to `6`.
        :param str completion_mode: Specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#completion-mode
        :param int completions: Specifies the desired number of successfully finished pods the job should be run with. Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ Defaults to `1`.
        :param bool manual_selector: Controls generation of pod labels and pod selectors. Leave unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. More info: https://git.k8s.io/community/contributors/design-proposals/selector-generation.md
        :param int parallelism: Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ Defaults to `1`.
        :param 'K8sCronJobSpecJobTemplateSpecSelectorArgs' selector: A label query over volumes to consider for binding.
        :param str ttl_seconds_after_finished: ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.
        """
        pulumi.set(__self__, "template", template)
        if active_deadline_seconds is not None:
            pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        if backoff_limit is not None:
            pulumi.set(__self__, "backoff_limit", backoff_limit)
        if completion_mode is not None:
            pulumi.set(__self__, "completion_mode", completion_mode)
        if completions is not None:
            pulumi.set(__self__, "completions", completions)
        if manual_selector is not None:
            pulumi.set(__self__, "manual_selector", manual_selector)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if ttl_seconds_after_finished is not None:
            pulumi.set(__self__, "ttl_seconds_after_finished", ttl_seconds_after_finished)

    @property
    @pulumi.getter
    def template(self) -> 'outputs.K8sCronJobSpecJobTemplateSpecTemplate':
        """
        Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[int]:
        """
        Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="backoffLimit")
    def backoff_limit(self) -> Optional[int]:
        """
        Specifies the number of retries before marking this job failed. Defaults to 6 Defaults to `6`.
        """
        return pulumi.get(self, "backoff_limit")

    @property
    @pulumi.getter(name="completionMode")
    def completion_mode(self) -> Optional[str]:
        """
        Specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#completion-mode
        """
        return pulumi.get(self, "completion_mode")

    @property
    @pulumi.getter
    def completions(self) -> Optional[int]:
        """
        Specifies the desired number of successfully finished pods the job should be run with. Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ Defaults to `1`.
        """
        return pulumi.get(self, "completions")

    @property
    @pulumi.getter(name="manualSelector")
    def manual_selector(self) -> Optional[bool]:
        """
        Controls generation of pod labels and pod selectors. Leave unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. More info: https://git.k8s.io/community/contributors/design-proposals/selector-generation.md
        """
        return pulumi.get(self, "manual_selector")

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ Defaults to `1`.
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecSelector']:
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="ttlSecondsAfterFinished")
    def ttl_seconds_after_finished(self) -> Optional[str]:
        """
        ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.
        """
        return pulumi.get(self, "ttl_seconds_after_finished")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplate(dict):
    def __init__(__self__, *,
                 metadata: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateMetadata'] = None,
                 spec: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpec'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateMetadataArgs' metadata: Standard job's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecArgs' spec: Spec of the pods owned by the job
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateMetadata']:
        """
        Standard job's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpec']:
        """
        Spec of the pods owned by the job
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generateName":
            suggest = "generate_name"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 generate_name: Optional[str] = None,
                 generation: Optional[int] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str resource_version: An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)
        if generation is not None:
            pulumi.set(__self__, "generation", generation)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")

    @property
    @pulumi.getter
    def generation(self) -> Optional[int]:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDeadlineSeconds":
            suggest = "active_deadline_seconds"
        elif key == "automountServiceAccountToken":
            suggest = "automount_service_account_token"
        elif key == "dnsConfig":
            suggest = "dns_config"
        elif key == "dnsPolicy":
            suggest = "dns_policy"
        elif key == "enableServiceLinks":
            suggest = "enable_service_links"
        elif key == "hostAliases":
            suggest = "host_aliases"
        elif key == "hostIpc":
            suggest = "host_ipc"
        elif key == "hostNetwork":
            suggest = "host_network"
        elif key == "hostPid":
            suggest = "host_pid"
        elif key == "imagePullSecrets":
            suggest = "image_pull_secrets"
        elif key == "initContainers":
            suggest = "init_containers"
        elif key == "nodeName":
            suggest = "node_name"
        elif key == "nodeSelector":
            suggest = "node_selector"
        elif key == "priorityClassName":
            suggest = "priority_class_name"
        elif key == "readinessGates":
            suggest = "readiness_gates"
        elif key == "restartPolicy":
            suggest = "restart_policy"
        elif key == "runtimeClassName":
            suggest = "runtime_class_name"
        elif key == "schedulerName":
            suggest = "scheduler_name"
        elif key == "securityContext":
            suggest = "security_context"
        elif key == "serviceAccountName":
            suggest = "service_account_name"
        elif key == "shareProcessNamespace":
            suggest = "share_process_namespace"
        elif key == "terminationGracePeriodSeconds":
            suggest = "termination_grace_period_seconds"
        elif key == "topologySpreadConstraints":
            suggest = "topology_spread_constraints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_deadline_seconds: Optional[int] = None,
                 affinity: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinity'] = None,
                 automount_service_account_token: Optional[bool] = None,
                 containers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainer']] = None,
                 dns_config: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfig'] = None,
                 dns_policy: Optional[str] = None,
                 enable_service_links: Optional[bool] = None,
                 host_aliases: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecHostAlias']] = None,
                 host_ipc: Optional[bool] = None,
                 host_network: Optional[bool] = None,
                 host_pid: Optional[bool] = None,
                 hostname: Optional[str] = None,
                 image_pull_secrets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecret']] = None,
                 init_containers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainer']] = None,
                 node_name: Optional[str] = None,
                 node_selector: Optional[Mapping[str, str]] = None,
                 priority_class_name: Optional[str] = None,
                 readiness_gates: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGate']] = None,
                 restart_policy: Optional[str] = None,
                 runtime_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContext'] = None,
                 service_account_name: Optional[str] = None,
                 share_process_namespace: Optional[bool] = None,
                 subdomain: Optional[str] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecToleration']] = None,
                 topology_spread_constraints: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraint']] = None,
                 volumes: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolume']] = None):
        """
        :param int active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityArgs' affinity: Optional pod scheduling constraints.
        :param bool automount_service_account_token: AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. Defaults to `true`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerArgs'] containers: List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigArgs' dns_config: Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
        :param str dns_policy: Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Defaults to 'ClusterFirst'. More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
        :param bool enable_service_links: Enables generating environment variables for service discovery. Defaults to true. Defaults to `true`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecHostAliasArgs'] host_aliases: List of hosts and IPs that will be injected into the pod's hosts file if specified. Optional: Defaults to empty.
        :param bool host_ipc: Use the host's ipc namespace. Optional: Defaults to false.
        :param bool host_network: Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified.
        :param bool host_pid: Use the host's pid namespace.
        :param str hostname: Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecretArgs'] image_pull_secrets: ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerArgs'] init_containers: List of init containers belonging to the pod. Init containers always run to completion and each must complete successfully before the next is started. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        :param str node_name: NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        :param Mapping[str, str] node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        :param str priority_class_name: If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGateArgs'] readiness_gates: If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        :param str restart_policy: Restart policy for all containers within the pod. One of OnFailure, Never. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy. Defaults to `Never`.
        :param str runtime_class_name: RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
        :param str scheduler_name: If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextArgs' security_context: SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty
        :param str service_account_name: ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.
        :param bool share_process_namespace: Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false. Defaults to `false`.
        :param str subdomain: If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..
        :param int termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecTolerationArgs'] tolerations: If specified, the pod's toleration. Optional: Defaults to empty
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintArgs'] topology_spread_constraints: describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeArgs'] volumes: List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
        """
        if active_deadline_seconds is not None:
            pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if automount_service_account_token is not None:
            pulumi.set(__self__, "automount_service_account_token", automount_service_account_token)
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if dns_config is not None:
            pulumi.set(__self__, "dns_config", dns_config)
        if dns_policy is not None:
            pulumi.set(__self__, "dns_policy", dns_policy)
        if enable_service_links is not None:
            pulumi.set(__self__, "enable_service_links", enable_service_links)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if host_ipc is not None:
            pulumi.set(__self__, "host_ipc", host_ipc)
        if host_network is not None:
            pulumi.set(__self__, "host_network", host_network)
        if host_pid is not None:
            pulumi.set(__self__, "host_pid", host_pid)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if readiness_gates is not None:
            pulumi.set(__self__, "readiness_gates", readiness_gates)
        if restart_policy is not None:
            pulumi.set(__self__, "restart_policy", restart_policy)
        if runtime_class_name is not None:
            pulumi.set(__self__, "runtime_class_name", runtime_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)
        if share_process_namespace is not None:
            pulumi.set(__self__, "share_process_namespace", share_process_namespace)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if topology_spread_constraints is not None:
            pulumi.set(__self__, "topology_spread_constraints", topology_spread_constraints)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[int]:
        """
        Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinity']:
        """
        Optional pod scheduling constraints.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="automountServiceAccountToken")
    def automount_service_account_token(self) -> Optional[bool]:
        """
        AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. Defaults to `true`.
        """
        return pulumi.get(self, "automount_service_account_token")

    @property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainer']]:
        """
        List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/
        """
        return pulumi.get(self, "containers")

    @property
    @pulumi.getter(name="dnsConfig")
    def dns_config(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfig']:
        """
        Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
        """
        return pulumi.get(self, "dns_config")

    @property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[str]:
        """
        Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Defaults to 'ClusterFirst'. More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
        """
        return pulumi.get(self, "dns_policy")

    @property
    @pulumi.getter(name="enableServiceLinks")
    def enable_service_links(self) -> Optional[bool]:
        """
        Enables generating environment variables for service discovery. Defaults to true. Defaults to `true`.
        """
        return pulumi.get(self, "enable_service_links")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecHostAlias']]:
        """
        List of hosts and IPs that will be injected into the pod's hosts file if specified. Optional: Defaults to empty.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="hostIpc")
    def host_ipc(self) -> Optional[bool]:
        """
        Use the host's ipc namespace. Optional: Defaults to false.
        """
        return pulumi.get(self, "host_ipc")

    @property
    @pulumi.getter(name="hostNetwork")
    def host_network(self) -> Optional[bool]:
        """
        Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified.
        """
        return pulumi.get(self, "host_network")

    @property
    @pulumi.getter(name="hostPid")
    def host_pid(self) -> Optional[bool]:
        """
        Use the host's pid namespace.
        """
        return pulumi.get(self, "host_pid")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecret']]:
        """
        ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainer']]:
        """
        List of init containers belonging to the pod. Init containers always run to completion and each must complete successfully before the next is started. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        """
        return pulumi.get(self, "init_containers")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, str]]:
        """
        NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="readinessGates")
    def readiness_gates(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGate']]:
        """
        If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        """
        return pulumi.get(self, "readiness_gates")

    @property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[str]:
        """
        Restart policy for all containers within the pod. One of OnFailure, Never. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy. Defaults to `Never`.
        """
        return pulumi.get(self, "restart_policy")

    @property
    @pulumi.getter(name="runtimeClassName")
    def runtime_class_name(self) -> Optional[str]:
        """
        RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
        """
        return pulumi.get(self, "runtime_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContext']:
        """
        SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[str]:
        """
        ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.
        """
        return pulumi.get(self, "service_account_name")

    @property
    @pulumi.getter(name="shareProcessNamespace")
    def share_process_namespace(self) -> Optional[bool]:
        """
        Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "share_process_namespace")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecToleration']]:
        """
        If specified, the pod's toleration. Optional: Defaults to empty
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter(name="topologySpreadConstraints")
    def topology_spread_constraints(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraint']]:
        """
        describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.
        """
        return pulumi.get(self, "topology_spread_constraints")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolume']]:
        """
        List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeAffinity":
            suggest = "node_affinity"
        elif key == "podAffinity":
            suggest = "pod_affinity"
        elif key == "podAntiAffinity":
            suggest = "pod_anti_affinity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_affinity: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinity'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityArgs' node_affinity: Node affinity scheduling rules for the pod.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityArgs' pod_affinity: Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityArgs' pod_anti_affinity: Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinity']:
        """
        Node affinity scheduling rules for the pod.
        """
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinity']:
        """
        Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinity']:
        """
        Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        return pulumi.get(self, "pod_anti_affinity")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecution":
            suggest = "required_during_scheduling_ignored_during_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs' required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
        """
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
                 weight: Optional[int] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs' preference: A node selector term, associated with the corresponding weight.
        :param int weight: weight is in the range 1-100
        """
        pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference':
        """
        A node selector term, associated with the corresponding weight.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        weight is in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression']] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionArgs'] match_expressions: List of node selector requirements. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression']]:
        """
        List of node selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelectorTerms":
            suggest = "node_selector_terms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm']] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs'] node_selector_terms: List of node selector terms. The terms are ORed.
        """
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm']]:
        """
        List of node selector terms. The terms are ORed.
        """
        return pulumi.get(self, "node_selector_terms")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression']] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs'] match_expressions: List of node selector requirements. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression']]:
        """
        List of node selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecutions":
            suggest = "required_during_scheduling_ignored_during_executions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_executions: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAffinityTerm":
            suggest = "pod_affinity_term"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
                 weight: int):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: A pod affinity term, associated with the corresponding weight
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm':
        """
        A pod affinity term, associated with the corresponding weight
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecutions":
            suggest = "required_during_scheduling_ignored_during_executions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_executions: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAffinityTerm":
            suggest = "pod_affinity_term"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
                 weight: int):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: A pod affinity term, associated with the corresponding weight
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm':
        """
        A pod affinity term, associated with the corresponding weight
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envFroms":
            suggest = "env_froms"
        elif key == "imagePullPolicy":
            suggest = "image_pull_policy"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "securityContext":
            suggest = "security_context"
        elif key == "startupProbe":
            suggest = "startup_probe"
        elif key == "stdinOnce":
            suggest = "stdin_once"
        elif key == "terminationMessagePath":
            suggest = "termination_message_path"
        elif key == "terminationMessagePolicy":
            suggest = "termination_message_policy"
        elif key == "volumeMounts":
            suggest = "volume_mounts"
        elif key == "workingDir":
            suggest = "working_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 env_froms: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFrom']] = None,
                 envs: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnv']] = None,
                 image: Optional[str] = None,
                 image_pull_policy: Optional[str] = None,
                 lifecycle: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycle'] = None,
                 liveness_probe: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbe'] = None,
                 ports: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerPort']] = None,
                 readiness_probe: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbe'] = None,
                 resources: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerResources'] = None,
                 security_context: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContext'] = None,
                 startup_probe: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbe'] = None,
                 stdin: Optional[bool] = None,
                 stdin_once: Optional[bool] = None,
                 termination_message_path: Optional[str] = None,
                 termination_message_policy: Optional[str] = None,
                 tty: Optional[bool] = None,
                 volume_mounts: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMount']] = None,
                 working_dir: Optional[str] = None):
        """
        :param str name: Name of the container specified as a DNS*LABEL. Each container in a pod must have a unique name (DNS*LABEL). Cannot be updated.
        :param Sequence[str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence[str] commands: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromArgs'] env_froms: List of sources to populate environment variables in the container. The keys defined within a source must be a C*IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvArgs'] envs: List of environment variables to set in the container. Cannot be updated.
        :param str image: Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycleArgs' lifecycle: Actions that the management system should take in response to container lifecycle events
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeArgs' liveness_probe: Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerPortArgs'] ports: List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeArgs' readiness_probe: Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerResourcesArgs' resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextArgs' security_context: Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeArgs' startup_probe: StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param bool stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.  Defaults to `false`.
        :param bool stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Defaults to `false`.
        :param str termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Defaults to `/dev/termination-log`.
        :param str termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        :param bool tty: Whether this container should allocate a TTY for itself Defaults to `false`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMountArgs'] volume_mounts: Pod volumes to mount into the container's filesystem. Cannot be updated.
        :param str working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if termination_message_policy is not None:
            pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container specified as a DNS*LABEL. Each container in a pod must have a unique name (DNS*LABEL). Cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFrom']]:
        """
        List of sources to populate environment variables in the container. The keys defined within a source must be a C*IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        """
        return pulumi.get(self, "env_froms")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnv']]:
        """
        List of environment variables to set in the container. Cannot be updated.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[str]:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycle']:
        """
        Actions that the management system should take in response to container lifecycle events
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbe']:
        """
        Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerPort']]:
        """
        List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbe']:
        """
        Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerResources']:
        """
        Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContext']:
        """
        Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbe']:
        """
        StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[bool]:
        """
        Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.  Defaults to `false`.
        """
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[bool]:
        """
        Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Defaults to `false`.
        """
        return pulumi.get(self, "stdin_once")

    @property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[str]:
        """
        Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Defaults to `/dev/termination-log`.
        """
        return pulumi.get(self, "termination_message_path")

    @property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> Optional[str]:
        """
        Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_policy")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        """
        Whether this container should allocate a TTY for itself Defaults to `false`.
        """
        return pulumi.get(self, "tty")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMount']]:
        """
        Pod volumes to mount into the container's filesystem. Cannot be updated.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueFrom":
            suggest = "value_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFrom'] = None):
        """
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER
        :param str value: Variable references $(VAR*NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromArgs' value_from: Source for the environment variable's value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR*NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFrom']:
        """
        Source for the environment variable's value
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapRef":
            suggest = "config_map_ref"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRef'] = None,
                 prefix: Optional[str] = None,
                 secret_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRef'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRefArgs' config_map_ref: The ConfigMap to select from
        :param str prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRefArgs' secret_ref: The Secret to select from
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRef']:
        """
        The ConfigMap to select from
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRef']:
        """
        The Secret to select from
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRef(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRef(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapKeyRef":
            suggest = "config_map_key_ref"
        elif key == "fieldRef":
            suggest = "field_ref"
        elif key == "resourceFieldRef":
            suggest = "resource_field_ref"
        elif key == "secretKeyRef":
            suggest = "secret_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRef'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        :param str divisor: Defaults to `1`.
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "divisor")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key of the secret to select from. Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the secret to select from. Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postStarts":
            suggest = "post_starts"
        elif key == "preStops":
            suggest = "pre_stops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_starts: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStart']] = None,
                 pre_stops: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStop']] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartArgs'] post_starts: post*start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopArgs'] pre_stops: pre*stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStart']]:
        """
        post*start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "post_starts")

    @property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStop']]:
        """
        pre*stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "pre_stops")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExec'] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGet'] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocket']] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExecArgs' exec_: exec specifies the action to take.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExec'] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGet'] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocket']] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExecArgs' exec_: exec specifies the action to take.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerPort":
            suggest = "container_port"
        elif key == "hostIp":
            suggest = "host_ip"
        elif key == "hostPort":
            suggest = "host_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_port: int,
                 host_ip: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param int container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        :param str host_ip: What host IP to bind the external port to.
        :param int host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        :param str name: If specified, this must be an IANA*SVC*NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        :param str protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP". Defaults to `TCP`.
        """
        pulumi.set(__self__, "container_port", container_port)
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[str]:
        """
        What host IP to bind the external port to.
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        If specified, this must be an IANA*SVC*NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for port. Must be UDP or TCP. Defaults to "TCP". Defaults to `TCP`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] limits: Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPrivilegeEscalation":
            suggest = "allow_privilege_escalation"
        elif key == "readOnlyRootFilesystem":
            suggest = "read_only_root_filesystem"
        elif key == "runAsGroup":
            suggest = "run_as_group"
        elif key == "runAsNonRoot":
            suggest = "run_as_non_root"
        elif key == "runAsUser":
            suggest = "run_as_user"
        elif key == "seLinuxOptions":
            suggest = "se_linux_options"
        elif key == "seccompProfile":
            suggest = "seccomp_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptions'] = None,
                 seccomp_profile: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfile'] = None):
        """
        :param bool allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no*new*privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP*SYS*ADMIN Defaults to `true`.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilitiesArgs' capabilities: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        :param bool privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Defaults to `false`.
        :param bool read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false. Defaults to `false`.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        """
        AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no*new*privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP*SYS*ADMIN Defaults to `true`.
        """
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilities']:
        """
        The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        """
        Whether this container has a read-only root filesystem. Default is false. Defaults to `false`.
        """
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptions']:
        """
        The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfile']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 adds: Optional[Sequence[str]] = None,
                 drops: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] adds: Added capabilities
        :param Sequence[str] drops: Removed capabilities
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[Sequence[str]]:
        """
        Added capabilities
        """
        return pulumi.get(self, "adds")

    @property
    @pulumi.getter
    def drops(self) -> Optional[Sequence[str]]:
        """
        Removed capabilities
        """
        return pulumi.get(self, "drops")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localhostProfile":
            suggest = "localhost_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "mountPropagation":
            suggest = "mount_propagation"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "subPath":
            suggest = "sub_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None):
        """
        :param str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Defaults to `None`.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Defaults to `false`.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Defaults to `None`.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfig(dict):
    def __init__(__self__, *,
                 nameservers: Optional[Sequence[str]] = None,
                 options: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOption']] = None,
                 searches: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] nameservers: A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOptionArgs'] options: A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        :param Sequence[str] searches: A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        """
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)

    @property
    @pulumi.getter
    def nameservers(self) -> Optional[Sequence[str]]:
        """
        A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        """
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOption']]:
        """
        A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def searches(self) -> Optional[Sequence[str]]:
        """
        A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        """
        return pulumi.get(self, "searches")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOption(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: Name of the option.
        :param str value: Value of the option. Optional: Defaults to empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the option.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the option. Optional: Defaults to empty.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecHostAlias(dict):
    def __init__(__self__, *,
                 hostnames: Sequence[str],
                 ip: str):
        """
        :param Sequence[str] hostnames: Hostnames for the IP address.
        :param str ip: IP address of the host file entry.
        """
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        Hostnames for the IP address.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address of the host file entry.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecret(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envFroms":
            suggest = "env_froms"
        elif key == "imagePullPolicy":
            suggest = "image_pull_policy"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "securityContext":
            suggest = "security_context"
        elif key == "startupProbe":
            suggest = "startup_probe"
        elif key == "stdinOnce":
            suggest = "stdin_once"
        elif key == "terminationMessagePath":
            suggest = "termination_message_path"
        elif key == "terminationMessagePolicy":
            suggest = "termination_message_policy"
        elif key == "volumeMounts":
            suggest = "volume_mounts"
        elif key == "workingDir":
            suggest = "working_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 env_froms: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFrom']] = None,
                 envs: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnv']] = None,
                 image: Optional[str] = None,
                 image_pull_policy: Optional[str] = None,
                 lifecycle: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycle'] = None,
                 liveness_probe: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbe'] = None,
                 ports: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPort']] = None,
                 readiness_probe: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbe'] = None,
                 resources: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResources'] = None,
                 security_context: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContext'] = None,
                 startup_probe: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbe'] = None,
                 stdin: Optional[bool] = None,
                 stdin_once: Optional[bool] = None,
                 termination_message_path: Optional[str] = None,
                 termination_message_policy: Optional[str] = None,
                 tty: Optional[bool] = None,
                 volume_mounts: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMount']] = None,
                 working_dir: Optional[str] = None):
        """
        :param str name: Name of the container specified as a DNS*LABEL. Each container in a pod must have a unique name (DNS*LABEL). Cannot be updated.
        :param Sequence[str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence[str] commands: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromArgs'] env_froms: List of sources to populate environment variables in the container. The keys defined within a source must be a C*IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvArgs'] envs: List of environment variables to set in the container. Cannot be updated.
        :param str image: Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycleArgs' lifecycle: Actions that the management system should take in response to container lifecycle events
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeArgs' liveness_probe: Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPortArgs'] ports: List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeArgs' readiness_probe: Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResourcesArgs' resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextArgs' security_context: Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeArgs' startup_probe: StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param bool stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.  Defaults to `false`.
        :param bool stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Defaults to `false`.
        :param str termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Defaults to `/dev/termination-log`.
        :param str termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        :param bool tty: Whether this container should allocate a TTY for itself Defaults to `false`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMountArgs'] volume_mounts: Pod volumes to mount into the container's filesystem. Cannot be updated.
        :param str working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if termination_message_policy is not None:
            pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container specified as a DNS*LABEL. Each container in a pod must have a unique name (DNS*LABEL). Cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFrom']]:
        """
        List of sources to populate environment variables in the container. The keys defined within a source must be a C*IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        """
        return pulumi.get(self, "env_froms")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnv']]:
        """
        List of environment variables to set in the container. Cannot be updated.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[str]:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycle']:
        """
        Actions that the management system should take in response to container lifecycle events
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbe']:
        """
        Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPort']]:
        """
        List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbe']:
        """
        Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResources']:
        """
        Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContext']:
        """
        Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbe']:
        """
        StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[bool]:
        """
        Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.  Defaults to `false`.
        """
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[bool]:
        """
        Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Defaults to `false`.
        """
        return pulumi.get(self, "stdin_once")

    @property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[str]:
        """
        Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Defaults to `/dev/termination-log`.
        """
        return pulumi.get(self, "termination_message_path")

    @property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> Optional[str]:
        """
        Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_policy")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        """
        Whether this container should allocate a TTY for itself Defaults to `false`.
        """
        return pulumi.get(self, "tty")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMount']]:
        """
        Pod volumes to mount into the container's filesystem. Cannot be updated.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueFrom":
            suggest = "value_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFrom'] = None):
        """
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER
        :param str value: Variable references $(VAR*NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromArgs' value_from: Source for the environment variable's value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR*NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFrom']:
        """
        Source for the environment variable's value
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapRef":
            suggest = "config_map_ref"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRef'] = None,
                 prefix: Optional[str] = None,
                 secret_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRef'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRefArgs' config_map_ref: The ConfigMap to select from
        :param str prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRefArgs' secret_ref: The Secret to select from
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRef']:
        """
        The ConfigMap to select from
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRef']:
        """
        The Secret to select from
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRef(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRef(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapKeyRef":
            suggest = "config_map_key_ref"
        elif key == "fieldRef":
            suggest = "field_ref"
        elif key == "resourceFieldRef":
            suggest = "resource_field_ref"
        elif key == "secretKeyRef":
            suggest = "secret_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRef'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        :param str divisor: Defaults to `1`.
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "divisor")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key of the secret to select from. Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the secret to select from. Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postStarts":
            suggest = "post_starts"
        elif key == "preStops":
            suggest = "pre_stops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_starts: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStart']] = None,
                 pre_stops: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStop']] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartArgs'] post_starts: post*start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopArgs'] pre_stops: pre*stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStart']]:
        """
        post*start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "post_starts")

    @property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStop']]:
        """
        pre*stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "pre_stops")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExec'] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGet'] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocket']] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExecArgs' exec_: exec specifies the action to take.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExec'] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGet'] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocket']] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExecArgs' exec_: exec specifies the action to take.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerPort":
            suggest = "container_port"
        elif key == "hostIp":
            suggest = "host_ip"
        elif key == "hostPort":
            suggest = "host_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_port: int,
                 host_ip: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param int container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        :param str host_ip: What host IP to bind the external port to.
        :param int host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        :param str name: If specified, this must be an IANA*SVC*NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        :param str protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP". Defaults to `TCP`.
        """
        pulumi.set(__self__, "container_port", container_port)
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[str]:
        """
        What host IP to bind the external port to.
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        If specified, this must be an IANA*SVC*NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for port. Must be UDP or TCP. Defaults to "TCP". Defaults to `TCP`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] limits: Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPrivilegeEscalation":
            suggest = "allow_privilege_escalation"
        elif key == "readOnlyRootFilesystem":
            suggest = "read_only_root_filesystem"
        elif key == "runAsGroup":
            suggest = "run_as_group"
        elif key == "runAsNonRoot":
            suggest = "run_as_non_root"
        elif key == "runAsUser":
            suggest = "run_as_user"
        elif key == "seLinuxOptions":
            suggest = "se_linux_options"
        elif key == "seccompProfile":
            suggest = "seccomp_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptions'] = None,
                 seccomp_profile: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfile'] = None):
        """
        :param bool allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no*new*privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP*SYS*ADMIN Defaults to `true`.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilitiesArgs' capabilities: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        :param bool privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Defaults to `false`.
        :param bool read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false. Defaults to `false`.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        """
        AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no*new*privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP*SYS*ADMIN Defaults to `true`.
        """
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilities']:
        """
        The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        """
        Whether this container has a read-only root filesystem. Default is false. Defaults to `false`.
        """
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptions']:
        """
        The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfile']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 adds: Optional[Sequence[str]] = None,
                 drops: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] adds: Added capabilities
        :param Sequence[str] drops: Removed capabilities
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[Sequence[str]]:
        """
        Added capabilities
        """
        return pulumi.get(self, "adds")

    @property
    @pulumi.getter
    def drops(self) -> Optional[Sequence[str]]:
        """
        Removed capabilities
        """
        return pulumi.get(self, "drops")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localhostProfile":
            suggest = "localhost_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "mountPropagation":
            suggest = "mount_propagation"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "subPath":
            suggest = "sub_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None):
        """
        :param str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Defaults to `None`.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Defaults to `false`.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Defaults to `None`.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str):
        """
        :param str condition_type: refers to a condition in the pod's condition list with matching type.
        """
        pulumi.set(__self__, "condition_type", condition_type)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """
        refers to a condition in the pod's condition list with matching type.
        """
        return pulumi.get(self, "condition_type")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsGroup":
            suggest = "fs_group"
        elif key == "fsGroupChangePolicy":
            suggest = "fs_group_change_policy"
        elif key == "runAsGroup":
            suggest = "run_as_group"
        elif key == "runAsNonRoot":
            suggest = "run_as_non_root"
        elif key == "runAsUser":
            suggest = "run_as_user"
        elif key == "seLinuxOptions":
            suggest = "se_linux_options"
        elif key == "seccompProfile":
            suggest = "seccomp_profile"
        elif key == "supplementalGroups":
            suggest = "supplemental_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fs_group: Optional[str] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptions'] = None,
                 seccomp_profile: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfile'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctl']] = None):
        """
        :param str fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        :param str fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        :param Sequence[int] supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctlArgs'] sysctls: holds a list of namespaced sysctls used for the pod.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[str]:
        """
        A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        """
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        """
        fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
        """
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptions']:
        """
        The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfile']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        """
        A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container.
        """
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctl']]:
        """
        holds a list of namespaced sysctls used for the pod.
        """
        return pulumi.get(self, "sysctls")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localhostProfile":
            suggest = "localhost_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctl(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of a property to set.
        :param str value: Value of a property to set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of a property to set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of a property to set.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecToleration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tolerationSeconds":
            suggest = "toleration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecToleration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecToleration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecToleration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param str key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param str operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Defaults to `Equal`.
        :param str toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param str value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[str]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "maxSkew":
            suggest = "max_skew"
        elif key == "topologyKey":
            suggest = "topology_key"
        elif key == "whenUnsatisfiable":
            suggest = "when_unsatisfiable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelector']] = None,
                 max_skew: Optional[int] = None,
                 topology_key: Optional[str] = None,
                 when_unsatisfiable: Optional[str] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param int max_skew: describes the degree to which pods may be unevenly distributed. Defaults to `1`.
        :param str topology_key: the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology.
        :param str when_unsatisfiable: indicates how to deal with a pod if it doesn't satisfy the spread constraint. Defaults to `DoNotSchedule`.
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if max_skew is not None:
            pulumi.set(__self__, "max_skew", max_skew)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)
        if when_unsatisfiable is not None:
            pulumi.set(__self__, "when_unsatisfiable", when_unsatisfiable)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter(name="maxSkew")
    def max_skew(self) -> Optional[int]:
        """
        describes the degree to which pods may be unevenly distributed. Defaults to `1`.
        """
        return pulumi.get(self, "max_skew")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology.
        """
        return pulumi.get(self, "topology_key")

    @property
    @pulumi.getter(name="whenUnsatisfiable")
    def when_unsatisfiable(self) -> Optional[str]:
        """
        indicates how to deal with a pod if it doesn't satisfy the spread constraint. Defaults to `DoNotSchedule`.
        """
        return pulumi.get(self, "when_unsatisfiable")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsElasticBlockStore":
            suggest = "aws_elastic_block_store"
        elif key == "azureDisk":
            suggest = "azure_disk"
        elif key == "azureFile":
            suggest = "azure_file"
        elif key == "cephFs":
            suggest = "ceph_fs"
        elif key == "configMap":
            suggest = "config_map"
        elif key == "downwardApi":
            suggest = "downward_api"
        elif key == "emptyDir":
            suggest = "empty_dir"
        elif key == "flexVolume":
            suggest = "flex_volume"
        elif key == "gcePersistentDisk":
            suggest = "gce_persistent_disk"
        elif key == "gitRepo":
            suggest = "git_repo"
        elif key == "hostPath":
            suggest = "host_path"
        elif key == "persistentVolumeClaim":
            suggest = "persistent_volume_claim"
        elif key == "photonPersistentDisk":
            suggest = "photon_persistent_disk"
        elif key == "vsphereVolume":
            suggest = "vsphere_volume"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_elastic_block_store: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStore'] = None,
                 azure_disk: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDisk'] = None,
                 azure_file: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFile'] = None,
                 ceph_fs: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFs'] = None,
                 cinder: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinder'] = None,
                 config_map: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMap'] = None,
                 csi: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsi'] = None,
                 downward_api: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApi'] = None,
                 empty_dir: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDir'] = None,
                 ephemeral: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeral'] = None,
                 fc: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFc'] = None,
                 flex_volume: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolume'] = None,
                 flocker: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlocker'] = None,
                 gce_persistent_disk: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDisk'] = None,
                 git_repo: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepo'] = None,
                 glusterfs: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfs'] = None,
                 host_path: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPath'] = None,
                 iscsi: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsi'] = None,
                 local: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocal'] = None,
                 name: Optional[str] = None,
                 nfs: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfs'] = None,
                 persistent_volume_claim: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaim'] = None,
                 photon_persistent_disk: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDisk'] = None,
                 projected: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjected'] = None,
                 quobyte: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyte'] = None,
                 rbd: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbd'] = None,
                 secret: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecret'] = None,
                 vsphere_volume: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolume'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStoreArgs' aws_elastic_block_store: Represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDiskArgs' azure_disk: Represents an Azure Data Disk mount on the host and bind mount to the pod.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFileArgs' azure_file: Represents an Azure File Service mount on the host and bind mount to the pod.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsArgs' ceph_fs: Represents a Ceph FS mount on the host that shares a pod's lifetime
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinderArgs' cinder: Represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapArgs' config_map: ConfigMap represents a configMap that should populate this volume
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiArgs' csi: Represents a CSI Volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiArgs' downward_api: DownwardAPI represents downward API about the pod that should populate this volume
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDirArgs' empty_dir: EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralArgs' ephemeral: Represents an ephemeral volume that is handled by a normal storage driver. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFcArgs' fc: Represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeArgs' flex_volume: Represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlockerArgs' flocker: Represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDiskArgs' gce_persistent_disk: Represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepoArgs' git_repo: GitRepo represents a git repository at a particular revision.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfsArgs' glusterfs: Represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPathArgs' host_path: Represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsiArgs' iscsi: Represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocalArgs' local: Represents a mounted local storage device such as a disk, partition or directory. Local volumes can only be used as a statically created PersistentVolume. Dynamic provisioning is not supported yet. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        :param str name: Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfsArgs' nfs: Represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaimArgs' persistent_volume_claim: The specification of a persistent volume.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDiskArgs' photon_persistent_disk: Represents a PhotonController persistent disk attached and mounted on kubelets host machine
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedArgs' projected: Projected represents a single volume that projects several volume sources into the same directory. More info: https://kubernetes.io/docs/concepts/storage/volumes/#projected
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyteArgs' quobyte: Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdArgs' rbd: Represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretArgs' secret: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolumeArgs' vsphere_volume: Represents a vSphere volume attached and mounted on kubelets host machine
        """
        if aws_elastic_block_store is not None:
            pulumi.set(__self__, "aws_elastic_block_store", aws_elastic_block_store)
        if azure_disk is not None:
            pulumi.set(__self__, "azure_disk", azure_disk)
        if azure_file is not None:
            pulumi.set(__self__, "azure_file", azure_file)
        if ceph_fs is not None:
            pulumi.set(__self__, "ceph_fs", ceph_fs)
        if cinder is not None:
            pulumi.set(__self__, "cinder", cinder)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if csi is not None:
            pulumi.set(__self__, "csi", csi)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if ephemeral is not None:
            pulumi.set(__self__, "ephemeral", ephemeral)
        if fc is not None:
            pulumi.set(__self__, "fc", fc)
        if flex_volume is not None:
            pulumi.set(__self__, "flex_volume", flex_volume)
        if flocker is not None:
            pulumi.set(__self__, "flocker", flocker)
        if gce_persistent_disk is not None:
            pulumi.set(__self__, "gce_persistent_disk", gce_persistent_disk)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if glusterfs is not None:
            pulumi.set(__self__, "glusterfs", glusterfs)
        if host_path is not None:
            pulumi.set(__self__, "host_path", host_path)
        if iscsi is not None:
            pulumi.set(__self__, "iscsi", iscsi)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if photon_persistent_disk is not None:
            pulumi.set(__self__, "photon_persistent_disk", photon_persistent_disk)
        if projected is not None:
            pulumi.set(__self__, "projected", projected)
        if quobyte is not None:
            pulumi.set(__self__, "quobyte", quobyte)
        if rbd is not None:
            pulumi.set(__self__, "rbd", rbd)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if vsphere_volume is not None:
            pulumi.set(__self__, "vsphere_volume", vsphere_volume)

    @property
    @pulumi.getter(name="awsElasticBlockStore")
    def aws_elastic_block_store(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStore']:
        """
        Represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "aws_elastic_block_store")

    @property
    @pulumi.getter(name="azureDisk")
    def azure_disk(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDisk']:
        """
        Represents an Azure Data Disk mount on the host and bind mount to the pod.
        """
        return pulumi.get(self, "azure_disk")

    @property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFile']:
        """
        Represents an Azure File Service mount on the host and bind mount to the pod.
        """
        return pulumi.get(self, "azure_file")

    @property
    @pulumi.getter(name="cephFs")
    def ceph_fs(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFs']:
        """
        Represents a Ceph FS mount on the host that shares a pod's lifetime
        """
        return pulumi.get(self, "ceph_fs")

    @property
    @pulumi.getter
    def cinder(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinder']:
        """
        Represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "cinder")

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMap']:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_map")

    @property
    @pulumi.getter
    def csi(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsi']:
        """
        Represents a CSI Volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        """
        return pulumi.get(self, "csi")

    @property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApi']:
        """
        DownwardAPI represents downward API about the pod that should populate this volume
        """
        return pulumi.get(self, "downward_api")

    @property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDir']:
        """
        EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        """
        return pulumi.get(self, "empty_dir")

    @property
    @pulumi.getter
    def ephemeral(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeral']:
        """
        Represents an ephemeral volume that is handled by a normal storage driver. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
        """
        return pulumi.get(self, "ephemeral")

    @property
    @pulumi.getter
    def fc(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFc']:
        """
        Represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        """
        return pulumi.get(self, "fc")

    @property
    @pulumi.getter(name="flexVolume")
    def flex_volume(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolume']:
        """
        Represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
        """
        return pulumi.get(self, "flex_volume")

    @property
    @pulumi.getter
    def flocker(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlocker']:
        """
        Represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
        """
        return pulumi.get(self, "flocker")

    @property
    @pulumi.getter(name="gcePersistentDisk")
    def gce_persistent_disk(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDisk']:
        """
        Represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "gce_persistent_disk")

    @property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepo']:
        """
        GitRepo represents a git repository at a particular revision.
        """
        return pulumi.get(self, "git_repo")

    @property
    @pulumi.getter
    def glusterfs(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfs']:
        """
        Represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        """
        return pulumi.get(self, "glusterfs")

    @property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPath']:
        """
        Represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        """
        return pulumi.get(self, "host_path")

    @property
    @pulumi.getter
    def iscsi(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsi']:
        """
        Represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
        """
        return pulumi.get(self, "iscsi")

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocal']:
        """
        Represents a mounted local storage device such as a disk, partition or directory. Local volumes can only be used as a statically created PersistentVolume. Dynamic provisioning is not supported yet. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def nfs(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfs']:
        """
        Represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "nfs")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaim']:
        """
        The specification of a persistent volume.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter(name="photonPersistentDisk")
    def photon_persistent_disk(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDisk']:
        """
        Represents a PhotonController persistent disk attached and mounted on kubelets host machine
        """
        return pulumi.get(self, "photon_persistent_disk")

    @property
    @pulumi.getter
    def projected(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjected']:
        """
        Projected represents a single volume that projects several volume sources into the same directory. More info: https://kubernetes.io/docs/concepts/storage/volumes/#projected
        """
        return pulumi.get(self, "projected")

    @property
    @pulumi.getter
    def quobyte(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyte']:
        """
        Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        """
        return pulumi.get(self, "quobyte")

    @property
    @pulumi.getter
    def rbd(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbd']:
        """
        Represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        """
        return pulumi.get(self, "rbd")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecret']:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="vsphereVolume")
    def vsphere_volume(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolume']:
        """
        Represents a vSphere volume attached and mounted on kubelets host machine
        """
        return pulumi.get(self, "vsphere_volume")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_id: str,
                 fs_type: Optional[str] = None,
                 partition: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str volume_id: Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param int partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        :param bool read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        pulumi.set(__self__, "volume_id", volume_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def partition(self) -> Optional[int]:
        """
        The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachingMode":
            suggest = "caching_mode"
        elif key == "dataDiskUri":
            suggest = "data_disk_uri"
        elif key == "diskName":
            suggest = "disk_name"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching_mode: str,
                 data_disk_uri: str,
                 disk_name: str,
                 fs_type: Optional[str] = None,
                 kind: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str caching_mode: Host Caching mode: None, Read Only, Read Write.
        :param str data_disk_uri: The URI the data disk in the blob storage
        :param str disk_name: The Name of the data disk in the blob storage
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param str kind: The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Defaults to `false`.
        """
        pulumi.set(__self__, "caching_mode", caching_mode)
        pulumi.set(__self__, "data_disk_uri", data_disk_uri)
        pulumi.set(__self__, "disk_name", disk_name)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="cachingMode")
    def caching_mode(self) -> str:
        """
        Host Caching mode: None, Read Only, Read Write.
        """
        return pulumi.get(self, "caching_mode")

    @property
    @pulumi.getter(name="dataDiskUri")
    def data_disk_uri(self) -> str:
        """
        The URI the data disk in the blob storage
        """
        return pulumi.get(self, "data_disk_uri")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> str:
        """
        The Name of the data disk in the blob storage
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Defaults to `false`.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "secretNamespace":
            suggest = "secret_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str,
                 share_name: str,
                 read_only: Optional[bool] = None,
                 secret_namespace: Optional[str] = None):
        """
        :param str secret_name: The name of secret that contains Azure Storage Account Name and Key
        :param str share_name: Share Name
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        :param str secret_namespace: The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.
        """
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "share_name", share_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_namespace is not None:
            pulumi.set(__self__, "secret_namespace", secret_namespace)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of secret that contains Azure Storage Account Name and Key
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        Share Name
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretNamespace")
    def secret_namespace(self) -> Optional[str]:
        """
        The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.
        """
        return pulumi.get(self, "secret_namespace")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"
        elif key == "secretFile":
            suggest = "secret_file"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitors: Sequence[str],
                 path: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 secret_file: Optional[str] = None,
                 secret_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRef'] = None,
                 user: Optional[str] = None):
        """
        :param Sequence[str] monitors: Monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str path: Used as the mounted root, rather than the full Ceph tree, default is /
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to `false` (read/write). More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str secret_file: The path to key ring for User, default is `/etc/ceph/user.secret`. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRefArgs' secret_ref: Reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str user: User is the rados user name, default is admin. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        pulumi.set(__self__, "monitors", monitors)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_file is not None:
            pulumi.set(__self__, "secret_file", secret_file)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def monitors(self) -> Sequence[str]:
        """
        Monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "monitors")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Used as the mounted root, rather than the full Ceph tree, default is /
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to `false` (read/write). More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretFile")
    def secret_file(self) -> Optional[str]:
        """
        The path to key ring for User, default is `/etc/ceph/user.secret`. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_file")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRef']:
        """
        Reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is the rados user name, default is admin. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRef(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_id: str,
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str volume_id: Volume ID used to identify the volume in Cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        pulumi.set(__self__, "volume_id", volume_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        Volume ID used to identify the volume in Cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultMode":
            suggest = "default_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItem']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Optional: Specify whether the ConfigMap or its keys must be defined.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the ConfigMap or its keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItem(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsType":
            suggest = "fs_type"
        elif key == "nodePublishSecretRef":
            suggest = "node_publish_secret_ref"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "volumeAttributes":
            suggest = "volume_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver: str,
                 fs_type: Optional[str] = None,
                 node_publish_secret_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRef'] = None,
                 read_only: Optional[bool] = None,
                 volume_attributes: Optional[Mapping[str, str]] = None):
        """
        :param str driver: the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRefArgs' node_publish_secret_ref: A reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls.
        :param bool read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        :param Mapping[str, str] volume_attributes: Attributes of the volume to publish.
        """
        pulumi.set(__self__, "driver", driver)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if node_publish_secret_ref is not None:
            pulumi.set(__self__, "node_publish_secret_ref", node_publish_secret_ref)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if volume_attributes is not None:
            pulumi.set(__self__, "volume_attributes", volume_attributes)

    @property
    @pulumi.getter
    def driver(self) -> str:
        """
        the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="nodePublishSecretRef")
    def node_publish_secret_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRef']:
        """
        A reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls.
        """
        return pulumi.get(self, "node_publish_secret_ref")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="volumeAttributes")
    def volume_attributes(self) -> Optional[Mapping[str, str]]:
        """
        Attributes of the volume to publish.
        """
        return pulumi.get(self, "volume_attributes")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRef(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultMode":
            suggest = "default_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItem']] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldRef":
            suggest = "field_ref"
        elif key == "resourceFieldRef":
            suggest = "resource_field_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_ref: 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRef',
                 path: str,
                 mode: Optional[str] = None,
                 resource_field_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRefArgs' field_ref: Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        :param str path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        pulumi.set(__self__, "field_ref", field_ref)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRef':
        """
        Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 resource: str,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        :param str divisor: Defaults to `1`.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "resource", resource)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "divisor")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDir(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeLimit":
            suggest = "size_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDir. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDir.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDir.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 medium: Optional[str] = None,
                 size_limit: Optional[str] = None):
        """
        :param str medium: What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir Defaults to ``.
        :param str size_limit: Total amount of local storage required for this EmptyDir volume.
        """
        if medium is not None:
            pulumi.set(__self__, "medium", medium)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @property
    @pulumi.getter
    def medium(self) -> Optional[str]:
        """
        What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir Defaults to ``.
        """
        return pulumi.get(self, "medium")

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[str]:
        """
        Total amount of local storage required for this EmptyDir volume.
        """
        return pulumi.get(self, "size_limit")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeral(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeClaimTemplate":
            suggest = "volume_claim_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeral. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeral.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeral.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_claim_template: 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplate'):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateArgs' volume_claim_template: Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC.
        """
        pulumi.set(__self__, "volume_claim_template", volume_claim_template)

    @property
    @pulumi.getter(name="volumeClaimTemplate")
    def volume_claim_template(self) -> 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplate':
        """
        Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC.
        """
        return pulumi.get(self, "volume_claim_template")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplate(dict):
    def __init__(__self__, *,
                 spec: 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec',
                 metadata: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadata'] = None):
        """
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecArgs' spec: The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataArgs' metadata: May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
        """
        pulumi.set(__self__, "spec", spec)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec':
        """
        The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadata']:
        """
        May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadata(dict):
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the persistent volume claim. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the persistent volume claim. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessModes":
            suggest = "access_modes"
        elif key == "storageClassName":
            suggest = "storage_class_name"
        elif key == "volumeMode":
            suggest = "volume_mode"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_modes: Sequence[str],
                 resources: 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResources',
                 storage_class_name: Optional[str] = None,
                 volume_mode: Optional[str] = None,
                 volume_name: Optional[str] = None):
        """
        :param Sequence[str] access_modes: A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesArgs' resources: A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        :param str storage_class_name: Name of the storage class requested by the claim
        :param str volume_mode: Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        :param str volume_name: The binding reference to the PersistentVolume backing this claim.
        """
        pulumi.set(__self__, "access_modes", access_modes)
        pulumi.set(__self__, "resources", resources)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Sequence[str]:
        """
        A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResources':
        """
        A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[str]:
        """
        Name of the storage class requested by the claim
        """
        return pulumi.get(self, "storage_class_name")

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[str]:
        """
        Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        """
        return pulumi.get(self, "volume_mode")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[str]:
        """
        The binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] limits: Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        :param Mapping[str, str] requests: Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetWwNs":
            suggest = "target_ww_ns"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lun: int,
                 target_ww_ns: Sequence[str],
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param int lun: FC target lun number
        :param Sequence[str] target_ww_ns: FC target worldwide names (WWNs)
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "target_ww_ns", target_ww_ns)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        FC target lun number
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="targetWwNs")
    def target_ww_ns(self) -> Sequence[str]:
        """
        FC target worldwide names (WWNs)
        """
        return pulumi.get(self, "target_ww_ns")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver: str,
                 fs_type: Optional[str] = None,
                 options: Optional[Mapping[str, str]] = None,
                 read_only: Optional[bool] = None,
                 secret_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRef'] = None):
        """
        :param str driver: Driver is the name of the driver to use for this volume.
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        :param Mapping[str, str] options: Extra command options if any.
        :param bool read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRefArgs' secret_ref: Reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        """
        pulumi.set(__self__, "driver", driver)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter
    def driver(self) -> str:
        """
        Driver is the name of the driver to use for this volume.
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, str]]:
        """
        Extra command options if any.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRef']:
        """
        Reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRef(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetName":
            suggest = "dataset_name"
        elif key == "datasetUuid":
            suggest = "dataset_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_name: Optional[str] = None,
                 dataset_uuid: Optional[str] = None):
        """
        :param str dataset_name: Name of the dataset stored as metadata > name on the dataset for Flocker should be considered as deprecated
        :param str dataset_uuid: UUID of the dataset. This is unique identifier of a Flocker dataset
        """
        if dataset_name is not None:
            pulumi.set(__self__, "dataset_name", dataset_name)
        if dataset_uuid is not None:
            pulumi.set(__self__, "dataset_uuid", dataset_uuid)

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[str]:
        """
        Name of the dataset stored as metadata > name on the dataset for Flocker should be considered as deprecated
        """
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="datasetUuid")
    def dataset_uuid(self) -> Optional[str]:
        """
        UUID of the dataset. This is unique identifier of a Flocker dataset
        """
        return pulumi.get(self, "dataset_uuid")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pdName":
            suggest = "pd_name"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pd_name: str,
                 fs_type: Optional[str] = None,
                 partition: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str pd_name: Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param int partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param bool read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        pulumi.set(__self__, "pd_name", pd_name)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="pdName")
    def pd_name(self) -> str:
        """
        Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "pd_name")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def partition(self) -> Optional[int]:
        """
        The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepo(dict):
    def __init__(__self__, *,
                 directory: Optional[str] = None,
                 repository: Optional[str] = None,
                 revision: Optional[str] = None):
        """
        :param str directory: Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        :param str repository: Repository URL
        :param str revision: Commit hash for the specified revision.
        """
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        Repository URL
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def revision(self) -> Optional[str]:
        """
        Commit hash for the specified revision.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointsName":
            suggest = "endpoints_name"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoints_name: str,
                 path: str,
                 read_only: Optional[bool] = None):
        """
        :param str endpoints_name: The endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        :param str path: The Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        :param bool read_only: Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        pulumi.set(__self__, "endpoints_name", endpoints_name)
        pulumi.set(__self__, "path", path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="endpointsName")
    def endpoints_name(self) -> str:
        """
        The endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "endpoints_name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPath(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str path: Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        :param str type: Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPortal":
            suggest = "target_portal"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "iscsiInterface":
            suggest = "iscsi_interface"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iqn: str,
                 target_portal: str,
                 fs_type: Optional[str] = None,
                 iscsi_interface: Optional[str] = None,
                 lun: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str iqn: Target iSCSI Qualified Name.
        :param str target_portal: iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        :param str iscsi_interface: iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp). Defaults to `default`.
        :param int lun: iSCSI target lun number.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false.
        """
        pulumi.set(__self__, "iqn", iqn)
        pulumi.set(__self__, "target_portal", target_portal)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if iscsi_interface is not None:
            pulumi.set(__self__, "iscsi_interface", iscsi_interface)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def iqn(self) -> str:
        """
        Target iSCSI Qualified Name.
        """
        return pulumi.get(self, "iqn")

    @property
    @pulumi.getter(name="targetPortal")
    def target_portal(self) -> str:
        """
        iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        """
        return pulumi.get(self, "target_portal")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="iscsiInterface")
    def iscsi_interface(self) -> Optional[str]:
        """
        iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp). Defaults to `default`.
        """
        return pulumi.get(self, "iscsi_interface")

    @property
    @pulumi.getter
    def lun(self) -> Optional[int]:
        """
        iSCSI target lun number.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocal(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None):
        """
        :param str path: Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 server: str,
                 read_only: Optional[bool] = None):
        """
        :param str path: Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param str server: Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param bool read_only: Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "server", server)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaim(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "claimName":
            suggest = "claim_name"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaim. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaim.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaim.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 claim_name: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str claim_name: ClaimName is the name of a PersistentVolumeClaim in the same
        :param bool read_only: Will force the ReadOnly setting in VolumeMounts. Defaults to `false`.
        """
        if claim_name is not None:
            pulumi.set(__self__, "claim_name", claim_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> Optional[str]:
        """
        ClaimName is the name of a PersistentVolumeClaim in the same
        """
        return pulumi.get(self, "claim_name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Will force the ReadOnly setting in VolumeMounts. Defaults to `false`.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pdId":
            suggest = "pd_id"
        elif key == "fsType":
            suggest = "fs_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pd_id: str,
                 fs_type: Optional[str] = None):
        """
        :param str pd_id: ID that identifies Photon Controller persistent disk
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        pulumi.set(__self__, "pd_id", pd_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)

    @property
    @pulumi.getter(name="pdId")
    def pd_id(self) -> str:
        """
        ID that identifies Photon Controller persistent disk
        """
        return pulumi.get(self, "pd_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjected(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultMode":
            suggest = "default_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjected. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjected.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjected.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSource'],
                 default_mode: Optional[str] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceArgs'] sources: Source of the volume to project in the directory.
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        pulumi.set(__self__, "sources", sources)
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSource']:
        """
        Source of the volume to project in the directory.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        return pulumi.get(self, "default_mode")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMaps":
            suggest = "config_maps"
        elif key == "downwardApi":
            suggest = "downward_api"
        elif key == "serviceAccountToken":
            suggest = "service_account_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_maps: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMap']] = None,
                 downward_api: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApi'] = None,
                 secrets: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecret']] = None,
                 service_account_token: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountToken'] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapArgs'] config_maps: ConfigMap represents a configMap that should populate this volume
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiArgs' downward_api: DownwardAPI represents downward API about the pod that should populate this volume
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretArgs'] secrets: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenArgs' service_account_token: A projected service account token volume
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_account_token is not None:
            pulumi.set(__self__, "service_account_token", service_account_token)

    @property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMap']]:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_maps")

    @property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApi']:
        """
        DownwardAPI represents downward API about the pod that should populate this volume
        """
        return pulumi.get(self, "downward_api")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecret']]:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceAccountToken")
    def service_account_token(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountToken']:
        """
        A projected service account token volume
        """
        return pulumi.get(self, "service_account_token")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMap(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItem']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Optional: Specify whether the ConfigMap or it's keys must be defined.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the ConfigMap or it's keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItem(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApi(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItem']] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemArgs'] items: Represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItem']]:
        """
        Represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldRef":
            suggest = "field_ref"
        elif key == "resourceFieldRef":
            suggest = "resource_field_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 field_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef'] = None,
                 mode: Optional[str] = None,
                 resource_field_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef'] = None):
        """
        :param str path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefArgs' field_ref: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        :param str mode: Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        pulumi.set(__self__, "path", path)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef']:
        """
        Selects a field of the pod: only annotations, labels, name and namespace are supported.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to 'v1'. Defaults to `v1`.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to 'v1'. Defaults to `v1`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 resource: str,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        :param str divisor: Defaults to `1`.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "resource", resource)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "divisor")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecret(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItem']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param bool optional: Optional: Specify whether the Secret or it's keys must be defined.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the Secret or it's keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItem(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationSeconds":
            suggest = "expiration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 audience: Optional[str] = None,
                 expiration_seconds: Optional[int] = None):
        """
        :param str path: Path specifies a relative path to the mount point of the projected volume.
        :param str audience: Audience is the intended audience of the token
        :param int expiration_seconds: ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds). Defaults to `3600`.
        """
        pulumi.set(__self__, "path", path)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if expiration_seconds is not None:
            pulumi.set(__self__, "expiration_seconds", expiration_seconds)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path specifies a relative path to the mount point of the projected volume.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Audience is the intended audience of the token
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="expirationSeconds")
    def expiration_seconds(self) -> Optional[int]:
        """
        ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds). Defaults to `3600`.
        """
        return pulumi.get(self, "expiration_seconds")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyte(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyte. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyte.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyte.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry: str,
                 volume: str,
                 group: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 user: Optional[str] = None):
        """
        :param str registry: Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        :param str volume: Volume is a string that references an already created Quobyte volume by name.
        :param str group: Group to map volume access to Default is no group
        :param bool read_only: Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        :param str user: User to map volume access to Defaults to serivceaccount user
        """
        pulumi.set(__self__, "registry", registry)
        pulumi.set(__self__, "volume", volume)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def registry(self) -> str:
        """
        Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        """
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter
    def volume(self) -> str:
        """
        Volume is a string that references an already created Quobyte volume by name.
        """
        return pulumi.get(self, "volume")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group to map volume access to Default is no group
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User to map volume access to Defaults to serivceaccount user
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cephMonitors":
            suggest = "ceph_monitors"
        elif key == "rbdImage":
            suggest = "rbd_image"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "radosUser":
            suggest = "rados_user"
        elif key == "rbdPool":
            suggest = "rbd_pool"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ceph_monitors: Sequence[str],
                 rbd_image: str,
                 fs_type: Optional[str] = None,
                 keyring: Optional[str] = None,
                 rados_user: Optional[str] = None,
                 rbd_pool: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 secret_ref: Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRef'] = None):
        """
        :param Sequence[str] ceph_monitors: A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str rbd_image: The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        :param str keyring: Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str rados_user: The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it Defaults to `admin`.
        :param str rbd_pool: The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it. Defaults to `rbd`.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it Defaults to `false`.
        :param 'K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRefArgs' secret_ref: Name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        pulumi.set(__self__, "ceph_monitors", ceph_monitors)
        pulumi.set(__self__, "rbd_image", rbd_image)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if keyring is not None:
            pulumi.set(__self__, "keyring", keyring)
        if rados_user is not None:
            pulumi.set(__self__, "rados_user", rados_user)
        if rbd_pool is not None:
            pulumi.set(__self__, "rbd_pool", rbd_pool)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="cephMonitors")
    def ceph_monitors(self) -> Sequence[str]:
        """
        A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "ceph_monitors")

    @property
    @pulumi.getter(name="rbdImage")
    def rbd_image(self) -> str:
        """
        The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "rbd_image")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def keyring(self) -> Optional[str]:
        """
        Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "keyring")

    @property
    @pulumi.getter(name="radosUser")
    def rados_user(self) -> Optional[str]:
        """
        The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it Defaults to `admin`.
        """
        return pulumi.get(self, "rados_user")

    @property
    @pulumi.getter(name="rbdPool")
    def rbd_pool(self) -> Optional[str]:
        """
        The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it. Defaults to `rbd`.
        """
        return pulumi.get(self, "rbd_pool")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it Defaults to `false`.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRef']:
        """
        Name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRef(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultMode":
            suggest = "default_mode"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItem']] = None,
                 optional: Optional[bool] = None,
                 secret_name: Optional[str] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        :param Sequence['K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param bool optional: Optional: Specify whether the Secret or its keys must be defined.
        :param str secret_name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the Secret or its keys must be defined.
        """
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItem(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumePath":
            suggest = "volume_path"
        elif key == "fsType":
            suggest = "fs_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_path: str,
                 fs_type: Optional[str] = None):
        """
        :param str volume_path: Path that identifies vSphere volume vmdk
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        pulumi.set(__self__, "volume_path", volume_path)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)

    @property
    @pulumi.getter(name="volumePath")
    def volume_path(self) -> str:
        """
        Path that identifies vSphere volume vmdk
        """
        return pulumi.get(self, "volume_path")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")


@pulumi.output_type
class K8sJobMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generateName":
            suggest = "generate_name"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 generate_name: Optional[str] = None,
                 generation: Optional[int] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace defines the space within which name of the job must be unique.
        :param str resource_version: An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)
        if generation is not None:
            pulumi.set(__self__, "generation", generation)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")

    @property
    @pulumi.getter
    def generation(self) -> Optional[int]:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace defines the space within which name of the job must be unique.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class K8sJobSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDeadlineSeconds":
            suggest = "active_deadline_seconds"
        elif key == "backoffLimit":
            suggest = "backoff_limit"
        elif key == "completionMode":
            suggest = "completion_mode"
        elif key == "manualSelector":
            suggest = "manual_selector"
        elif key == "ttlSecondsAfterFinished":
            suggest = "ttl_seconds_after_finished"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: 'outputs.K8sJobSpecTemplate',
                 active_deadline_seconds: Optional[int] = None,
                 backoff_limit: Optional[int] = None,
                 completion_mode: Optional[str] = None,
                 completions: Optional[int] = None,
                 manual_selector: Optional[bool] = None,
                 parallelism: Optional[int] = None,
                 selector: Optional['outputs.K8sJobSpecSelector'] = None,
                 ttl_seconds_after_finished: Optional[str] = None):
        """
        :param 'K8sJobSpecTemplateArgs' template: Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param int active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        :param int backoff_limit: Specifies the number of retries before marking this job failed. Defaults to 6 Defaults to `6`.
        :param str completion_mode: Specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#completion-mode
        :param int completions: Specifies the desired number of successfully finished pods the job should be run with. Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ Defaults to `1`.
        :param bool manual_selector: Controls generation of pod labels and pod selectors. Leave unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. More info: https://git.k8s.io/community/contributors/design-proposals/selector-generation.md
        :param int parallelism: Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ Defaults to `1`.
        :param 'K8sJobSpecSelectorArgs' selector: A label query over volumes to consider for binding.
        :param str ttl_seconds_after_finished: ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.
        """
        pulumi.set(__self__, "template", template)
        if active_deadline_seconds is not None:
            pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        if backoff_limit is not None:
            pulumi.set(__self__, "backoff_limit", backoff_limit)
        if completion_mode is not None:
            pulumi.set(__self__, "completion_mode", completion_mode)
        if completions is not None:
            pulumi.set(__self__, "completions", completions)
        if manual_selector is not None:
            pulumi.set(__self__, "manual_selector", manual_selector)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if ttl_seconds_after_finished is not None:
            pulumi.set(__self__, "ttl_seconds_after_finished", ttl_seconds_after_finished)

    @property
    @pulumi.getter
    def template(self) -> 'outputs.K8sJobSpecTemplate':
        """
        Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[int]:
        """
        Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="backoffLimit")
    def backoff_limit(self) -> Optional[int]:
        """
        Specifies the number of retries before marking this job failed. Defaults to 6 Defaults to `6`.
        """
        return pulumi.get(self, "backoff_limit")

    @property
    @pulumi.getter(name="completionMode")
    def completion_mode(self) -> Optional[str]:
        """
        Specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#completion-mode
        """
        return pulumi.get(self, "completion_mode")

    @property
    @pulumi.getter
    def completions(self) -> Optional[int]:
        """
        Specifies the desired number of successfully finished pods the job should be run with. Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ Defaults to `1`.
        """
        return pulumi.get(self, "completions")

    @property
    @pulumi.getter(name="manualSelector")
    def manual_selector(self) -> Optional[bool]:
        """
        Controls generation of pod labels and pod selectors. Leave unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. More info: https://git.k8s.io/community/contributors/design-proposals/selector-generation.md
        """
        return pulumi.get(self, "manual_selector")

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/ Defaults to `1`.
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.K8sJobSpecSelector']:
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter(name="ttlSecondsAfterFinished")
    def ttl_seconds_after_finished(self) -> Optional[str]:
        """
        ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.
        """
        return pulumi.get(self, "ttl_seconds_after_finished")


@pulumi.output_type
class K8sJobSpecSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sJobSpecSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sJobSpecSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sJobSpecSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sJobSpecSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sJobSpecTemplate(dict):
    def __init__(__self__, *,
                 metadata: Optional['outputs.K8sJobSpecTemplateMetadata'] = None,
                 spec: Optional['outputs.K8sJobSpecTemplateSpec'] = None):
        """
        :param 'K8sJobSpecTemplateMetadataArgs' metadata: Standard job's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param 'K8sJobSpecTemplateSpecArgs' spec: Spec of the pods owned by the job
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.K8sJobSpecTemplateMetadata']:
        """
        Standard job's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.K8sJobSpecTemplateSpec']:
        """
        Spec of the pods owned by the job
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class K8sJobSpecTemplateMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generateName":
            suggest = "generate_name"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 generate_name: Optional[str] = None,
                 generation: Optional[int] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str resource_version: An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)
        if generation is not None:
            pulumi.set(__self__, "generation", generation)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")

    @property
    @pulumi.getter
    def generation(self) -> Optional[int]:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class K8sJobSpecTemplateSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDeadlineSeconds":
            suggest = "active_deadline_seconds"
        elif key == "automountServiceAccountToken":
            suggest = "automount_service_account_token"
        elif key == "dnsConfig":
            suggest = "dns_config"
        elif key == "dnsPolicy":
            suggest = "dns_policy"
        elif key == "enableServiceLinks":
            suggest = "enable_service_links"
        elif key == "hostAliases":
            suggest = "host_aliases"
        elif key == "hostIpc":
            suggest = "host_ipc"
        elif key == "hostNetwork":
            suggest = "host_network"
        elif key == "hostPid":
            suggest = "host_pid"
        elif key == "imagePullSecrets":
            suggest = "image_pull_secrets"
        elif key == "initContainers":
            suggest = "init_containers"
        elif key == "nodeName":
            suggest = "node_name"
        elif key == "nodeSelector":
            suggest = "node_selector"
        elif key == "priorityClassName":
            suggest = "priority_class_name"
        elif key == "readinessGates":
            suggest = "readiness_gates"
        elif key == "restartPolicy":
            suggest = "restart_policy"
        elif key == "runtimeClassName":
            suggest = "runtime_class_name"
        elif key == "schedulerName":
            suggest = "scheduler_name"
        elif key == "securityContext":
            suggest = "security_context"
        elif key == "serviceAccountName":
            suggest = "service_account_name"
        elif key == "shareProcessNamespace":
            suggest = "share_process_namespace"
        elif key == "terminationGracePeriodSeconds":
            suggest = "termination_grace_period_seconds"
        elif key == "topologySpreadConstraints":
            suggest = "topology_spread_constraints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_deadline_seconds: Optional[int] = None,
                 affinity: Optional['outputs.K8sJobSpecTemplateSpecAffinity'] = None,
                 automount_service_account_token: Optional[bool] = None,
                 containers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainer']] = None,
                 dns_config: Optional['outputs.K8sJobSpecTemplateSpecDnsConfig'] = None,
                 dns_policy: Optional[str] = None,
                 enable_service_links: Optional[bool] = None,
                 host_aliases: Optional[Sequence['outputs.K8sJobSpecTemplateSpecHostAlias']] = None,
                 host_ipc: Optional[bool] = None,
                 host_network: Optional[bool] = None,
                 host_pid: Optional[bool] = None,
                 hostname: Optional[str] = None,
                 image_pull_secrets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecImagePullSecret']] = None,
                 init_containers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainer']] = None,
                 node_name: Optional[str] = None,
                 node_selector: Optional[Mapping[str, str]] = None,
                 priority_class_name: Optional[str] = None,
                 readiness_gates: Optional[Sequence['outputs.K8sJobSpecTemplateSpecReadinessGate']] = None,
                 restart_policy: Optional[str] = None,
                 runtime_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.K8sJobSpecTemplateSpecSecurityContext'] = None,
                 service_account_name: Optional[str] = None,
                 share_process_namespace: Optional[bool] = None,
                 subdomain: Optional[str] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.K8sJobSpecTemplateSpecToleration']] = None,
                 topology_spread_constraints: Optional[Sequence['outputs.K8sJobSpecTemplateSpecTopologySpreadConstraint']] = None,
                 volumes: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolume']] = None):
        """
        :param int active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        :param 'K8sJobSpecTemplateSpecAffinityArgs' affinity: Optional pod scheduling constraints.
        :param bool automount_service_account_token: AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. Defaults to `true`.
        :param Sequence['K8sJobSpecTemplateSpecContainerArgs'] containers: List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/
        :param 'K8sJobSpecTemplateSpecDnsConfigArgs' dns_config: Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
        :param str dns_policy: Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Defaults to 'ClusterFirst'. More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
        :param bool enable_service_links: Enables generating environment variables for service discovery. Defaults to true. Defaults to `true`.
        :param Sequence['K8sJobSpecTemplateSpecHostAliasArgs'] host_aliases: List of hosts and IPs that will be injected into the pod's hosts file if specified. Optional: Defaults to empty.
        :param bool host_ipc: Use the host's ipc namespace. Optional: Defaults to false.
        :param bool host_network: Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified.
        :param bool host_pid: Use the host's pid namespace.
        :param str hostname: Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
        :param Sequence['K8sJobSpecTemplateSpecImagePullSecretArgs'] image_pull_secrets: ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        :param Sequence['K8sJobSpecTemplateSpecInitContainerArgs'] init_containers: List of init containers belonging to the pod. Init containers always run to completion and each must complete successfully before the next is started. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        :param str node_name: NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        :param Mapping[str, str] node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        :param str priority_class_name: If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        :param Sequence['K8sJobSpecTemplateSpecReadinessGateArgs'] readiness_gates: If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        :param str restart_policy: Restart policy for all containers within the pod. One of OnFailure, Never. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy. Defaults to `Never`.
        :param str runtime_class_name: RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
        :param str scheduler_name: If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        :param 'K8sJobSpecTemplateSpecSecurityContextArgs' security_context: SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty
        :param str service_account_name: ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.
        :param bool share_process_namespace: Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false. Defaults to `false`.
        :param str subdomain: If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..
        :param int termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.
        :param Sequence['K8sJobSpecTemplateSpecTolerationArgs'] tolerations: If specified, the pod's toleration. Optional: Defaults to empty
        :param Sequence['K8sJobSpecTemplateSpecTopologySpreadConstraintArgs'] topology_spread_constraints: describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.
        :param Sequence['K8sJobSpecTemplateSpecVolumeArgs'] volumes: List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
        """
        if active_deadline_seconds is not None:
            pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if automount_service_account_token is not None:
            pulumi.set(__self__, "automount_service_account_token", automount_service_account_token)
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if dns_config is not None:
            pulumi.set(__self__, "dns_config", dns_config)
        if dns_policy is not None:
            pulumi.set(__self__, "dns_policy", dns_policy)
        if enable_service_links is not None:
            pulumi.set(__self__, "enable_service_links", enable_service_links)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if host_ipc is not None:
            pulumi.set(__self__, "host_ipc", host_ipc)
        if host_network is not None:
            pulumi.set(__self__, "host_network", host_network)
        if host_pid is not None:
            pulumi.set(__self__, "host_pid", host_pid)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if readiness_gates is not None:
            pulumi.set(__self__, "readiness_gates", readiness_gates)
        if restart_policy is not None:
            pulumi.set(__self__, "restart_policy", restart_policy)
        if runtime_class_name is not None:
            pulumi.set(__self__, "runtime_class_name", runtime_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)
        if share_process_namespace is not None:
            pulumi.set(__self__, "share_process_namespace", share_process_namespace)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if topology_spread_constraints is not None:
            pulumi.set(__self__, "topology_spread_constraints", topology_spread_constraints)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[int]:
        """
        Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.K8sJobSpecTemplateSpecAffinity']:
        """
        Optional pod scheduling constraints.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="automountServiceAccountToken")
    def automount_service_account_token(self) -> Optional[bool]:
        """
        AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. Defaults to `true`.
        """
        return pulumi.get(self, "automount_service_account_token")

    @property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainer']]:
        """
        List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/
        """
        return pulumi.get(self, "containers")

    @property
    @pulumi.getter(name="dnsConfig")
    def dns_config(self) -> Optional['outputs.K8sJobSpecTemplateSpecDnsConfig']:
        """
        Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
        """
        return pulumi.get(self, "dns_config")

    @property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[str]:
        """
        Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Defaults to 'ClusterFirst'. More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
        """
        return pulumi.get(self, "dns_policy")

    @property
    @pulumi.getter(name="enableServiceLinks")
    def enable_service_links(self) -> Optional[bool]:
        """
        Enables generating environment variables for service discovery. Defaults to true. Defaults to `true`.
        """
        return pulumi.get(self, "enable_service_links")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecHostAlias']]:
        """
        List of hosts and IPs that will be injected into the pod's hosts file if specified. Optional: Defaults to empty.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="hostIpc")
    def host_ipc(self) -> Optional[bool]:
        """
        Use the host's ipc namespace. Optional: Defaults to false.
        """
        return pulumi.get(self, "host_ipc")

    @property
    @pulumi.getter(name="hostNetwork")
    def host_network(self) -> Optional[bool]:
        """
        Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified.
        """
        return pulumi.get(self, "host_network")

    @property
    @pulumi.getter(name="hostPid")
    def host_pid(self) -> Optional[bool]:
        """
        Use the host's pid namespace.
        """
        return pulumi.get(self, "host_pid")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecImagePullSecret']]:
        """
        ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainer']]:
        """
        List of init containers belonging to the pod. Init containers always run to completion and each must complete successfully before the next is started. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        """
        return pulumi.get(self, "init_containers")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, str]]:
        """
        NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="readinessGates")
    def readiness_gates(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecReadinessGate']]:
        """
        If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        """
        return pulumi.get(self, "readiness_gates")

    @property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[str]:
        """
        Restart policy for all containers within the pod. One of OnFailure, Never. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy. Defaults to `Never`.
        """
        return pulumi.get(self, "restart_policy")

    @property
    @pulumi.getter(name="runtimeClassName")
    def runtime_class_name(self) -> Optional[str]:
        """
        RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
        """
        return pulumi.get(self, "runtime_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.K8sJobSpecTemplateSpecSecurityContext']:
        """
        SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[str]:
        """
        ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.
        """
        return pulumi.get(self, "service_account_name")

    @property
    @pulumi.getter(name="shareProcessNamespace")
    def share_process_namespace(self) -> Optional[bool]:
        """
        Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "share_process_namespace")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecToleration']]:
        """
        If specified, the pod's toleration. Optional: Defaults to empty
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter(name="topologySpreadConstraints")
    def topology_spread_constraints(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecTopologySpreadConstraint']]:
        """
        describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.
        """
        return pulumi.get(self, "topology_spread_constraints")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolume']]:
        """
        List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeAffinity":
            suggest = "node_affinity"
        elif key == "podAffinity":
            suggest = "pod_affinity"
        elif key == "podAntiAffinity":
            suggest = "pod_anti_affinity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_affinity: Optional['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.K8sJobSpecTemplateSpecAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinity'] = None):
        """
        :param 'K8sJobSpecTemplateSpecAffinityNodeAffinityArgs' node_affinity: Node affinity scheduling rules for the pod.
        :param 'K8sJobSpecTemplateSpecAffinityPodAffinityArgs' pod_affinity: Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        :param 'K8sJobSpecTemplateSpecAffinityPodAntiAffinityArgs' pod_anti_affinity: Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinity']:
        """
        Node affinity scheduling rules for the pod.
        """
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.K8sJobSpecTemplateSpecAffinityPodAffinity']:
        """
        Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinity']:
        """
        Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        return pulumi.get(self, "pod_anti_affinity")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityNodeAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecution":
            suggest = "required_during_scheduling_ignored_during_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityNodeAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityNodeAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityNodeAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param 'K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs' required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
        """
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: 'outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
                 weight: Optional[int] = None):
        """
        :param 'K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs' preference: A node selector term, associated with the corresponding weight.
        :param int weight: weight is in the range 1-100
        """
        pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> 'outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference':
        """
        A node selector term, associated with the corresponding weight.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        weight is in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression']] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionArgs'] match_expressions: List of node selector requirements. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression']]:
        """
        List of node selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelectorTerms":
            suggest = "node_selector_terms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm']] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs'] node_selector_terms: List of node selector terms. The terms are ORed.
        """
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm']]:
        """
        List of node selector terms. The terms are ORed.
        """
        return pulumi.get(self, "node_selector_terms")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression']] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs'] match_expressions: List of node selector requirements. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression']]:
        """
        List of node selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecutions":
            suggest = "required_during_scheduling_ignored_during_executions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_executions: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAffinityTerm":
            suggest = "pod_affinity_term"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
                 weight: int):
        """
        :param 'K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: A pod affinity term, associated with the corresponding weight
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm':
        """
        A pod affinity term, associated with the corresponding weight
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAntiAffinity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredDuringSchedulingIgnoredDuringExecutions":
            suggest = "preferred_during_scheduling_ignored_during_executions"
        elif key == "requiredDuringSchedulingIgnoredDuringExecutions":
            suggest = "required_during_scheduling_ignored_during_executions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAntiAffinity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_executions: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAffinityTerm":
            suggest = "pod_affinity_term"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
                 weight: int):
        """
        :param 'K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: A pod affinity term, associated with the corresponding weight
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm':
        """
        A pod affinity term, associated with the corresponding weight
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "topologyKey":
            suggest = "topology_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envFroms":
            suggest = "env_froms"
        elif key == "imagePullPolicy":
            suggest = "image_pull_policy"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "securityContext":
            suggest = "security_context"
        elif key == "startupProbe":
            suggest = "startup_probe"
        elif key == "stdinOnce":
            suggest = "stdin_once"
        elif key == "terminationMessagePath":
            suggest = "termination_message_path"
        elif key == "terminationMessagePolicy":
            suggest = "termination_message_policy"
        elif key == "volumeMounts":
            suggest = "volume_mounts"
        elif key == "workingDir":
            suggest = "working_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 env_froms: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerEnvFrom']] = None,
                 envs: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerEnv']] = None,
                 image: Optional[str] = None,
                 image_pull_policy: Optional[str] = None,
                 lifecycle: Optional['outputs.K8sJobSpecTemplateSpecContainerLifecycle'] = None,
                 liveness_probe: Optional['outputs.K8sJobSpecTemplateSpecContainerLivenessProbe'] = None,
                 ports: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerPort']] = None,
                 readiness_probe: Optional['outputs.K8sJobSpecTemplateSpecContainerReadinessProbe'] = None,
                 resources: Optional['outputs.K8sJobSpecTemplateSpecContainerResources'] = None,
                 security_context: Optional['outputs.K8sJobSpecTemplateSpecContainerSecurityContext'] = None,
                 startup_probe: Optional['outputs.K8sJobSpecTemplateSpecContainerStartupProbe'] = None,
                 stdin: Optional[bool] = None,
                 stdin_once: Optional[bool] = None,
                 termination_message_path: Optional[str] = None,
                 termination_message_policy: Optional[str] = None,
                 tty: Optional[bool] = None,
                 volume_mounts: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerVolumeMount']] = None,
                 working_dir: Optional[str] = None):
        """
        :param str name: Name of the container specified as a DNS*LABEL. Each container in a pod must have a unique name (DNS*LABEL). Cannot be updated.
        :param Sequence[str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence[str] commands: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence['K8sJobSpecTemplateSpecContainerEnvFromArgs'] env_froms: List of sources to populate environment variables in the container. The keys defined within a source must be a C*IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        :param Sequence['K8sJobSpecTemplateSpecContainerEnvArgs'] envs: List of environment variables to set in the container. Cannot be updated.
        :param str image: Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        :param 'K8sJobSpecTemplateSpecContainerLifecycleArgs' lifecycle: Actions that the management system should take in response to container lifecycle events
        :param 'K8sJobSpecTemplateSpecContainerLivenessProbeArgs' liveness_probe: Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param Sequence['K8sJobSpecTemplateSpecContainerPortArgs'] ports: List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        :param 'K8sJobSpecTemplateSpecContainerReadinessProbeArgs' readiness_probe: Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param 'K8sJobSpecTemplateSpecContainerResourcesArgs' resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param 'K8sJobSpecTemplateSpecContainerSecurityContextArgs' security_context: Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        :param 'K8sJobSpecTemplateSpecContainerStartupProbeArgs' startup_probe: StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param bool stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.  Defaults to `false`.
        :param bool stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Defaults to `false`.
        :param str termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Defaults to `/dev/termination-log`.
        :param str termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        :param bool tty: Whether this container should allocate a TTY for itself Defaults to `false`.
        :param Sequence['K8sJobSpecTemplateSpecContainerVolumeMountArgs'] volume_mounts: Pod volumes to mount into the container's filesystem. Cannot be updated.
        :param str working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if termination_message_policy is not None:
            pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container specified as a DNS*LABEL. Each container in a pod must have a unique name (DNS*LABEL). Cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerEnvFrom']]:
        """
        List of sources to populate environment variables in the container. The keys defined within a source must be a C*IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        """
        return pulumi.get(self, "env_froms")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerEnv']]:
        """
        List of environment variables to set in the container. Cannot be updated.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[str]:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerLifecycle']:
        """
        Actions that the management system should take in response to container lifecycle events
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerLivenessProbe']:
        """
        Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerPort']]:
        """
        List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerReadinessProbe']:
        """
        Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerResources']:
        """
        Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerSecurityContext']:
        """
        Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerStartupProbe']:
        """
        StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[bool]:
        """
        Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.  Defaults to `false`.
        """
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[bool]:
        """
        Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Defaults to `false`.
        """
        return pulumi.get(self, "stdin_once")

    @property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[str]:
        """
        Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Defaults to `/dev/termination-log`.
        """
        return pulumi.get(self, "termination_message_path")

    @property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> Optional[str]:
        """
        Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_policy")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        """
        Whether this container should allocate a TTY for itself Defaults to `false`.
        """
        return pulumi.get(self, "tty")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerVolumeMount']]:
        """
        Pod volumes to mount into the container's filesystem. Cannot be updated.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueFrom":
            suggest = "value_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerEnv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerEnv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerEnv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFrom'] = None):
        """
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER
        :param str value: Variable references $(VAR*NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'K8sJobSpecTemplateSpecContainerEnvValueFromArgs' value_from: Source for the environment variable's value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR*NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFrom']:
        """
        Source for the environment variable's value
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnvFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapRef":
            suggest = "config_map_ref"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerEnvFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerEnvFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerEnvFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_ref: Optional['outputs.K8sJobSpecTemplateSpecContainerEnvFromConfigMapRef'] = None,
                 prefix: Optional[str] = None,
                 secret_ref: Optional['outputs.K8sJobSpecTemplateSpecContainerEnvFromSecretRef'] = None):
        """
        :param 'K8sJobSpecTemplateSpecContainerEnvFromConfigMapRefArgs' config_map_ref: The ConfigMap to select from
        :param str prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        :param 'K8sJobSpecTemplateSpecContainerEnvFromSecretRefArgs' secret_ref: The Secret to select from
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerEnvFromConfigMapRef']:
        """
        The ConfigMap to select from
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerEnvFromSecretRef']:
        """
        The Secret to select from
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnvFromConfigMapRef(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnvFromSecretRef(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnvValueFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapKeyRef":
            suggest = "config_map_key_ref"
        elif key == "fieldRef":
            suggest = "field_ref"
        elif key == "resourceFieldRef":
            suggest = "resource_field_ref"
        elif key == "secretKeyRef":
            suggest = "secret_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerEnvValueFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerEnvValueFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerEnvValueFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRef'] = None):
        """
        :param 'K8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'K8sJobSpecTemplateSpecContainerEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        :param 'K8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'K8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnvValueFromFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerEnvValueFromFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerEnvValueFromFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerEnvValueFromFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        :param str divisor: Defaults to `1`.
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "divisor")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key of the secret to select from. Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the secret to select from. Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecycle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postStarts":
            suggest = "post_starts"
        elif key == "preStops":
            suggest = "pre_stops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerLifecycle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerLifecycle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerLifecycle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_starts: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStart']] = None,
                 pre_stops: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStop']] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecContainerLifecyclePostStartArgs'] post_starts: post*start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        :param Sequence['K8sJobSpecTemplateSpecContainerLifecyclePreStopArgs'] pre_stops: pre*stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStart']]:
        """
        post*start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "post_starts")

    @property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStop']]:
        """
        pre*stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "pre_stops")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePostStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerLifecyclePostStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerLifecyclePostStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerLifecyclePostStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStartExec'] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGet'] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocket']] = None):
        """
        :param 'K8sJobSpecTemplateSpecContainerLifecyclePostStartExecArgs' exec_: exec specifies the action to take.
        :param 'K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['K8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStartExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePostStartExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePreStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerLifecyclePreStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerLifecyclePreStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerLifecyclePreStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStopExec'] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGet'] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocket']] = None):
        """
        :param 'K8sJobSpecTemplateSpecContainerLifecyclePreStopExecArgs' exec_: exec specifies the action to take.
        :param 'K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['K8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStopExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePreStopExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sJobSpecTemplateSpecContainerLivenessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sJobSpecTemplateSpecContainerLivenessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sJobSpecTemplateSpecContainerLivenessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sJobSpecTemplateSpecContainerLivenessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLivenessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLivenessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLivenessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerLivenessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerLivenessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerLivenessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerLivenessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerPort":
            suggest = "container_port"
        elif key == "hostIp":
            suggest = "host_ip"
        elif key == "hostPort":
            suggest = "host_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_port: int,
                 host_ip: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param int container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        :param str host_ip: What host IP to bind the external port to.
        :param int host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        :param str name: If specified, this must be an IANA*SVC*NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        :param str protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP". Defaults to `TCP`.
        """
        pulumi.set(__self__, "container_port", container_port)
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[str]:
        """
        What host IP to bind the external port to.
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        If specified, this must be an IANA*SVC*NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for port. Must be UDP or TCP. Defaults to "TCP". Defaults to `TCP`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sJobSpecTemplateSpecContainerReadinessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sJobSpecTemplateSpecContainerReadinessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sJobSpecTemplateSpecContainerReadinessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sJobSpecTemplateSpecContainerReadinessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerReadinessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerReadinessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerReadinessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerReadinessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerReadinessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerReadinessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerReadinessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] limits: Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerSecurityContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPrivilegeEscalation":
            suggest = "allow_privilege_escalation"
        elif key == "readOnlyRootFilesystem":
            suggest = "read_only_root_filesystem"
        elif key == "runAsGroup":
            suggest = "run_as_group"
        elif key == "runAsNonRoot":
            suggest = "run_as_non_root"
        elif key == "runAsUser":
            suggest = "run_as_user"
        elif key == "seLinuxOptions":
            suggest = "se_linux_options"
        elif key == "seccompProfile":
            suggest = "seccomp_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerSecurityContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerSecurityContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerSecurityContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.K8sJobSpecTemplateSpecContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.K8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptions'] = None,
                 seccomp_profile: Optional['outputs.K8sJobSpecTemplateSpecContainerSecurityContextSeccompProfile'] = None):
        """
        :param bool allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no*new*privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP*SYS*ADMIN Defaults to `true`.
        :param 'K8sJobSpecTemplateSpecContainerSecurityContextCapabilitiesArgs' capabilities: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        :param bool privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Defaults to `false`.
        :param bool read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false. Defaults to `false`.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'K8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'K8sJobSpecTemplateSpecContainerSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        """
        AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no*new*privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP*SYS*ADMIN Defaults to `true`.
        """
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerSecurityContextCapabilities']:
        """
        The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        """
        Whether this container has a read-only root filesystem. Default is false. Defaults to `false`.
        """
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptions']:
        """
        The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerSecurityContextSeccompProfile']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 adds: Optional[Sequence[str]] = None,
                 drops: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] adds: Added capabilities
        :param Sequence[str] drops: Removed capabilities
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[Sequence[str]]:
        """
        Added capabilities
        """
        return pulumi.get(self, "adds")

    @property
    @pulumi.getter
    def drops(self) -> Optional[Sequence[str]]:
        """
        Removed capabilities
        """
        return pulumi.get(self, "drops")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerSecurityContextSeccompProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localhostProfile":
            suggest = "localhost_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerSecurityContextSeccompProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerSecurityContextSeccompProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerSecurityContextSeccompProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerStartupProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerStartupProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerStartupProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerStartupProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecContainerStartupProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerStartupProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecContainerStartupProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerStartupProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sJobSpecTemplateSpecContainerStartupProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sJobSpecTemplateSpecContainerStartupProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sJobSpecTemplateSpecContainerStartupProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sJobSpecTemplateSpecContainerStartupProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerStartupProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerStartupProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecContainerStartupProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerStartupProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerStartupProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerStartupProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerStartupProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerStartupProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerStartupProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerStartupProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerStartupProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecContainerVolumeMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "mountPropagation":
            suggest = "mount_propagation"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "subPath":
            suggest = "sub_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecContainerVolumeMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecContainerVolumeMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecContainerVolumeMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None):
        """
        :param str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Defaults to `None`.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Defaults to `false`.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Defaults to `None`.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class K8sJobSpecTemplateSpecDnsConfig(dict):
    def __init__(__self__, *,
                 nameservers: Optional[Sequence[str]] = None,
                 options: Optional[Sequence['outputs.K8sJobSpecTemplateSpecDnsConfigOption']] = None,
                 searches: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] nameservers: A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        :param Sequence['K8sJobSpecTemplateSpecDnsConfigOptionArgs'] options: A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        :param Sequence[str] searches: A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        """
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)

    @property
    @pulumi.getter
    def nameservers(self) -> Optional[Sequence[str]]:
        """
        A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        """
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecDnsConfigOption']]:
        """
        A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def searches(self) -> Optional[Sequence[str]]:
        """
        A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        """
        return pulumi.get(self, "searches")


@pulumi.output_type
class K8sJobSpecTemplateSpecDnsConfigOption(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: Name of the option.
        :param str value: Value of the option. Optional: Defaults to empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the option.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the option. Optional: Defaults to empty.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecHostAlias(dict):
    def __init__(__self__, *,
                 hostnames: Sequence[str],
                 ip: str):
        """
        :param Sequence[str] hostnames: Hostnames for the IP address.
        :param str ip: IP address of the host file entry.
        """
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        Hostnames for the IP address.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address of the host file entry.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class K8sJobSpecTemplateSpecImagePullSecret(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envFroms":
            suggest = "env_froms"
        elif key == "imagePullPolicy":
            suggest = "image_pull_policy"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "securityContext":
            suggest = "security_context"
        elif key == "startupProbe":
            suggest = "startup_probe"
        elif key == "stdinOnce":
            suggest = "stdin_once"
        elif key == "terminationMessagePath":
            suggest = "termination_message_path"
        elif key == "terminationMessagePolicy":
            suggest = "termination_message_policy"
        elif key == "volumeMounts":
            suggest = "volume_mounts"
        elif key == "workingDir":
            suggest = "working_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 env_froms: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerEnvFrom']] = None,
                 envs: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerEnv']] = None,
                 image: Optional[str] = None,
                 image_pull_policy: Optional[str] = None,
                 lifecycle: Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecycle'] = None,
                 liveness_probe: Optional['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbe'] = None,
                 ports: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerPort']] = None,
                 readiness_probe: Optional['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbe'] = None,
                 resources: Optional['outputs.K8sJobSpecTemplateSpecInitContainerResources'] = None,
                 security_context: Optional['outputs.K8sJobSpecTemplateSpecInitContainerSecurityContext'] = None,
                 startup_probe: Optional['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbe'] = None,
                 stdin: Optional[bool] = None,
                 stdin_once: Optional[bool] = None,
                 termination_message_path: Optional[str] = None,
                 termination_message_policy: Optional[str] = None,
                 tty: Optional[bool] = None,
                 volume_mounts: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerVolumeMount']] = None,
                 working_dir: Optional[str] = None):
        """
        :param str name: Name of the container specified as a DNS*LABEL. Each container in a pod must have a unique name (DNS*LABEL). Cannot be updated.
        :param Sequence[str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence[str] commands: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence['K8sJobSpecTemplateSpecInitContainerEnvFromArgs'] env_froms: List of sources to populate environment variables in the container. The keys defined within a source must be a C*IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerEnvArgs'] envs: List of environment variables to set in the container. Cannot be updated.
        :param str image: Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        :param 'K8sJobSpecTemplateSpecInitContainerLifecycleArgs' lifecycle: Actions that the management system should take in response to container lifecycle events
        :param 'K8sJobSpecTemplateSpecInitContainerLivenessProbeArgs' liveness_probe: Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param Sequence['K8sJobSpecTemplateSpecInitContainerPortArgs'] ports: List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        :param 'K8sJobSpecTemplateSpecInitContainerReadinessProbeArgs' readiness_probe: Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param 'K8sJobSpecTemplateSpecInitContainerResourcesArgs' resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param 'K8sJobSpecTemplateSpecInitContainerSecurityContextArgs' security_context: Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        :param 'K8sJobSpecTemplateSpecInitContainerStartupProbeArgs' startup_probe: StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param bool stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.  Defaults to `false`.
        :param bool stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Defaults to `false`.
        :param str termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Defaults to `/dev/termination-log`.
        :param str termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        :param bool tty: Whether this container should allocate a TTY for itself Defaults to `false`.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerVolumeMountArgs'] volume_mounts: Pod volumes to mount into the container's filesystem. Cannot be updated.
        :param str working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if termination_message_policy is not None:
            pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container specified as a DNS*LABEL. Each container in a pod must have a unique name (DNS*LABEL). Cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR*NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerEnvFrom']]:
        """
        List of sources to populate environment variables in the container. The keys defined within a source must be a C*IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        """
        return pulumi.get(self, "env_froms")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerEnv']]:
        """
        List of environment variables to set in the container. Cannot be updated.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[str]:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecycle']:
        """
        Actions that the management system should take in response to container lifecycle events
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbe']:
        """
        Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerPort']]:
        """
        List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbe']:
        """
        Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerResources']:
        """
        Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerSecurityContext']:
        """
        Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbe']:
        """
        StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[bool]:
        """
        Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.  Defaults to `false`.
        """
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[bool]:
        """
        Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Defaults to `false`.
        """
        return pulumi.get(self, "stdin_once")

    @property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[str]:
        """
        Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated. Defaults to `/dev/termination-log`.
        """
        return pulumi.get(self, "termination_message_path")

    @property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> Optional[str]:
        """
        Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_policy")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        """
        Whether this container should allocate a TTY for itself Defaults to `false`.
        """
        return pulumi.get(self, "tty")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerVolumeMount']]:
        """
        Pod volumes to mount into the container's filesystem. Cannot be updated.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueFrom":
            suggest = "value_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerEnv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFrom'] = None):
        """
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER
        :param str value: Variable references $(VAR*NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'K8sJobSpecTemplateSpecInitContainerEnvValueFromArgs' value_from: Source for the environment variable's value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR*NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFrom']:
        """
        Source for the environment variable's value
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnvFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapRef":
            suggest = "config_map_ref"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerEnvFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnvFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnvFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_ref: Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRef'] = None,
                 prefix: Optional[str] = None,
                 secret_ref: Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvFromSecretRef'] = None):
        """
        :param 'K8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRefArgs' config_map_ref: The ConfigMap to select from
        :param str prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        :param 'K8sJobSpecTemplateSpecInitContainerEnvFromSecretRefArgs' secret_ref: The Secret to select from
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRef']:
        """
        The ConfigMap to select from
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvFromSecretRef']:
        """
        The Secret to select from
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRef(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnvFromSecretRef(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnvValueFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMapKeyRef":
            suggest = "config_map_key_ref"
        elif key == "fieldRef":
            suggest = "field_ref"
        elif key == "resourceFieldRef":
            suggest = "resource_field_ref"
        elif key == "secretKeyRef":
            suggest = "secret_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerEnvValueFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnvValueFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnvValueFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRef'] = None):
        """
        :param 'K8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'K8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        :param 'K8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'K8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        :param str divisor: Defaults to `1`.
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "divisor")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key of the secret to select from. Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the secret to select from. Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecycle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postStarts":
            suggest = "post_starts"
        elif key == "preStops":
            suggest = "pre_stops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerLifecycle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecycle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecycle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_starts: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStart']] = None,
                 pre_stops: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStop']] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLifecyclePostStartArgs'] post_starts: post*start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLifecyclePreStopArgs'] pre_stops: pre*stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStart']]:
        """
        post*start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "post_starts")

    @property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStop']]:
        """
        pre*stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "pre_stops")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePostStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerLifecyclePostStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecyclePostStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecyclePostStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStartExec'] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGet'] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocket']] = None):
        """
        :param 'K8sJobSpecTemplateSpecInitContainerLifecyclePostStartExecArgs' exec_: exec specifies the action to take.
        :param 'K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStartExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePostStartExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePreStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerLifecyclePreStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecyclePreStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecyclePreStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStopExec'] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGet'] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocket']] = None):
        """
        :param 'K8sJobSpecTemplateSpecInitContainerLifecyclePreStopExecArgs' exec_: exec specifies the action to take.
        :param 'K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStopExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePreStopExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sJobSpecTemplateSpecInitContainerLivenessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLivenessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLivenessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLivenessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerPort":
            suggest = "container_port"
        elif key == "hostIp":
            suggest = "host_ip"
        elif key == "hostPort":
            suggest = "host_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_port: int,
                 host_ip: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param int container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        :param str host_ip: What host IP to bind the external port to.
        :param int host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        :param str name: If specified, this must be an IANA*SVC*NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        :param str protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP". Defaults to `TCP`.
        """
        pulumi.set(__self__, "container_port", container_port)
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[str]:
        """
        What host IP to bind the external port to.
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        If specified, this must be an IANA*SVC*NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for port. Must be UDP or TCP. Defaults to "TCP". Defaults to `TCP`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sJobSpecTemplateSpecInitContainerReadinessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerReadinessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerReadinessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerReadinessProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] limits: Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerSecurityContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPrivilegeEscalation":
            suggest = "allow_privilege_escalation"
        elif key == "readOnlyRootFilesystem":
            suggest = "read_only_root_filesystem"
        elif key == "runAsGroup":
            suggest = "run_as_group"
        elif key == "runAsNonRoot":
            suggest = "run_as_non_root"
        elif key == "runAsUser":
            suggest = "run_as_user"
        elif key == "seLinuxOptions":
            suggest = "se_linux_options"
        elif key == "seccompProfile":
            suggest = "seccomp_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerSecurityContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerSecurityContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerSecurityContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.K8sJobSpecTemplateSpecInitContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.K8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptions'] = None,
                 seccomp_profile: Optional['outputs.K8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfile'] = None):
        """
        :param bool allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no*new*privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP*SYS*ADMIN Defaults to `true`.
        :param 'K8sJobSpecTemplateSpecInitContainerSecurityContextCapabilitiesArgs' capabilities: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        :param bool privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Defaults to `false`.
        :param bool read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false. Defaults to `false`.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'K8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'K8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        """
        AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no*new*privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP*SYS*ADMIN Defaults to `true`.
        """
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerSecurityContextCapabilities']:
        """
        The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        """
        Whether this container has a read-only root filesystem. Default is false. Defaults to `false`.
        """
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptions']:
        """
        The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfile']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 adds: Optional[Sequence[str]] = None,
                 drops: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] adds: Added capabilities
        :param Sequence[str] drops: Removed capabilities
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[Sequence[str]]:
        """
        Added capabilities
        """
        return pulumi.get(self, "adds")

    @property
    @pulumi.getter
    def drops(self) -> Optional[Sequence[str]]:
        """
        Removed capabilities
        """
        return pulumi.get(self, "drops")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localhostProfile":
            suggest = "localhost_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerStartupProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSockets":
            suggest = "tcp_sockets"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerStartupProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerStartupProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerStartupProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeGrpc']] = None,
                 http_get: Optional['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocket']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'K8sJobSpecTemplateSpecInitContainerStartupProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerStartupProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe Defaults to `10`.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeExec']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to `3`.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeGrpc']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGet']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe Defaults to `10`.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to `1`.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocket']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes Defaults to `1`.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerStartupProbeExec(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerStartupProbeGrpc(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        :param str scheme: Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to `HTTP`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocket(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA*SVC*NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class K8sJobSpecTemplateSpecInitContainerVolumeMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "mountPropagation":
            suggest = "mount_propagation"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "subPath":
            suggest = "sub_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecInitContainerVolumeMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecInitContainerVolumeMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecInitContainerVolumeMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None):
        """
        :param str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Defaults to `None`.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Defaults to `false`.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional. Defaults to `None`.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. Defaults to `false`.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class K8sJobSpecTemplateSpecReadinessGate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecReadinessGate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecReadinessGate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecReadinessGate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str):
        """
        :param str condition_type: refers to a condition in the pod's condition list with matching type.
        """
        pulumi.set(__self__, "condition_type", condition_type)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """
        refers to a condition in the pod's condition list with matching type.
        """
        return pulumi.get(self, "condition_type")


@pulumi.output_type
class K8sJobSpecTemplateSpecSecurityContext(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsGroup":
            suggest = "fs_group"
        elif key == "fsGroupChangePolicy":
            suggest = "fs_group_change_policy"
        elif key == "runAsGroup":
            suggest = "run_as_group"
        elif key == "runAsNonRoot":
            suggest = "run_as_non_root"
        elif key == "runAsUser":
            suggest = "run_as_user"
        elif key == "seLinuxOptions":
            suggest = "se_linux_options"
        elif key == "seccompProfile":
            suggest = "seccomp_profile"
        elif key == "supplementalGroups":
            suggest = "supplemental_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecSecurityContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecSecurityContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecSecurityContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fs_group: Optional[str] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.K8sJobSpecTemplateSpecSecurityContextSeLinuxOptions'] = None,
                 seccomp_profile: Optional['outputs.K8sJobSpecTemplateSpecSecurityContextSeccompProfile'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.K8sJobSpecTemplateSpecSecurityContextSysctl']] = None):
        """
        :param str fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        :param str fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param 'K8sJobSpecTemplateSpecSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param 'K8sJobSpecTemplateSpecSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        :param Sequence[int] supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container.
        :param Sequence['K8sJobSpecTemplateSpecSecurityContextSysctlArgs'] sysctls: holds a list of namespaced sysctls used for the pod.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[str]:
        """
        A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        """
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        """
        fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
        """
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.K8sJobSpecTemplateSpecSecurityContextSeLinuxOptions']:
        """
        The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.K8sJobSpecTemplateSpecSecurityContextSeccompProfile']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        """
        A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container.
        """
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecSecurityContextSysctl']]:
        """
        holds a list of namespaced sysctls used for the pod.
        """
        return pulumi.get(self, "sysctls")


@pulumi.output_type
class K8sJobSpecTemplateSpecSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sJobSpecTemplateSpecSecurityContextSeccompProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localhostProfile":
            suggest = "localhost_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecSecurityContextSeccompProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecSecurityContextSeccompProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecSecurityContextSeccompProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Defaults to ``.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined. Defaults to `Unconfined`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class K8sJobSpecTemplateSpecSecurityContextSysctl(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of a property to set.
        :param str value: Value of a property to set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of a property to set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of a property to set.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecToleration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tolerationSeconds":
            suggest = "toleration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecToleration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecToleration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecToleration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param str key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param str operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Defaults to `Equal`.
        :param str toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param str value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. Defaults to `Equal`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[str]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class K8sJobSpecTemplateSpecTopologySpreadConstraint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSelectors":
            suggest = "label_selectors"
        elif key == "maxSkew":
            suggest = "max_skew"
        elif key == "topologyKey":
            suggest = "topology_key"
        elif key == "whenUnsatisfiable":
            suggest = "when_unsatisfiable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecTopologySpreadConstraint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecTopologySpreadConstraint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecTopologySpreadConstraint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_selectors: Optional[Sequence['outputs.K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelector']] = None,
                 max_skew: Optional[int] = None,
                 topology_key: Optional[str] = None,
                 when_unsatisfiable: Optional[str] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param int max_skew: describes the degree to which pods may be unevenly distributed. Defaults to `1`.
        :param str topology_key: the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology.
        :param str when_unsatisfiable: indicates how to deal with a pod if it doesn't satisfy the spread constraint. Defaults to `DoNotSchedule`.
        """
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)
        if max_skew is not None:
            pulumi.set(__self__, "max_skew", max_skew)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)
        if when_unsatisfiable is not None:
            pulumi.set(__self__, "when_unsatisfiable", when_unsatisfiable)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelector']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter(name="maxSkew")
    def max_skew(self) -> Optional[int]:
        """
        describes the degree to which pods may be unevenly distributed. Defaults to `1`.
        """
        return pulumi.get(self, "max_skew")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology.
        """
        return pulumi.get(self, "topology_key")

    @property
    @pulumi.getter(name="whenUnsatisfiable")
    def when_unsatisfiable(self) -> Optional[str]:
        """
        indicates how to deal with a pod if it doesn't satisfy the spread constraint. Defaults to `DoNotSchedule`.
        """
        return pulumi.get(self, "when_unsatisfiable")


@pulumi.output_type
class K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpression']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class K8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsElasticBlockStore":
            suggest = "aws_elastic_block_store"
        elif key == "azureDisk":
            suggest = "azure_disk"
        elif key == "azureFile":
            suggest = "azure_file"
        elif key == "cephFs":
            suggest = "ceph_fs"
        elif key == "configMap":
            suggest = "config_map"
        elif key == "downwardApi":
            suggest = "downward_api"
        elif key == "emptyDir":
            suggest = "empty_dir"
        elif key == "flexVolume":
            suggest = "flex_volume"
        elif key == "gcePersistentDisk":
            suggest = "gce_persistent_disk"
        elif key == "gitRepo":
            suggest = "git_repo"
        elif key == "hostPath":
            suggest = "host_path"
        elif key == "persistentVolumeClaim":
            suggest = "persistent_volume_claim"
        elif key == "photonPersistentDisk":
            suggest = "photon_persistent_disk"
        elif key == "vsphereVolume":
            suggest = "vsphere_volume"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_elastic_block_store: Optional['outputs.K8sJobSpecTemplateSpecVolumeAwsElasticBlockStore'] = None,
                 azure_disk: Optional['outputs.K8sJobSpecTemplateSpecVolumeAzureDisk'] = None,
                 azure_file: Optional['outputs.K8sJobSpecTemplateSpecVolumeAzureFile'] = None,
                 ceph_fs: Optional['outputs.K8sJobSpecTemplateSpecVolumeCephFs'] = None,
                 cinder: Optional['outputs.K8sJobSpecTemplateSpecVolumeCinder'] = None,
                 config_map: Optional['outputs.K8sJobSpecTemplateSpecVolumeConfigMap'] = None,
                 csi: Optional['outputs.K8sJobSpecTemplateSpecVolumeCsi'] = None,
                 downward_api: Optional['outputs.K8sJobSpecTemplateSpecVolumeDownwardApi'] = None,
                 empty_dir: Optional['outputs.K8sJobSpecTemplateSpecVolumeEmptyDir'] = None,
                 ephemeral: Optional['outputs.K8sJobSpecTemplateSpecVolumeEphemeral'] = None,
                 fc: Optional['outputs.K8sJobSpecTemplateSpecVolumeFc'] = None,
                 flex_volume: Optional['outputs.K8sJobSpecTemplateSpecVolumeFlexVolume'] = None,
                 flocker: Optional['outputs.K8sJobSpecTemplateSpecVolumeFlocker'] = None,
                 gce_persistent_disk: Optional['outputs.K8sJobSpecTemplateSpecVolumeGcePersistentDisk'] = None,
                 git_repo: Optional['outputs.K8sJobSpecTemplateSpecVolumeGitRepo'] = None,
                 glusterfs: Optional['outputs.K8sJobSpecTemplateSpecVolumeGlusterfs'] = None,
                 host_path: Optional['outputs.K8sJobSpecTemplateSpecVolumeHostPath'] = None,
                 iscsi: Optional['outputs.K8sJobSpecTemplateSpecVolumeIscsi'] = None,
                 local: Optional['outputs.K8sJobSpecTemplateSpecVolumeLocal'] = None,
                 name: Optional[str] = None,
                 nfs: Optional['outputs.K8sJobSpecTemplateSpecVolumeNfs'] = None,
                 persistent_volume_claim: Optional['outputs.K8sJobSpecTemplateSpecVolumePersistentVolumeClaim'] = None,
                 photon_persistent_disk: Optional['outputs.K8sJobSpecTemplateSpecVolumePhotonPersistentDisk'] = None,
                 projected: Optional['outputs.K8sJobSpecTemplateSpecVolumeProjected'] = None,
                 quobyte: Optional['outputs.K8sJobSpecTemplateSpecVolumeQuobyte'] = None,
                 rbd: Optional['outputs.K8sJobSpecTemplateSpecVolumeRbd'] = None,
                 secret: Optional['outputs.K8sJobSpecTemplateSpecVolumeSecret'] = None,
                 vsphere_volume: Optional['outputs.K8sJobSpecTemplateSpecVolumeVsphereVolume'] = None):
        """
        :param 'K8sJobSpecTemplateSpecVolumeAwsElasticBlockStoreArgs' aws_elastic_block_store: Represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param 'K8sJobSpecTemplateSpecVolumeAzureDiskArgs' azure_disk: Represents an Azure Data Disk mount on the host and bind mount to the pod.
        :param 'K8sJobSpecTemplateSpecVolumeAzureFileArgs' azure_file: Represents an Azure File Service mount on the host and bind mount to the pod.
        :param 'K8sJobSpecTemplateSpecVolumeCephFsArgs' ceph_fs: Represents a Ceph FS mount on the host that shares a pod's lifetime
        :param 'K8sJobSpecTemplateSpecVolumeCinderArgs' cinder: Represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param 'K8sJobSpecTemplateSpecVolumeConfigMapArgs' config_map: ConfigMap represents a configMap that should populate this volume
        :param 'K8sJobSpecTemplateSpecVolumeCsiArgs' csi: Represents a CSI Volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        :param 'K8sJobSpecTemplateSpecVolumeDownwardApiArgs' downward_api: DownwardAPI represents downward API about the pod that should populate this volume
        :param 'K8sJobSpecTemplateSpecVolumeEmptyDirArgs' empty_dir: EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        :param 'K8sJobSpecTemplateSpecVolumeEphemeralArgs' ephemeral: Represents an ephemeral volume that is handled by a normal storage driver. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
        :param 'K8sJobSpecTemplateSpecVolumeFcArgs' fc: Represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        :param 'K8sJobSpecTemplateSpecVolumeFlexVolumeArgs' flex_volume: Represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
        :param 'K8sJobSpecTemplateSpecVolumeFlockerArgs' flocker: Represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
        :param 'K8sJobSpecTemplateSpecVolumeGcePersistentDiskArgs' gce_persistent_disk: Represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param 'K8sJobSpecTemplateSpecVolumeGitRepoArgs' git_repo: GitRepo represents a git repository at a particular revision.
        :param 'K8sJobSpecTemplateSpecVolumeGlusterfsArgs' glusterfs: Represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        :param 'K8sJobSpecTemplateSpecVolumeHostPathArgs' host_path: Represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        :param 'K8sJobSpecTemplateSpecVolumeIscsiArgs' iscsi: Represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
        :param 'K8sJobSpecTemplateSpecVolumeLocalArgs' local: Represents a mounted local storage device such as a disk, partition or directory. Local volumes can only be used as a statically created PersistentVolume. Dynamic provisioning is not supported yet. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        :param str name: Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param 'K8sJobSpecTemplateSpecVolumeNfsArgs' nfs: Represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param 'K8sJobSpecTemplateSpecVolumePersistentVolumeClaimArgs' persistent_volume_claim: The specification of a persistent volume.
        :param 'K8sJobSpecTemplateSpecVolumePhotonPersistentDiskArgs' photon_persistent_disk: Represents a PhotonController persistent disk attached and mounted on kubelets host machine
        :param 'K8sJobSpecTemplateSpecVolumeProjectedArgs' projected: Projected represents a single volume that projects several volume sources into the same directory. More info: https://kubernetes.io/docs/concepts/storage/volumes/#projected
        :param 'K8sJobSpecTemplateSpecVolumeQuobyteArgs' quobyte: Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        :param 'K8sJobSpecTemplateSpecVolumeRbdArgs' rbd: Represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        :param 'K8sJobSpecTemplateSpecVolumeSecretArgs' secret: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param 'K8sJobSpecTemplateSpecVolumeVsphereVolumeArgs' vsphere_volume: Represents a vSphere volume attached and mounted on kubelets host machine
        """
        if aws_elastic_block_store is not None:
            pulumi.set(__self__, "aws_elastic_block_store", aws_elastic_block_store)
        if azure_disk is not None:
            pulumi.set(__self__, "azure_disk", azure_disk)
        if azure_file is not None:
            pulumi.set(__self__, "azure_file", azure_file)
        if ceph_fs is not None:
            pulumi.set(__self__, "ceph_fs", ceph_fs)
        if cinder is not None:
            pulumi.set(__self__, "cinder", cinder)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if csi is not None:
            pulumi.set(__self__, "csi", csi)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if ephemeral is not None:
            pulumi.set(__self__, "ephemeral", ephemeral)
        if fc is not None:
            pulumi.set(__self__, "fc", fc)
        if flex_volume is not None:
            pulumi.set(__self__, "flex_volume", flex_volume)
        if flocker is not None:
            pulumi.set(__self__, "flocker", flocker)
        if gce_persistent_disk is not None:
            pulumi.set(__self__, "gce_persistent_disk", gce_persistent_disk)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if glusterfs is not None:
            pulumi.set(__self__, "glusterfs", glusterfs)
        if host_path is not None:
            pulumi.set(__self__, "host_path", host_path)
        if iscsi is not None:
            pulumi.set(__self__, "iscsi", iscsi)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if photon_persistent_disk is not None:
            pulumi.set(__self__, "photon_persistent_disk", photon_persistent_disk)
        if projected is not None:
            pulumi.set(__self__, "projected", projected)
        if quobyte is not None:
            pulumi.set(__self__, "quobyte", quobyte)
        if rbd is not None:
            pulumi.set(__self__, "rbd", rbd)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if vsphere_volume is not None:
            pulumi.set(__self__, "vsphere_volume", vsphere_volume)

    @property
    @pulumi.getter(name="awsElasticBlockStore")
    def aws_elastic_block_store(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeAwsElasticBlockStore']:
        """
        Represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "aws_elastic_block_store")

    @property
    @pulumi.getter(name="azureDisk")
    def azure_disk(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeAzureDisk']:
        """
        Represents an Azure Data Disk mount on the host and bind mount to the pod.
        """
        return pulumi.get(self, "azure_disk")

    @property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeAzureFile']:
        """
        Represents an Azure File Service mount on the host and bind mount to the pod.
        """
        return pulumi.get(self, "azure_file")

    @property
    @pulumi.getter(name="cephFs")
    def ceph_fs(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeCephFs']:
        """
        Represents a Ceph FS mount on the host that shares a pod's lifetime
        """
        return pulumi.get(self, "ceph_fs")

    @property
    @pulumi.getter
    def cinder(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeCinder']:
        """
        Represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "cinder")

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeConfigMap']:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_map")

    @property
    @pulumi.getter
    def csi(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeCsi']:
        """
        Represents a CSI Volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        """
        return pulumi.get(self, "csi")

    @property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeDownwardApi']:
        """
        DownwardAPI represents downward API about the pod that should populate this volume
        """
        return pulumi.get(self, "downward_api")

    @property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeEmptyDir']:
        """
        EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        """
        return pulumi.get(self, "empty_dir")

    @property
    @pulumi.getter
    def ephemeral(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeEphemeral']:
        """
        Represents an ephemeral volume that is handled by a normal storage driver. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
        """
        return pulumi.get(self, "ephemeral")

    @property
    @pulumi.getter
    def fc(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeFc']:
        """
        Represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        """
        return pulumi.get(self, "fc")

    @property
    @pulumi.getter(name="flexVolume")
    def flex_volume(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeFlexVolume']:
        """
        Represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
        """
        return pulumi.get(self, "flex_volume")

    @property
    @pulumi.getter
    def flocker(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeFlocker']:
        """
        Represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
        """
        return pulumi.get(self, "flocker")

    @property
    @pulumi.getter(name="gcePersistentDisk")
    def gce_persistent_disk(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeGcePersistentDisk']:
        """
        Represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "gce_persistent_disk")

    @property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeGitRepo']:
        """
        GitRepo represents a git repository at a particular revision.
        """
        return pulumi.get(self, "git_repo")

    @property
    @pulumi.getter
    def glusterfs(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeGlusterfs']:
        """
        Represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        """
        return pulumi.get(self, "glusterfs")

    @property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeHostPath']:
        """
        Represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        """
        return pulumi.get(self, "host_path")

    @property
    @pulumi.getter
    def iscsi(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeIscsi']:
        """
        Represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
        """
        return pulumi.get(self, "iscsi")

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeLocal']:
        """
        Represents a mounted local storage device such as a disk, partition or directory. Local volumes can only be used as a statically created PersistentVolume. Dynamic provisioning is not supported yet. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def nfs(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeNfs']:
        """
        Represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "nfs")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumePersistentVolumeClaim']:
        """
        The specification of a persistent volume.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter(name="photonPersistentDisk")
    def photon_persistent_disk(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumePhotonPersistentDisk']:
        """
        Represents a PhotonController persistent disk attached and mounted on kubelets host machine
        """
        return pulumi.get(self, "photon_persistent_disk")

    @property
    @pulumi.getter
    def projected(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeProjected']:
        """
        Projected represents a single volume that projects several volume sources into the same directory. More info: https://kubernetes.io/docs/concepts/storage/volumes/#projected
        """
        return pulumi.get(self, "projected")

    @property
    @pulumi.getter
    def quobyte(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeQuobyte']:
        """
        Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        """
        return pulumi.get(self, "quobyte")

    @property
    @pulumi.getter
    def rbd(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeRbd']:
        """
        Represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        """
        return pulumi.get(self, "rbd")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeSecret']:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="vsphereVolume")
    def vsphere_volume(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeVsphereVolume']:
        """
        Represents a vSphere volume attached and mounted on kubelets host machine
        """
        return pulumi.get(self, "vsphere_volume")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeAwsElasticBlockStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeAwsElasticBlockStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeAwsElasticBlockStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeAwsElasticBlockStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_id: str,
                 fs_type: Optional[str] = None,
                 partition: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str volume_id: Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param int partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        :param bool read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        pulumi.set(__self__, "volume_id", volume_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def partition(self) -> Optional[int]:
        """
        The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeAzureDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachingMode":
            suggest = "caching_mode"
        elif key == "dataDiskUri":
            suggest = "data_disk_uri"
        elif key == "diskName":
            suggest = "disk_name"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeAzureDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeAzureDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeAzureDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caching_mode: str,
                 data_disk_uri: str,
                 disk_name: str,
                 fs_type: Optional[str] = None,
                 kind: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str caching_mode: Host Caching mode: None, Read Only, Read Write.
        :param str data_disk_uri: The URI the data disk in the blob storage
        :param str disk_name: The Name of the data disk in the blob storage
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param str kind: The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Defaults to `false`.
        """
        pulumi.set(__self__, "caching_mode", caching_mode)
        pulumi.set(__self__, "data_disk_uri", data_disk_uri)
        pulumi.set(__self__, "disk_name", disk_name)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="cachingMode")
    def caching_mode(self) -> str:
        """
        Host Caching mode: None, Read Only, Read Write.
        """
        return pulumi.get(self, "caching_mode")

    @property
    @pulumi.getter(name="dataDiskUri")
    def data_disk_uri(self) -> str:
        """
        The URI the data disk in the blob storage
        """
        return pulumi.get(self, "data_disk_uri")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> str:
        """
        The Name of the data disk in the blob storage
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). Defaults to `false`.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeAzureFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"
        elif key == "shareName":
            suggest = "share_name"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "secretNamespace":
            suggest = "secret_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeAzureFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeAzureFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeAzureFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: str,
                 share_name: str,
                 read_only: Optional[bool] = None,
                 secret_namespace: Optional[str] = None):
        """
        :param str secret_name: The name of secret that contains Azure Storage Account Name and Key
        :param str share_name: Share Name
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        :param str secret_namespace: The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.
        """
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "share_name", share_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_namespace is not None:
            pulumi.set(__self__, "secret_namespace", secret_namespace)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of secret that contains Azure Storage Account Name and Key
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        Share Name
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretNamespace")
    def secret_namespace(self) -> Optional[str]:
        """
        The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.
        """
        return pulumi.get(self, "secret_namespace")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeCephFs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"
        elif key == "secretFile":
            suggest = "secret_file"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeCephFs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeCephFs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeCephFs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitors: Sequence[str],
                 path: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 secret_file: Optional[str] = None,
                 secret_ref: Optional['outputs.K8sJobSpecTemplateSpecVolumeCephFsSecretRef'] = None,
                 user: Optional[str] = None):
        """
        :param Sequence[str] monitors: Monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str path: Used as the mounted root, rather than the full Ceph tree, default is /
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to `false` (read/write). More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str secret_file: The path to key ring for User, default is `/etc/ceph/user.secret`. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param 'K8sJobSpecTemplateSpecVolumeCephFsSecretRefArgs' secret_ref: Reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str user: User is the rados user name, default is admin. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        pulumi.set(__self__, "monitors", monitors)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_file is not None:
            pulumi.set(__self__, "secret_file", secret_file)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def monitors(self) -> Sequence[str]:
        """
        Monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "monitors")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Used as the mounted root, rather than the full Ceph tree, default is /
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to `false` (read/write). More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretFile")
    def secret_file(self) -> Optional[str]:
        """
        The path to key ring for User, default is `/etc/ceph/user.secret`. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_file")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeCephFsSecretRef']:
        """
        Reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is the rados user name, default is admin. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeCephFsSecretRef(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeCinder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeCinder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeCinder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeCinder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_id: str,
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str volume_id: Volume ID used to identify the volume in Cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        pulumi.set(__self__, "volume_id", volume_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        Volume ID used to identify the volume in Cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeConfigMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultMode":
            suggest = "default_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeConfigMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeConfigMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeConfigMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeConfigMapItem']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        :param Sequence['K8sJobSpecTemplateSpecVolumeConfigMapItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Optional: Specify whether the ConfigMap or its keys must be defined.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeConfigMapItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the ConfigMap or its keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeConfigMapItem(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeCsi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsType":
            suggest = "fs_type"
        elif key == "nodePublishSecretRef":
            suggest = "node_publish_secret_ref"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "volumeAttributes":
            suggest = "volume_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeCsi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeCsi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeCsi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver: str,
                 fs_type: Optional[str] = None,
                 node_publish_secret_ref: Optional['outputs.K8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRef'] = None,
                 read_only: Optional[bool] = None,
                 volume_attributes: Optional[Mapping[str, str]] = None):
        """
        :param str driver: the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param 'K8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRefArgs' node_publish_secret_ref: A reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls.
        :param bool read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        :param Mapping[str, str] volume_attributes: Attributes of the volume to publish.
        """
        pulumi.set(__self__, "driver", driver)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if node_publish_secret_ref is not None:
            pulumi.set(__self__, "node_publish_secret_ref", node_publish_secret_ref)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if volume_attributes is not None:
            pulumi.set(__self__, "volume_attributes", volume_attributes)

    @property
    @pulumi.getter
    def driver(self) -> str:
        """
        the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="nodePublishSecretRef")
    def node_publish_secret_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRef']:
        """
        A reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls.
        """
        return pulumi.get(self, "node_publish_secret_ref")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="volumeAttributes")
    def volume_attributes(self) -> Optional[Mapping[str, str]]:
        """
        Attributes of the volume to publish.
        """
        return pulumi.get(self, "volume_attributes")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRef(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeDownwardApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultMode":
            suggest = "default_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeDownwardApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeDownwardApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeDownwardApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeDownwardApiItem']] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        :param Sequence['K8sJobSpecTemplateSpecVolumeDownwardApiItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeDownwardApiItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeDownwardApiItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldRef":
            suggest = "field_ref"
        elif key == "resourceFieldRef":
            suggest = "resource_field_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeDownwardApiItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeDownwardApiItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeDownwardApiItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_ref: 'outputs.K8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRef',
                 path: str,
                 mode: Optional[str] = None,
                 resource_field_ref: Optional['outputs.K8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef'] = None):
        """
        :param 'K8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRefArgs' field_ref: Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        :param str path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param 'K8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        pulumi.set(__self__, "field_ref", field_ref)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> 'outputs.K8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRef':
        """
        Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1". Defaults to `v1`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 resource: str,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        :param str divisor: Defaults to `1`.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "resource", resource)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "divisor")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeEmptyDir(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeLimit":
            suggest = "size_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeEmptyDir. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeEmptyDir.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeEmptyDir.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 medium: Optional[str] = None,
                 size_limit: Optional[str] = None):
        """
        :param str medium: What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir Defaults to ``.
        :param str size_limit: Total amount of local storage required for this EmptyDir volume.
        """
        if medium is not None:
            pulumi.set(__self__, "medium", medium)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @property
    @pulumi.getter
    def medium(self) -> Optional[str]:
        """
        What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir Defaults to ``.
        """
        return pulumi.get(self, "medium")

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[str]:
        """
        Total amount of local storage required for this EmptyDir volume.
        """
        return pulumi.get(self, "size_limit")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeEphemeral(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeClaimTemplate":
            suggest = "volume_claim_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeEphemeral. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeEphemeral.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeEphemeral.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_claim_template: 'outputs.K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplate'):
        """
        :param 'K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateArgs' volume_claim_template: Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC.
        """
        pulumi.set(__self__, "volume_claim_template", volume_claim_template)

    @property
    @pulumi.getter(name="volumeClaimTemplate")
    def volume_claim_template(self) -> 'outputs.K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplate':
        """
        Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC.
        """
        return pulumi.get(self, "volume_claim_template")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplate(dict):
    def __init__(__self__, *,
                 spec: 'outputs.K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec',
                 metadata: Optional['outputs.K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadata'] = None):
        """
        :param 'K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecArgs' spec: The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
        :param 'K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataArgs' metadata: May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
        """
        pulumi.set(__self__, "spec", spec)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec':
        """
        The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadata']:
        """
        May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadata(dict):
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 labels: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the persistent volume claim. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the persistent volume claim that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the persistent volume claim. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessModes":
            suggest = "access_modes"
        elif key == "storageClassName":
            suggest = "storage_class_name"
        elif key == "volumeMode":
            suggest = "volume_mode"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_modes: Sequence[str],
                 resources: 'outputs.K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResources',
                 storage_class_name: Optional[str] = None,
                 volume_mode: Optional[str] = None,
                 volume_name: Optional[str] = None):
        """
        :param Sequence[str] access_modes: A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        :param 'K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesArgs' resources: A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        :param str storage_class_name: Name of the storage class requested by the claim
        :param str volume_mode: Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        :param str volume_name: The binding reference to the PersistentVolume backing this claim.
        """
        pulumi.set(__self__, "access_modes", access_modes)
        pulumi.set(__self__, "resources", resources)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)
        if volume_mode is not None:
            pulumi.set(__self__, "volume_mode", volume_mode)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Sequence[str]:
        """
        A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResources':
        """
        A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[str]:
        """
        Name of the storage class requested by the claim
        """
        return pulumi.get(self, "storage_class_name")

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> Optional[str]:
        """
        Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        """
        return pulumi.get(self, "volume_mode")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[str]:
        """
        The binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] limits: Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        :param Mapping[str, str] requests: Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeFc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetWwNs":
            suggest = "target_ww_ns"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeFc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeFc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeFc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lun: int,
                 target_ww_ns: Sequence[str],
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param int lun: FC target lun number
        :param Sequence[str] target_ww_ns: FC target worldwide names (WWNs)
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "target_ww_ns", target_ww_ns)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        FC target lun number
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="targetWwNs")
    def target_ww_ns(self) -> Sequence[str]:
        """
        FC target worldwide names (WWNs)
        """
        return pulumi.get(self, "target_ww_ns")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeFlexVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeFlexVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeFlexVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeFlexVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver: str,
                 fs_type: Optional[str] = None,
                 options: Optional[Mapping[str, str]] = None,
                 read_only: Optional[bool] = None,
                 secret_ref: Optional['outputs.K8sJobSpecTemplateSpecVolumeFlexVolumeSecretRef'] = None):
        """
        :param str driver: Driver is the name of the driver to use for this volume.
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        :param Mapping[str, str] options: Extra command options if any.
        :param bool read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).
        :param 'K8sJobSpecTemplateSpecVolumeFlexVolumeSecretRefArgs' secret_ref: Reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        """
        pulumi.set(__self__, "driver", driver)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter
    def driver(self) -> str:
        """
        Driver is the name of the driver to use for this volume.
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, str]]:
        """
        Extra command options if any.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeFlexVolumeSecretRef']:
        """
        Reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeFlexVolumeSecretRef(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeFlocker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetName":
            suggest = "dataset_name"
        elif key == "datasetUuid":
            suggest = "dataset_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeFlocker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeFlocker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeFlocker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_name: Optional[str] = None,
                 dataset_uuid: Optional[str] = None):
        """
        :param str dataset_name: Name of the dataset stored as metadata > name on the dataset for Flocker should be considered as deprecated
        :param str dataset_uuid: UUID of the dataset. This is unique identifier of a Flocker dataset
        """
        if dataset_name is not None:
            pulumi.set(__self__, "dataset_name", dataset_name)
        if dataset_uuid is not None:
            pulumi.set(__self__, "dataset_uuid", dataset_uuid)

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[str]:
        """
        Name of the dataset stored as metadata > name on the dataset for Flocker should be considered as deprecated
        """
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="datasetUuid")
    def dataset_uuid(self) -> Optional[str]:
        """
        UUID of the dataset. This is unique identifier of a Flocker dataset
        """
        return pulumi.get(self, "dataset_uuid")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeGcePersistentDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pdName":
            suggest = "pd_name"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeGcePersistentDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeGcePersistentDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeGcePersistentDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pd_name: str,
                 fs_type: Optional[str] = None,
                 partition: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str pd_name: Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param int partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param bool read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        pulumi.set(__self__, "pd_name", pd_name)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="pdName")
    def pd_name(self) -> str:
        """
        Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "pd_name")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def partition(self) -> Optional[int]:
        """
        The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeGitRepo(dict):
    def __init__(__self__, *,
                 directory: Optional[str] = None,
                 repository: Optional[str] = None,
                 revision: Optional[str] = None):
        """
        :param str directory: Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        :param str repository: Repository URL
        :param str revision: Commit hash for the specified revision.
        """
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        Repository URL
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def revision(self) -> Optional[str]:
        """
        Commit hash for the specified revision.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeGlusterfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointsName":
            suggest = "endpoints_name"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeGlusterfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeGlusterfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeGlusterfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoints_name: str,
                 path: str,
                 read_only: Optional[bool] = None):
        """
        :param str endpoints_name: The endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        :param str path: The Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        :param bool read_only: Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        pulumi.set(__self__, "endpoints_name", endpoints_name)
        pulumi.set(__self__, "path", path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="endpointsName")
    def endpoints_name(self) -> str:
        """
        The endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "endpoints_name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeHostPath(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str path: Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        :param str type: Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeIscsi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPortal":
            suggest = "target_portal"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "iscsiInterface":
            suggest = "iscsi_interface"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeIscsi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeIscsi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeIscsi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iqn: str,
                 target_portal: str,
                 fs_type: Optional[str] = None,
                 iscsi_interface: Optional[str] = None,
                 lun: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str iqn: Target iSCSI Qualified Name.
        :param str target_portal: iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        :param str iscsi_interface: iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp). Defaults to `default`.
        :param int lun: iSCSI target lun number.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false.
        """
        pulumi.set(__self__, "iqn", iqn)
        pulumi.set(__self__, "target_portal", target_portal)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if iscsi_interface is not None:
            pulumi.set(__self__, "iscsi_interface", iscsi_interface)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def iqn(self) -> str:
        """
        Target iSCSI Qualified Name.
        """
        return pulumi.get(self, "iqn")

    @property
    @pulumi.getter(name="targetPortal")
    def target_portal(self) -> str:
        """
        iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        """
        return pulumi.get(self, "target_portal")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="iscsiInterface")
    def iscsi_interface(self) -> Optional[str]:
        """
        iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp). Defaults to `default`.
        """
        return pulumi.get(self, "iscsi_interface")

    @property
    @pulumi.getter
    def lun(self) -> Optional[int]:
        """
        iSCSI target lun number.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeLocal(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None):
        """
        :param str path: Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeNfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeNfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeNfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeNfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 server: str,
                 read_only: Optional[bool] = None):
        """
        :param str path: Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param str server: Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param bool read_only: Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "server", server)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumePersistentVolumeClaim(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "claimName":
            suggest = "claim_name"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumePersistentVolumeClaim. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumePersistentVolumeClaim.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumePersistentVolumeClaim.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 claim_name: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str claim_name: ClaimName is the name of a PersistentVolumeClaim in the same
        :param bool read_only: Will force the ReadOnly setting in VolumeMounts. Defaults to `false`.
        """
        if claim_name is not None:
            pulumi.set(__self__, "claim_name", claim_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> Optional[str]:
        """
        ClaimName is the name of a PersistentVolumeClaim in the same
        """
        return pulumi.get(self, "claim_name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Will force the ReadOnly setting in VolumeMounts. Defaults to `false`.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumePhotonPersistentDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pdId":
            suggest = "pd_id"
        elif key == "fsType":
            suggest = "fs_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumePhotonPersistentDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumePhotonPersistentDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumePhotonPersistentDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pd_id: str,
                 fs_type: Optional[str] = None):
        """
        :param str pd_id: ID that identifies Photon Controller persistent disk
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        pulumi.set(__self__, "pd_id", pd_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)

    @property
    @pulumi.getter(name="pdId")
    def pd_id(self) -> str:
        """
        ID that identifies Photon Controller persistent disk
        """
        return pulumi.get(self, "pd_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjected(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultMode":
            suggest = "default_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeProjected. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeProjected.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeProjected.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSource'],
                 default_mode: Optional[str] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecVolumeProjectedSourceArgs'] sources: Source of the volume to project in the directory.
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        pulumi.set(__self__, "sources", sources)
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSource']:
        """
        Source of the volume to project in the directory.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        return pulumi.get(self, "default_mode")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMaps":
            suggest = "config_maps"
        elif key == "downwardApi":
            suggest = "downward_api"
        elif key == "serviceAccountToken":
            suggest = "service_account_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeProjectedSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_maps: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMap']] = None,
                 downward_api: Optional['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApi'] = None,
                 secrets: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceSecret']] = None,
                 service_account_token: Optional['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountToken'] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapArgs'] config_maps: ConfigMap represents a configMap that should populate this volume
        :param 'K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiArgs' downward_api: DownwardAPI represents downward API about the pod that should populate this volume
        :param Sequence['K8sJobSpecTemplateSpecVolumeProjectedSourceSecretArgs'] secrets: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param 'K8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenArgs' service_account_token: A projected service account token volume
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_account_token is not None:
            pulumi.set(__self__, "service_account_token", service_account_token)

    @property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMap']]:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_maps")

    @property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApi']:
        """
        DownwardAPI represents downward API about the pod that should populate this volume
        """
        return pulumi.get(self, "downward_api")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceSecret']]:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceAccountToken")
    def service_account_token(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountToken']:
        """
        A projected service account token volume
        """
        return pulumi.get(self, "service_account_token")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMap(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItem']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Optional: Specify whether the ConfigMap or it's keys must be defined.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the ConfigMap or it's keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItem(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApi(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItem']] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemArgs'] items: Represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItem']]:
        """
        Represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldRef":
            suggest = "field_ref"
        elif key == "resourceFieldRef":
            suggest = "resource_field_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 field_ref: Optional['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef'] = None,
                 mode: Optional[str] = None,
                 resource_field_ref: Optional['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef'] = None):
        """
        :param str path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        :param 'K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefArgs' field_ref: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        :param str mode: Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param 'K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        pulumi.set(__self__, "path", path)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef']:
        """
        Selects a field of the pod: only annotations, labels, name and namespace are supported.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldPath":
            suggest = "field_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to 'v1'. Defaults to `v1`.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to 'v1'. Defaults to `v1`.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 resource: str,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        :param str divisor: Defaults to `1`.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "resource", resource)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        """
        Defaults to `1`.
        """
        return pulumi.get(self, "divisor")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceSecret(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceSecretItem']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param Sequence['K8sJobSpecTemplateSpecVolumeProjectedSourceSecretItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param bool optional: Optional: Specify whether the Secret or it's keys must be defined.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeProjectedSourceSecretItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the Secret or it's keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceSecretItem(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationSeconds":
            suggest = "expiration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 audience: Optional[str] = None,
                 expiration_seconds: Optional[int] = None):
        """
        :param str path: Path specifies a relative path to the mount point of the projected volume.
        :param str audience: Audience is the intended audience of the token
        :param int expiration_seconds: ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds). Defaults to `3600`.
        """
        pulumi.set(__self__, "path", path)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if expiration_seconds is not None:
            pulumi.set(__self__, "expiration_seconds", expiration_seconds)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path specifies a relative path to the mount point of the projected volume.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Audience is the intended audience of the token
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="expirationSeconds")
    def expiration_seconds(self) -> Optional[int]:
        """
        ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds). Defaults to `3600`.
        """
        return pulumi.get(self, "expiration_seconds")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeQuobyte(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeQuobyte. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeQuobyte.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeQuobyte.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry: str,
                 volume: str,
                 group: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 user: Optional[str] = None):
        """
        :param str registry: Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        :param str volume: Volume is a string that references an already created Quobyte volume by name.
        :param str group: Group to map volume access to Default is no group
        :param bool read_only: Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        :param str user: User to map volume access to Defaults to serivceaccount user
        """
        pulumi.set(__self__, "registry", registry)
        pulumi.set(__self__, "volume", volume)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def registry(self) -> str:
        """
        Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        """
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter
    def volume(self) -> str:
        """
        Volume is a string that references an already created Quobyte volume by name.
        """
        return pulumi.get(self, "volume")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group to map volume access to Default is no group
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User to map volume access to Defaults to serivceaccount user
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeRbd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cephMonitors":
            suggest = "ceph_monitors"
        elif key == "rbdImage":
            suggest = "rbd_image"
        elif key == "fsType":
            suggest = "fs_type"
        elif key == "radosUser":
            suggest = "rados_user"
        elif key == "rbdPool":
            suggest = "rbd_pool"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeRbd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeRbd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeRbd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ceph_monitors: Sequence[str],
                 rbd_image: str,
                 fs_type: Optional[str] = None,
                 keyring: Optional[str] = None,
                 rados_user: Optional[str] = None,
                 rbd_pool: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 secret_ref: Optional['outputs.K8sJobSpecTemplateSpecVolumeRbdSecretRef'] = None):
        """
        :param Sequence[str] ceph_monitors: A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str rbd_image: The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        :param str keyring: Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str rados_user: The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it Defaults to `admin`.
        :param str rbd_pool: The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it. Defaults to `rbd`.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it Defaults to `false`.
        :param 'K8sJobSpecTemplateSpecVolumeRbdSecretRefArgs' secret_ref: Name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        pulumi.set(__self__, "ceph_monitors", ceph_monitors)
        pulumi.set(__self__, "rbd_image", rbd_image)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if keyring is not None:
            pulumi.set(__self__, "keyring", keyring)
        if rados_user is not None:
            pulumi.set(__self__, "rados_user", rados_user)
        if rbd_pool is not None:
            pulumi.set(__self__, "rbd_pool", rbd_pool)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="cephMonitors")
    def ceph_monitors(self) -> Sequence[str]:
        """
        A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "ceph_monitors")

    @property
    @pulumi.getter(name="rbdImage")
    def rbd_image(self) -> str:
        """
        The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "rbd_image")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def keyring(self) -> Optional[str]:
        """
        Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "keyring")

    @property
    @pulumi.getter(name="radosUser")
    def rados_user(self) -> Optional[str]:
        """
        The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it Defaults to `admin`.
        """
        return pulumi.get(self, "rados_user")

    @property
    @pulumi.getter(name="rbdPool")
    def rbd_pool(self) -> Optional[str]:
        """
        The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it. Defaults to `rbd`.
        """
        return pulumi.get(self, "rbd_pool")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it Defaults to `false`.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.K8sJobSpecTemplateSpecVolumeRbdSecretRef']:
        """
        Name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeRbdSecretRef(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultMode":
            suggest = "default_mode"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeSecretItem']] = None,
                 optional: Optional[bool] = None,
                 secret_name: Optional[str] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        :param Sequence['K8sJobSpecTemplateSpecVolumeSecretItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param bool optional: Optional: Specify whether the Secret or its keys must be defined.
        :param str secret_name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Defaults to `0644`.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.K8sJobSpecTemplateSpecVolumeSecretItem']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the Secret or its keys must be defined.
        """
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeSecretItem(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class K8sJobSpecTemplateSpecVolumeVsphereVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumePath":
            suggest = "volume_path"
        elif key == "fsType":
            suggest = "fs_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sJobSpecTemplateSpecVolumeVsphereVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sJobSpecTemplateSpecVolumeVsphereVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sJobSpecTemplateSpecVolumeVsphereVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_path: str,
                 fs_type: Optional[str] = None):
        """
        :param str volume_path: Path that identifies vSphere volume vmdk
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        pulumi.set(__self__, "volume_path", volume_path)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)

    @property
    @pulumi.getter(name="volumePath")
    def volume_path(self) -> str:
        """
        Path that identifies vSphere volume vmdk
        """
        return pulumi.get(self, "volume_path")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")


@pulumi.output_type
class OciContainerengineNodePoolInitialNodeLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class OciContainerengineNodePoolNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "faultDomain":
            suggest = "fault_domain"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "lifecycleDetails":
            suggest = "lifecycle_details"
        elif key == "nodePoolId":
            suggest = "node_pool_id"
        elif key == "privateIp":
            suggest = "private_ip"
        elif key == "publicIp":
            suggest = "public_ip"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "systemTags":
            suggest = "system_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OciContainerengineNodePoolNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OciContainerengineNodePoolNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OciContainerengineNodePoolNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_domain: Optional[str] = None,
                 defined_tags: Optional[Mapping[str, str]] = None,
                 fault_domain: Optional[str] = None,
                 freeform_tags: Optional[Mapping[str, str]] = None,
                 id: Optional[str] = None,
                 kubernetes_version: Optional[str] = None,
                 lifecycle_details: Optional[str] = None,
                 name: Optional[str] = None,
                 node_pool_id: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_ip: Optional[str] = None,
                 state: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 system_tags: Optional[Mapping[str, str]] = None):
        """
        :param str id: The ID of this resource.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_pool_id is not None:
            pulumi.set(__self__, "node_pool_id", node_pool_id)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if system_tags is not None:
            pulumi.set(__self__, "system_tags", system_tags)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[str]:
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[str]:
        return pulumi.get(self, "fault_domain")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[str]:
        return pulumi.get(self, "kubernetes_version")

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[str]:
        return pulumi.get(self, "lifecycle_details")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodePoolId")
    def node_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "node_pool_id")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[str]:
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="systemTags")
    def system_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "system_tags")


@pulumi.output_type
class OciContainerengineNodePoolNodeConfigDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placementConfigs":
            suggest = "placement_configs"
        elif key == "definedTags":
            suggest = "defined_tags"
        elif key == "freeformTags":
            suggest = "freeform_tags"
        elif key == "isPvEncryptionInTransitEnabled":
            suggest = "is_pv_encryption_in_transit_enabled"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "nsgIds":
            suggest = "nsg_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OciContainerengineNodePoolNodeConfigDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OciContainerengineNodePoolNodeConfigDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OciContainerengineNodePoolNodeConfigDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placement_configs: Sequence['outputs.OciContainerengineNodePoolNodeConfigDetailsPlacementConfig'],
                 size: int,
                 defined_tags: Optional[Mapping[str, str]] = None,
                 freeform_tags: Optional[Mapping[str, str]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 nsg_ids: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "placement_configs", placement_configs)
        pulumi.set(__self__, "size", size)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if is_pv_encryption_in_transit_enabled is not None:
            pulumi.set(__self__, "is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)

    @property
    @pulumi.getter(name="placementConfigs")
    def placement_configs(self) -> Sequence['outputs.OciContainerengineNodePoolNodeConfigDetailsPlacementConfig']:
        return pulumi.get(self, "placement_configs")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "defined_tags")

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "freeform_tags")

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "nsg_ids")


@pulumi.output_type
class OciContainerengineNodePoolNodeConfigDetailsPlacementConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityDomain":
            suggest = "availability_domain"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "capacityReservationId":
            suggest = "capacity_reservation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OciContainerengineNodePoolNodeConfigDetailsPlacementConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OciContainerengineNodePoolNodeConfigDetailsPlacementConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OciContainerengineNodePoolNodeConfigDetailsPlacementConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_domain: str,
                 subnet_id: str,
                 capacity_reservation_id: Optional[str] = None):
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> str:
        return pulumi.get(self, "availability_domain")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[str]:
        return pulumi.get(self, "capacity_reservation_id")


@pulumi.output_type
class OciContainerengineNodePoolNodeShapeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryInGbs":
            suggest = "memory_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OciContainerengineNodePoolNodeShapeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OciContainerengineNodePoolNodeShapeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OciContainerengineNodePoolNodeShapeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_in_gbs: Optional[float] = None,
                 ocpus: Optional[float] = None):
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[float]:
        return pulumi.get(self, "memory_in_gbs")

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[float]:
        return pulumi.get(self, "ocpus")


@pulumi.output_type
class OciContainerengineNodePoolNodeSourceDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "bootVolumeSizeInGbs":
            suggest = "boot_volume_size_in_gbs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OciContainerengineNodePoolNodeSourceDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OciContainerengineNodePoolNodeSourceDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OciContainerengineNodePoolNodeSourceDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_id: str,
                 source_type: str,
                 boot_volume_size_in_gbs: Optional[str] = None):
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "source_type", source_type)
        if boot_volume_size_in_gbs is not None:
            pulumi.set(__self__, "boot_volume_size_in_gbs", boot_volume_size_in_gbs)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter(name="bootVolumeSizeInGbs")
    def boot_volume_size_in_gbs(self) -> Optional[str]:
        return pulumi.get(self, "boot_volume_size_in_gbs")


@pulumi.output_type
class OtherAgentsAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentName":
            suggest = "agent_name"
        elif key == "agentLinuxPackagePath":
            suggest = "agent_linux_package_path"
        elif key == "agentWindowsPackagePath":
            suggest = "agent_windows_package_path"
        elif key == "executionCount":
            suggest = "execution_count"
        elif key == "linuxAgentInstallStatusCmd":
            suggest = "linux_agent_install_status_cmd"
        elif key == "linuxAgentServiceName":
            suggest = "linux_agent_service_name"
        elif key == "linuxAgentUninstallStatusCmd":
            suggest = "linux_agent_uninstall_status_cmd"
        elif key == "linuxInstallCmd":
            suggest = "linux_install_cmd"
        elif key == "userRequestResetIsPending":
            suggest = "user_request_reset_is_pending"
        elif key == "windowsAgentServiceName":
            suggest = "windows_agent_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OtherAgentsAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OtherAgentsAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OtherAgentsAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_name: str,
                 agent_linux_package_path: Optional[str] = None,
                 agent_windows_package_path: Optional[str] = None,
                 execution_count: Optional[int] = None,
                 linux_agent_install_status_cmd: Optional[str] = None,
                 linux_agent_service_name: Optional[str] = None,
                 linux_agent_uninstall_status_cmd: Optional[str] = None,
                 linux_install_cmd: Optional[str] = None,
                 user_request_reset_is_pending: Optional[bool] = None,
                 windows_agent_service_name: Optional[str] = None):
        pulumi.set(__self__, "agent_name", agent_name)
        if agent_linux_package_path is not None:
            pulumi.set(__self__, "agent_linux_package_path", agent_linux_package_path)
        if agent_windows_package_path is not None:
            pulumi.set(__self__, "agent_windows_package_path", agent_windows_package_path)
        if execution_count is not None:
            pulumi.set(__self__, "execution_count", execution_count)
        if linux_agent_install_status_cmd is not None:
            pulumi.set(__self__, "linux_agent_install_status_cmd", linux_agent_install_status_cmd)
        if linux_agent_service_name is not None:
            pulumi.set(__self__, "linux_agent_service_name", linux_agent_service_name)
        if linux_agent_uninstall_status_cmd is not None:
            pulumi.set(__self__, "linux_agent_uninstall_status_cmd", linux_agent_uninstall_status_cmd)
        if linux_install_cmd is not None:
            pulumi.set(__self__, "linux_install_cmd", linux_install_cmd)
        if user_request_reset_is_pending is not None:
            pulumi.set(__self__, "user_request_reset_is_pending", user_request_reset_is_pending)
        if windows_agent_service_name is not None:
            pulumi.set(__self__, "windows_agent_service_name", windows_agent_service_name)

    @property
    @pulumi.getter(name="agentName")
    def agent_name(self) -> str:
        return pulumi.get(self, "agent_name")

    @property
    @pulumi.getter(name="agentLinuxPackagePath")
    def agent_linux_package_path(self) -> Optional[str]:
        return pulumi.get(self, "agent_linux_package_path")

    @property
    @pulumi.getter(name="agentWindowsPackagePath")
    def agent_windows_package_path(self) -> Optional[str]:
        return pulumi.get(self, "agent_windows_package_path")

    @property
    @pulumi.getter(name="executionCount")
    def execution_count(self) -> Optional[int]:
        return pulumi.get(self, "execution_count")

    @property
    @pulumi.getter(name="linuxAgentInstallStatusCmd")
    def linux_agent_install_status_cmd(self) -> Optional[str]:
        return pulumi.get(self, "linux_agent_install_status_cmd")

    @property
    @pulumi.getter(name="linuxAgentServiceName")
    def linux_agent_service_name(self) -> Optional[str]:
        return pulumi.get(self, "linux_agent_service_name")

    @property
    @pulumi.getter(name="linuxAgentUninstallStatusCmd")
    def linux_agent_uninstall_status_cmd(self) -> Optional[str]:
        return pulumi.get(self, "linux_agent_uninstall_status_cmd")

    @property
    @pulumi.getter(name="linuxInstallCmd")
    def linux_install_cmd(self) -> Optional[str]:
        return pulumi.get(self, "linux_install_cmd")

    @property
    @pulumi.getter(name="userRequestResetIsPending")
    def user_request_reset_is_pending(self) -> Optional[bool]:
        return pulumi.get(self, "user_request_reset_is_pending")

    @property
    @pulumi.getter(name="windowsAgentServiceName")
    def windows_agent_service_name(self) -> Optional[str]:
        return pulumi.get(self, "windows_agent_service_name")


@pulumi.output_type
class PlanCertificatesCertificate(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 arn: Optional[str] = None):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")


@pulumi.output_type
class PlanConfigsConfig(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 type: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class PlanImagesImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanImagesImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanImagesImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanImagesImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_id: str,
                 name: str,
                 os: str,
                 username: str,
                 tags: Optional[Sequence['outputs.PlanImagesImageTag']] = None):
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "username", username)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def os(self) -> str:
        return pulumi.get(self, "os")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.PlanImagesImageTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class PlanImagesImageTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PlanKmsV2Km(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class PlanKmsV2KmsKey(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class PlanSettingsAllMetadata(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PlanSettingsDnsSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainId":
            suggest = "domain_id"
        elif key == "externalDnsSuffix":
            suggest = "external_dns_suffix"
        elif key == "ignoreGlobalDns":
            suggest = "ignore_global_dns"
        elif key == "internalDnsSuffix":
            suggest = "internal_dns_suffix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanSettingsDnsSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanSettingsDnsSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanSettingsDnsSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_id: Optional[str] = None,
                 external_dns_suffix: Optional[str] = None,
                 ignore_global_dns: Optional[bool] = None,
                 internal_dns_suffix: Optional[str] = None):
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if external_dns_suffix is not None:
            pulumi.set(__self__, "external_dns_suffix", external_dns_suffix)
        if ignore_global_dns is not None:
            pulumi.set(__self__, "ignore_global_dns", ignore_global_dns)
        if internal_dns_suffix is not None:
            pulumi.set(__self__, "internal_dns_suffix", internal_dns_suffix)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[str]:
        return pulumi.get(self, "domain_id")

    @property
    @pulumi.getter(name="externalDnsSuffix")
    def external_dns_suffix(self) -> Optional[str]:
        return pulumi.get(self, "external_dns_suffix")

    @property
    @pulumi.getter(name="ignoreGlobalDns")
    def ignore_global_dns(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_global_dns")

    @property
    @pulumi.getter(name="internalDnsSuffix")
    def internal_dns_suffix(self) -> Optional[str]:
        return pulumi.get(self, "internal_dns_suffix")


@pulumi.output_type
class PlanSettingsMetadata(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PlanWafV2Waf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardUrl":
            suggest = "dashboard_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlanWafV2Waf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlanWafV2Waf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlanWafV2Waf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: str,
                 name: str,
                 dashboard_url: Optional[str] = None):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "name", name)
        if dashboard_url is not None:
            pulumi.set(__self__, "dashboard_url", dashboard_url)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="dashboardUrl")
    def dashboard_url(self) -> Optional[str]:
        return pulumi.get(self, "dashboard_url")


@pulumi.output_type
class RdsInstancePerformanceInsights(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "retentionPeriod":
            suggest = "retention_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsInstancePerformanceInsights. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsInstancePerformanceInsights.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsInstancePerformanceInsights.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 retention_period: Optional[int] = None):
        """
        :param bool enabled: Turn on or off Performance Insights
        :param str kms_key_id: Specify ARN for the KMS key to encrypt Performance Insights data.
        :param int retention_period: Specify retention period in Days. Valid values are 7, 731 (2 years) or a multiple of 31. For Document DB retention period is 7
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Turn on or off Performance Insights
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        Specify ARN for the KMS key to encrypt Performance Insights data.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[int]:
        """
        Specify retention period in Days. Valid values are 7, 731 (2 years) or a multiple of 31. For Document DB retention period is 7
        """
        return pulumi.get(self, "retention_period")


@pulumi.output_type
class RdsInstanceV2ScalingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsInstanceV2ScalingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsInstanceV2ScalingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsInstanceV2ScalingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: float,
                 min_capacity: float):
        """
        :param float max_capacity: Specifies max scaling capacity.
        :param float min_capacity: Specifies min scaling capacity.
        """
        pulumi.set(__self__, "max_capacity", max_capacity)
        pulumi.set(__self__, "min_capacity", min_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> float:
        """
        Specifies max scaling capacity.
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> float:
        """
        Specifies min scaling capacity.
        """
        return pulumi.get(self, "min_capacity")


@pulumi.output_type
class RdsReadReplicaPerformanceInsights(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "retentionPeriod":
            suggest = "retention_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsReadReplicaPerformanceInsights. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsReadReplicaPerformanceInsights.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsReadReplicaPerformanceInsights.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 kms_key_id: Optional[str] = None,
                 retention_period: Optional[int] = None):
        """
        :param bool enabled: Turn on or off Performance Insights Defaults to `false`.
        :param str kms_key_id: Specify ARN for the KMS key to encrypt Performance Insights data.
        :param int retention_period: Specify retention period in Days. Valid values are 7, 731 (2 years) or a multiple of 31. For Document DB retention period is 7 Defaults to `7`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Turn on or off Performance Insights Defaults to `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        Specify ARN for the KMS key to encrypt Performance Insights data.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[int]:
        """
        Specify retention period in Days. Valid values are 7, 731 (2 years) or a multiple of 31. For Document DB retention period is 7 Defaults to `7`.
        """
        return pulumi.get(self, "retention_period")


@pulumi.output_type
class RdsReadReplicaV2ScalingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdsReadReplicaV2ScalingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdsReadReplicaV2ScalingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdsReadReplicaV2ScalingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: float,
                 min_capacity: float):
        """
        :param float max_capacity: Specifies max scalling capacity.
        :param float min_capacity: Specifies min scalling capacity.
        """
        pulumi.set(__self__, "max_capacity", max_capacity)
        pulumi.set(__self__, "min_capacity", min_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> float:
        """
        Specifies max scalling capacity.
        """
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> float:
        """
        Specifies min scalling capacity.
        """
        return pulumi.get(self, "min_capacity")


@pulumi.output_type
class S3BucketDefaultEncryption(dict):
    def __init__(__self__, *,
                 method: Optional[str] = None):
        """
        :param str method: Default encryption method.  Must be one of: `None`, `Sse`, `AwsKms`, `TenantKms`.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Default encryption method.  Must be one of: `None`, `Sse`, `AwsKms`, `TenantKms`.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class S3BucketReplicationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationBucket":
            suggest = "destination_bucket"
        elif key == "deleteMarkerReplication":
            suggest = "delete_marker_replication"
        elif key == "destinationArn":
            suggest = "destination_arn"
        elif key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3BucketReplicationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3BucketReplicationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3BucketReplicationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_bucket: str,
                 name: str,
                 priority: int,
                 delete_marker_replication: Optional[bool] = None,
                 destination_arn: Optional[str] = None,
                 fullname: Optional[str] = None,
                 storage_class: Optional[str] = None):
        """
        :param str destination_bucket: fullname of the destination bucket.
        :param str name: replication rule name for s3 source bucket
        :param int priority: replication priority. Priority must be unique between multiple rules.
        :param bool delete_marker_replication: Whether or not to enable delete marker on replication. Defaults to `false`.
        :param str destination_arn: destination bucket arn
        :param str fullname: replication rule fullname for s3 source bucket
        :param str storage_class: storage*class type: STANDARD, INTELLIGENT*TIERING, STANDARD*IA, ONEZONE*IA, GLACIER*IR, GLACIER, DEEP*ARCHIVE, REDUCED_REDUNDANCY.
        """
        pulumi.set(__self__, "destination_bucket", destination_bucket)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        if delete_marker_replication is not None:
            pulumi.set(__self__, "delete_marker_replication", delete_marker_replication)
        if destination_arn is not None:
            pulumi.set(__self__, "destination_arn", destination_arn)
        if fullname is not None:
            pulumi.set(__self__, "fullname", fullname)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter(name="destinationBucket")
    def destination_bucket(self) -> str:
        """
        fullname of the destination bucket.
        """
        return pulumi.get(self, "destination_bucket")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        replication rule name for s3 source bucket
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        replication priority. Priority must be unique between multiple rules.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="deleteMarkerReplication")
    def delete_marker_replication(self) -> Optional[bool]:
        """
        Whether or not to enable delete marker on replication. Defaults to `false`.
        """
        return pulumi.get(self, "delete_marker_replication")

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> Optional[str]:
        """
        destination bucket arn
        """
        return pulumi.get(self, "destination_arn")

    @property
    @pulumi.getter
    def fullname(self) -> Optional[str]:
        """
        replication rule fullname for s3 source bucket
        """
        return pulumi.get(self, "fullname")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[str]:
        """
        storage*class type: STANDARD, INTELLIGENT*TIERING, STANDARD*IA, ONEZONE*IA, GLACIER*IR, GLACIER, DEEP*ARCHIVE, REDUCED_REDUNDANCY.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class S3BucketTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TenantConfigMetadata(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TenantConfigSetting(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TenantKmsKm(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class TenantKmsUnspecifiedKmsKey(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class TenantPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowVolumeMapping":
            suggest = "allow_volume_mapping"
        elif key == "blockExternalEp":
            suggest = "block_external_ep"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TenantPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TenantPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TenantPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_volume_mapping: Optional[bool] = None,
                 block_external_ep: Optional[bool] = None):
        if allow_volume_mapping is not None:
            pulumi.set(__self__, "allow_volume_mapping", allow_volume_mapping)
        if block_external_ep is not None:
            pulumi.set(__self__, "block_external_ep", block_external_ep)

    @property
    @pulumi.getter(name="allowVolumeMapping")
    def allow_volume_mapping(self) -> Optional[bool]:
        return pulumi.get(self, "allow_volume_mapping")

    @property
    @pulumi.getter(name="blockExternalEp")
    def block_external_ep(self) -> Optional[bool]:
        return pulumi.get(self, "block_external_ep")


@pulumi.output_type
class TenantSecretTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TenantTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAsgProfilesAsgProfileResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 base64_user_data: str,
                 can_scale_from_zero: bool,
                 capacity: str,
                 friendly_name: str,
                 fullname: str,
                 image_id: str,
                 initial_base64_user_data: str,
                 instance_count: int,
                 is_cluster_autoscaled: bool,
                 keypair_type: int,
                 max_instance_count: int,
                 metadatas: Sequence['outputs.GetAsgProfilesAsgProfileMetadataResult'],
                 min_instance_count: int,
                 minion_tags: Sequence['outputs.GetAsgProfilesAsgProfileMinionTagResult'],
                 network_interfaces: Sequence['outputs.GetAsgProfilesAsgProfileNetworkInterfaceResult'],
                 public_ip_address: str,
                 tags: Sequence['outputs.GetAsgProfilesAsgProfileTagResult'],
                 tenant_id: str,
                 user_account: str,
                 volumes: Sequence['outputs.GetAsgProfilesAsgProfileVolumeResult'],
                 zones: Sequence[int],
                 agent_platform: Optional[int] = None,
                 allocated_public_ip: Optional[bool] = None,
                 cloud: Optional[int] = None,
                 custom_node_labels: Optional[Mapping[str, str]] = None,
                 enabled_metrics: Optional[Sequence[str]] = None,
                 encrypt_disk: Optional[bool] = None,
                 is_ebs_optimized: Optional[bool] = None,
                 is_minion: Optional[bool] = None,
                 max_spot_price: Optional[str] = None,
                 prepend_user_data: Optional[bool] = None,
                 taints: Optional[Sequence['outputs.GetAsgProfilesAsgProfileTaintResult']] = None,
                 use_spot_instances: Optional[bool] = None,
                 wait_for_capacity: Optional[bool] = None):
        """
        :param str arn: The ASG arn.
        :param str base64_user_data: Base64 encoded EC2 user data to associated with the host.
        :param bool can_scale_from_zero: Whether or not ASG should leverage duplocloud's scale from 0 feature
        :param str capacity: The AWS EC2 instance type.
        :param str friendly_name: The short name of the host.
        :param str fullname: The full name of the ASG profile.
        :param str image_id: The AMI ID to use.
        :param int instance_count: The number of instances that should be running in the group.
        :param bool is_cluster_autoscaled: Whether or not to enable cluster autoscaler.
        :param int keypair_type: The numeric ID of the keypair type being used.Should be one of:
               
                  - `0` : Default
                  - `1` : RSA (deprecated - some operating systems no longer support it)
                  - `2` : ED25519
        :param int max_instance_count: The maximum size of the Auto Scaling Group.
        :param Sequence['GetAsgProfilesAsgProfileMetadataArgs'] metadatas: Configuration metadata used when creating the host.<br>*Note: To configure OS disk size OsDiskSize can be specified as Key and its size as value, size value should be atleast 10*
        :param int min_instance_count: The minimum size of the Auto Scaling Group.
        :param Sequence['GetAsgProfilesAsgProfileMinionTagArgs'] minion_tags: A map of tags to assign to the resource. Example - `AllocationTags` can be passed as tag key with any value.
        :param Sequence['GetAsgProfilesAsgProfileNetworkInterfaceArgs'] network_interfaces: An optional list of custom network interface configurations to use when creating the host.
        :param str public_ip_address: The primary public IP address assigned to the host.
        :param str tenant_id: The GUID of the tenant that the host will be created in.
        :param str user_account: The name of the tenant that the host will be created in.
        :param Sequence['GetAsgProfilesAsgProfileVolumeArgs'] volumes: Block to specify additional or secondary volume beyond the root device
        :param Sequence[int] zones: The multi availability zone to launch the asg in, expressed as a number and starting at 0
        :param int agent_platform: The numeric ID of the container agent pool that this host is added to.
                - 0: Linux Docker/Native
               - 	4: None
               - 5: Docker Windows
               - 7: EKS Linux
               - 8: ECS
        :param bool allocated_public_ip: Whether or not to allocate a public IP.
        :param int cloud: The numeric ID of the cloud provider to launch the host in.
        :param Mapping[str, str] custom_node_labels: Specify the labels to attach to the nodes.
        :param Sequence[str] enabled_metrics: List of metrics to collect for the ASG Specify one or more of the following metrics.`GroupMinSize`,`GroupMaxSize`,`GroupDesiredCapacity`,`GroupInServiceInstances`,`GroupPendingInstances`,`GroupStandbyInstances`,`GroupTerminatingInstances`,`GroupTotalInstances`,`GroupInServiceCapacity`,`GroupPendingCapacity`,`GroupStandbyCapacity`,`GroupTerminatingCapacity`,`GroupTotalCapacity`,`WarmPoolDesiredCapacity`,`WarmPoolWarmedCapacity`,`WarmPoolPendingCapacity`,`WarmPoolTerminatingCapacity`,`WarmPoolTotalCapacity`,`GroupAndWarmPoolDesiredCapacity`,`GroupAndWarmPoolTotalCapacity`.
        :param str max_spot_price: Maximum price to pay for a spot instance in dollars per unit hour.
        :param bool prepend_user_data: Bootstrap an EKS host with Duplo's user data, prepending it to custom user data if also provided.
        :param Sequence['GetAsgProfilesAsgProfileTaintArgs'] taints: Specify taints to attach to the nodes, to repel other nodes with different toleration
        :param bool use_spot_instances: Whether or not to use spot instances.
        :param bool wait_for_capacity: Whether or not to wait until ASG instances to be healthy, after creation.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "base64_user_data", base64_user_data)
        pulumi.set(__self__, "can_scale_from_zero", can_scale_from_zero)
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "friendly_name", friendly_name)
        pulumi.set(__self__, "fullname", fullname)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "initial_base64_user_data", initial_base64_user_data)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "is_cluster_autoscaled", is_cluster_autoscaled)
        pulumi.set(__self__, "keypair_type", keypair_type)
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "min_instance_count", min_instance_count)
        pulumi.set(__self__, "minion_tags", minion_tags)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "user_account", user_account)
        pulumi.set(__self__, "volumes", volumes)
        pulumi.set(__self__, "zones", zones)
        if agent_platform is not None:
            pulumi.set(__self__, "agent_platform", agent_platform)
        if allocated_public_ip is not None:
            pulumi.set(__self__, "allocated_public_ip", allocated_public_ip)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if custom_node_labels is not None:
            pulumi.set(__self__, "custom_node_labels", custom_node_labels)
        if enabled_metrics is not None:
            pulumi.set(__self__, "enabled_metrics", enabled_metrics)
        if encrypt_disk is not None:
            pulumi.set(__self__, "encrypt_disk", encrypt_disk)
        if is_ebs_optimized is not None:
            pulumi.set(__self__, "is_ebs_optimized", is_ebs_optimized)
        if is_minion is not None:
            pulumi.set(__self__, "is_minion", is_minion)
        if max_spot_price is not None:
            pulumi.set(__self__, "max_spot_price", max_spot_price)
        if prepend_user_data is not None:
            pulumi.set(__self__, "prepend_user_data", prepend_user_data)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if use_spot_instances is not None:
            pulumi.set(__self__, "use_spot_instances", use_spot_instances)
        if wait_for_capacity is not None:
            pulumi.set(__self__, "wait_for_capacity", wait_for_capacity)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The ASG arn.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="base64UserData")
    def base64_user_data(self) -> str:
        """
        Base64 encoded EC2 user data to associated with the host.
        """
        return pulumi.get(self, "base64_user_data")

    @property
    @pulumi.getter(name="canScaleFromZero")
    def can_scale_from_zero(self) -> bool:
        """
        Whether or not ASG should leverage duplocloud's scale from 0 feature
        """
        return pulumi.get(self, "can_scale_from_zero")

    @property
    @pulumi.getter
    def capacity(self) -> str:
        """
        The AWS EC2 instance type.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> str:
        """
        The short name of the host.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter
    def fullname(self) -> str:
        """
        The full name of the ASG profile.
        """
        return pulumi.get(self, "fullname")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The AMI ID to use.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="initialBase64UserData")
    def initial_base64_user_data(self) -> str:
        return pulumi.get(self, "initial_base64_user_data")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> int:
        """
        The number of instances that should be running in the group.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="isClusterAutoscaled")
    def is_cluster_autoscaled(self) -> bool:
        """
        Whether or not to enable cluster autoscaler.
        """
        return pulumi.get(self, "is_cluster_autoscaled")

    @property
    @pulumi.getter(name="keypairType")
    def keypair_type(self) -> int:
        """
        The numeric ID of the keypair type being used.Should be one of:

           - `0` : Default
           - `1` : RSA (deprecated - some operating systems no longer support it)
           - `2` : ED25519
        """
        return pulumi.get(self, "keypair_type")

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> int:
        """
        The maximum size of the Auto Scaling Group.
        """
        return pulumi.get(self, "max_instance_count")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetAsgProfilesAsgProfileMetadataResult']:
        """
        Configuration metadata used when creating the host.<br>*Note: To configure OS disk size OsDiskSize can be specified as Key and its size as value, size value should be atleast 10*
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> int:
        """
        The minimum size of the Auto Scaling Group.
        """
        return pulumi.get(self, "min_instance_count")

    @property
    @pulumi.getter(name="minionTags")
    def minion_tags(self) -> Sequence['outputs.GetAsgProfilesAsgProfileMinionTagResult']:
        """
        A map of tags to assign to the resource. Example - `AllocationTags` can be passed as tag key with any value.
        """
        return pulumi.get(self, "minion_tags")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetAsgProfilesAsgProfileNetworkInterfaceResult']:
        """
        An optional list of custom network interface configurations to use when creating the host.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        The primary public IP address assigned to the host.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetAsgProfilesAsgProfileTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The GUID of the tenant that the host will be created in.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> str:
        """
        The name of the tenant that the host will be created in.
        """
        return pulumi.get(self, "user_account")

    @property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.GetAsgProfilesAsgProfileVolumeResult']:
        """
        Block to specify additional or secondary volume beyond the root device
        """
        return pulumi.get(self, "volumes")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[int]:
        """
        The multi availability zone to launch the asg in, expressed as a number and starting at 0
        """
        return pulumi.get(self, "zones")

    @property
    @pulumi.getter(name="agentPlatform")
    def agent_platform(self) -> Optional[int]:
        """
        The numeric ID of the container agent pool that this host is added to.
         - 0: Linux Docker/Native
        - 	4: None
        - 5: Docker Windows
        - 7: EKS Linux
        - 8: ECS
        """
        return pulumi.get(self, "agent_platform")

    @property
    @pulumi.getter(name="allocatedPublicIp")
    def allocated_public_ip(self) -> Optional[bool]:
        """
        Whether or not to allocate a public IP.
        """
        return pulumi.get(self, "allocated_public_ip")

    @property
    @pulumi.getter
    def cloud(self) -> Optional[int]:
        """
        The numeric ID of the cloud provider to launch the host in.
        """
        return pulumi.get(self, "cloud")

    @property
    @pulumi.getter(name="customNodeLabels")
    def custom_node_labels(self) -> Optional[Mapping[str, str]]:
        """
        Specify the labels to attach to the nodes.
        """
        return pulumi.get(self, "custom_node_labels")

    @property
    @pulumi.getter(name="enabledMetrics")
    def enabled_metrics(self) -> Optional[Sequence[str]]:
        """
        List of metrics to collect for the ASG Specify one or more of the following metrics.`GroupMinSize`,`GroupMaxSize`,`GroupDesiredCapacity`,`GroupInServiceInstances`,`GroupPendingInstances`,`GroupStandbyInstances`,`GroupTerminatingInstances`,`GroupTotalInstances`,`GroupInServiceCapacity`,`GroupPendingCapacity`,`GroupStandbyCapacity`,`GroupTerminatingCapacity`,`GroupTotalCapacity`,`WarmPoolDesiredCapacity`,`WarmPoolWarmedCapacity`,`WarmPoolPendingCapacity`,`WarmPoolTerminatingCapacity`,`WarmPoolTotalCapacity`,`GroupAndWarmPoolDesiredCapacity`,`GroupAndWarmPoolTotalCapacity`.
        """
        return pulumi.get(self, "enabled_metrics")

    @property
    @pulumi.getter(name="encryptDisk")
    def encrypt_disk(self) -> Optional[bool]:
        return pulumi.get(self, "encrypt_disk")

    @property
    @pulumi.getter(name="isEbsOptimized")
    def is_ebs_optimized(self) -> Optional[bool]:
        return pulumi.get(self, "is_ebs_optimized")

    @property
    @pulumi.getter(name="isMinion")
    def is_minion(self) -> Optional[bool]:
        return pulumi.get(self, "is_minion")

    @property
    @pulumi.getter(name="maxSpotPrice")
    def max_spot_price(self) -> Optional[str]:
        """
        Maximum price to pay for a spot instance in dollars per unit hour.
        """
        return pulumi.get(self, "max_spot_price")

    @property
    @pulumi.getter(name="prependUserData")
    def prepend_user_data(self) -> Optional[bool]:
        """
        Bootstrap an EKS host with Duplo's user data, prepending it to custom user data if also provided.
        """
        return pulumi.get(self, "prepend_user_data")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.GetAsgProfilesAsgProfileTaintResult']]:
        """
        Specify taints to attach to the nodes, to repel other nodes with different toleration
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="useSpotInstances")
    def use_spot_instances(self) -> Optional[bool]:
        """
        Whether or not to use spot instances.
        """
        return pulumi.get(self, "use_spot_instances")

    @property
    @pulumi.getter(name="waitForCapacity")
    def wait_for_capacity(self) -> Optional[bool]:
        """
        Whether or not to wait until ASG instances to be healthy, after creation.
        """
        return pulumi.get(self, "wait_for_capacity")


@pulumi.output_type
class GetAsgProfilesAsgProfileMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAsgProfilesAsgProfileMinionTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAsgProfilesAsgProfileNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 associate_public_ip: bool,
                 device_index: int,
                 groups: Sequence[str],
                 metadatas: Sequence['outputs.GetAsgProfilesAsgProfileNetworkInterfaceMetadataResult'],
                 network_interface_id: str,
                 subnet_id: str):
        """
        :param bool associate_public_ip: Whether or not to associate a public IP with the newly created ENI.  Cannot be specified if `network_interface_id` is specified.
        :param int device_index: The device index to pass to AWS for attaching the ENI.  Starts at zero.
        :param str network_interface_id: The ID of an ENI to attach to this host.  Cannot be specified if `subnet_id` or `associate_public_ip` is specified.
        :param str subnet_id: The ID of a subnet in which to create a new ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        pulumi.set(__self__, "associate_public_ip", associate_public_ip)
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associatePublicIp")
    def associate_public_ip(self) -> bool:
        """
        Whether or not to associate a public IP with the newly created ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        return pulumi.get(self, "associate_public_ip")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> int:
        """
        The device index to pass to AWS for attaching the ENI.  Starts at zero.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter
    def groups(self) -> Sequence[str]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetAsgProfilesAsgProfileNetworkInterfaceMetadataResult']:
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        """
        The ID of an ENI to attach to this host.  Cannot be specified if `subnet_id` or `associate_public_ip` is specified.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of a subnet in which to create a new ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetAsgProfilesAsgProfileNetworkInterfaceMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAsgProfilesAsgProfileTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAsgProfilesAsgProfileTaintResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str effect: Update strategy of the node. Effect types <br>      - NoSchedule<br>     - PreferNoSchedule<br>     - NoExecute
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Update strategy of the node. Effect types <br>      - NoSchedule<br>     - PreferNoSchedule<br>     - NoExecute
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAsgProfilesAsgProfileVolumeResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: bool,
                 iops: int,
                 name: str,
                 size: int,
                 volume_id: str,
                 volume_type: str):
        """
        :param bool delete_on_termination: Whether the volume should be deleted when the instance is terminated.
        """
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_id", volume_id)
        pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        """
        Whether the volume should be deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def iops(self) -> int:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetAwsLbListenersListenerResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 certificates: Sequence['outputs.GetAwsLbListenersListenerCertificateResult'],
                 default_actions: Sequence['outputs.GetAwsLbListenersListenerDefaultActionResult'],
                 load_balancer_arn: str,
                 load_balancer_name: str,
                 port: int,
                 protocol: str,
                 ssl_policy: str,
                 tenant_id: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "default_actions", default_actions)
        pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "ssl_policy", ssl_policy)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetAwsLbListenersListenerCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="defaultActions")
    def default_actions(self) -> Sequence['outputs.GetAwsLbListenersListenerDefaultActionResult']:
        return pulumi.get(self, "default_actions")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> str:
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> str:
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sslPolicy")
    def ssl_policy(self) -> str:
        return pulumi.get(self, "ssl_policy")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetAwsLbListenersListenerCertificateResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 is_default: bool):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "is_default", is_default)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        return pulumi.get(self, "is_default")


@pulumi.output_type
class GetAwsLbListenersListenerDefaultActionResult(dict):
    def __init__(__self__, *,
                 order: int,
                 target_group_arn: str,
                 type: str):
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "target_group_arn", target_group_arn)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> str:
        return pulumi.get(self, "target_group_arn")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAwsLbTargetGroupsTargetGroupResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 health_checks: Sequence['outputs.GetAwsLbTargetGroupsTargetGroupHealthCheckResult'],
                 load_balancer_arns: Sequence[str],
                 name: str,
                 protocol: str,
                 protocol_version: str,
                 target_type: str,
                 tenant_id: str,
                 vpc_id: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "health_checks", health_checks)
        pulumi.set(__self__, "load_balancer_arns", load_balancer_arns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "protocol_version", protocol_version)
        pulumi.set(__self__, "target_type", target_type)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Sequence['outputs.GetAwsLbTargetGroupsTargetGroupHealthCheckResult']:
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter(name="loadBalancerArns")
    def load_balancer_arns(self) -> Sequence[str]:
        return pulumi.get(self, "load_balancer_arns")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> str:
        return pulumi.get(self, "protocol_version")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetAwsLbTargetGroupsTargetGroupHealthCheckResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 healthy_threshold: int,
                 interval: int,
                 matchers: Sequence['outputs.GetAwsLbTargetGroupsTargetGroupHealthCheckMatcherResult'],
                 path: str,
                 port: str,
                 protocol: str,
                 timeout: int,
                 unhealthy_threshold: int):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "matchers", matchers)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> int:
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.GetAwsLbTargetGroupsTargetGroupHealthCheckMatcherResult']:
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> str:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> int:
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetAwsLbTargetGroupsTargetGroupHealthCheckMatcherResult(dict):
    def __init__(__self__, *,
                 grpc_code: str,
                 http_code: str):
        pulumi.set(__self__, "grpc_code", grpc_code)
        pulumi.set(__self__, "http_code", http_code)

    @property
    @pulumi.getter(name="grpcCode")
    def grpc_code(self) -> str:
        return pulumi.get(self, "grpc_code")

    @property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> str:
        return pulumi.get(self, "http_code")


@pulumi.output_type
class GetAwsSsmParametersParameterResult(dict):
    def __init__(__self__, *,
                 allowed_pattern: str,
                 description: str,
                 key_id: str,
                 last_modified_date: str,
                 last_modified_user: str,
                 name: str,
                 tenant_id: str,
                 type: str):
        pulumi.set(__self__, "allowed_pattern", allowed_pattern)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "last_modified_date", last_modified_date)
        pulumi.set(__self__, "last_modified_user", last_modified_user)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedPattern")
    def allowed_pattern(self) -> str:
        return pulumi.get(self, "allowed_pattern")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> str:
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="lastModifiedDate")
    def last_modified_date(self) -> str:
        return pulumi.get(self, "last_modified_date")

    @property
    @pulumi.getter(name="lastModifiedUser")
    def last_modified_user(self) -> str:
        return pulumi.get(self, "last_modified_user")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAzureAvailabilitySetVirtualMachineResult(dict):
    def __init__(__self__, *,
                 id: str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAzureCosmosDbAccountBackupPolicyResult(dict):
    def __init__(__self__, *,
                 backup_interval: int,
                 backup_retention_interval: int,
                 backup_storage_redundancy: str,
                 continuous_mode_tier: str,
                 type: str):
        """
        :param int backup_interval: Backup interval in minutes
        :param int backup_retention_interval: Backup retention interval in hours
        :param str backup_storage_redundancy: Backup storage redundancy type. Valid values are Geo, Local, Zone. Defaults to Geo.
        :param str continuous_mode_tier: The continuous mode tier for the Cosmos DB account. This is only applicable if the backup policy type is Continuous.
        :param str type: Valid values Periodic, Continuous
        """
        pulumi.set(__self__, "backup_interval", backup_interval)
        pulumi.set(__self__, "backup_retention_interval", backup_retention_interval)
        pulumi.set(__self__, "backup_storage_redundancy", backup_storage_redundancy)
        pulumi.set(__self__, "continuous_mode_tier", continuous_mode_tier)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="backupInterval")
    def backup_interval(self) -> int:
        """
        Backup interval in minutes
        """
        return pulumi.get(self, "backup_interval")

    @property
    @pulumi.getter(name="backupRetentionInterval")
    def backup_retention_interval(self) -> int:
        """
        Backup retention interval in hours
        """
        return pulumi.get(self, "backup_retention_interval")

    @property
    @pulumi.getter(name="backupStorageRedundancy")
    def backup_storage_redundancy(self) -> str:
        """
        Backup storage redundancy type. Valid values are Geo, Local, Zone. Defaults to Geo.
        """
        return pulumi.get(self, "backup_storage_redundancy")

    @property
    @pulumi.getter(name="continuousModeTier")
    def continuous_mode_tier(self) -> str:
        """
        The continuous mode tier for the Cosmos DB account. This is only applicable if the backup policy type is Continuous.
        """
        return pulumi.get(self, "continuous_mode_tier")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Valid values Periodic, Continuous
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAzureCosmosDbAccountCapabilityResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the Cosmos DB capability, for example, 'EnableServerless'.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Cosmos DB capability, for example, 'EnableServerless'.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAzureCosmosDbAccountConsistencyPolicyResult(dict):
    def __init__(__self__, *,
                 default_consistency_level: str,
                 max_interval_in_seconds: int,
                 max_staleness_prefix: int):
        """
        :param str default_consistency_level: Specify the default consistency level and configuration settings of the Cosmos DB account. Possible values include: 'Eventual', 'Session', 'BoundedStaleness','Strong', 'ConsistentPrefix'
        :param int max_interval_in_seconds: Max amount of time staleness (in seconds) is tolerated
        :param int max_staleness_prefix: Max number of stale requests tolerated. Accepted range for this values 1 to 2147483647
        """
        pulumi.set(__self__, "default_consistency_level", default_consistency_level)
        pulumi.set(__self__, "max_interval_in_seconds", max_interval_in_seconds)
        pulumi.set(__self__, "max_staleness_prefix", max_staleness_prefix)

    @property
    @pulumi.getter(name="defaultConsistencyLevel")
    def default_consistency_level(self) -> str:
        """
        Specify the default consistency level and configuration settings of the Cosmos DB account. Possible values include: 'Eventual', 'Session', 'BoundedStaleness','Strong', 'ConsistentPrefix'
        """
        return pulumi.get(self, "default_consistency_level")

    @property
    @pulumi.getter(name="maxIntervalInSeconds")
    def max_interval_in_seconds(self) -> int:
        """
        Max amount of time staleness (in seconds) is tolerated
        """
        return pulumi.get(self, "max_interval_in_seconds")

    @property
    @pulumi.getter(name="maxStalenessPrefix")
    def max_staleness_prefix(self) -> int:
        """
        Max number of stale requests tolerated. Accepted range for this values 1 to 2147483647
        """
        return pulumi.get(self, "max_staleness_prefix")


@pulumi.output_type
class GetAzureCosmosDbAccountGeoLocationResult(dict):
    def __init__(__self__, *,
                 failover_priority: int,
                 is_zone_redundant: bool,
                 location_name: str):
        """
        :param int failover_priority: The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists. Changing this causes the location to be re-provisioned and cannot be changed for the location with failover priority 0
        :param bool is_zone_redundant: Should zone redundancy be enabled for this region?
        :param str location_name: The name of the Azure region to host replicated data
        """
        pulumi.set(__self__, "failover_priority", failover_priority)
        pulumi.set(__self__, "is_zone_redundant", is_zone_redundant)
        pulumi.set(__self__, "location_name", location_name)

    @property
    @pulumi.getter(name="failoverPriority")
    def failover_priority(self) -> int:
        """
        The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists. Changing this causes the location to be re-provisioned and cannot be changed for the location with failover priority 0
        """
        return pulumi.get(self, "failover_priority")

    @property
    @pulumi.getter(name="isZoneRedundant")
    def is_zone_redundant(self) -> bool:
        """
        Should zone redundancy be enabled for this region?
        """
        return pulumi.get(self, "is_zone_redundant")

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> str:
        """
        The name of the Azure region to host replicated data
        """
        return pulumi.get(self, "location_name")


@pulumi.output_type
class GetAzureCosmosDbAccountVirtualNetworkRuleResult(dict):
    def __init__(__self__, *,
                 ignore_missing_vnet_service_endpoint: bool,
                 subnet_id: str):
        """
        :param bool ignore_missing_vnet_service_endpoint: If set to true, the specified subnet will be added as a virtual network rule even if its CosmosDB service endpoint is not active
        :param str subnet_id: The ID of the subnet to allow access to this CosmosDB account. This should be in the format /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        """
        pulumi.set(__self__, "ignore_missing_vnet_service_endpoint", ignore_missing_vnet_service_endpoint)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="ignoreMissingVnetServiceEndpoint")
    def ignore_missing_vnet_service_endpoint(self) -> bool:
        """
        If set to true, the specified subnet will be added as a virtual network rule even if its CosmosDB service endpoint is not active
        """
        return pulumi.get(self, "ignore_missing_vnet_service_endpoint")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of the subnet to allow access to this CosmosDB account. This should be in the format /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetDuploServiceLbconfigsServiceResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 lbconfigs: Sequence['outputs.GetDuploServiceLbconfigsServiceLbconfigResult'],
                 name: str,
                 replication_controller_name: str,
                 status: str):
        """
        :param str arn: The ARN (or ID) of the cloud load balancer (if applicable).
        :param str name: The name of the duplo service.
        :param str replication_controller_name: The name of the duplo service.
        :param str status: The status of the cloud load balancer (if applicable).
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "lbconfigs", lbconfigs)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replication_controller_name", replication_controller_name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The ARN (or ID) of the cloud load balancer (if applicable).
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def lbconfigs(self) -> Sequence['outputs.GetDuploServiceLbconfigsServiceLbconfigResult']:
        return pulumi.get(self, "lbconfigs")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the duplo service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="replicationControllerName")
    def replication_controller_name(self) -> str:
        """
        The name of the duplo service.
        """
        return pulumi.get(self, "replication_controller_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the cloud load balancer (if applicable).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDuploServiceLbconfigsServiceLbconfigResult(dict):
    def __init__(__self__, *,
                 allow_global_access: bool,
                 backend_config_timeout_sec: int,
                 backend_protocol_version: str,
                 certificate_arn: str,
                 cloud_name: str,
                 custom_cidrs: Sequence[str],
                 dns_name: str,
                 external_port: int,
                 external_traffic_policy: str,
                 extra_selector_labels: Sequence['outputs.GetDuploServiceLbconfigsServiceLbconfigExtraSelectorLabelResult'],
                 frontend_ip: str,
                 health_check: 'outputs.GetDuploServiceLbconfigsServiceLbconfigHealthCheckResult',
                 health_check_url: str,
                 host_name: str,
                 host_port: int,
                 index: int,
                 is_infra_deployment: bool,
                 is_internal: bool,
                 is_native: bool,
                 lb_type: int,
                 name: str,
                 port: str,
                 protocol: str,
                 replication_controller_name: str,
                 set_ingress_health_check: bool,
                 skip_http_to_https: bool,
                 target_group_arn: str):
        """
        :param bool allow_global_access: Applicable for internal lb.
        :param int backend_config_timeout_sec: The number of seconds to wait for the backend to send a response. Must be at least 1. Applicable only for GCP.
        :param str backend_protocol_version: Is used for communication between the load balancer and the target instances. This field is used to set protocol version for ALB load balancer. Only applicable when protocol is HTTP or HTTPS. The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1
        :param str certificate_arn: The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        :param str cloud_name: The name of the cloud load balancer (if applicable).
        :param Sequence[str] custom_cidrs: Specify CIDR Values. This is applicable only for Network Load Balancer if `lb_type` is `6`.
        :param str dns_name: The DNS name of the cloud load balancer (if applicable).
        :param int external_port: The frontend port associated with this load balancer configuration. Required if `lb_type` is not `7`.
        :param str external_traffic_policy: Only for K8S Node Port (`lb_type = 4`) or load balancers in Kubernetes.  Set the kubernetes service `externalTrafficPolicy` attribute.
        :param Sequence['GetDuploServiceLbconfigsServiceLbconfigExtraSelectorLabelArgs'] extra_selector_labels: Only for K8S services or load balancers in Kubernetes.  Sets an additional selector label to narrow which pods can receive traffic.
        :param 'GetDuploServiceLbconfigsServiceLbconfigHealthCheckArgs' health_check: Health Check configuration block.
        :param str health_check_url: The health check URL to associate with this load balancer configuration.
        :param str host_name: (Azure Only) Set only if Azure Shared Application Gateway is used (`lb_type = 5`).
        :param int host_port: The automatically assigned host port.
        :param int index: The load balancer Index.
        :param bool is_internal: Whether or not to create an internal load balancer.
        :param bool is_native: Set to true if the service for which the load balancer is being created is hosted on a docker native host, which is managed directly by DuploCloud, or false if the service is hosted on a cloud-provided platform like EKS, AKS, GKE, ECS, etc. The `get_native_hosts` data source lists the native hosts in a DuploCloud Tenant
        :param int lb_type: The numerical index of the type of load balancer configuration to create.
               Should be one of:
               
                  - `0` : ELB (Classic Load Balancer)
                  - `1` : ALB (Application Load Balancer)
                  - `2` : Health-check Only (No Load Balancer)
                  - `3` : K8S Service w/ Cluster IP (No Load Balancer)
                  - `4` : K8S Service w/ Node Port (No Load Balancer)
                  - `5` : Azure Shared Application Gateway
                  - `6` : NLB (Network Load Balancer)
                  - `7` : Target Group Only
        :param str name: The name of the duplo service.
        :param str port: The backend port associated with this load balancer configuration.
        :param str protocol: The backend protocol associated with this load balancer configuration.
               Supported protocol based on lb_type:
               
               	- `0 (ELB)`: HTTP, HTTPS, TCP, UDP
               	- `1 (ALB)` : HTTP, HTTPS
               	- `3 (K8S Service w/ Cluster IP)`: TCP, UDP
               	- `4 (K8S Service w/ Node Port)` : TCP, UDP
               	- `5 (Azure Shared Application Gateway)`: HTTP, HTTPS
               	- `6 (NLB)` : TCP, UDP, TLS
               	- `7 (Target Group Only)` : HTTP, HTTPS, TCP, UDP, TLS
        :param str replication_controller_name: The name of the duplo service.
        :param bool set_ingress_health_check: Only for K8S services or load balancers in Kubernetes.  Set to `true` to set health check annotations for ingress.
        :param bool skip_http_to_https: Skip http to https.
        :param str target_group_arn: The ARN of the Target Group to which to route traffic.
        """
        pulumi.set(__self__, "allow_global_access", allow_global_access)
        pulumi.set(__self__, "backend_config_timeout_sec", backend_config_timeout_sec)
        pulumi.set(__self__, "backend_protocol_version", backend_protocol_version)
        pulumi.set(__self__, "certificate_arn", certificate_arn)
        pulumi.set(__self__, "cloud_name", cloud_name)
        pulumi.set(__self__, "custom_cidrs", custom_cidrs)
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "external_port", external_port)
        pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        pulumi.set(__self__, "extra_selector_labels", extra_selector_labels)
        pulumi.set(__self__, "frontend_ip", frontend_ip)
        pulumi.set(__self__, "health_check", health_check)
        pulumi.set(__self__, "health_check_url", health_check_url)
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "host_port", host_port)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "is_infra_deployment", is_infra_deployment)
        pulumi.set(__self__, "is_internal", is_internal)
        pulumi.set(__self__, "is_native", is_native)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "replication_controller_name", replication_controller_name)
        pulumi.set(__self__, "set_ingress_health_check", set_ingress_health_check)
        pulumi.set(__self__, "skip_http_to_https", skip_http_to_https)
        pulumi.set(__self__, "target_group_arn", target_group_arn)

    @property
    @pulumi.getter(name="allowGlobalAccess")
    def allow_global_access(self) -> bool:
        """
        Applicable for internal lb.
        """
        return pulumi.get(self, "allow_global_access")

    @property
    @pulumi.getter(name="backendConfigTimeoutSec")
    def backend_config_timeout_sec(self) -> int:
        """
        The number of seconds to wait for the backend to send a response. Must be at least 1. Applicable only for GCP.
        """
        return pulumi.get(self, "backend_config_timeout_sec")

    @property
    @pulumi.getter(name="backendProtocolVersion")
    def backend_protocol_version(self) -> str:
        """
        Is used for communication between the load balancer and the target instances. This field is used to set protocol version for ALB load balancer. Only applicable when protocol is HTTP or HTTPS. The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1
        """
        return pulumi.get(self, "backend_protocol_version")

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> str:
        """
        The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter(name="cloudName")
    def cloud_name(self) -> str:
        """
        The name of the cloud load balancer (if applicable).
        """
        return pulumi.get(self, "cloud_name")

    @property
    @pulumi.getter(name="customCidrs")
    def custom_cidrs(self) -> Sequence[str]:
        """
        Specify CIDR Values. This is applicable only for Network Load Balancer if `lb_type` is `6`.
        """
        return pulumi.get(self, "custom_cidrs")

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> str:
        """
        The DNS name of the cloud load balancer (if applicable).
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> int:
        """
        The frontend port associated with this load balancer configuration. Required if `lb_type` is not `7`.
        """
        return pulumi.get(self, "external_port")

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> str:
        """
        Only for K8S Node Port (`lb_type = 4`) or load balancers in Kubernetes.  Set the kubernetes service `externalTrafficPolicy` attribute.
        """
        return pulumi.get(self, "external_traffic_policy")

    @property
    @pulumi.getter(name="extraSelectorLabels")
    def extra_selector_labels(self) -> Sequence['outputs.GetDuploServiceLbconfigsServiceLbconfigExtraSelectorLabelResult']:
        """
        Only for K8S services or load balancers in Kubernetes.  Sets an additional selector label to narrow which pods can receive traffic.
        """
        return pulumi.get(self, "extra_selector_labels")

    @property
    @pulumi.getter(name="frontendIp")
    def frontend_ip(self) -> str:
        return pulumi.get(self, "frontend_ip")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> 'outputs.GetDuploServiceLbconfigsServiceLbconfigHealthCheckResult':
        """
        Health Check configuration block.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="healthCheckUrl")
    def health_check_url(self) -> str:
        """
        The health check URL to associate with this load balancer configuration.
        """
        return pulumi.get(self, "health_check_url")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        """
        (Azure Only) Set only if Azure Shared Application Gateway is used (`lb_type = 5`).
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> int:
        """
        The automatically assigned host port.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The load balancer Index.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="isInfraDeployment")
    def is_infra_deployment(self) -> bool:
        return pulumi.get(self, "is_infra_deployment")

    @property
    @pulumi.getter(name="isInternal")
    def is_internal(self) -> bool:
        """
        Whether or not to create an internal load balancer.
        """
        return pulumi.get(self, "is_internal")

    @property
    @pulumi.getter(name="isNative")
    def is_native(self) -> bool:
        """
        Set to true if the service for which the load balancer is being created is hosted on a docker native host, which is managed directly by DuploCloud, or false if the service is hosted on a cloud-provided platform like EKS, AKS, GKE, ECS, etc. The `get_native_hosts` data source lists the native hosts in a DuploCloud Tenant
        """
        return pulumi.get(self, "is_native")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        The numerical index of the type of load balancer configuration to create.
        Should be one of:

           - `0` : ELB (Classic Load Balancer)
           - `1` : ALB (Application Load Balancer)
           - `2` : Health-check Only (No Load Balancer)
           - `3` : K8S Service w/ Cluster IP (No Load Balancer)
           - `4` : K8S Service w/ Node Port (No Load Balancer)
           - `5` : Azure Shared Application Gateway
           - `6` : NLB (Network Load Balancer)
           - `7` : Target Group Only
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the duplo service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        The backend port associated with this load balancer configuration.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The backend protocol associated with this load balancer configuration.
        Supported protocol based on lb_type:

        	- `0 (ELB)`: HTTP, HTTPS, TCP, UDP
        	- `1 (ALB)` : HTTP, HTTPS
        	- `3 (K8S Service w/ Cluster IP)`: TCP, UDP
        	- `4 (K8S Service w/ Node Port)` : TCP, UDP
        	- `5 (Azure Shared Application Gateway)`: HTTP, HTTPS
        	- `6 (NLB)` : TCP, UDP, TLS
        	- `7 (Target Group Only)` : HTTP, HTTPS, TCP, UDP, TLS
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="replicationControllerName")
    def replication_controller_name(self) -> str:
        """
        The name of the duplo service.
        """
        return pulumi.get(self, "replication_controller_name")

    @property
    @pulumi.getter(name="setIngressHealthCheck")
    def set_ingress_health_check(self) -> bool:
        """
        Only for K8S services or load balancers in Kubernetes.  Set to `true` to set health check annotations for ingress.
        """
        return pulumi.get(self, "set_ingress_health_check")

    @property
    @pulumi.getter(name="skipHttpToHttps")
    def skip_http_to_https(self) -> bool:
        """
        Skip http to https.
        """
        return pulumi.get(self, "skip_http_to_https")

    @property
    @pulumi.getter(name="targetGroupArn")
    def target_group_arn(self) -> str:
        """
        The ARN of the Target Group to which to route traffic.
        """
        return pulumi.get(self, "target_group_arn")


@pulumi.output_type
class GetDuploServiceLbconfigsServiceLbconfigExtraSelectorLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDuploServiceLbconfigsServiceLbconfigHealthCheckResult(dict):
    def __init__(__self__, *,
                 grpc_success_codes: str,
                 http_success_codes: str,
                 timeout: int,
                 healthy_threshold: Optional[int] = None,
                 interval: Optional[int] = None,
                 unhealthy_threshold: Optional[int] = None):
        """
        :param str grpc_success_codes: Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "0,12" for GRPC) or a range of values (for example, "0-99"). Required for GRPC ALB. Only applies to Application Load Balancers (i.e., GRPC) not Network Load Balancers (i.e., TCP).
        :param str http_success_codes: Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "200,202" for HTTP(s)) or a range of values (for example, "200-299"). Required for HTTP/HTTPS ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS) not Network Load Balancers (i.e., TCP).
        :param int timeout: Amount of time, in seconds, during which no response means a failed health check.
        :param int healthy_threshold: Number of consecutive health checks successes required before considering an unhealthy target healthy.
        :param int interval: Approximate amount of time, in seconds, between health checks of an individual target. Minimum value 5 seconds, Maximum value 300 seconds.
        :param int unhealthy_threshold: Number of consecutive health check failures required before considering the target unhealthy.
        """
        pulumi.set(__self__, "grpc_success_codes", grpc_success_codes)
        pulumi.set(__self__, "http_success_codes", http_success_codes)
        pulumi.set(__self__, "timeout", timeout)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="grpcSuccessCodes")
    def grpc_success_codes(self) -> str:
        """
        Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "0,12" for GRPC) or a range of values (for example, "0-99"). Required for GRPC ALB. Only applies to Application Load Balancers (i.e., GRPC) not Network Load Balancers (i.e., TCP).
        """
        return pulumi.get(self, "grpc_success_codes")

    @property
    @pulumi.getter(name="httpSuccessCodes")
    def http_success_codes(self) -> str:
        """
        Response codes to use when checking for a healthy responses from a target. You can specify multiple values (for example, "200,202" for HTTP(s)) or a range of values (for example, "200-299"). Required for HTTP/HTTPS ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS) not Network Load Balancers (i.e., TCP).
        """
        return pulumi.get(self, "http_success_codes")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        Amount of time, in seconds, during which no response means a failed health check.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive health checks successes required before considering an unhealthy target healthy.
        """
        return pulumi.get(self, "healthy_threshold")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Approximate amount of time, in seconds, between health checks of an individual target. Minimum value 5 seconds, Maximum value 300 seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[int]:
        """
        Number of consecutive health check failures required before considering the target unhealthy.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetDuploServiceParamsResultResult(dict):
    def __init__(__self__, *,
                 dns_prfx: str,
                 replication_controller_name: str,
                 tenant_id: str,
                 webaclid: str):
        pulumi.set(__self__, "dns_prfx", dns_prfx)
        pulumi.set(__self__, "replication_controller_name", replication_controller_name)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "webaclid", webaclid)

    @property
    @pulumi.getter(name="dnsPrfx")
    def dns_prfx(self) -> str:
        return pulumi.get(self, "dns_prfx")

    @property
    @pulumi.getter(name="replicationControllerName")
    def replication_controller_name(self) -> str:
        return pulumi.get(self, "replication_controller_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def webaclid(self) -> str:
        return pulumi.get(self, "webaclid")


@pulumi.output_type
class GetDuploServiceTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDuploServicesServiceResult(dict):
    def __init__(__self__, *,
                 agent_platform: int,
                 allocation_tags: str,
                 any_host_allowed: bool,
                 cloud: int,
                 cloud_creds_from_k8s_service_account: bool,
                 commands: Sequence[str],
                 docker_image: str,
                 domain: str,
                 extra_config: str,
                 force_stateful_set: bool,
                 fqdn: str,
                 fqdn_ex: str,
                 hpa_specs: str,
                 is_daemonset: bool,
                 is_unique_k8s_node_required: bool,
                 lb_synced_deployment: bool,
                 name: str,
                 other_docker_config: str,
                 other_docker_host_config: str,
                 parent_domain: str,
                 replica_collocation_allowed: bool,
                 replicas: int,
                 replicas_matching_asg_name: str,
                 should_spread_across_zones: bool,
                 tags: Sequence['outputs.GetDuploServicesServiceTagResult'],
                 tenant_id: str,
                 volumes: str):
        """
        :param str domain: The service domain (whichever fqdn_ex or fqdn which is non empty)
        :param str fqdn: The fully qualified domain associated with the service
        :param str fqdn_ex: External fully qualified domain associated with the service
        :param bool is_unique_k8s_node_required: Whether or not the replicas must be scheduled on separate Kubernetes nodes.  Only supported on Kubernetes.
        :param str parent_domain: The service's parent domain
        :param bool should_spread_across_zones: Whether or not the replicas must be spread across availability zones.  Only supported on Kubernetes.
        """
        pulumi.set(__self__, "agent_platform", agent_platform)
        pulumi.set(__self__, "allocation_tags", allocation_tags)
        pulumi.set(__self__, "any_host_allowed", any_host_allowed)
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "cloud_creds_from_k8s_service_account", cloud_creds_from_k8s_service_account)
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "docker_image", docker_image)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "extra_config", extra_config)
        pulumi.set(__self__, "force_stateful_set", force_stateful_set)
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "fqdn_ex", fqdn_ex)
        pulumi.set(__self__, "hpa_specs", hpa_specs)
        pulumi.set(__self__, "is_daemonset", is_daemonset)
        pulumi.set(__self__, "is_unique_k8s_node_required", is_unique_k8s_node_required)
        pulumi.set(__self__, "lb_synced_deployment", lb_synced_deployment)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "other_docker_config", other_docker_config)
        pulumi.set(__self__, "other_docker_host_config", other_docker_host_config)
        pulumi.set(__self__, "parent_domain", parent_domain)
        pulumi.set(__self__, "replica_collocation_allowed", replica_collocation_allowed)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "replicas_matching_asg_name", replicas_matching_asg_name)
        pulumi.set(__self__, "should_spread_across_zones", should_spread_across_zones)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="agentPlatform")
    def agent_platform(self) -> int:
        return pulumi.get(self, "agent_platform")

    @property
    @pulumi.getter(name="allocationTags")
    def allocation_tags(self) -> str:
        return pulumi.get(self, "allocation_tags")

    @property
    @pulumi.getter(name="anyHostAllowed")
    def any_host_allowed(self) -> bool:
        return pulumi.get(self, "any_host_allowed")

    @property
    @pulumi.getter
    def cloud(self) -> int:
        return pulumi.get(self, "cloud")

    @property
    @pulumi.getter(name="cloudCredsFromK8sServiceAccount")
    def cloud_creds_from_k8s_service_account(self) -> bool:
        return pulumi.get(self, "cloud_creds_from_k8s_service_account")

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> str:
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The service domain (whichever fqdn_ex or fqdn which is non empty)
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="extraConfig")
    def extra_config(self) -> str:
        return pulumi.get(self, "extra_config")

    @property
    @pulumi.getter(name="forceStatefulSet")
    def force_stateful_set(self) -> bool:
        return pulumi.get(self, "force_stateful_set")

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        The fully qualified domain associated with the service
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="fqdnEx")
    def fqdn_ex(self) -> str:
        """
        External fully qualified domain associated with the service
        """
        return pulumi.get(self, "fqdn_ex")

    @property
    @pulumi.getter(name="hpaSpecs")
    def hpa_specs(self) -> str:
        return pulumi.get(self, "hpa_specs")

    @property
    @pulumi.getter(name="isDaemonset")
    def is_daemonset(self) -> bool:
        return pulumi.get(self, "is_daemonset")

    @property
    @pulumi.getter(name="isUniqueK8sNodeRequired")
    def is_unique_k8s_node_required(self) -> bool:
        """
        Whether or not the replicas must be scheduled on separate Kubernetes nodes.  Only supported on Kubernetes.
        """
        return pulumi.get(self, "is_unique_k8s_node_required")

    @property
    @pulumi.getter(name="lbSyncedDeployment")
    def lb_synced_deployment(self) -> bool:
        return pulumi.get(self, "lb_synced_deployment")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="otherDockerConfig")
    def other_docker_config(self) -> str:
        return pulumi.get(self, "other_docker_config")

    @property
    @pulumi.getter(name="otherDockerHostConfig")
    def other_docker_host_config(self) -> str:
        return pulumi.get(self, "other_docker_host_config")

    @property
    @pulumi.getter(name="parentDomain")
    def parent_domain(self) -> str:
        """
        The service's parent domain
        """
        return pulumi.get(self, "parent_domain")

    @property
    @pulumi.getter(name="replicaCollocationAllowed")
    def replica_collocation_allowed(self) -> bool:
        return pulumi.get(self, "replica_collocation_allowed")

    @property
    @pulumi.getter
    def replicas(self) -> int:
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="replicasMatchingAsgName")
    def replicas_matching_asg_name(self) -> str:
        return pulumi.get(self, "replicas_matching_asg_name")

    @property
    @pulumi.getter(name="shouldSpreadAcrossZones")
    def should_spread_across_zones(self) -> bool:
        """
        Whether or not the replicas must be spread across availability zones.  Only supported on Kubernetes.
        """
        return pulumi.get(self, "should_spread_across_zones")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetDuploServicesServiceTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def volumes(self) -> str:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GetDuploServicesServiceTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetEcsServiceCapacityProviderStrategyResult(dict):
    def __init__(__self__, *,
                 base: int,
                 capacity_provider: str,
                 weight: int):
        """
        :param int base: The number of tasks, at a minimum, to run on the specified capacity provider.
        :param str capacity_provider: Name of the capacity provider. Should be one of:
                	- FARGATE
                	- FARGATE_SPOT
                	- ASG fullname: Used when asg created with agent platform ECS
        :param int weight: The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        pulumi.set(__self__, "base", base)
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def base(self) -> int:
        """
        The number of tasks, at a minimum, to run on the specified capacity provider.
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> str:
        """
        Name of the capacity provider. Should be one of:
         	- FARGATE
         	- FARGATE_SPOT
         	- ASG fullname: Used when asg created with agent platform ECS
        """
        return pulumi.get(self, "capacity_provider")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetEcsServiceDeploymentConfigurationResult(dict):
    def __init__(__self__, *,
                 alarms: Sequence['outputs.GetEcsServiceDeploymentConfigurationAlarmResult'],
                 enable_circuit_breaker: bool,
                 maximum_percent: int,
                 minimum_healthy_percent: int,
                 rollback_circuit_breaker: bool):
        """
        :param bool enable_circuit_breaker: Enables ECS deployment circuit breaker to stop deployments on failures.
        :param int maximum_percent: Specifies the maximum percentage of tasks that can run at once during a deployment.
        :param int minimum_healthy_percent: Specifies the minimum percentage of tasks that must remain in the RUNNING state during a deployment
        :param bool rollback_circuit_breaker: Enables automatic rollback when the circuit breaker detects a failed deployment.
        """
        pulumi.set(__self__, "alarms", alarms)
        pulumi.set(__self__, "enable_circuit_breaker", enable_circuit_breaker)
        pulumi.set(__self__, "maximum_percent", maximum_percent)
        pulumi.set(__self__, "minimum_healthy_percent", minimum_healthy_percent)
        pulumi.set(__self__, "rollback_circuit_breaker", rollback_circuit_breaker)

    @property
    @pulumi.getter
    def alarms(self) -> Sequence['outputs.GetEcsServiceDeploymentConfigurationAlarmResult']:
        return pulumi.get(self, "alarms")

    @property
    @pulumi.getter(name="enableCircuitBreaker")
    def enable_circuit_breaker(self) -> bool:
        """
        Enables ECS deployment circuit breaker to stop deployments on failures.
        """
        return pulumi.get(self, "enable_circuit_breaker")

    @property
    @pulumi.getter(name="maximumPercent")
    def maximum_percent(self) -> int:
        """
        Specifies the maximum percentage of tasks that can run at once during a deployment.
        """
        return pulumi.get(self, "maximum_percent")

    @property
    @pulumi.getter(name="minimumHealthyPercent")
    def minimum_healthy_percent(self) -> int:
        """
        Specifies the minimum percentage of tasks that must remain in the RUNNING state during a deployment
        """
        return pulumi.get(self, "minimum_healthy_percent")

    @property
    @pulumi.getter(name="rollbackCircuitBreaker")
    def rollback_circuit_breaker(self) -> bool:
        """
        Enables automatic rollback when the circuit breaker detects a failed deployment.
        """
        return pulumi.get(self, "rollback_circuit_breaker")


@pulumi.output_type
class GetEcsServiceDeploymentConfigurationAlarmResult(dict):
    def __init__(__self__, *,
                 enable: bool,
                 names: Sequence[str],
                 rollback: bool):
        """
        :param bool enable: Enables or disables CloudWatch alarm monitoring during deployments.
        :param Sequence[str] names: Names of CloudWatch alarms that ECS monitors during deployments.
        :param bool rollback: Automatically rolls back the deployment if any configured CloudWatch alarm enters ALARM state.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Enables or disables CloudWatch alarm monitoring during deployments.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def names(self) -> Sequence[str]:
        """
        Names of CloudWatch alarms that ECS monitors during deployments.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def rollback(self) -> bool:
        """
        Automatically rolls back the deployment if any configured CloudWatch alarm enters ALARM state.
        """
        return pulumi.get(self, "rollback")


@pulumi.output_type
class GetEcsServiceLoadBalancerResult(dict):
    def __init__(__self__, *,
                 backend_protocol: str,
                 backend_protocol_version: str,
                 certificate_arn: str,
                 drop_invalid_headers: bool,
                 enable_access_logs: bool,
                 external_port: int,
                 health_check_configs: Sequence['outputs.GetEcsServiceLoadBalancerHealthCheckConfigResult'],
                 health_check_url: str,
                 http_to_https_redirect: bool,
                 idle_timeout: int,
                 index: int,
                 is_internal: bool,
                 lb_type: int,
                 load_balancer_arn: str,
                 load_balancer_name: str,
                 port: str,
                 protocol: str,
                 replication_controller_name: str,
                 target_group_count: int,
                 webaclid: str):
        """
        :param str backend_protocol: The backend protocol associated with this load balancer configuration.
        :param str backend_protocol_version: The backend protocol version associated with this load balancer configuration.
        :param str certificate_arn: The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        :param bool drop_invalid_headers: Whether or not to drop invalid HTTP headers received by the load balancer.
        :param bool enable_access_logs: Whether or not to enable access logs.  When enabled, Duplo will send access logs to a centralized S3 bucket per plan
        :param int external_port: The frontend port associated with this load balancer configuration.
        :param Sequence['GetEcsServiceLoadBalancerHealthCheckConfigArgs'] health_check_configs: Health check configuration for this load balancer.
        :param str health_check_url: The health check URL to associate with this load balancer configuration.
        :param bool http_to_https_redirect: Whether or not the load balancer should redirect HTTP to HTTPS.
        :param int idle_timeout: The time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`.
        :param int index: The load balancer Index.
        :param bool is_internal: Whether or not to create an internal load balancer.
        :param int lb_type: The numerical index of the type of load balancer configuration to create.
               Should be one of:
               
                  - `0` : ELB (Classic Load Balancer)
                  - `1` : ALB (Application Load Balancer)
                  - `2` : Health-check Only (No Load Balancer)
        :param str load_balancer_arn: The load balancer ARN.
        :param str load_balancer_name: The load balancer name.
        :param str port: The backend port associated with this load balancer configuration.
        :param str protocol: The frontend protocol associated with this load balancer configuration.
        :param int target_group_count: Number of Load Balancer target group to associate with the service.
        :param str webaclid: The ARN of a web application firewall to associate this load balancer.
        """
        pulumi.set(__self__, "backend_protocol", backend_protocol)
        pulumi.set(__self__, "backend_protocol_version", backend_protocol_version)
        pulumi.set(__self__, "certificate_arn", certificate_arn)
        pulumi.set(__self__, "drop_invalid_headers", drop_invalid_headers)
        pulumi.set(__self__, "enable_access_logs", enable_access_logs)
        pulumi.set(__self__, "external_port", external_port)
        pulumi.set(__self__, "health_check_configs", health_check_configs)
        pulumi.set(__self__, "health_check_url", health_check_url)
        pulumi.set(__self__, "http_to_https_redirect", http_to_https_redirect)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "is_internal", is_internal)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "replication_controller_name", replication_controller_name)
        pulumi.set(__self__, "target_group_count", target_group_count)
        pulumi.set(__self__, "webaclid", webaclid)

    @property
    @pulumi.getter(name="backendProtocol")
    @_utilities.deprecated("""Use 'backend_protocol_version' instead.""")
    def backend_protocol(self) -> str:
        """
        The backend protocol associated with this load balancer configuration.
        """
        return pulumi.get(self, "backend_protocol")

    @property
    @pulumi.getter(name="backendProtocolVersion")
    def backend_protocol_version(self) -> str:
        """
        The backend protocol version associated with this load balancer configuration.
        """
        return pulumi.get(self, "backend_protocol_version")

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> str:
        """
        The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter(name="dropInvalidHeaders")
    def drop_invalid_headers(self) -> bool:
        """
        Whether or not to drop invalid HTTP headers received by the load balancer.
        """
        return pulumi.get(self, "drop_invalid_headers")

    @property
    @pulumi.getter(name="enableAccessLogs")
    def enable_access_logs(self) -> bool:
        """
        Whether or not to enable access logs.  When enabled, Duplo will send access logs to a centralized S3 bucket per plan
        """
        return pulumi.get(self, "enable_access_logs")

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> int:
        """
        The frontend port associated with this load balancer configuration.
        """
        return pulumi.get(self, "external_port")

    @property
    @pulumi.getter(name="healthCheckConfigs")
    def health_check_configs(self) -> Sequence['outputs.GetEcsServiceLoadBalancerHealthCheckConfigResult']:
        """
        Health check configuration for this load balancer.
        """
        return pulumi.get(self, "health_check_configs")

    @property
    @pulumi.getter(name="healthCheckUrl")
    def health_check_url(self) -> str:
        """
        The health check URL to associate with this load balancer configuration.
        """
        return pulumi.get(self, "health_check_url")

    @property
    @pulumi.getter(name="httpToHttpsRedirect")
    def http_to_https_redirect(self) -> bool:
        """
        Whether or not the load balancer should redirect HTTP to HTTPS.
        """
        return pulumi.get(self, "http_to_https_redirect")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> int:
        """
        The time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The load balancer Index.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="isInternal")
    def is_internal(self) -> bool:
        """
        Whether or not to create an internal load balancer.
        """
        return pulumi.get(self, "is_internal")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        The numerical index of the type of load balancer configuration to create.
        Should be one of:

           - `0` : ELB (Classic Load Balancer)
           - `1` : ALB (Application Load Balancer)
           - `2` : Health-check Only (No Load Balancer)
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> str:
        """
        The load balancer ARN.
        """
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> str:
        """
        The load balancer name.
        """
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        The backend port associated with this load balancer configuration.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The frontend protocol associated with this load balancer configuration.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="replicationControllerName")
    def replication_controller_name(self) -> str:
        return pulumi.get(self, "replication_controller_name")

    @property
    @pulumi.getter(name="targetGroupCount")
    def target_group_count(self) -> int:
        """
        Number of Load Balancer target group to associate with the service.
        """
        return pulumi.get(self, "target_group_count")

    @property
    @pulumi.getter
    def webaclid(self) -> str:
        """
        The ARN of a web application firewall to associate this load balancer.
        """
        return pulumi.get(self, "webaclid")


@pulumi.output_type
class GetEcsServiceLoadBalancerHealthCheckConfigResult(dict):
    def __init__(__self__, *,
                 grpc_success_code: str,
                 health_check_interval_seconds: int,
                 health_check_timeout_seconds: int,
                 healthy_threshold_count: int,
                 http_success_code: str,
                 unhealthy_threshold_count: int):
        pulumi.set(__self__, "grpc_success_code", grpc_success_code)
        pulumi.set(__self__, "health_check_interval_seconds", health_check_interval_seconds)
        pulumi.set(__self__, "health_check_timeout_seconds", health_check_timeout_seconds)
        pulumi.set(__self__, "healthy_threshold_count", healthy_threshold_count)
        pulumi.set(__self__, "http_success_code", http_success_code)
        pulumi.set(__self__, "unhealthy_threshold_count", unhealthy_threshold_count)

    @property
    @pulumi.getter(name="grpcSuccessCode")
    def grpc_success_code(self) -> str:
        return pulumi.get(self, "grpc_success_code")

    @property
    @pulumi.getter(name="healthCheckIntervalSeconds")
    def health_check_interval_seconds(self) -> int:
        return pulumi.get(self, "health_check_interval_seconds")

    @property
    @pulumi.getter(name="healthCheckTimeoutSeconds")
    def health_check_timeout_seconds(self) -> int:
        return pulumi.get(self, "health_check_timeout_seconds")

    @property
    @pulumi.getter(name="healthyThresholdCount")
    def healthy_threshold_count(self) -> int:
        return pulumi.get(self, "healthy_threshold_count")

    @property
    @pulumi.getter(name="httpSuccessCode")
    def http_success_code(self) -> str:
        return pulumi.get(self, "http_success_code")

    @property
    @pulumi.getter(name="unhealthyThresholdCount")
    def unhealthy_threshold_count(self) -> int:
        return pulumi.get(self, "unhealthy_threshold_count")


@pulumi.output_type
class GetEcsServicePlacementConstraintResult(dict):
    def __init__(__self__, *,
                 expression: str,
                 type: str):
        """
        :param str expression: Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        :param str type: Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEcsServicePlacementStrategyResult(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str):
        """
        :param str field: For the spread placement strategy, valid values are instanceId, or any platform or custom attribute that is applied to a container instance. For the binpack type, valid values are memory and cpu. For the random type, this attribute is not needed. For more information, see [PlacementStrategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html)
        :param str type: Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        For the spread placement strategy, valid values are instanceId, or any platform or custom attribute that is applied to a container instance. For the binpack type, valid values are memory and cpu. For the random type, this attribute is not needed. For more information, see [PlacementStrategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html)
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEcsServicesServiceResult(dict):
    def __init__(__self__, *,
                 capacity_provider_strategies: Sequence['outputs.GetEcsServicesServiceCapacityProviderStrategyResult'],
                 deployment_configurations: Sequence['outputs.GetEcsServicesServiceDeploymentConfigurationResult'],
                 dns_prfx: str,
                 health_check_grace_period_seconds: int,
                 index: int,
                 is_target_group_only: bool,
                 load_balancers: Sequence['outputs.GetEcsServicesServiceLoadBalancerResult'],
                 name: str,
                 old_task_definition_buffer_size: int,
                 placement_constraints: Sequence['outputs.GetEcsServicesServicePlacementConstraintResult'],
                 placement_strategies: Sequence['outputs.GetEcsServicesServicePlacementStrategyResult'],
                 replicas: int,
                 target_group_arns: Sequence[str],
                 task_definition: str,
                 tenant_id: str):
        """
        :param str dns_prfx: The DNS prefix to assign to this service's load balancer.
        :param int index: The index of the ecs service.
        :param Sequence['GetEcsServicesServiceLoadBalancerArgs'] load_balancers: Zero or more load balancer configurations to associate with this service.
        :param str name: The name of the service to create.
        :param int old_task_definition_buffer_size: The number of older task definitions to retain in AWS.
        :param Sequence['GetEcsServicesServicePlacementConstraintArgs'] placement_constraints: Rules that are taken into consideration during task placement. Maximum number of `placement_constraints` is `10`
        :param Sequence['GetEcsServicesServicePlacementStrategyArgs'] placement_strategies: Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. The maximum number of `placement_strategy` blocks is `5`
        :param int replicas: The number of container replicas to create.
        :param str task_definition: The ARN of the task definition to use.
        :param str tenant_id: The GUID of the tenant that the service will be created in.
        """
        pulumi.set(__self__, "capacity_provider_strategies", capacity_provider_strategies)
        pulumi.set(__self__, "deployment_configurations", deployment_configurations)
        pulumi.set(__self__, "dns_prfx", dns_prfx)
        pulumi.set(__self__, "health_check_grace_period_seconds", health_check_grace_period_seconds)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "is_target_group_only", is_target_group_only)
        pulumi.set(__self__, "load_balancers", load_balancers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "old_task_definition_buffer_size", old_task_definition_buffer_size)
        pulumi.set(__self__, "placement_constraints", placement_constraints)
        pulumi.set(__self__, "placement_strategies", placement_strategies)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "target_group_arns", target_group_arns)
        pulumi.set(__self__, "task_definition", task_definition)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="capacityProviderStrategies")
    def capacity_provider_strategies(self) -> Sequence['outputs.GetEcsServicesServiceCapacityProviderStrategyResult']:
        return pulumi.get(self, "capacity_provider_strategies")

    @property
    @pulumi.getter(name="deploymentConfigurations")
    def deployment_configurations(self) -> Sequence['outputs.GetEcsServicesServiceDeploymentConfigurationResult']:
        return pulumi.get(self, "deployment_configurations")

    @property
    @pulumi.getter(name="dnsPrfx")
    def dns_prfx(self) -> str:
        """
        The DNS prefix to assign to this service's load balancer.
        """
        return pulumi.get(self, "dns_prfx")

    @property
    @pulumi.getter(name="healthCheckGracePeriodSeconds")
    def health_check_grace_period_seconds(self) -> int:
        return pulumi.get(self, "health_check_grace_period_seconds")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The index of the ecs service.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="isTargetGroupOnly")
    def is_target_group_only(self) -> bool:
        return pulumi.get(self, "is_target_group_only")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Sequence['outputs.GetEcsServicesServiceLoadBalancerResult']:
        """
        Zero or more load balancer configurations to associate with this service.
        """
        return pulumi.get(self, "load_balancers")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the service to create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="oldTaskDefinitionBufferSize")
    def old_task_definition_buffer_size(self) -> int:
        """
        The number of older task definitions to retain in AWS.
        """
        return pulumi.get(self, "old_task_definition_buffer_size")

    @property
    @pulumi.getter(name="placementConstraints")
    def placement_constraints(self) -> Sequence['outputs.GetEcsServicesServicePlacementConstraintResult']:
        """
        Rules that are taken into consideration during task placement. Maximum number of `placement_constraints` is `10`
        """
        return pulumi.get(self, "placement_constraints")

    @property
    @pulumi.getter(name="placementStrategies")
    def placement_strategies(self) -> Sequence['outputs.GetEcsServicesServicePlacementStrategyResult']:
        """
        Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. The maximum number of `placement_strategy` blocks is `5`
        """
        return pulumi.get(self, "placement_strategies")

    @property
    @pulumi.getter
    def replicas(self) -> int:
        """
        The number of container replicas to create.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="targetGroupArns")
    def target_group_arns(self) -> Sequence[str]:
        return pulumi.get(self, "target_group_arns")

    @property
    @pulumi.getter(name="taskDefinition")
    def task_definition(self) -> str:
        """
        The ARN of the task definition to use.
        """
        return pulumi.get(self, "task_definition")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The GUID of the tenant that the service will be created in.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetEcsServicesServiceCapacityProviderStrategyResult(dict):
    def __init__(__self__, *,
                 base: int,
                 capacity_provider: str,
                 weight: int):
        """
        :param int base: The number of tasks, at a minimum, to run on the specified capacity provider.
        :param str capacity_provider: Name of the capacity provider. Should be one of:
                	- FARGATE
                	- FARGATE_SPOT
                	- ASG fullname: Used when asg created with agent platform ECS
        :param int weight: The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        pulumi.set(__self__, "base", base)
        pulumi.set(__self__, "capacity_provider", capacity_provider)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def base(self) -> int:
        """
        The number of tasks, at a minimum, to run on the specified capacity provider.
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter(name="capacityProvider")
    def capacity_provider(self) -> str:
        """
        Name of the capacity provider. Should be one of:
         	- FARGATE
         	- FARGATE_SPOT
         	- ASG fullname: Used when asg created with agent platform ECS
        """
        return pulumi.get(self, "capacity_provider")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The relative percentage of the total number of launched tasks that should use the specified capacity provider.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetEcsServicesServiceDeploymentConfigurationResult(dict):
    def __init__(__self__, *,
                 alarms: Sequence['outputs.GetEcsServicesServiceDeploymentConfigurationAlarmResult'],
                 enable_circuit_breaker: bool,
                 maximum_percent: int,
                 minimum_healthy_percent: int,
                 rollback_circuit_breaker: bool):
        """
        :param bool enable_circuit_breaker: Enables ECS deployment circuit breaker to stop deployments on failures.
        :param int maximum_percent: Specifies the maximum percentage of tasks that can run at once during a deployment.
        :param int minimum_healthy_percent: Specifies the minimum percentage of tasks that must remain in the RUNNING state during a deployment
        :param bool rollback_circuit_breaker: Enables automatic rollback when the circuit breaker detects a failed deployment.
        """
        pulumi.set(__self__, "alarms", alarms)
        pulumi.set(__self__, "enable_circuit_breaker", enable_circuit_breaker)
        pulumi.set(__self__, "maximum_percent", maximum_percent)
        pulumi.set(__self__, "minimum_healthy_percent", minimum_healthy_percent)
        pulumi.set(__self__, "rollback_circuit_breaker", rollback_circuit_breaker)

    @property
    @pulumi.getter
    def alarms(self) -> Sequence['outputs.GetEcsServicesServiceDeploymentConfigurationAlarmResult']:
        return pulumi.get(self, "alarms")

    @property
    @pulumi.getter(name="enableCircuitBreaker")
    def enable_circuit_breaker(self) -> bool:
        """
        Enables ECS deployment circuit breaker to stop deployments on failures.
        """
        return pulumi.get(self, "enable_circuit_breaker")

    @property
    @pulumi.getter(name="maximumPercent")
    def maximum_percent(self) -> int:
        """
        Specifies the maximum percentage of tasks that can run at once during a deployment.
        """
        return pulumi.get(self, "maximum_percent")

    @property
    @pulumi.getter(name="minimumHealthyPercent")
    def minimum_healthy_percent(self) -> int:
        """
        Specifies the minimum percentage of tasks that must remain in the RUNNING state during a deployment
        """
        return pulumi.get(self, "minimum_healthy_percent")

    @property
    @pulumi.getter(name="rollbackCircuitBreaker")
    def rollback_circuit_breaker(self) -> bool:
        """
        Enables automatic rollback when the circuit breaker detects a failed deployment.
        """
        return pulumi.get(self, "rollback_circuit_breaker")


@pulumi.output_type
class GetEcsServicesServiceDeploymentConfigurationAlarmResult(dict):
    def __init__(__self__, *,
                 enable: bool,
                 names: Sequence[str],
                 rollback: bool):
        """
        :param bool enable: Enables or disables CloudWatch alarm monitoring during deployments.
        :param Sequence[str] names: Names of CloudWatch alarms that ECS monitors during deployments.
        :param bool rollback: Automatically rolls back the deployment if any configured CloudWatch alarm enters ALARM state.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "rollback", rollback)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Enables or disables CloudWatch alarm monitoring during deployments.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def names(self) -> Sequence[str]:
        """
        Names of CloudWatch alarms that ECS monitors during deployments.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def rollback(self) -> bool:
        """
        Automatically rolls back the deployment if any configured CloudWatch alarm enters ALARM state.
        """
        return pulumi.get(self, "rollback")


@pulumi.output_type
class GetEcsServicesServiceLoadBalancerResult(dict):
    def __init__(__self__, *,
                 backend_protocol: str,
                 backend_protocol_version: str,
                 certificate_arn: str,
                 drop_invalid_headers: bool,
                 enable_access_logs: bool,
                 external_port: int,
                 health_check_configs: Sequence['outputs.GetEcsServicesServiceLoadBalancerHealthCheckConfigResult'],
                 health_check_url: str,
                 http_to_https_redirect: bool,
                 idle_timeout: int,
                 index: int,
                 is_internal: bool,
                 lb_type: int,
                 load_balancer_arn: str,
                 load_balancer_name: str,
                 port: str,
                 protocol: str,
                 replication_controller_name: str,
                 target_group_count: int,
                 webaclid: str):
        """
        :param str backend_protocol: The backend protocol associated with this load balancer configuration.
        :param str backend_protocol_version: The backend protocol version associated with this load balancer configuration.
        :param str certificate_arn: The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        :param bool drop_invalid_headers: Whether or not to drop invalid HTTP headers received by the load balancer.
        :param bool enable_access_logs: Whether or not to enable access logs.  When enabled, Duplo will send access logs to a centralized S3 bucket per plan
        :param int external_port: The frontend port associated with this load balancer configuration.
        :param Sequence['GetEcsServicesServiceLoadBalancerHealthCheckConfigArgs'] health_check_configs: Health check configuration for this load balancer.
        :param str health_check_url: The health check URL to associate with this load balancer configuration.
        :param bool http_to_https_redirect: Whether or not the load balancer should redirect HTTP to HTTPS.
        :param int idle_timeout: The time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`.
        :param int index: The load balancer Index.
        :param bool is_internal: Whether or not to create an internal load balancer.
        :param int lb_type: The numerical index of the type of load balancer configuration to create.
               Should be one of:
               
                  - `0` : ELB (Classic Load Balancer)
                  - `1` : ALB (Application Load Balancer)
                  - `2` : Health-check Only (No Load Balancer)
        :param str load_balancer_arn: The load balancer ARN.
        :param str load_balancer_name: The load balancer name.
        :param str port: The backend port associated with this load balancer configuration.
        :param str protocol: The frontend protocol associated with this load balancer configuration.
        :param int target_group_count: Number of Load Balancer target group to associate with the service.
        :param str webaclid: The ARN of a web application firewall to associate this load balancer.
        """
        pulumi.set(__self__, "backend_protocol", backend_protocol)
        pulumi.set(__self__, "backend_protocol_version", backend_protocol_version)
        pulumi.set(__self__, "certificate_arn", certificate_arn)
        pulumi.set(__self__, "drop_invalid_headers", drop_invalid_headers)
        pulumi.set(__self__, "enable_access_logs", enable_access_logs)
        pulumi.set(__self__, "external_port", external_port)
        pulumi.set(__self__, "health_check_configs", health_check_configs)
        pulumi.set(__self__, "health_check_url", health_check_url)
        pulumi.set(__self__, "http_to_https_redirect", http_to_https_redirect)
        pulumi.set(__self__, "idle_timeout", idle_timeout)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "is_internal", is_internal)
        pulumi.set(__self__, "lb_type", lb_type)
        pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        pulumi.set(__self__, "load_balancer_name", load_balancer_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "replication_controller_name", replication_controller_name)
        pulumi.set(__self__, "target_group_count", target_group_count)
        pulumi.set(__self__, "webaclid", webaclid)

    @property
    @pulumi.getter(name="backendProtocol")
    @_utilities.deprecated("""Use 'backend_protocol_version' instead.""")
    def backend_protocol(self) -> str:
        """
        The backend protocol associated with this load balancer configuration.
        """
        return pulumi.get(self, "backend_protocol")

    @property
    @pulumi.getter(name="backendProtocolVersion")
    def backend_protocol_version(self) -> str:
        """
        The backend protocol version associated with this load balancer configuration.
        """
        return pulumi.get(self, "backend_protocol_version")

    @property
    @pulumi.getter(name="certificateArn")
    def certificate_arn(self) -> str:
        """
        The ARN of an ACM certificate to associate with this load balancer.  Only applicable for HTTPS.
        """
        return pulumi.get(self, "certificate_arn")

    @property
    @pulumi.getter(name="dropInvalidHeaders")
    def drop_invalid_headers(self) -> bool:
        """
        Whether or not to drop invalid HTTP headers received by the load balancer.
        """
        return pulumi.get(self, "drop_invalid_headers")

    @property
    @pulumi.getter(name="enableAccessLogs")
    def enable_access_logs(self) -> bool:
        """
        Whether or not to enable access logs.  When enabled, Duplo will send access logs to a centralized S3 bucket per plan
        """
        return pulumi.get(self, "enable_access_logs")

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> int:
        """
        The frontend port associated with this load balancer configuration.
        """
        return pulumi.get(self, "external_port")

    @property
    @pulumi.getter(name="healthCheckConfigs")
    def health_check_configs(self) -> Sequence['outputs.GetEcsServicesServiceLoadBalancerHealthCheckConfigResult']:
        """
        Health check configuration for this load balancer.
        """
        return pulumi.get(self, "health_check_configs")

    @property
    @pulumi.getter(name="healthCheckUrl")
    def health_check_url(self) -> str:
        """
        The health check URL to associate with this load balancer configuration.
        """
        return pulumi.get(self, "health_check_url")

    @property
    @pulumi.getter(name="httpToHttpsRedirect")
    def http_to_https_redirect(self) -> bool:
        """
        Whether or not the load balancer should redirect HTTP to HTTPS.
        """
        return pulumi.get(self, "http_to_https_redirect")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> int:
        """
        The time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The load balancer Index.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="isInternal")
    def is_internal(self) -> bool:
        """
        Whether or not to create an internal load balancer.
        """
        return pulumi.get(self, "is_internal")

    @property
    @pulumi.getter(name="lbType")
    def lb_type(self) -> int:
        """
        The numerical index of the type of load balancer configuration to create.
        Should be one of:

           - `0` : ELB (Classic Load Balancer)
           - `1` : ALB (Application Load Balancer)
           - `2` : Health-check Only (No Load Balancer)
        """
        return pulumi.get(self, "lb_type")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> str:
        """
        The load balancer ARN.
        """
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerName")
    def load_balancer_name(self) -> str:
        """
        The load balancer name.
        """
        return pulumi.get(self, "load_balancer_name")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        The backend port associated with this load balancer configuration.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The frontend protocol associated with this load balancer configuration.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="replicationControllerName")
    def replication_controller_name(self) -> str:
        return pulumi.get(self, "replication_controller_name")

    @property
    @pulumi.getter(name="targetGroupCount")
    def target_group_count(self) -> int:
        """
        Number of Load Balancer target group to associate with the service.
        """
        return pulumi.get(self, "target_group_count")

    @property
    @pulumi.getter
    def webaclid(self) -> str:
        """
        The ARN of a web application firewall to associate this load balancer.
        """
        return pulumi.get(self, "webaclid")


@pulumi.output_type
class GetEcsServicesServiceLoadBalancerHealthCheckConfigResult(dict):
    def __init__(__self__, *,
                 grpc_success_code: str,
                 health_check_interval_seconds: int,
                 health_check_timeout_seconds: int,
                 healthy_threshold_count: int,
                 http_success_code: str,
                 unhealthy_threshold_count: int):
        pulumi.set(__self__, "grpc_success_code", grpc_success_code)
        pulumi.set(__self__, "health_check_interval_seconds", health_check_interval_seconds)
        pulumi.set(__self__, "health_check_timeout_seconds", health_check_timeout_seconds)
        pulumi.set(__self__, "healthy_threshold_count", healthy_threshold_count)
        pulumi.set(__self__, "http_success_code", http_success_code)
        pulumi.set(__self__, "unhealthy_threshold_count", unhealthy_threshold_count)

    @property
    @pulumi.getter(name="grpcSuccessCode")
    def grpc_success_code(self) -> str:
        return pulumi.get(self, "grpc_success_code")

    @property
    @pulumi.getter(name="healthCheckIntervalSeconds")
    def health_check_interval_seconds(self) -> int:
        return pulumi.get(self, "health_check_interval_seconds")

    @property
    @pulumi.getter(name="healthCheckTimeoutSeconds")
    def health_check_timeout_seconds(self) -> int:
        return pulumi.get(self, "health_check_timeout_seconds")

    @property
    @pulumi.getter(name="healthyThresholdCount")
    def healthy_threshold_count(self) -> int:
        return pulumi.get(self, "healthy_threshold_count")

    @property
    @pulumi.getter(name="httpSuccessCode")
    def http_success_code(self) -> str:
        return pulumi.get(self, "http_success_code")

    @property
    @pulumi.getter(name="unhealthyThresholdCount")
    def unhealthy_threshold_count(self) -> int:
        return pulumi.get(self, "unhealthy_threshold_count")


@pulumi.output_type
class GetEcsServicesServicePlacementConstraintResult(dict):
    def __init__(__self__, *,
                 expression: str,
                 type: str):
        """
        :param str expression: Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        :param str type: Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see [Cluster Query Language in the Amazon EC2 Container Service Developer Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/cluster-query-language.html).
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of constraint. The only valid values at this time are `memberOf` and `distinctInstance`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEcsServicesServicePlacementStrategyResult(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str):
        """
        :param str field: For the spread placement strategy, valid values are instanceId, or any platform or custom attribute that is applied to a container instance. For the binpack type, valid values are memory and cpu. For the random type, this attribute is not needed. For more information, see [PlacementStrategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html)
        :param str type: Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        For the spread placement strategy, valid values are instanceId, or any platform or custom attribute that is applied to a container instance. For the binpack type, valid values are memory and cpu. For the random type, this attribute is not needed. For more information, see [PlacementStrategy](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PlacementStrategy.html)
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of placement strategy. Must be one of: `binpack`, `random`, or `spread`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEcsTaskDefinitionInferenceAcceleratorResult(dict):
    def __init__(__self__, *,
                 device_name: str,
                 device_type: str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "device_type", device_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> str:
        return pulumi.get(self, "device_type")


@pulumi.output_type
class GetEcsTaskDefinitionPlacementConstraintResult(dict):
    def __init__(__self__, *,
                 expression: str,
                 type: str):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEcsTaskDefinitionProxyConfigurationResult(dict):
    def __init__(__self__, *,
                 container_name: str,
                 properties: Mapping[str, str],
                 type: str):
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def properties(self) -> Mapping[str, str]:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEcsTaskDefinitionRequiresAttributeResult(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetEcsTaskDefinitionRuntimePlatformResult(dict):
    def __init__(__self__, *,
                 cpu_architecture: str,
                 operating_system_family: str):
        """
        :param str cpu_architecture: Valid values are 'X86_64','ARM64'
        :param str operating_system_family: Valid values are <br>For FARGATE: 'LINUX','WINDOWS_SERVER_2019_FULL','WINDOWS_SERVER_2019_CORE','WINDOWS_SERVER_2022_FULL','WINDOWS_SERVER_2022_CORE'
        """
        pulumi.set(__self__, "cpu_architecture", cpu_architecture)
        pulumi.set(__self__, "operating_system_family", operating_system_family)

    @property
    @pulumi.getter(name="cpuArchitecture")
    def cpu_architecture(self) -> str:
        """
        Valid values are 'X86_64','ARM64'
        """
        return pulumi.get(self, "cpu_architecture")

    @property
    @pulumi.getter(name="operatingSystemFamily")
    def operating_system_family(self) -> str:
        """
        Valid values are <br>For FARGATE: 'LINUX','WINDOWS_SERVER_2019_FULL','WINDOWS_SERVER_2019_CORE','WINDOWS_SERVER_2022_FULL','WINDOWS_SERVER_2022_CORE'
        """
        return pulumi.get(self, "operating_system_family")


@pulumi.output_type
class GetEcsTaskDefinitionTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetEcsTaskDefinitionsTaskDefinitionResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 family: str,
                 latest: bool,
                 name: str,
                 revision: int):
        """
        :param str arn: The ARN of the task definition.
        :param str family: The family the task definition.
        :param bool latest: The current revision of the task definition.
        :param str name: The short name of the task definition.
        :param int revision: The current revision of the task definition.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "latest", latest)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The ARN of the task definition.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def family(self) -> str:
        """
        The family the task definition.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def latest(self) -> bool:
        """
        The current revision of the task definition.
        """
        return pulumi.get(self, "latest")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The short name of the task definition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def revision(self) -> int:
        """
        The current revision of the task definition.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class GetEmrClusterDataResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 job_flow_id: str,
                 name: str,
                 status: str,
                 tenant_id: str):
        """
        :param str arn: The ARN of the emrCluster.
        :param str job_flow_id: The job flow id of the emrCluster.
        :param str name: The  name of the emrCluster.
        :param str status: The status of the emrCluster.
        :param str tenant_id: The GUID of the tenant that the emrCluster will be created in.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "job_flow_id", job_flow_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The ARN of the emrCluster.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="jobFlowId")
    def job_flow_id(self) -> str:
        """
        The job flow id of the emrCluster.
        """
        return pulumi.get(self, "job_flow_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The  name of the emrCluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the emrCluster.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The GUID of the tenant that the emrCluster will be created in.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetGcpFirestoresFirestoreResult(dict):
    def __init__(__self__, *,
                 app_engine_integration_mode: str,
                 concurrency_mode: str,
                 earliest_version_time: str,
                 enable_delete_protection: bool,
                 enable_point_in_time_recovery: bool,
                 etag: str,
                 fullname: str,
                 location_id: str,
                 name: str,
                 type: str,
                 uid: str,
                 version_retention_period: str):
        """
        :param bool enable_delete_protection: Delete protection prevents accidental deletion of firestore.
        :param bool enable_point_in_time_recovery: Restores data to a specific moment in time, enhancing data protection and recovery capabilities.
        :param str fullname: The full name of the firestore.
        :param str location_id: Location for firestore
        :param str name: The short name of the firestore.  Duplo will add a prefix to the name.  You can retrieve the full name from the `fullname` attribute.
        :param str type: Firestore type
        """
        pulumi.set(__self__, "app_engine_integration_mode", app_engine_integration_mode)
        pulumi.set(__self__, "concurrency_mode", concurrency_mode)
        pulumi.set(__self__, "earliest_version_time", earliest_version_time)
        pulumi.set(__self__, "enable_delete_protection", enable_delete_protection)
        pulumi.set(__self__, "enable_point_in_time_recovery", enable_point_in_time_recovery)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "fullname", fullname)
        pulumi.set(__self__, "location_id", location_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "version_retention_period", version_retention_period)

    @property
    @pulumi.getter(name="appEngineIntegrationMode")
    def app_engine_integration_mode(self) -> str:
        return pulumi.get(self, "app_engine_integration_mode")

    @property
    @pulumi.getter(name="concurrencyMode")
    def concurrency_mode(self) -> str:
        return pulumi.get(self, "concurrency_mode")

    @property
    @pulumi.getter(name="earliestVersionTime")
    def earliest_version_time(self) -> str:
        return pulumi.get(self, "earliest_version_time")

    @property
    @pulumi.getter(name="enableDeleteProtection")
    def enable_delete_protection(self) -> bool:
        """
        Delete protection prevents accidental deletion of firestore.
        """
        return pulumi.get(self, "enable_delete_protection")

    @property
    @pulumi.getter(name="enablePointInTimeRecovery")
    def enable_point_in_time_recovery(self) -> bool:
        """
        Restores data to a specific moment in time, enhancing data protection and recovery capabilities.
        """
        return pulumi.get(self, "enable_point_in_time_recovery")

    @property
    @pulumi.getter
    def etag(self) -> str:
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def fullname(self) -> str:
        """
        The full name of the firestore.
        """
        return pulumi.get(self, "fullname")

    @property
    @pulumi.getter(name="locationId")
    def location_id(self) -> str:
        """
        Location for firestore
        """
        return pulumi.get(self, "location_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The short name of the firestore.  Duplo will add a prefix to the name.  You can retrieve the full name from the `fullname` attribute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Firestore type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uid(self) -> str:
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="versionRetentionPeriod")
    def version_retention_period(self) -> str:
        return pulumi.get(self, "version_retention_period")


@pulumi.output_type
class GetGcpNodePoolAcceleratorResult(dict):
    def __init__(__self__, *,
                 accelerator_count: str,
                 accelerator_type: str,
                 gpu_driver_installation_configs: Sequence['outputs.GetGcpNodePoolAcceleratorGpuDriverInstallationConfigResult'],
                 gpu_partition_size: str,
                 gpu_sharing_configs: Sequence['outputs.GetGcpNodePoolAcceleratorGpuSharingConfigResult'],
                 max_time_shared_clients_per_gpu: str):
        """
        :param str accelerator_count: The number of the accelerator cards exposed to an instance.
        :param str accelerator_type: The accelerator type resource name.
        :param str gpu_partition_size: Size of partitions to create on the GPU
        :param str max_time_shared_clients_per_gpu: The number of time-shared GPU resources to expose for each physical GPU.
        """
        pulumi.set(__self__, "accelerator_count", accelerator_count)
        pulumi.set(__self__, "accelerator_type", accelerator_type)
        pulumi.set(__self__, "gpu_driver_installation_configs", gpu_driver_installation_configs)
        pulumi.set(__self__, "gpu_partition_size", gpu_partition_size)
        pulumi.set(__self__, "gpu_sharing_configs", gpu_sharing_configs)
        pulumi.set(__self__, "max_time_shared_clients_per_gpu", max_time_shared_clients_per_gpu)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> str:
        """
        The number of the accelerator cards exposed to an instance.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> str:
        """
        The accelerator type resource name.
        """
        return pulumi.get(self, "accelerator_type")

    @property
    @pulumi.getter(name="gpuDriverInstallationConfigs")
    def gpu_driver_installation_configs(self) -> Sequence['outputs.GetGcpNodePoolAcceleratorGpuDriverInstallationConfigResult']:
        return pulumi.get(self, "gpu_driver_installation_configs")

    @property
    @pulumi.getter(name="gpuPartitionSize")
    def gpu_partition_size(self) -> str:
        """
        Size of partitions to create on the GPU
        """
        return pulumi.get(self, "gpu_partition_size")

    @property
    @pulumi.getter(name="gpuSharingConfigs")
    def gpu_sharing_configs(self) -> Sequence['outputs.GetGcpNodePoolAcceleratorGpuSharingConfigResult']:
        return pulumi.get(self, "gpu_sharing_configs")

    @property
    @pulumi.getter(name="maxTimeSharedClientsPerGpu")
    def max_time_shared_clients_per_gpu(self) -> str:
        """
        The number of time-shared GPU resources to expose for each physical GPU.
        """
        return pulumi.get(self, "max_time_shared_clients_per_gpu")


@pulumi.output_type
class GetGcpNodePoolAcceleratorGpuDriverInstallationConfigResult(dict):
    def __init__(__self__, *,
                 gpu_driver_version: str):
        pulumi.set(__self__, "gpu_driver_version", gpu_driver_version)

    @property
    @pulumi.getter(name="gpuDriverVersion")
    def gpu_driver_version(self) -> str:
        return pulumi.get(self, "gpu_driver_version")


@pulumi.output_type
class GetGcpNodePoolAcceleratorGpuSharingConfigResult(dict):
    def __init__(__self__, *,
                 gpu_sharing_strategy: str,
                 max_shared_clients_per_gpu: str):
        """
        :param str gpu_sharing_strategy: The configuration for GPU sharing options.
        :param str max_shared_clients_per_gpu: The max number of containers that can share a physical GPU.
        """
        pulumi.set(__self__, "gpu_sharing_strategy", gpu_sharing_strategy)
        pulumi.set(__self__, "max_shared_clients_per_gpu", max_shared_clients_per_gpu)

    @property
    @pulumi.getter(name="gpuSharingStrategy")
    def gpu_sharing_strategy(self) -> str:
        """
        The configuration for GPU sharing options.
        """
        return pulumi.get(self, "gpu_sharing_strategy")

    @property
    @pulumi.getter(name="maxSharedClientsPerGpu")
    def max_shared_clients_per_gpu(self) -> str:
        """
        The max number of containers that can share a physical GPU.
        """
        return pulumi.get(self, "max_shared_clients_per_gpu")


@pulumi.output_type
class GetGcpNodePoolLinuxNodeConfigResult(dict):
    def __init__(__self__, *,
                 cgroup_mode: str,
                 sysctls: Mapping[str, str]):
        """
        :param str cgroup_mode: cgroupMode specifies the cgroup mode to be used on the node.
        :param Mapping[str, str] sysctls: The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.
        """
        pulumi.set(__self__, "cgroup_mode", cgroup_mode)
        pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter(name="cgroupMode")
    def cgroup_mode(self) -> str:
        """
        cgroupMode specifies the cgroup mode to be used on the node.
        """
        return pulumi.get(self, "cgroup_mode")

    @property
    @pulumi.getter
    def sysctls(self) -> Mapping[str, str]:
        """
        The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.
        """
        return pulumi.get(self, "sysctls")


@pulumi.output_type
class GetGcpNodePoolNodePoolLoggingConfigResult(dict):
    def __init__(__self__, *,
                 variant_config: Mapping[str, str]):
        pulumi.set(__self__, "variant_config", variant_config)

    @property
    @pulumi.getter(name="variantConfig")
    def variant_config(self) -> Mapping[str, str]:
        return pulumi.get(self, "variant_config")


@pulumi.output_type
class GetGcpNodePoolTaintResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        """
        :param str effect: Update strategy of the node pool.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Update strategy of the node pool.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGcpNodePoolUpgradeSettingResult(dict):
    def __init__(__self__, *,
                 blue_green_settings: Sequence['outputs.GetGcpNodePoolUpgradeSettingBlueGreenSettingResult'],
                 max_surge: int,
                 max_unavailable: int,
                 strategy: str):
        """
        :param str strategy: Update strategy of the node pool.
        """
        pulumi.set(__self__, "blue_green_settings", blue_green_settings)
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="blueGreenSettings")
    def blue_green_settings(self) -> Sequence['outputs.GetGcpNodePoolUpgradeSettingBlueGreenSettingResult']:
        return pulumi.get(self, "blue_green_settings")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> int:
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        Update strategy of the node pool.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetGcpNodePoolUpgradeSettingBlueGreenSettingResult(dict):
    def __init__(__self__, *,
                 node_pool_soak_duration: str,
                 standard_rollout_policies: Optional[Sequence['outputs.GetGcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyResult']] = None):
        pulumi.set(__self__, "node_pool_soak_duration", node_pool_soak_duration)
        if standard_rollout_policies is not None:
            pulumi.set(__self__, "standard_rollout_policies", standard_rollout_policies)

    @property
    @pulumi.getter(name="nodePoolSoakDuration")
    def node_pool_soak_duration(self) -> str:
        return pulumi.get(self, "node_pool_soak_duration")

    @property
    @pulumi.getter(name="standardRolloutPolicies")
    def standard_rollout_policies(self) -> Optional[Sequence['outputs.GetGcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyResult']]:
        return pulumi.get(self, "standard_rollout_policies")


@pulumi.output_type
class GetGcpNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyResult(dict):
    def __init__(__self__, *,
                 batch_node_count: int,
                 batch_percentage: float,
                 batch_soak_duration: str):
        pulumi.set(__self__, "batch_node_count", batch_node_count)
        pulumi.set(__self__, "batch_percentage", batch_percentage)
        pulumi.set(__self__, "batch_soak_duration", batch_soak_duration)

    @property
    @pulumi.getter(name="batchNodeCount")
    def batch_node_count(self) -> int:
        return pulumi.get(self, "batch_node_count")

    @property
    @pulumi.getter(name="batchPercentage")
    def batch_percentage(self) -> float:
        return pulumi.get(self, "batch_percentage")

    @property
    @pulumi.getter(name="batchSoakDuration")
    def batch_soak_duration(self) -> str:
        return pulumi.get(self, "batch_soak_duration")


@pulumi.output_type
class GetGcpNodePoolsNodePoolResult(dict):
    def __init__(__self__, *,
                 auto_repair: bool,
                 auto_upgrade: bool,
                 disc_size_gb: int,
                 disc_type: str,
                 fullname: str,
                 image_type: str,
                 initial_node_count: int,
                 is_autoscaling_enabled: bool,
                 labels: Mapping[str, str],
                 linux_node_configs: Sequence['outputs.GetGcpNodePoolsNodePoolLinuxNodeConfigResult'],
                 location_policy: str,
                 machine_type: str,
                 max_node_count: int,
                 metadata: Mapping[str, str],
                 min_node_count: int,
                 name: str,
                 node_pool_logging_configs: Sequence['outputs.GetGcpNodePoolsNodePoolNodePoolLoggingConfigResult'],
                 oauth_scopes: Sequence[str],
                 resource_labels: Mapping[str, str],
                 spot: bool,
                 tags: Sequence[str],
                 total_max_node_count: int,
                 total_min_node_count: int,
                 upgrade_settings: Sequence['outputs.GetGcpNodePoolsNodePoolUpgradeSettingResult'],
                 zones: Sequence[str],
                 accelerators: Optional[Sequence['outputs.GetGcpNodePoolsNodePoolAcceleratorResult']] = None,
                 taints: Optional[Sequence['outputs.GetGcpNodePoolsNodePoolTaintResult']] = None):
        """
        :param bool auto_repair: Whether the nodes will be automatically repaired.
        :param bool auto_upgrade: Whether the nodes will be automatically upgraded.
        :param int disc_size_gb: Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.
               				If unspecified, the default disk size is 100GB.
        :param str disc_type: Type of the disk attached to each node
               				If unspecified, the default disk type is 'pd-standard'
        :param str fullname: The full name of the node pool.
        :param str image_type: The image type to use for this node. Note that for a given image type, the latest version of it will be used
        :param int initial_node_count: The initial node count for the pool
        :param bool is_autoscaling_enabled: Is autoscaling enabled for this node pool.
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to each node.
        :param Sequence['GetGcpNodePoolsNodePoolLinuxNodeConfigArgs'] linux_node_configs: Parameters that can be configured on Linux nodes
        :param str location_policy: Update strategy of the node pool.
        :param str machine_type: The name of a Google Compute Engine machine type.
               				If unspecified, the default machine type is e2-medium.
        :param int max_node_count: Maximum number of nodes for one location in the NodePool. Must be >= minNodeCount.
        :param Mapping[str, str] metadata: The metadata key/value pairs assigned to instances in the cluster.
        :param int min_node_count: Minimum number of nodes for one location in the NodePool. Must be >= 1 and <= maxNodeCount.
        :param str name: The short name of the node pool.
        :param Sequence['GetGcpNodePoolsNodePoolNodePoolLoggingConfigArgs'] node_pool_logging_configs: Logging configuration.
        :param Sequence[str] oauth_scopes: The set of Google API scopes to be made available on all of the node VMs under the default service account.
        :param Mapping[str, str] resource_labels: Resource labels associated to node pool.
        :param bool spot: Spot flag for enabling Spot VM
        :param Sequence[str] tags: The list of instance tags applied to all nodes.
               				Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation.
               				Each tag within the list must comply with RFC1035.
        :param int total_max_node_count: Maximum number of nodes for one location in the NodePool. Must be >= minNodeCount.
        :param int total_min_node_count: Minimum number of nodes for one location in the NodePool. Must be >= 1 and <= maxNodeCount.
        :param Sequence['GetGcpNodePoolsNodePoolUpgradeSettingArgs'] upgrade_settings: Upgrade settings control disruption and speed of the upgrade.
        :param Sequence[str] zones: The list of Google Compute Engine zones in which the NodePool's nodes should be located.
        """
        pulumi.set(__self__, "auto_repair", auto_repair)
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)
        pulumi.set(__self__, "disc_size_gb", disc_size_gb)
        pulumi.set(__self__, "disc_type", disc_type)
        pulumi.set(__self__, "fullname", fullname)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "initial_node_count", initial_node_count)
        pulumi.set(__self__, "is_autoscaling_enabled", is_autoscaling_enabled)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "linux_node_configs", linux_node_configs)
        pulumi.set(__self__, "location_policy", location_policy)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "max_node_count", max_node_count)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "min_node_count", min_node_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_pool_logging_configs", node_pool_logging_configs)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)
        pulumi.set(__self__, "resource_labels", resource_labels)
        pulumi.set(__self__, "spot", spot)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "total_max_node_count", total_max_node_count)
        pulumi.set(__self__, "total_min_node_count", total_min_node_count)
        pulumi.set(__self__, "upgrade_settings", upgrade_settings)
        pulumi.set(__self__, "zones", zones)
        if accelerators is not None:
            pulumi.set(__self__, "accelerators", accelerators)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> bool:
        """
        Whether the nodes will be automatically repaired.
        """
        return pulumi.get(self, "auto_repair")

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> bool:
        """
        Whether the nodes will be automatically upgraded.
        """
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter(name="discSizeGb")
    def disc_size_gb(self) -> int:
        """
        Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB.
        				If unspecified, the default disk size is 100GB.
        """
        return pulumi.get(self, "disc_size_gb")

    @property
    @pulumi.getter(name="discType")
    def disc_type(self) -> str:
        """
        Type of the disk attached to each node
        				If unspecified, the default disk type is 'pd-standard'
        """
        return pulumi.get(self, "disc_type")

    @property
    @pulumi.getter
    def fullname(self) -> str:
        """
        The full name of the node pool.
        """
        return pulumi.get(self, "fullname")

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        """
        The image type to use for this node. Note that for a given image type, the latest version of it will be used
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="initialNodeCount")
    def initial_node_count(self) -> int:
        """
        The initial node count for the pool
        """
        return pulumi.get(self, "initial_node_count")

    @property
    @pulumi.getter(name="isAutoscalingEnabled")
    def is_autoscaling_enabled(self) -> bool:
        """
        Is autoscaling enabled for this node pool.
        """
        return pulumi.get(self, "is_autoscaling_enabled")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to each node.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="linuxNodeConfigs")
    def linux_node_configs(self) -> Sequence['outputs.GetGcpNodePoolsNodePoolLinuxNodeConfigResult']:
        """
        Parameters that can be configured on Linux nodes
        """
        return pulumi.get(self, "linux_node_configs")

    @property
    @pulumi.getter(name="locationPolicy")
    def location_policy(self) -> str:
        """
        Update strategy of the node pool.
        """
        return pulumi.get(self, "location_policy")

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        """
        The name of a Google Compute Engine machine type.
        				If unspecified, the default machine type is e2-medium.
        """
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> int:
        """
        Maximum number of nodes for one location in the NodePool. Must be >= minNodeCount.
        """
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter
    def metadata(self) -> Mapping[str, str]:
        """
        The metadata key/value pairs assigned to instances in the cluster.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> int:
        """
        Minimum number of nodes for one location in the NodePool. Must be >= 1 and <= maxNodeCount.
        """
        return pulumi.get(self, "min_node_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The short name of the node pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodePoolLoggingConfigs")
    def node_pool_logging_configs(self) -> Sequence['outputs.GetGcpNodePoolsNodePoolNodePoolLoggingConfigResult']:
        """
        Logging configuration.
        """
        return pulumi.get(self, "node_pool_logging_configs")

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[str]:
        """
        The set of Google API scopes to be made available on all of the node VMs under the default service account.
        """
        return pulumi.get(self, "oauth_scopes")

    @property
    @pulumi.getter(name="resourceLabels")
    def resource_labels(self) -> Mapping[str, str]:
        """
        Resource labels associated to node pool.
        """
        return pulumi.get(self, "resource_labels")

    @property
    @pulumi.getter
    def spot(self) -> bool:
        """
        Spot flag for enabling Spot VM
        """
        return pulumi.get(self, "spot")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        The list of instance tags applied to all nodes.
        				Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation.
        				Each tag within the list must comply with RFC1035.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="totalMaxNodeCount")
    def total_max_node_count(self) -> int:
        """
        Maximum number of nodes for one location in the NodePool. Must be >= minNodeCount.
        """
        return pulumi.get(self, "total_max_node_count")

    @property
    @pulumi.getter(name="totalMinNodeCount")
    def total_min_node_count(self) -> int:
        """
        Minimum number of nodes for one location in the NodePool. Must be >= 1 and <= maxNodeCount.
        """
        return pulumi.get(self, "total_min_node_count")

    @property
    @pulumi.getter(name="upgradeSettings")
    def upgrade_settings(self) -> Sequence['outputs.GetGcpNodePoolsNodePoolUpgradeSettingResult']:
        """
        Upgrade settings control disruption and speed of the upgrade.
        """
        return pulumi.get(self, "upgrade_settings")

    @property
    @pulumi.getter
    def zones(self) -> Sequence[str]:
        """
        The list of Google Compute Engine zones in which the NodePool's nodes should be located.
        """
        return pulumi.get(self, "zones")

    @property
    @pulumi.getter
    def accelerators(self) -> Optional[Sequence['outputs.GetGcpNodePoolsNodePoolAcceleratorResult']]:
        return pulumi.get(self, "accelerators")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.GetGcpNodePoolsNodePoolTaintResult']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class GetGcpNodePoolsNodePoolAcceleratorResult(dict):
    def __init__(__self__, *,
                 accelerator_count: str,
                 accelerator_type: str,
                 gpu_driver_installation_configs: Sequence['outputs.GetGcpNodePoolsNodePoolAcceleratorGpuDriverInstallationConfigResult'],
                 gpu_partition_size: str,
                 gpu_sharing_configs: Sequence['outputs.GetGcpNodePoolsNodePoolAcceleratorGpuSharingConfigResult'],
                 max_time_shared_clients_per_gpu: str):
        """
        :param str accelerator_count: The number of the accelerator cards exposed to an instance.
        :param str accelerator_type: The accelerator type resource name.
        :param str gpu_partition_size: Size of partitions to create on the GPU
        :param str max_time_shared_clients_per_gpu: The number of time-shared GPU resources to expose for each physical GPU.
        """
        pulumi.set(__self__, "accelerator_count", accelerator_count)
        pulumi.set(__self__, "accelerator_type", accelerator_type)
        pulumi.set(__self__, "gpu_driver_installation_configs", gpu_driver_installation_configs)
        pulumi.set(__self__, "gpu_partition_size", gpu_partition_size)
        pulumi.set(__self__, "gpu_sharing_configs", gpu_sharing_configs)
        pulumi.set(__self__, "max_time_shared_clients_per_gpu", max_time_shared_clients_per_gpu)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> str:
        """
        The number of the accelerator cards exposed to an instance.
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorType")
    def accelerator_type(self) -> str:
        """
        The accelerator type resource name.
        """
        return pulumi.get(self, "accelerator_type")

    @property
    @pulumi.getter(name="gpuDriverInstallationConfigs")
    def gpu_driver_installation_configs(self) -> Sequence['outputs.GetGcpNodePoolsNodePoolAcceleratorGpuDriverInstallationConfigResult']:
        return pulumi.get(self, "gpu_driver_installation_configs")

    @property
    @pulumi.getter(name="gpuPartitionSize")
    def gpu_partition_size(self) -> str:
        """
        Size of partitions to create on the GPU
        """
        return pulumi.get(self, "gpu_partition_size")

    @property
    @pulumi.getter(name="gpuSharingConfigs")
    def gpu_sharing_configs(self) -> Sequence['outputs.GetGcpNodePoolsNodePoolAcceleratorGpuSharingConfigResult']:
        return pulumi.get(self, "gpu_sharing_configs")

    @property
    @pulumi.getter(name="maxTimeSharedClientsPerGpu")
    def max_time_shared_clients_per_gpu(self) -> str:
        """
        The number of time-shared GPU resources to expose for each physical GPU.
        """
        return pulumi.get(self, "max_time_shared_clients_per_gpu")


@pulumi.output_type
class GetGcpNodePoolsNodePoolAcceleratorGpuDriverInstallationConfigResult(dict):
    def __init__(__self__, *,
                 gpu_driver_version: str):
        pulumi.set(__self__, "gpu_driver_version", gpu_driver_version)

    @property
    @pulumi.getter(name="gpuDriverVersion")
    def gpu_driver_version(self) -> str:
        return pulumi.get(self, "gpu_driver_version")


@pulumi.output_type
class GetGcpNodePoolsNodePoolAcceleratorGpuSharingConfigResult(dict):
    def __init__(__self__, *,
                 gpu_sharing_strategy: str,
                 max_shared_clients_per_gpu: str):
        """
        :param str gpu_sharing_strategy: The configuration for GPU sharing options.
        :param str max_shared_clients_per_gpu: The max number of containers that can share a physical GPU.
        """
        pulumi.set(__self__, "gpu_sharing_strategy", gpu_sharing_strategy)
        pulumi.set(__self__, "max_shared_clients_per_gpu", max_shared_clients_per_gpu)

    @property
    @pulumi.getter(name="gpuSharingStrategy")
    def gpu_sharing_strategy(self) -> str:
        """
        The configuration for GPU sharing options.
        """
        return pulumi.get(self, "gpu_sharing_strategy")

    @property
    @pulumi.getter(name="maxSharedClientsPerGpu")
    def max_shared_clients_per_gpu(self) -> str:
        """
        The max number of containers that can share a physical GPU.
        """
        return pulumi.get(self, "max_shared_clients_per_gpu")


@pulumi.output_type
class GetGcpNodePoolsNodePoolLinuxNodeConfigResult(dict):
    def __init__(__self__, *,
                 cgroup_modes: Sequence[str],
                 sysctls: Mapping[str, str]):
        """
        :param Sequence[str] cgroup_modes: cgroupMode specifies the cgroup mode to be used on the node.
        :param Mapping[str, str] sysctls: The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.
        """
        pulumi.set(__self__, "cgroup_modes", cgroup_modes)
        pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter(name="cgroupModes")
    def cgroup_modes(self) -> Sequence[str]:
        """
        cgroupMode specifies the cgroup mode to be used on the node.
        """
        return pulumi.get(self, "cgroup_modes")

    @property
    @pulumi.getter
    def sysctls(self) -> Mapping[str, str]:
        """
        The Linux kernel parameters to be applied to the nodes and all pods running on the nodes.
        """
        return pulumi.get(self, "sysctls")


@pulumi.output_type
class GetGcpNodePoolsNodePoolNodePoolLoggingConfigResult(dict):
    def __init__(__self__, *,
                 variant_config: Mapping[str, str]):
        pulumi.set(__self__, "variant_config", variant_config)

    @property
    @pulumi.getter(name="variantConfig")
    def variant_config(self) -> Mapping[str, str]:
        return pulumi.get(self, "variant_config")


@pulumi.output_type
class GetGcpNodePoolsNodePoolTaintResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        """
        :param str effect: Update strategy of the node pool.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Update strategy of the node pool.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGcpNodePoolsNodePoolUpgradeSettingResult(dict):
    def __init__(__self__, *,
                 blue_green_settings: Sequence['outputs.GetGcpNodePoolsNodePoolUpgradeSettingBlueGreenSettingResult'],
                 max_surge: int,
                 max_unavailable: int,
                 strategy: str):
        """
        :param str strategy: Update strategy of the node pool.
        """
        pulumi.set(__self__, "blue_green_settings", blue_green_settings)
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)
        pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="blueGreenSettings")
    def blue_green_settings(self) -> Sequence['outputs.GetGcpNodePoolsNodePoolUpgradeSettingBlueGreenSettingResult']:
        return pulumi.get(self, "blue_green_settings")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> int:
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        Update strategy of the node pool.
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetGcpNodePoolsNodePoolUpgradeSettingBlueGreenSettingResult(dict):
    def __init__(__self__, *,
                 node_pool_soak_duration: str,
                 standard_rollout_policies: Optional[Sequence['outputs.GetGcpNodePoolsNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyResult']] = None):
        pulumi.set(__self__, "node_pool_soak_duration", node_pool_soak_duration)
        if standard_rollout_policies is not None:
            pulumi.set(__self__, "standard_rollout_policies", standard_rollout_policies)

    @property
    @pulumi.getter(name="nodePoolSoakDuration")
    def node_pool_soak_duration(self) -> str:
        return pulumi.get(self, "node_pool_soak_duration")

    @property
    @pulumi.getter(name="standardRolloutPolicies")
    def standard_rollout_policies(self) -> Optional[Sequence['outputs.GetGcpNodePoolsNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyResult']]:
        return pulumi.get(self, "standard_rollout_policies")


@pulumi.output_type
class GetGcpNodePoolsNodePoolUpgradeSettingBlueGreenSettingStandardRolloutPolicyResult(dict):
    def __init__(__self__, *,
                 batch_node_count: int,
                 batch_percentage: float,
                 batch_soak_duration: str):
        pulumi.set(__self__, "batch_node_count", batch_node_count)
        pulumi.set(__self__, "batch_percentage", batch_percentage)
        pulumi.set(__self__, "batch_soak_duration", batch_soak_duration)

    @property
    @pulumi.getter(name="batchNodeCount")
    def batch_node_count(self) -> int:
        return pulumi.get(self, "batch_node_count")

    @property
    @pulumi.getter(name="batchPercentage")
    def batch_percentage(self) -> float:
        return pulumi.get(self, "batch_percentage")

    @property
    @pulumi.getter(name="batchSoakDuration")
    def batch_soak_duration(self) -> str:
        return pulumi.get(self, "batch_soak_duration")


@pulumi.output_type
class GetGcpSqlDatabaseInstancesDatabaseResult(dict):
    def __init__(__self__, *,
                 connection_name: str,
                 database_version: str,
                 disk_size: int,
                 ip_addresses: Sequence[str],
                 labels: Mapping[str, str],
                 name: str,
                 self_link: str,
                 tier: str):
        """
        :param str connection_name: Connection name  of the database.
        :param str database_version: The MySQL, PostgreSQL orSQL Server version to use.Supported values include `MYSQL_5_6`,`MYSQL_5_7`, `MYSQL_8_0`, `POSTGRES_9_6`,`POSTGRES_10`,`POSTGRES_11`,`POSTGRES_12`, `POSTGRES_13`, `POSTGRES_14`, `POSTGRES_15`, `SQLSERVER_2017_STANDARD`,`SQLSERVER_2017_ENTERPRISE`,`SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`.`SQLSERVER_2019_STANDARD`, `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`,`SQLSERVER_2019_WEB`.[Database Version Policies](https://cloud.google.com/sql/docs/db-versions)includes an up-to-date reference of supported versions.
        :param int disk_size: The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased. The minimum value is 10GB.
        :param Sequence[str] ip_addresses: IP address of the database.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize this resource.
        :param str name: The name of the sql database.
        :param str self_link: The SelfLink of the sql database.
        :param str tier: The machine type to use. See tiers for more details and supported versions. Postgres supports only shared-core machine types, and custom machine types such as `db-custom-2-13312`.See the [Custom Machine Type Documentation](https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#create) to learn about specifying custom machine types.
        """
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "database_version", database_version)
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "self_link", self_link)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        """
        Connection name  of the database.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="databaseVersion")
    def database_version(self) -> str:
        """
        The MySQL, PostgreSQL orSQL Server version to use.Supported values include `MYSQL_5_6`,`MYSQL_5_7`, `MYSQL_8_0`, `POSTGRES_9_6`,`POSTGRES_10`,`POSTGRES_11`,`POSTGRES_12`, `POSTGRES_13`, `POSTGRES_14`, `POSTGRES_15`, `SQLSERVER_2017_STANDARD`,`SQLSERVER_2017_ENTERPRISE`,`SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`.`SQLSERVER_2019_STANDARD`, `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`,`SQLSERVER_2019_WEB`.[Database Version Policies](https://cloud.google.com/sql/docs/db-versions)includes an up-to-date reference of supported versions.
        """
        return pulumi.get(self, "database_version")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        """
        The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased. The minimum value is 10GB.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        IP address of the database.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize this resource.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the sql database.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> str:
        """
        The SelfLink of the sql database.
        """
        return pulumi.get(self, "self_link")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The machine type to use. See tiers for more details and supported versions. Postgres supports only shared-core machine types, and custom machine types such as `db-custom-2-13312`.See the [Custom Machine Type Documentation](https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#create) to learn about specifying custom machine types.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetInfrastructurePrivateSubnetResult(dict):
    def __init__(__self__, *,
                 cidr_block: str,
                 id: str,
                 name: str,
                 tags: Sequence['outputs.GetInfrastructurePrivateSubnetTagResult'],
                 type: str,
                 zone: str):
        """
        :param str cidr_block: The subnet CIDR block.
        :param str id: The subnet ID.
        :param str name: The subnet name.
        :param Sequence['GetInfrastructurePrivateSubnetTagArgs'] tags: The subnet's tags.
        :param str type: The type of subnet.  Will be one of: `"public"` or `"private"`.
        :param str zone: The Duplo zone that the subnet resides in.  Will be one of:  `"A"`, `"B"`, `"C"`, or `"D"`
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        The subnet CIDR block.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The subnet name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetInfrastructurePrivateSubnetTagResult']:
        """
        The subnet's tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of subnet.  Will be one of: `"public"` or `"private"`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The Duplo zone that the subnet resides in.  Will be one of:  `"A"`, `"B"`, `"C"`, or `"D"`
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetInfrastructurePrivateSubnetTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInfrastructurePublicSubnetResult(dict):
    def __init__(__self__, *,
                 cidr_block: str,
                 id: str,
                 name: str,
                 tags: Sequence['outputs.GetInfrastructurePublicSubnetTagResult'],
                 type: str,
                 zone: str):
        """
        :param str cidr_block: The subnet CIDR block.
        :param str id: The subnet ID.
        :param str name: The subnet name.
        :param Sequence['GetInfrastructurePublicSubnetTagArgs'] tags: The subnet's tags.
        :param str type: The type of subnet.  Will be one of: `"public"` or `"private"`.
        :param str zone: The Duplo zone that the subnet resides in.  Will be one of:  `"A"`, `"B"`, `"C"`, or `"D"`
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        The subnet CIDR block.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The subnet name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetInfrastructurePublicSubnetTagResult']:
        """
        The subnet's tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of subnet.  Will be one of: `"public"` or `"private"`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        The Duplo zone that the subnet resides in.  Will be one of:  `"A"`, `"B"`, `"C"`, or `"D"`
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetInfrastructurePublicSubnetTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInfrastructureSecurityGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 read_only: bool,
                 rules: Sequence['outputs.GetInfrastructureSecurityGroupRuleResult'],
                 type: str):
        """
        :param str id: The security group ID.
        :param str name: The security group name.
        :param Sequence['GetInfrastructureSecurityGroupRuleArgs'] rules: Security group rules
        :param str type: The type of security group.  Will be one of: `"host"` or `"lb"`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "read_only", read_only)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The security group ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The security group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> bool:
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetInfrastructureSecurityGroupRuleResult']:
        """
        Security group rules
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of security group.  Will be one of: `"host"` or `"lb"`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInfrastructureSecurityGroupRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 destination_rule_type: int,
                 direction: str,
                 priority: int,
                 protocol: str,
                 source_address_prefix: str,
                 source_port_range: str,
                 source_rule_type: int):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "destination_rule_type", destination_rule_type)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_address_prefix", source_address_prefix)
        pulumi.set(__self__, "source_port_range", source_port_range)
        pulumi.set(__self__, "source_rule_type", source_rule_type)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="destinationRuleType")
    def destination_rule_type(self) -> int:
        return pulumi.get(self, "destination_rule_type")

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddressPrefix")
    def source_address_prefix(self) -> str:
        return pulumi.get(self, "source_address_prefix")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> str:
        return pulumi.get(self, "source_port_range")

    @property
    @pulumi.getter(name="sourceRuleType")
    def source_rule_type(self) -> int:
        return pulumi.get(self, "source_rule_type")


@pulumi.output_type
class GetInfrastructuresDataResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 address_prefix: str,
                 azcount: int,
                 cloud: int,
                 enable_k8_cluster: bool,
                 infra_name: str,
                 nat_ips: Sequence[str],
                 region: str,
                 status: str,
                 subnet_cidr: int):
        """
        :param str account_id: The cloud account ID.
        :param str address_prefix: The CIDR for the VPC or VNet.
        :param int azcount: The number of availability zones.  Will be one of: `2`, `3`, or `4`.
        :param int cloud: The numerical index of cloud provider to use for the infrastructure.
               Will be one of:
               
                  - `0` : AWS
                  - `2` : Azure
        :param bool enable_k8_cluster: Whether or not a kubernetes cluster is provisioned.
        :param str infra_name: The name of the infrastructure.
        :param Sequence[str] nat_ips: The NAT IPs for the subnet.
        :param str region: The cloud provider region.  The Duplo portal must have already been configured to support this region.
        :param str status: The status of the infrastructure.
        :param int subnet_cidr: The CIDR subnet size (in bits) of the automatically created subnets.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "address_prefix", address_prefix)
        pulumi.set(__self__, "azcount", azcount)
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "enable_k8_cluster", enable_k8_cluster)
        pulumi.set(__self__, "infra_name", infra_name)
        pulumi.set(__self__, "nat_ips", nat_ips)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subnet_cidr", subnet_cidr)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        The cloud account ID.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> str:
        """
        The CIDR for the VPC or VNet.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter
    def azcount(self) -> int:
        """
        The number of availability zones.  Will be one of: `2`, `3`, or `4`.
        """
        return pulumi.get(self, "azcount")

    @property
    @pulumi.getter
    def cloud(self) -> int:
        """
        The numerical index of cloud provider to use for the infrastructure.
        Will be one of:

           - `0` : AWS
           - `2` : Azure
        """
        return pulumi.get(self, "cloud")

    @property
    @pulumi.getter(name="enableK8Cluster")
    def enable_k8_cluster(self) -> bool:
        """
        Whether or not a kubernetes cluster is provisioned.
        """
        return pulumi.get(self, "enable_k8_cluster")

    @property
    @pulumi.getter(name="infraName")
    def infra_name(self) -> str:
        """
        The name of the infrastructure.
        """
        return pulumi.get(self, "infra_name")

    @property
    @pulumi.getter(name="natIps")
    def nat_ips(self) -> Sequence[str]:
        """
        The NAT IPs for the subnet.
        """
        return pulumi.get(self, "nat_ips")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The cloud provider region.  The Duplo portal must have already been configured to support this region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the infrastructure.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> int:
        """
        The CIDR subnet size (in bits) of the automatically created subnets.
        """
        return pulumi.get(self, "subnet_cidr")


@pulumi.output_type
class GetK8ConfigMapsConfigMapResult(dict):
    def __init__(__self__, *,
                 data: str,
                 metadata: str,
                 name: str,
                 tenant_id: str):
        """
        :param str data: A JSON encoded string representing the configmap data. You can use the `jsondecode()` function to parse this, if needed.
        :param str metadata: A JSON encoded string representing the configmap metadata. You can use the `jsondecode()` function to parse this, if needed.
        :param str name: The name of the configmap.
        :param str tenant_id: The GUID of the tenant that the configmap will be created in.
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        A JSON encoded string representing the configmap data. You can use the `jsondecode()` function to parse this, if needed.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def metadata(self) -> str:
        """
        A JSON encoded string representing the configmap metadata. You can use the `jsondecode()` function to parse this, if needed.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the configmap.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The GUID of the tenant that the configmap will be created in.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetK8SecretsSecretResult(dict):
    def __init__(__self__, *,
                 client_secret_version: str,
                 secret_annotations: Mapping[str, str],
                 secret_data: str,
                 secret_labels: Mapping[str, str],
                 secret_name: str,
                 secret_type: str,
                 secret_version: str):
        pulumi.set(__self__, "client_secret_version", client_secret_version)
        pulumi.set(__self__, "secret_annotations", secret_annotations)
        pulumi.set(__self__, "secret_data", secret_data)
        pulumi.set(__self__, "secret_labels", secret_labels)
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "secret_type", secret_type)
        pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> str:
        return pulumi.get(self, "client_secret_version")

    @property
    @pulumi.getter(name="secretAnnotations")
    def secret_annotations(self) -> Mapping[str, str]:
        return pulumi.get(self, "secret_annotations")

    @property
    @pulumi.getter(name="secretData")
    def secret_data(self) -> str:
        return pulumi.get(self, "secret_data")

    @property
    @pulumi.getter(name="secretLabels")
    def secret_labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "secret_labels")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> str:
        return pulumi.get(self, "secret_type")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> str:
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class GetK8sCronJobMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 generation: int,
                 labels: Mapping[str, str],
                 name: str,
                 namespace: str,
                 resource_version: str,
                 uid: str,
                 generate_name: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the cronjob that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the cronjob. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the cronjob, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace defines the space within which name of the cronjob must be unique.
        :param str resource_version: An opaque value that represents the internal version of this cronjob that can be used by clients to determine when cronjob has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this cronjob. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_version", resource_version)
        pulumi.set(__self__, "uid", uid)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        An unstructured key value map stored with the cronjob that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def generation(self) -> int:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the cronjob. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the cronjob, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace defines the space within which name of the cronjob must be unique.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> str:
        """
        An opaque value that represents the internal version of this cronjob that can be used by clients to determine when cronjob has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The unique in time and space value for this cronjob. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")


@pulumi.output_type
class GetK8sCronJobSpecResult(dict):
    def __init__(__self__, *,
                 job_template: 'outputs.GetK8sCronJobSpecJobTemplateResult',
                 schedule: str,
                 concurrency_policy: Optional[str] = None,
                 failed_jobs_history_limit: Optional[int] = None,
                 starting_deadline_seconds: Optional[int] = None,
                 successful_jobs_history_limit: Optional[int] = None,
                 suspend: Optional[bool] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateArgs' job_template: Describes the pod that will be created when executing a cron job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param str schedule: Cron format string, e.g. 0 * * * * or @hourly, as schedule time of its jobs to be created and executed.
        :param str concurrency_policy: Specifies how to treat concurrent executions of a Job. Defaults to Allow.
        :param int failed_jobs_history_limit: The number of failed finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
        :param int starting_deadline_seconds: Optional deadline in seconds for starting the job if it misses scheduled time for any reason. Missed jobs executions will be counted as failed ones.
        :param int successful_jobs_history_limit: The number of successful finished jobs to retain. Defaults to 3.
        :param bool suspend: This flag tells the controller to suspend subsequent executions, it does not apply to already started executions. Defaults to false.
        """
        pulumi.set(__self__, "job_template", job_template)
        pulumi.set(__self__, "schedule", schedule)
        if concurrency_policy is not None:
            pulumi.set(__self__, "concurrency_policy", concurrency_policy)
        if failed_jobs_history_limit is not None:
            pulumi.set(__self__, "failed_jobs_history_limit", failed_jobs_history_limit)
        if starting_deadline_seconds is not None:
            pulumi.set(__self__, "starting_deadline_seconds", starting_deadline_seconds)
        if successful_jobs_history_limit is not None:
            pulumi.set(__self__, "successful_jobs_history_limit", successful_jobs_history_limit)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter(name="jobTemplate")
    def job_template(self) -> 'outputs.GetK8sCronJobSpecJobTemplateResult':
        """
        Describes the pod that will be created when executing a cron job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "job_template")

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        Cron format string, e.g. 0 * * * * or @hourly, as schedule time of its jobs to be created and executed.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="concurrencyPolicy")
    def concurrency_policy(self) -> Optional[str]:
        """
        Specifies how to treat concurrent executions of a Job. Defaults to Allow.
        """
        return pulumi.get(self, "concurrency_policy")

    @property
    @pulumi.getter(name="failedJobsHistoryLimit")
    def failed_jobs_history_limit(self) -> Optional[int]:
        """
        The number of failed finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
        """
        return pulumi.get(self, "failed_jobs_history_limit")

    @property
    @pulumi.getter(name="startingDeadlineSeconds")
    def starting_deadline_seconds(self) -> Optional[int]:
        """
        Optional deadline in seconds for starting the job if it misses scheduled time for any reason. Missed jobs executions will be counted as failed ones.
        """
        return pulumi.get(self, "starting_deadline_seconds")

    @property
    @pulumi.getter(name="successfulJobsHistoryLimit")
    def successful_jobs_history_limit(self) -> Optional[int]:
        """
        The number of successful finished jobs to retain. Defaults to 3.
        """
        return pulumi.get(self, "successful_jobs_history_limit")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        """
        This flag tells the controller to suspend subsequent executions, it does not apply to already started executions. Defaults to false.
        """
        return pulumi.get(self, "suspend")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateResult(dict):
    def __init__(__self__, *,
                 metadata: 'outputs.GetK8sCronJobSpecJobTemplateMetadataResult',
                 spec: 'outputs.GetK8sCronJobSpecJobTemplateSpecResult'):
        """
        :param 'GetK8sCronJobSpecJobTemplateMetadataArgs' metadata: Standard jobTemplateSpec's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param 'GetK8sCronJobSpecJobTemplateSpecArgs' spec: Specification of the desired behavior of the job
        """
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetK8sCronJobSpecJobTemplateMetadataResult':
        """
        Standard jobTemplateSpec's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecResult':
        """
        Specification of the desired behavior of the job
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 generation: int,
                 labels: Mapping[str, str],
                 name: str,
                 resource_version: str,
                 uid: str,
                 generate_name: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the jobTemplateSpec that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the jobTemplateSpec. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the jobTemplateSpec, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str resource_version: An opaque value that represents the internal version of this jobTemplateSpec that can be used by clients to determine when jobTemplateSpec has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this jobTemplateSpec. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_version", resource_version)
        pulumi.set(__self__, "uid", uid)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        An unstructured key value map stored with the jobTemplateSpec that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def generation(self) -> int:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the jobTemplateSpec. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the jobTemplateSpec, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> str:
        """
        An opaque value that represents the internal version of this jobTemplateSpec that can be used by clients to determine when jobTemplateSpec has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The unique in time and space value for this jobTemplateSpec. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecResult(dict):
    def __init__(__self__, *,
                 active_deadline_seconds: int,
                 completion_mode: str,
                 manual_selector: bool,
                 selector: 'outputs.GetK8sCronJobSpecJobTemplateSpecSelectorResult',
                 template: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateResult',
                 backoff_limit: Optional[int] = None,
                 completions: Optional[int] = None,
                 parallelism: Optional[int] = None,
                 ttl_seconds_after_finished: Optional[str] = None):
        """
        :param int active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        :param str completion_mode: Specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#completion-mode
        :param bool manual_selector: Controls generation of pod labels and pod selectors. Leave unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. More info: https://git.k8s.io/community/contributors/design-proposals/selector-generation.md
        :param 'GetK8sCronJobSpecJobTemplateSpecSelectorArgs' selector: A label query over volumes to consider for binding.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateArgs' template: Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param int backoff_limit: Specifies the number of retries before marking this job failed. Defaults to 6
        :param int completions: Specifies the desired number of successfully finished pods the job should be run with. Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param int parallelism: Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param str ttl_seconds_after_finished: ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.
        """
        pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        pulumi.set(__self__, "completion_mode", completion_mode)
        pulumi.set(__self__, "manual_selector", manual_selector)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "template", template)
        if backoff_limit is not None:
            pulumi.set(__self__, "backoff_limit", backoff_limit)
        if completions is not None:
            pulumi.set(__self__, "completions", completions)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if ttl_seconds_after_finished is not None:
            pulumi.set(__self__, "ttl_seconds_after_finished", ttl_seconds_after_finished)

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> int:
        """
        Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="completionMode")
    def completion_mode(self) -> str:
        """
        Specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#completion-mode
        """
        return pulumi.get(self, "completion_mode")

    @property
    @pulumi.getter(name="manualSelector")
    def manual_selector(self) -> bool:
        """
        Controls generation of pod labels and pod selectors. Leave unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. More info: https://git.k8s.io/community/contributors/design-proposals/selector-generation.md
        """
        return pulumi.get(self, "manual_selector")

    @property
    @pulumi.getter
    def selector(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecSelectorResult':
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def template(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateResult':
        """
        Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="backoffLimit")
    def backoff_limit(self) -> Optional[int]:
        """
        Specifies the number of retries before marking this job failed. Defaults to 6
        """
        return pulumi.get(self, "backoff_limit")

    @property
    @pulumi.getter
    def completions(self) -> Optional[int]:
        """
        Specifies the desired number of successfully finished pods the job should be run with. Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "completions")

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="ttlSecondsAfterFinished")
    def ttl_seconds_after_finished(self) -> Optional[str]:
        """
        ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.
        """
        return pulumi.get(self, "ttl_seconds_after_finished")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecSelectorResult(dict):
    def __init__(__self__, *,
                 match_labels: Mapping[str, str],
                 match_expressions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecSelectorMatchExpressionResult']] = None):
        """
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        """
        pulumi.set(__self__, "match_labels", match_labels)
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateResult(dict):
    def __init__(__self__, *,
                 metadata: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateMetadataResult',
                 spec: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateMetadataArgs' metadata: Standard cronjob's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecArgs' spec: Spec of the cron job owned by the cluster
        """
        pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateMetadataResult':
        """
        Standard cronjob's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecResult']:
        """
        Spec of the cron job owned by the cluster
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 generation: int,
                 labels: Mapping[str, str],
                 name: str,
                 resource_version: str,
                 uid: str,
                 generate_name: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the cronjob that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the cronjob. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the cronjob, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str resource_version: An opaque value that represents the internal version of this cronjob that can be used by clients to determine when cronjob has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this cronjob. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_version", resource_version)
        pulumi.set(__self__, "uid", uid)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        An unstructured key value map stored with the cronjob that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def generation(self) -> int:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the cronjob. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the cronjob, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> str:
        """
        An opaque value that represents the internal version of this cronjob that can be used by clients to determine when cronjob has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The unique in time and space value for this cronjob. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecResult(dict):
    def __init__(__self__, *,
                 active_deadline_seconds: int,
                 dns_policy: str,
                 host_aliases: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecHostAliasResult'],
                 host_ipc: bool,
                 host_network: bool,
                 host_pid: bool,
                 hostname: str,
                 node_name: str,
                 node_selector: Mapping[str, str],
                 priority_class_name: str,
                 readiness_gates: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGateResult'],
                 runtime_class_name: str,
                 scheduler_name: str,
                 security_context: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextResult',
                 service_account_name: str,
                 subdomain: str,
                 termination_grace_period_seconds: int,
                 affinity: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityResult'] = None,
                 automount_service_account_token: Optional[bool] = None,
                 containers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResult']] = None,
                 dns_config: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigResult'] = None,
                 enable_service_links: Optional[bool] = None,
                 image_pull_secrets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecretResult']] = None,
                 init_containers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResult']] = None,
                 restart_policy: Optional[str] = None,
                 share_process_namespace: Optional[bool] = None,
                 tolerations: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecTolerationResult']] = None,
                 topology_spread_constraints: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintResult']] = None,
                 volumes: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeResult']] = None):
        """
        :param int active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        :param str dns_policy: Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Defaults to 'ClusterFirst'. More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecHostAliasArgs'] host_aliases: List of hosts and IPs that will be injected into the pod's hosts file if specified. Optional: Defaults to empty.
        :param bool host_ipc: Use the host's ipc namespace. Optional: Defaults to false.
        :param bool host_network: Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified.
        :param bool host_pid: Use the host's pid namespace.
        :param str hostname: Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
        :param str node_name: NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        :param Mapping[str, str] node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        :param str priority_class_name: If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGateArgs'] readiness_gates: If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        :param str runtime_class_name: RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
        :param str scheduler_name: If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextArgs' security_context: SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty
        :param str service_account_name: ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.
        :param str subdomain: If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..
        :param int termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityArgs' affinity: Optional pod scheduling constraints.
        :param bool automount_service_account_token: AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerArgs'] containers: List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigArgs' dns_config: Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
        :param bool enable_service_links: Enables generating environment variables for service discovery. Defaults to true.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecretArgs'] image_pull_secrets: ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerArgs'] init_containers: List of init containers belonging to the pod. Init containers always run to completion and each must complete successfully before the next is started. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        :param str restart_policy: Restart policy for all containers within the pod. One of OnFailure, Never. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy.
        :param bool share_process_namespace: Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecTolerationArgs'] tolerations: If specified, the pod's toleration. Optional: Defaults to empty
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintArgs'] topology_spread_constraints: describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeArgs'] volumes: List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
        """
        pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        pulumi.set(__self__, "dns_policy", dns_policy)
        pulumi.set(__self__, "host_aliases", host_aliases)
        pulumi.set(__self__, "host_ipc", host_ipc)
        pulumi.set(__self__, "host_network", host_network)
        pulumi.set(__self__, "host_pid", host_pid)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "node_selector", node_selector)
        pulumi.set(__self__, "priority_class_name", priority_class_name)
        pulumi.set(__self__, "readiness_gates", readiness_gates)
        pulumi.set(__self__, "runtime_class_name", runtime_class_name)
        pulumi.set(__self__, "scheduler_name", scheduler_name)
        pulumi.set(__self__, "security_context", security_context)
        pulumi.set(__self__, "service_account_name", service_account_name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if automount_service_account_token is not None:
            pulumi.set(__self__, "automount_service_account_token", automount_service_account_token)
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if dns_config is not None:
            pulumi.set(__self__, "dns_config", dns_config)
        if enable_service_links is not None:
            pulumi.set(__self__, "enable_service_links", enable_service_links)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if restart_policy is not None:
            pulumi.set(__self__, "restart_policy", restart_policy)
        if share_process_namespace is not None:
            pulumi.set(__self__, "share_process_namespace", share_process_namespace)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if topology_spread_constraints is not None:
            pulumi.set(__self__, "topology_spread_constraints", topology_spread_constraints)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> int:
        """
        Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> str:
        """
        Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Defaults to 'ClusterFirst'. More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
        """
        return pulumi.get(self, "dns_policy")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecHostAliasResult']:
        """
        List of hosts and IPs that will be injected into the pod's hosts file if specified. Optional: Defaults to empty.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="hostIpc")
    def host_ipc(self) -> bool:
        """
        Use the host's ipc namespace. Optional: Defaults to false.
        """
        return pulumi.get(self, "host_ipc")

    @property
    @pulumi.getter(name="hostNetwork")
    def host_network(self) -> bool:
        """
        Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified.
        """
        return pulumi.get(self, "host_network")

    @property
    @pulumi.getter(name="hostPid")
    def host_pid(self) -> bool:
        """
        Use the host's pid namespace.
        """
        return pulumi.get(self, "host_pid")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> str:
        """
        NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Mapping[str, str]:
        """
        NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> str:
        """
        If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="readinessGates")
    def readiness_gates(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGateResult']:
        """
        If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        """
        return pulumi.get(self, "readiness_gates")

    @property
    @pulumi.getter(name="runtimeClassName")
    def runtime_class_name(self) -> str:
        """
        RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
        """
        return pulumi.get(self, "runtime_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> str:
        """
        If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextResult':
        """
        SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> str:
        """
        ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.
        """
        return pulumi.get(self, "service_account_name")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> int:
        """
        Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityResult']:
        """
        Optional pod scheduling constraints.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="automountServiceAccountToken")
    def automount_service_account_token(self) -> Optional[bool]:
        """
        AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
        """
        return pulumi.get(self, "automount_service_account_token")

    @property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResult']]:
        """
        List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/
        """
        return pulumi.get(self, "containers")

    @property
    @pulumi.getter(name="dnsConfig")
    def dns_config(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigResult']:
        """
        Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
        """
        return pulumi.get(self, "dns_config")

    @property
    @pulumi.getter(name="enableServiceLinks")
    def enable_service_links(self) -> Optional[bool]:
        """
        Enables generating environment variables for service discovery. Defaults to true.
        """
        return pulumi.get(self, "enable_service_links")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecretResult']]:
        """
        ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResult']]:
        """
        List of init containers belonging to the pod. Init containers always run to completion and each must complete successfully before the next is started. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        """
        return pulumi.get(self, "init_containers")

    @property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[str]:
        """
        Restart policy for all containers within the pod. One of OnFailure, Never. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy.
        """
        return pulumi.get(self, "restart_policy")

    @property
    @pulumi.getter(name="shareProcessNamespace")
    def share_process_namespace(self) -> Optional[bool]:
        """
        Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false.
        """
        return pulumi.get(self, "share_process_namespace")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecTolerationResult']]:
        """
        If specified, the pod's toleration. Optional: Defaults to empty
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter(name="topologySpreadConstraints")
    def topology_spread_constraints(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintResult']]:
        """
        describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.
        """
        return pulumi.get(self, "topology_spread_constraints")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeResult']]:
        """
        List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityResult(dict):
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityResult'] = None,
                 pod_affinity: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityResult'] = None,
                 pod_anti_affinity: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityArgs' node_affinity: Node affinity scheduling rules for the pod.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityArgs' pod_affinity: Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityArgs' pod_anti_affinity: Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityResult']:
        """
        Node affinity scheduling rules for the pod.
        """
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityResult']:
        """
        Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityResult']:
        """
        Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        return pulumi.get(self, "pod_anti_affinity")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_execution: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult'] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs' required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
        """
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 preference: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult',
                 weight: int):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs' preference: A node selector term, associated with the corresponding weight.
        :param int weight: weight is in the range 1-100
        """
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult':
        """
        A node selector term, associated with the corresponding weight.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight is in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult']] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionArgs'] match_expressions: List of node selector requirements. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult']]:
        """
        List of node selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult']] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs'] node_selector_terms: List of node selector terms. The terms are ORed.
        """
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult']]:
        """
        List of node selector terms. The terms are ORed.
        """
        return pulumi.get(self, "node_selector_terms")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult']] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs'] match_expressions: List of node selector requirements. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult']]:
        """
        List of node selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_executions: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
                 weight: int):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: A pod affinity term, associated with the corresponding weight
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult':
        """
        A pod affinity term, associated with the corresponding weight
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_executions: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
                 weight: int):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: A pod affinity term, associated with the corresponding weight
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult':
        """
        A pod affinity term, associated with the corresponding weight
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResult(dict):
    def __init__(__self__, *,
                 image_pull_policy: str,
                 name: str,
                 resources: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResourcesResult',
                 termination_message_policy: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 env_froms: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromResult']] = None,
                 envs: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvResult']] = None,
                 image: Optional[str] = None,
                 lifecycle: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycleResult'] = None,
                 liveness_probe: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeResult'] = None,
                 ports: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerPortResult']] = None,
                 readiness_probe: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeResult'] = None,
                 security_context: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextResult'] = None,
                 startup_probe: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeResult'] = None,
                 stdin: Optional[bool] = None,
                 stdin_once: Optional[bool] = None,
                 termination_message_path: Optional[str] = None,
                 tty: Optional[bool] = None,
                 volume_mounts: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMountResult']] = None,
                 working_dir: Optional[str] = None):
        """
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        :param str name: Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResourcesArgs' resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param str termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        :param Sequence[str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence[str] commands: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromArgs'] env_froms: List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvArgs'] envs: List of environment variables to set in the container. Cannot be updated.
        :param str image: Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycleArgs' lifecycle: Actions that the management system should take in response to container lifecycle events
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeArgs' liveness_probe: Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerPortArgs'] ports: List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeArgs' readiness_probe: Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextArgs' security_context: Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeArgs' startup_probe: StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param bool stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.
        :param bool stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
        :param str termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.
        :param bool tty: Whether this container should allocate a TTY for itself
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMountArgs'] volume_mounts: Pod volumes to mount into the container's filesystem. Cannot be updated.
        :param str working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> str:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResourcesResult':
        """
        Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> str:
        """
        Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_policy")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromResult']]:
        """
        List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        """
        return pulumi.get(self, "env_froms")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvResult']]:
        """
        List of environment variables to set in the container. Cannot be updated.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycleResult']:
        """
        Actions that the management system should take in response to container lifecycle events
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeResult']:
        """
        Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerPortResult']]:
        """
        List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeResult']:
        """
        Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextResult']:
        """
        Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeResult']:
        """
        StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[bool]:
        """
        Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.
        """
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[bool]:
        """
        Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
        """
        return pulumi.get(self, "stdin_once")

    @property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[str]:
        """
        Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_path")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        """
        Whether this container should allocate a TTY for itself
        """
        return pulumi.get(self, "tty")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMountResult']]:
        """
        Pod volumes to mount into the container's filesystem. Cannot be updated.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResult'] = None):
        """
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromArgs' value_from: Source for the environment variable's value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResult']:
        """
        Source for the environment variable's value
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromResult(dict):
    def __init__(__self__, *,
                 config_map_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRefResult'] = None,
                 prefix: Optional[str] = None,
                 secret_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRefResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRefArgs' config_map_ref: The ConfigMap to select from
        :param str prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRefArgs' secret_ref: The Secret to select from
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRefResult']:
        """
        The ConfigMap to select from
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRefResult']:
        """
        The Secret to select from
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromConfigMapRefResult(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvFromSecretRefResult(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResult(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefResult'] = None,
                 field_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRefResult'] = None,
                 resource_field_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRefResult'] = None,
                 secret_key_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRefResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefResult']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRefResult']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRefResult']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRefResult']:
        """
        Selects a key of a secret in the pod's namespace.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromFieldRefResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromResourceFieldRefResult(dict):
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerEnvValueFromSecretKeyRefResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key of the secret to select from. Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the secret to select from. Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecycleResult(dict):
    def __init__(__self__, *,
                 post_starts: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartResult']] = None,
                 pre_stops: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopResult']] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartArgs'] post_starts: post_start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopArgs'] pre_stops: pre_stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartResult']]:
        """
        post_start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "post_starts")

    @property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopResult']]:
        """
        pre_stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "pre_stops")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExecResult'] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetResult'] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocketResult']] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExecArgs' exec_: exec specifies the action to take.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePostStartTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExecResult'] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetResult'] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocketResult']] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExecArgs' exec_: exec specifies the action to take.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLifecyclePreStopTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerLivenessProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerPortResult(dict):
    def __init__(__self__, *,
                 container_port: int,
                 host_ip: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param int container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        :param str host_ip: What host IP to bind the external port to.
        :param int host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        :param str name: If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        :param str protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP".
        """
        pulumi.set(__self__, "container_port", container_port)
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[str]:
        """
        What host IP to bind the external port to.
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for port. Must be UDP or TCP. Defaults to "TCP".
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerReadinessProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerResourcesResult(dict):
    def __init__(__self__, *,
                 limits: Mapping[str, str],
                 requests: Mapping[str, str]):
        """
        :param Mapping[str, str] limits: Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Mapping[str, str]:
        """
        Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Mapping[str, str]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextResult(dict):
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilitiesResult'] = None,
                 privileged: Optional[bool] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptionsResult'] = None,
                 seccomp_profile: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfileResult'] = None):
        """
        :param bool allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilitiesArgs' capabilities: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        :param bool privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        :param bool read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        """
        AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
        """
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilitiesResult']:
        """
        The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        """
        Whether this container has a read-only root filesystem. Default is false.
        """
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptionsResult']:
        """
        The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfileResult']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextCapabilitiesResult(dict):
    def __init__(__self__, *,
                 adds: Optional[Sequence[str]] = None,
                 drops: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] adds: Added capabilities
        :param Sequence[str] drops: Removed capabilities
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[Sequence[str]]:
        """
        Added capabilities
        """
        return pulumi.get(self, "adds")

    @property
    @pulumi.getter
    def drops(self) -> Optional[Sequence[str]]:
        """
        Removed capabilities
        """
        return pulumi.get(self, "drops")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeLinuxOptionsResult(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerSecurityContextSeccompProfileResult(dict):
    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerStartupProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecContainerVolumeMountResult(dict):
    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None):
        """
        :param str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigResult(dict):
    def __init__(__self__, *,
                 nameservers: Optional[Sequence[str]] = None,
                 options: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOptionResult']] = None,
                 searches: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] nameservers: A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOptionArgs'] options: A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        :param Sequence[str] searches: A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        """
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)

    @property
    @pulumi.getter
    def nameservers(self) -> Optional[Sequence[str]]:
        """
        A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        """
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOptionResult']]:
        """
        A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def searches(self) -> Optional[Sequence[str]]:
        """
        A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        """
        return pulumi.get(self, "searches")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecDnsConfigOptionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: Name of the option.
        :param str value: Value of the option. Optional: Defaults to empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the option.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the option. Optional: Defaults to empty.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecHostAliasResult(dict):
    def __init__(__self__, *,
                 hostnames: Sequence[str],
                 ip: str):
        """
        :param Sequence[str] hostnames: Hostnames for the IP address.
        :param str ip: IP address of the host file entry.
        """
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        Hostnames for the IP address.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address of the host file entry.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecImagePullSecretResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResult(dict):
    def __init__(__self__, *,
                 image_pull_policy: str,
                 name: str,
                 resources: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResourcesResult',
                 termination_message_policy: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 env_froms: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromResult']] = None,
                 envs: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvResult']] = None,
                 image: Optional[str] = None,
                 lifecycle: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycleResult'] = None,
                 liveness_probe: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeResult'] = None,
                 ports: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPortResult']] = None,
                 readiness_probe: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeResult'] = None,
                 security_context: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextResult'] = None,
                 startup_probe: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeResult'] = None,
                 stdin: Optional[bool] = None,
                 stdin_once: Optional[bool] = None,
                 termination_message_path: Optional[str] = None,
                 tty: Optional[bool] = None,
                 volume_mounts: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMountResult']] = None,
                 working_dir: Optional[str] = None):
        """
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        :param str name: Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResourcesArgs' resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param str termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        :param Sequence[str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence[str] commands: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromArgs'] env_froms: List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvArgs'] envs: List of environment variables to set in the container. Cannot be updated.
        :param str image: Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycleArgs' lifecycle: Actions that the management system should take in response to container lifecycle events
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeArgs' liveness_probe: Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPortArgs'] ports: List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeArgs' readiness_probe: Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextArgs' security_context: Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeArgs' startup_probe: StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param bool stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.
        :param bool stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
        :param str termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.
        :param bool tty: Whether this container should allocate a TTY for itself
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMountArgs'] volume_mounts: Pod volumes to mount into the container's filesystem. Cannot be updated.
        :param str working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> str:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResourcesResult':
        """
        Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> str:
        """
        Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_policy")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromResult']]:
        """
        List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        """
        return pulumi.get(self, "env_froms")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvResult']]:
        """
        List of environment variables to set in the container. Cannot be updated.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycleResult']:
        """
        Actions that the management system should take in response to container lifecycle events
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeResult']:
        """
        Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPortResult']]:
        """
        List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeResult']:
        """
        Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextResult']:
        """
        Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeResult']:
        """
        StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[bool]:
        """
        Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.
        """
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[bool]:
        """
        Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
        """
        return pulumi.get(self, "stdin_once")

    @property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[str]:
        """
        Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_path")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        """
        Whether this container should allocate a TTY for itself
        """
        return pulumi.get(self, "tty")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMountResult']]:
        """
        Pod volumes to mount into the container's filesystem. Cannot be updated.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResult'] = None):
        """
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromArgs' value_from: Source for the environment variable's value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResult']:
        """
        Source for the environment variable's value
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromResult(dict):
    def __init__(__self__, *,
                 config_map_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRefResult'] = None,
                 prefix: Optional[str] = None,
                 secret_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRefResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRefArgs' config_map_ref: The ConfigMap to select from
        :param str prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRefArgs' secret_ref: The Secret to select from
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRefResult']:
        """
        The ConfigMap to select from
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRefResult']:
        """
        The Secret to select from
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromConfigMapRefResult(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvFromSecretRefResult(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResult(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefResult'] = None,
                 field_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRefResult'] = None,
                 resource_field_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefResult'] = None,
                 secret_key_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefResult']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRefResult']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefResult']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefResult']:
        """
        Selects a key of a secret in the pod's namespace.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromFieldRefResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefResult(dict):
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key of the secret to select from. Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the secret to select from. Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecycleResult(dict):
    def __init__(__self__, *,
                 post_starts: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartResult']] = None,
                 pre_stops: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopResult']] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartArgs'] post_starts: post_start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopArgs'] pre_stops: pre_stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartResult']]:
        """
        post_start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "post_starts")

    @property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopResult']]:
        """
        pre_stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "pre_stops")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExecResult'] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetResult'] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketResult']] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExecArgs' exec_: exec specifies the action to take.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExecResult'] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetResult'] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketResult']] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExecArgs' exec_: exec specifies the action to take.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerLivenessProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerPortResult(dict):
    def __init__(__self__, *,
                 container_port: int,
                 host_ip: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param int container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        :param str host_ip: What host IP to bind the external port to.
        :param int host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        :param str name: If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        :param str protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP".
        """
        pulumi.set(__self__, "container_port", container_port)
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[str]:
        """
        What host IP to bind the external port to.
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for port. Must be UDP or TCP. Defaults to "TCP".
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerReadinessProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerResourcesResult(dict):
    def __init__(__self__, *,
                 limits: Mapping[str, str],
                 requests: Mapping[str, str]):
        """
        :param Mapping[str, str] limits: Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Mapping[str, str]:
        """
        Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Mapping[str, str]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextResult(dict):
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilitiesResult'] = None,
                 privileged: Optional[bool] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsResult'] = None,
                 seccomp_profile: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfileResult'] = None):
        """
        :param bool allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilitiesArgs' capabilities: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        :param bool privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        :param bool read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        """
        AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
        """
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilitiesResult']:
        """
        The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        """
        Whether this container has a read-only root filesystem. Default is false.
        """
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsResult']:
        """
        The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfileResult']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextCapabilitiesResult(dict):
    def __init__(__self__, *,
                 adds: Optional[Sequence[str]] = None,
                 drops: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] adds: Added capabilities
        :param Sequence[str] drops: Removed capabilities
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[Sequence[str]]:
        """
        Added capabilities
        """
        return pulumi.get(self, "adds")

    @property
    @pulumi.getter
    def drops(self) -> Optional[Sequence[str]]:
        """
        Removed capabilities
        """
        return pulumi.get(self, "drops")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsResult(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerSecurityContextSeccompProfileResult(dict):
    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerStartupProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecInitContainerVolumeMountResult(dict):
    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None):
        """
        :param str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecReadinessGateResult(dict):
    def __init__(__self__, *,
                 condition_type: str):
        """
        :param str condition_type: refers to a condition in the pod's condition list with matching type.
        """
        pulumi.set(__self__, "condition_type", condition_type)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """
        refers to a condition in the pod's condition list with matching type.
        """
        return pulumi.get(self, "condition_type")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextResult(dict):
    def __init__(__self__, *,
                 fs_group: Optional[str] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptionsResult'] = None,
                 seccomp_profile: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfileResult'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctlResult']] = None):
        """
        :param str fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        :param str fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        :param Sequence[int] supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctlArgs'] sysctls: holds a list of namespaced sysctls used for the pod.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[str]:
        """
        A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        """
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        """
        fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
        """
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptionsResult']:
        """
        The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfileResult']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        """
        A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container.
        """
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctlResult']]:
        """
        holds a list of namespaced sysctls used for the pod.
        """
        return pulumi.get(self, "sysctls")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeLinuxOptionsResult(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSeccompProfileResult(dict):
    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecSecurityContextSysctlResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of a property to set.
        :param str value: Value of a property to set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of a property to set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of a property to set.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecTolerationResult(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param str key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param str operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        :param str toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param str value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[str]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorResult'],
                 max_skew: Optional[int] = None,
                 topology_key: Optional[str] = None,
                 when_unsatisfiable: Optional[str] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param int max_skew: describes the degree to which pods may be unevenly distributed.
        :param str topology_key: the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology.
        :param str when_unsatisfiable: indicates how to deal with a pod if it doesn't satisfy the spread constraint.
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        if max_skew is not None:
            pulumi.set(__self__, "max_skew", max_skew)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)
        if when_unsatisfiable is not None:
            pulumi.set(__self__, "when_unsatisfiable", when_unsatisfiable)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter(name="maxSkew")
    def max_skew(self) -> Optional[int]:
        """
        describes the degree to which pods may be unevenly distributed.
        """
        return pulumi.get(self, "max_skew")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology.
        """
        return pulumi.get(self, "topology_key")

    @property
    @pulumi.getter(name="whenUnsatisfiable")
    def when_unsatisfiable(self) -> Optional[str]:
        """
        indicates how to deal with a pod if it doesn't satisfy the spread constraint.
        """
        return pulumi.get(self, "when_unsatisfiable")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeResult(dict):
    def __init__(__self__, *,
                 aws_elastic_block_store: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStoreResult'] = None,
                 azure_disk: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDiskResult'] = None,
                 azure_file: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFileResult'] = None,
                 ceph_fs: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsResult'] = None,
                 cinder: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinderResult'] = None,
                 config_map: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapResult'] = None,
                 csi: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiResult'] = None,
                 downward_api: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiResult'] = None,
                 empty_dir: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDirResult'] = None,
                 ephemeral: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralResult'] = None,
                 fc: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFcResult'] = None,
                 flex_volume: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeResult'] = None,
                 flocker: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlockerResult'] = None,
                 gce_persistent_disk: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDiskResult'] = None,
                 git_repo: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepoResult'] = None,
                 glusterfs: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfsResult'] = None,
                 host_path: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPathResult'] = None,
                 iscsi: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsiResult'] = None,
                 local: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocalResult'] = None,
                 name: Optional[str] = None,
                 nfs: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfsResult'] = None,
                 persistent_volume_claim: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaimResult'] = None,
                 photon_persistent_disk: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDiskResult'] = None,
                 projected: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedResult'] = None,
                 quobyte: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyteResult'] = None,
                 rbd: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdResult'] = None,
                 secret: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretResult'] = None,
                 vsphere_volume: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolumeResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStoreArgs' aws_elastic_block_store: Represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDiskArgs' azure_disk: Represents an Azure Data Disk mount on the host and bind mount to the pod.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFileArgs' azure_file: Represents an Azure File Service mount on the host and bind mount to the pod.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsArgs' ceph_fs: Represents a Ceph FS mount on the host that shares a pod's lifetime
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinderArgs' cinder: Represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapArgs' config_map: ConfigMap represents a configMap that should populate this volume
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiArgs' csi: Represents a CSI Volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiArgs' downward_api: DownwardAPI represents downward API about the pod that should populate this volume
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDirArgs' empty_dir: EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralArgs' ephemeral: Represents an ephemeral volume that is handled by a normal storage driver. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFcArgs' fc: Represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeArgs' flex_volume: Represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlockerArgs' flocker: Represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDiskArgs' gce_persistent_disk: Represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepoArgs' git_repo: GitRepo represents a git repository at a particular revision.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfsArgs' glusterfs: Represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPathArgs' host_path: Represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsiArgs' iscsi: Represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocalArgs' local: Represents a mounted local storage device such as a disk, partition or directory. Local volumes can only be used as a statically created PersistentVolume. Dynamic provisioning is not supported yet. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        :param str name: Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfsArgs' nfs: Represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaimArgs' persistent_volume_claim: The specification of a persistent volume.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDiskArgs' photon_persistent_disk: Represents a PhotonController persistent disk attached and mounted on kubelets host machine
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedArgs' projected: Projected represents a single volume that projects several volume sources into the same directory. More info: https://kubernetes.io/docs/concepts/storage/volumes/#projected
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyteArgs' quobyte: Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdArgs' rbd: Represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretArgs' secret: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolumeArgs' vsphere_volume: Represents a vSphere volume attached and mounted on kubelets host machine
        """
        if aws_elastic_block_store is not None:
            pulumi.set(__self__, "aws_elastic_block_store", aws_elastic_block_store)
        if azure_disk is not None:
            pulumi.set(__self__, "azure_disk", azure_disk)
        if azure_file is not None:
            pulumi.set(__self__, "azure_file", azure_file)
        if ceph_fs is not None:
            pulumi.set(__self__, "ceph_fs", ceph_fs)
        if cinder is not None:
            pulumi.set(__self__, "cinder", cinder)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if csi is not None:
            pulumi.set(__self__, "csi", csi)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if ephemeral is not None:
            pulumi.set(__self__, "ephemeral", ephemeral)
        if fc is not None:
            pulumi.set(__self__, "fc", fc)
        if flex_volume is not None:
            pulumi.set(__self__, "flex_volume", flex_volume)
        if flocker is not None:
            pulumi.set(__self__, "flocker", flocker)
        if gce_persistent_disk is not None:
            pulumi.set(__self__, "gce_persistent_disk", gce_persistent_disk)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if glusterfs is not None:
            pulumi.set(__self__, "glusterfs", glusterfs)
        if host_path is not None:
            pulumi.set(__self__, "host_path", host_path)
        if iscsi is not None:
            pulumi.set(__self__, "iscsi", iscsi)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if photon_persistent_disk is not None:
            pulumi.set(__self__, "photon_persistent_disk", photon_persistent_disk)
        if projected is not None:
            pulumi.set(__self__, "projected", projected)
        if quobyte is not None:
            pulumi.set(__self__, "quobyte", quobyte)
        if rbd is not None:
            pulumi.set(__self__, "rbd", rbd)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if vsphere_volume is not None:
            pulumi.set(__self__, "vsphere_volume", vsphere_volume)

    @property
    @pulumi.getter(name="awsElasticBlockStore")
    def aws_elastic_block_store(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStoreResult']:
        """
        Represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "aws_elastic_block_store")

    @property
    @pulumi.getter(name="azureDisk")
    def azure_disk(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDiskResult']:
        """
        Represents an Azure Data Disk mount on the host and bind mount to the pod.
        """
        return pulumi.get(self, "azure_disk")

    @property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFileResult']:
        """
        Represents an Azure File Service mount on the host and bind mount to the pod.
        """
        return pulumi.get(self, "azure_file")

    @property
    @pulumi.getter(name="cephFs")
    def ceph_fs(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsResult']:
        """
        Represents a Ceph FS mount on the host that shares a pod's lifetime
        """
        return pulumi.get(self, "ceph_fs")

    @property
    @pulumi.getter
    def cinder(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinderResult']:
        """
        Represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "cinder")

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapResult']:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_map")

    @property
    @pulumi.getter
    def csi(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiResult']:
        """
        Represents a CSI Volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        """
        return pulumi.get(self, "csi")

    @property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiResult']:
        """
        DownwardAPI represents downward API about the pod that should populate this volume
        """
        return pulumi.get(self, "downward_api")

    @property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDirResult']:
        """
        EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        """
        return pulumi.get(self, "empty_dir")

    @property
    @pulumi.getter
    def ephemeral(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralResult']:
        """
        Represents an ephemeral volume that is handled by a normal storage driver. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
        """
        return pulumi.get(self, "ephemeral")

    @property
    @pulumi.getter
    def fc(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFcResult']:
        """
        Represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        """
        return pulumi.get(self, "fc")

    @property
    @pulumi.getter(name="flexVolume")
    def flex_volume(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeResult']:
        """
        Represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
        """
        return pulumi.get(self, "flex_volume")

    @property
    @pulumi.getter
    def flocker(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlockerResult']:
        """
        Represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
        """
        return pulumi.get(self, "flocker")

    @property
    @pulumi.getter(name="gcePersistentDisk")
    def gce_persistent_disk(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDiskResult']:
        """
        Represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "gce_persistent_disk")

    @property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepoResult']:
        """
        GitRepo represents a git repository at a particular revision.
        """
        return pulumi.get(self, "git_repo")

    @property
    @pulumi.getter
    def glusterfs(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfsResult']:
        """
        Represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        """
        return pulumi.get(self, "glusterfs")

    @property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPathResult']:
        """
        Represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        """
        return pulumi.get(self, "host_path")

    @property
    @pulumi.getter
    def iscsi(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsiResult']:
        """
        Represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
        """
        return pulumi.get(self, "iscsi")

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocalResult']:
        """
        Represents a mounted local storage device such as a disk, partition or directory. Local volumes can only be used as a statically created PersistentVolume. Dynamic provisioning is not supported yet. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def nfs(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfsResult']:
        """
        Represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "nfs")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaimResult']:
        """
        The specification of a persistent volume.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter(name="photonPersistentDisk")
    def photon_persistent_disk(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDiskResult']:
        """
        Represents a PhotonController persistent disk attached and mounted on kubelets host machine
        """
        return pulumi.get(self, "photon_persistent_disk")

    @property
    @pulumi.getter
    def projected(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedResult']:
        """
        Projected represents a single volume that projects several volume sources into the same directory. More info: https://kubernetes.io/docs/concepts/storage/volumes/#projected
        """
        return pulumi.get(self, "projected")

    @property
    @pulumi.getter
    def quobyte(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyteResult']:
        """
        Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        """
        return pulumi.get(self, "quobyte")

    @property
    @pulumi.getter
    def rbd(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdResult']:
        """
        Represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        """
        return pulumi.get(self, "rbd")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretResult']:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="vsphereVolume")
    def vsphere_volume(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolumeResult']:
        """
        Represents a vSphere volume attached and mounted on kubelets host machine
        """
        return pulumi.get(self, "vsphere_volume")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAwsElasticBlockStoreResult(dict):
    def __init__(__self__, *,
                 volume_id: str,
                 fs_type: Optional[str] = None,
                 partition: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str volume_id: Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param int partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        :param bool read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        pulumi.set(__self__, "volume_id", volume_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def partition(self) -> Optional[int]:
        """
        The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureDiskResult(dict):
    def __init__(__self__, *,
                 caching_mode: str,
                 data_disk_uri: str,
                 disk_name: str,
                 kind: str,
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str caching_mode: Host Caching mode: None, Read Only, Read Write.
        :param str data_disk_uri: The URI the data disk in the blob storage
        :param str disk_name: The Name of the data disk in the blob storage
        :param str kind: The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        pulumi.set(__self__, "caching_mode", caching_mode)
        pulumi.set(__self__, "data_disk_uri", data_disk_uri)
        pulumi.set(__self__, "disk_name", disk_name)
        pulumi.set(__self__, "kind", kind)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="cachingMode")
    def caching_mode(self) -> str:
        """
        Host Caching mode: None, Read Only, Read Write.
        """
        return pulumi.get(self, "caching_mode")

    @property
    @pulumi.getter(name="dataDiskUri")
    def data_disk_uri(self) -> str:
        """
        The URI the data disk in the blob storage
        """
        return pulumi.get(self, "data_disk_uri")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> str:
        """
        The Name of the data disk in the blob storage
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeAzureFileResult(dict):
    def __init__(__self__, *,
                 secret_name: str,
                 share_name: str,
                 read_only: Optional[bool] = None,
                 secret_namespace: Optional[str] = None):
        """
        :param str secret_name: The name of secret that contains Azure Storage Account Name and Key
        :param str share_name: Share Name
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        :param str secret_namespace: The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.
        """
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "share_name", share_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_namespace is not None:
            pulumi.set(__self__, "secret_namespace", secret_namespace)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of secret that contains Azure Storage Account Name and Key
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        Share Name
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretNamespace")
    def secret_namespace(self) -> Optional[str]:
        """
        The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.
        """
        return pulumi.get(self, "secret_namespace")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsResult(dict):
    def __init__(__self__, *,
                 monitors: Sequence[str],
                 path: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 secret_file: Optional[str] = None,
                 secret_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRefResult'] = None,
                 user: Optional[str] = None):
        """
        :param Sequence[str] monitors: Monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str path: Used as the mounted root, rather than the full Ceph tree, default is /
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to `false` (read/write). More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str secret_file: The path to key ring for User, default is `/etc/ceph/user.secret`. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRefArgs' secret_ref: Reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str user: User is the rados user name, default is admin. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        pulumi.set(__self__, "monitors", monitors)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_file is not None:
            pulumi.set(__self__, "secret_file", secret_file)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def monitors(self) -> Sequence[str]:
        """
        Monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "monitors")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Used as the mounted root, rather than the full Ceph tree, default is /
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to `false` (read/write). More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretFile")
    def secret_file(self) -> Optional[str]:
        """
        The path to key ring for User, default is `/etc/ceph/user.secret`. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_file")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRefResult']:
        """
        Reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is the rados user name, default is admin. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCephFsSecretRefResult(dict):
    def __init__(__self__, *,
                 namespace: str,
                 name: Optional[str] = None):
        """
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "namespace", namespace)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCinderResult(dict):
    def __init__(__self__, *,
                 volume_id: str,
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str volume_id: Volume ID used to identify the volume in Cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        pulumi.set(__self__, "volume_id", volume_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        Volume ID used to identify the volume in Cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapResult(dict):
    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItemResult']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Optional: Specify whether the ConfigMap or its keys must be defined.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the ConfigMap or its keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeConfigMapItemResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiResult(dict):
    def __init__(__self__, *,
                 driver: str,
                 fs_type: Optional[str] = None,
                 node_publish_secret_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRefResult'] = None,
                 read_only: Optional[bool] = None,
                 volume_attributes: Optional[Mapping[str, str]] = None):
        """
        :param str driver: the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRefArgs' node_publish_secret_ref: A reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls.
        :param bool read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        :param Mapping[str, str] volume_attributes: Attributes of the volume to publish.
        """
        pulumi.set(__self__, "driver", driver)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if node_publish_secret_ref is not None:
            pulumi.set(__self__, "node_publish_secret_ref", node_publish_secret_ref)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if volume_attributes is not None:
            pulumi.set(__self__, "volume_attributes", volume_attributes)

    @property
    @pulumi.getter
    def driver(self) -> str:
        """
        the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="nodePublishSecretRef")
    def node_publish_secret_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRefResult']:
        """
        A reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls.
        """
        return pulumi.get(self, "node_publish_secret_ref")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="volumeAttributes")
    def volume_attributes(self) -> Optional[Mapping[str, str]]:
        """
        Attributes of the volume to publish.
        """
        return pulumi.get(self, "volume_attributes")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeCsiNodePublishSecretRefResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiResult(dict):
    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResult']] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResult(dict):
    def __init__(__self__, *,
                 field_ref: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRefResult',
                 path: str,
                 mode: Optional[str] = None,
                 resource_field_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRefArgs' field_ref: Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        :param str path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        pulumi.set(__self__, "field_ref", field_ref)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRefResult':
        """
        Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefResult']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemFieldRefResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefResult(dict):
    def __init__(__self__, *,
                 container_name: str,
                 resource: str,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "resource", resource)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEmptyDirResult(dict):
    def __init__(__self__, *,
                 medium: Optional[str] = None,
                 size_limit: Optional[str] = None):
        """
        :param str medium: What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        :param str size_limit: Total amount of local storage required for this EmptyDir volume.
        """
        if medium is not None:
            pulumi.set(__self__, "medium", medium)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @property
    @pulumi.getter
    def medium(self) -> Optional[str]:
        """
        What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        """
        return pulumi.get(self, "medium")

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[str]:
        """
        Total amount of local storage required for this EmptyDir volume.
        """
        return pulumi.get(self, "size_limit")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralResult(dict):
    def __init__(__self__, *,
                 volume_claim_template: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateResult'):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateArgs' volume_claim_template: Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC.
        """
        pulumi.set(__self__, "volume_claim_template", volume_claim_template)

    @property
    @pulumi.getter(name="volumeClaimTemplate")
    def volume_claim_template(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateResult':
        """
        Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC.
        """
        return pulumi.get(self, "volume_claim_template")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateResult(dict):
    def __init__(__self__, *,
                 spec: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResult',
                 metadata: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataResult'] = None):
        """
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecArgs' spec: Spec of the cron job owned by the cluster
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataArgs' metadata: Standard cronjob's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        pulumi.set(__self__, "spec", spec)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResult':
        """
        Spec of the cron job owned by the cluster
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataResult']:
        """
        Standard cronjob's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataResult(dict):
    def __init__(__self__, *,
                 labels: Mapping[str, str],
                 annotations: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the cronjob. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param Mapping[str, str] annotations: An unstructured key value map stored with the cronjob that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        pulumi.set(__self__, "labels", labels)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the cronjob. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the cronjob that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResult(dict):
    def __init__(__self__, *,
                 access_modes: Sequence[str],
                 resources: 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesResult',
                 storage_class_name: str,
                 volume_mode: str,
                 volume_name: str):
        """
        :param Sequence[str] access_modes: A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesArgs' resources: A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        :param str storage_class_name: Name of the storage class requested by the claim
        :param str volume_mode: Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        :param str volume_name: The binding reference to the PersistentVolume backing this claim.
        """
        pulumi.set(__self__, "access_modes", access_modes)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "storage_class_name", storage_class_name)
        pulumi.set(__self__, "volume_mode", volume_mode)
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Sequence[str]:
        """
        A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesResult':
        """
        A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> str:
        """
        Name of the storage class requested by the claim
        """
        return pulumi.get(self, "storage_class_name")

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> str:
        """
        Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        """
        return pulumi.get(self, "volume_mode")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> str:
        """
        The binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesResult(dict):
    def __init__(__self__, *,
                 requests: Mapping[str, str],
                 limits: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] requests: Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        :param Mapping[str, str] limits: Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        pulumi.set(__self__, "requests", requests)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)

    @property
    @pulumi.getter
    def requests(self) -> Mapping[str, str]:
        """
        Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "limits")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFcResult(dict):
    def __init__(__self__, *,
                 lun: int,
                 target_ww_ns: Sequence[str],
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param int lun: FC target lun number
        :param Sequence[str] target_ww_ns: FC target worldwide names (WWNs)
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "target_ww_ns", target_ww_ns)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        FC target lun number
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="targetWwNs")
    def target_ww_ns(self) -> Sequence[str]:
        """
        FC target worldwide names (WWNs)
        """
        return pulumi.get(self, "target_ww_ns")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeResult(dict):
    def __init__(__self__, *,
                 driver: str,
                 fs_type: Optional[str] = None,
                 options: Optional[Mapping[str, str]] = None,
                 read_only: Optional[bool] = None,
                 secret_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRefResult'] = None):
        """
        :param str driver: Driver is the name of the driver to use for this volume.
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        :param Mapping[str, str] options: Extra command options if any.
        :param bool read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRefArgs' secret_ref: Reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        """
        pulumi.set(__self__, "driver", driver)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter
    def driver(self) -> str:
        """
        Driver is the name of the driver to use for this volume.
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, str]]:
        """
        Extra command options if any.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRefResult']:
        """
        Reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlexVolumeSecretRefResult(dict):
    def __init__(__self__, *,
                 namespace: str,
                 name: Optional[str] = None):
        """
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "namespace", namespace)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeFlockerResult(dict):
    def __init__(__self__, *,
                 dataset_name: Optional[str] = None,
                 dataset_uuid: Optional[str] = None):
        """
        :param str dataset_name: Name of the dataset stored as metadata > name on the dataset for Flocker should be considered as deprecated
        :param str dataset_uuid: UUID of the dataset. This is unique identifier of a Flocker dataset
        """
        if dataset_name is not None:
            pulumi.set(__self__, "dataset_name", dataset_name)
        if dataset_uuid is not None:
            pulumi.set(__self__, "dataset_uuid", dataset_uuid)

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[str]:
        """
        Name of the dataset stored as metadata > name on the dataset for Flocker should be considered as deprecated
        """
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="datasetUuid")
    def dataset_uuid(self) -> Optional[str]:
        """
        UUID of the dataset. This is unique identifier of a Flocker dataset
        """
        return pulumi.get(self, "dataset_uuid")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGcePersistentDiskResult(dict):
    def __init__(__self__, *,
                 pd_name: str,
                 fs_type: Optional[str] = None,
                 partition: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str pd_name: Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param int partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param bool read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        pulumi.set(__self__, "pd_name", pd_name)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="pdName")
    def pd_name(self) -> str:
        """
        Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "pd_name")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def partition(self) -> Optional[int]:
        """
        The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGitRepoResult(dict):
    def __init__(__self__, *,
                 directory: Optional[str] = None,
                 repository: Optional[str] = None,
                 revision: Optional[str] = None):
        """
        :param str directory: Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        :param str repository: Repository URL
        :param str revision: Commit hash for the specified revision.
        """
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        Repository URL
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def revision(self) -> Optional[str]:
        """
        Commit hash for the specified revision.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeGlusterfsResult(dict):
    def __init__(__self__, *,
                 endpoints_name: str,
                 path: str,
                 read_only: Optional[bool] = None):
        """
        :param str endpoints_name: The endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        :param str path: The Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        :param bool read_only: Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        pulumi.set(__self__, "endpoints_name", endpoints_name)
        pulumi.set(__self__, "path", path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="endpointsName")
    def endpoints_name(self) -> str:
        """
        The endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "endpoints_name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeHostPathResult(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str path: Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        :param str type: Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeIscsiResult(dict):
    def __init__(__self__, *,
                 iqn: str,
                 target_portal: str,
                 fs_type: Optional[str] = None,
                 iscsi_interface: Optional[str] = None,
                 lun: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str iqn: Target iSCSI Qualified Name.
        :param str target_portal: iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        :param str iscsi_interface: iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp).
        :param int lun: iSCSI target lun number.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false.
        """
        pulumi.set(__self__, "iqn", iqn)
        pulumi.set(__self__, "target_portal", target_portal)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if iscsi_interface is not None:
            pulumi.set(__self__, "iscsi_interface", iscsi_interface)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def iqn(self) -> str:
        """
        Target iSCSI Qualified Name.
        """
        return pulumi.get(self, "iqn")

    @property
    @pulumi.getter(name="targetPortal")
    def target_portal(self) -> str:
        """
        iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        """
        return pulumi.get(self, "target_portal")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="iscsiInterface")
    def iscsi_interface(self) -> Optional[str]:
        """
        iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp).
        """
        return pulumi.get(self, "iscsi_interface")

    @property
    @pulumi.getter
    def lun(self) -> Optional[int]:
        """
        iSCSI target lun number.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeLocalResult(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None):
        """
        :param str path: Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeNfsResult(dict):
    def __init__(__self__, *,
                 path: str,
                 server: str,
                 read_only: Optional[bool] = None):
        """
        :param str path: Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param str server: Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param bool read_only: Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "server", server)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePersistentVolumeClaimResult(dict):
    def __init__(__self__, *,
                 claim_name: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str claim_name: ClaimName is the name of a PersistentVolumeClaim in the same
        :param bool read_only: Will force the ReadOnly setting in VolumeMounts.
        """
        if claim_name is not None:
            pulumi.set(__self__, "claim_name", claim_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> Optional[str]:
        """
        ClaimName is the name of a PersistentVolumeClaim in the same
        """
        return pulumi.get(self, "claim_name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Will force the ReadOnly setting in VolumeMounts.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumePhotonPersistentDiskResult(dict):
    def __init__(__self__, *,
                 pd_id: str,
                 fs_type: Optional[str] = None):
        """
        :param str pd_id: ID that identifies Photon Controller persistent disk
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        pulumi.set(__self__, "pd_id", pd_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)

    @property
    @pulumi.getter(name="pdId")
    def pd_id(self) -> str:
        """
        ID that identifies Photon Controller persistent disk
        """
        return pulumi.get(self, "pd_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedResult(dict):
    def __init__(__self__, *,
                 sources: Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceResult'],
                 default_mode: Optional[str] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceArgs'] sources: Source of the volume to project in the directory.
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        pulumi.set(__self__, "sources", sources)
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceResult']:
        """
        Source of the volume to project in the directory.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceResult(dict):
    def __init__(__self__, *,
                 config_maps: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapResult']] = None,
                 downward_api: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiResult'] = None,
                 secrets: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretResult']] = None,
                 service_account_token: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenResult'] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapArgs'] config_maps: ConfigMap represents a configMap that should populate this volume
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiArgs' downward_api: DownwardAPI represents downward API about the pod that should populate this volume
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretArgs'] secrets: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenArgs' service_account_token: A projected service account token volume
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_account_token is not None:
            pulumi.set(__self__, "service_account_token", service_account_token)

    @property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapResult']]:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_maps")

    @property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiResult']:
        """
        DownwardAPI represents downward API about the pod that should populate this volume
        """
        return pulumi.get(self, "downward_api")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretResult']]:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceAccountToken")
    def service_account_token(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenResult']:
        """
        A projected service account token volume
        """
        return pulumi.get(self, "service_account_token")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapResult(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItemResult']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Optional: Specify whether the ConfigMap or it's keys must be defined.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the ConfigMap or it's keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceConfigMapItemResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiResult(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResult']] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemArgs'] items: Represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResult']]:
        """
        Represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResult(dict):
    def __init__(__self__, *,
                 path: str,
                 field_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefResult'] = None,
                 mode: Optional[str] = None,
                 resource_field_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefResult'] = None):
        """
        :param str path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefArgs' field_ref: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        :param str mode: Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        pulumi.set(__self__, "path", path)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefResult']:
        """
        Selects a field of the pod: only annotations, labels, name and namespace are supported.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefResult']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefResult(dict):
    def __init__(__self__, *,
                 container_name: str,
                 resource: str,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "resource", resource)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretResult(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItemResult']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param bool optional: Optional: Specify whether the Secret or it's keys must be defined.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the Secret or it's keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceSecretItemResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenResult(dict):
    def __init__(__self__, *,
                 path: str,
                 audience: Optional[str] = None,
                 expiration_seconds: Optional[int] = None):
        """
        :param str path: Path specifies a relative path to the mount point of the projected volume.
        :param str audience: Audience is the intended audience of the token
        :param int expiration_seconds: ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds).
        """
        pulumi.set(__self__, "path", path)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if expiration_seconds is not None:
            pulumi.set(__self__, "expiration_seconds", expiration_seconds)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path specifies a relative path to the mount point of the projected volume.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Audience is the intended audience of the token
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="expirationSeconds")
    def expiration_seconds(self) -> Optional[int]:
        """
        ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds).
        """
        return pulumi.get(self, "expiration_seconds")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeQuobyteResult(dict):
    def __init__(__self__, *,
                 registry: str,
                 volume: str,
                 group: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 user: Optional[str] = None):
        """
        :param str registry: Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        :param str volume: Volume is a string that references an already created Quobyte volume by name.
        :param str group: Group to map volume access to Default is no group
        :param bool read_only: Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        :param str user: User to map volume access to Defaults to serivceaccount user
        """
        pulumi.set(__self__, "registry", registry)
        pulumi.set(__self__, "volume", volume)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def registry(self) -> str:
        """
        Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        """
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter
    def volume(self) -> str:
        """
        Volume is a string that references an already created Quobyte volume by name.
        """
        return pulumi.get(self, "volume")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group to map volume access to Default is no group
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User to map volume access to Defaults to serivceaccount user
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdResult(dict):
    def __init__(__self__, *,
                 ceph_monitors: Sequence[str],
                 keyring: str,
                 rbd_image: str,
                 fs_type: Optional[str] = None,
                 rados_user: Optional[str] = None,
                 rbd_pool: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 secret_ref: Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRefResult'] = None):
        """
        :param Sequence[str] ceph_monitors: A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str keyring: Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str rbd_image: The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        :param str rados_user: The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str rbd_pool: The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param 'GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRefArgs' secret_ref: Name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        pulumi.set(__self__, "ceph_monitors", ceph_monitors)
        pulumi.set(__self__, "keyring", keyring)
        pulumi.set(__self__, "rbd_image", rbd_image)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if rados_user is not None:
            pulumi.set(__self__, "rados_user", rados_user)
        if rbd_pool is not None:
            pulumi.set(__self__, "rbd_pool", rbd_pool)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="cephMonitors")
    def ceph_monitors(self) -> Sequence[str]:
        """
        A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "ceph_monitors")

    @property
    @pulumi.getter
    def keyring(self) -> str:
        """
        Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "keyring")

    @property
    @pulumi.getter(name="rbdImage")
    def rbd_image(self) -> str:
        """
        The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "rbd_image")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="radosUser")
    def rados_user(self) -> Optional[str]:
        """
        The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "rados_user")

    @property
    @pulumi.getter(name="rbdPool")
    def rbd_pool(self) -> Optional[str]:
        """
        The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it.
        """
        return pulumi.get(self, "rbd_pool")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRefResult']:
        """
        Name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeRbdSecretRefResult(dict):
    def __init__(__self__, *,
                 namespace: str,
                 name: Optional[str] = None):
        """
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "namespace", namespace)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretResult(dict):
    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItemResult']] = None,
                 optional: Optional[bool] = None,
                 secret_name: Optional[str] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param Sequence['GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param bool optional: Optional: Specify whether the Secret or its keys must be defined.
        :param str secret_name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the Secret or its keys must be defined.
        """
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeSecretItemResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sCronJobSpecJobTemplateSpecTemplateSpecVolumeVsphereVolumeResult(dict):
    def __init__(__self__, *,
                 volume_path: str,
                 fs_type: Optional[str] = None):
        """
        :param str volume_path: Path that identifies vSphere volume vmdk
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        pulumi.set(__self__, "volume_path", volume_path)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)

    @property
    @pulumi.getter(name="volumePath")
    def volume_path(self) -> str:
        """
        Path that identifies vSphere volume vmdk
        """
        return pulumi.get(self, "volume_path")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")


@pulumi.output_type
class GetK8sJobMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 generation: int,
                 labels: Mapping[str, str],
                 name: str,
                 namespace: str,
                 resource_version: str,
                 uid: str,
                 generate_name: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace defines the space within which name of the job must be unique.
        :param str resource_version: An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "resource_version", resource_version)
        pulumi.set(__self__, "uid", uid)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def generation(self) -> int:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace defines the space within which name of the job must be unique.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> str:
        """
        An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")


@pulumi.output_type
class GetK8sJobSpecResult(dict):
    def __init__(__self__, *,
                 active_deadline_seconds: int,
                 completion_mode: str,
                 manual_selector: bool,
                 selector: 'outputs.GetK8sJobSpecSelectorResult',
                 template: 'outputs.GetK8sJobSpecTemplateResult',
                 backoff_limit: Optional[int] = None,
                 completions: Optional[int] = None,
                 parallelism: Optional[int] = None,
                 ttl_seconds_after_finished: Optional[str] = None):
        """
        :param int active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        :param str completion_mode: Specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#completion-mode
        :param bool manual_selector: Controls generation of pod labels and pod selectors. Leave unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. More info: https://git.k8s.io/community/contributors/design-proposals/selector-generation.md
        :param 'GetK8sJobSpecSelectorArgs' selector: A label query over volumes to consider for binding.
        :param 'GetK8sJobSpecTemplateArgs' template: Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param int backoff_limit: Specifies the number of retries before marking this job failed. Defaults to 6
        :param int completions: Specifies the desired number of successfully finished pods the job should be run with. Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param int parallelism: Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        :param str ttl_seconds_after_finished: ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.
        """
        pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        pulumi.set(__self__, "completion_mode", completion_mode)
        pulumi.set(__self__, "manual_selector", manual_selector)
        pulumi.set(__self__, "selector", selector)
        pulumi.set(__self__, "template", template)
        if backoff_limit is not None:
            pulumi.set(__self__, "backoff_limit", backoff_limit)
        if completions is not None:
            pulumi.set(__self__, "completions", completions)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if ttl_seconds_after_finished is not None:
            pulumi.set(__self__, "ttl_seconds_after_finished", ttl_seconds_after_finished)

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> int:
        """
        Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="completionMode")
    def completion_mode(self) -> str:
        """
        Specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`. More info: https://kubernetes.io/docs/concepts/workloads/controllers/job/#completion-mode
        """
        return pulumi.get(self, "completion_mode")

    @property
    @pulumi.getter(name="manualSelector")
    def manual_selector(self) -> bool:
        """
        Controls generation of pod labels and pod selectors. Leave unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template. When true, the user is responsible for picking unique labels and specifying the selector. Failure to pick a unique label may cause this and other jobs to not function correctly. More info: https://git.k8s.io/community/contributors/design-proposals/selector-generation.md
        """
        return pulumi.get(self, "manual_selector")

    @property
    @pulumi.getter
    def selector(self) -> 'outputs.GetK8sJobSpecSelectorResult':
        """
        A label query over volumes to consider for binding.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def template(self) -> 'outputs.GetK8sJobSpecTemplateResult':
        """
        Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="backoffLimit")
    def backoff_limit(self) -> Optional[int]:
        """
        Specifies the number of retries before marking this job failed. Defaults to 6
        """
        return pulumi.get(self, "backoff_limit")

    @property
    @pulumi.getter
    def completions(self) -> Optional[int]:
        """
        Specifies the desired number of successfully finished pods the job should be run with. Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value. Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "completions")

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="ttlSecondsAfterFinished")
    def ttl_seconds_after_finished(self) -> Optional[str]:
        """
        ttlSecondsAfterFinished limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is unset, the Job won't be automatically deleted. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes.
        """
        return pulumi.get(self, "ttl_seconds_after_finished")


@pulumi.output_type
class GetK8sJobSpecSelectorResult(dict):
    def __init__(__self__, *,
                 match_labels: Mapping[str, str],
                 match_expressions: Optional[Sequence['outputs.GetK8sJobSpecSelectorMatchExpressionResult']] = None):
        """
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        :param Sequence['GetK8sJobSpecSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        """
        pulumi.set(__self__, "match_labels", match_labels)
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Mapping[str, str]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sJobSpecSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class GetK8sJobSpecSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sJobSpecTemplateResult(dict):
    def __init__(__self__, *,
                 metadata: 'outputs.GetK8sJobSpecTemplateMetadataResult',
                 spec: Optional['outputs.GetK8sJobSpecTemplateSpecResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateMetadataArgs' metadata: Standard job's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        :param 'GetK8sJobSpecTemplateSpecArgs' spec: Spec of the pods owned by the job
        """
        pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetK8sJobSpecTemplateMetadataResult':
        """
        Standard job's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecResult']:
        """
        Spec of the pods owned by the job
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetK8sJobSpecTemplateMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 generation: int,
                 labels: Mapping[str, str],
                 name: str,
                 resource_version: str,
                 uid: str,
                 generate_name: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        :param int generation: A sequence number representing a specific generation of the desired state.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param str name: Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str resource_version: An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        :param str generate_name: Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_version", resource_version)
        pulumi.set(__self__, "uid", uid)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def generation(self) -> int:
        """
        A sequence number representing a specific generation of the desired state.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the job, must be unique. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> str:
        """
        An opaque value that represents the internal version of this job that can be used by clients to determine when job has changed. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        The unique in time and space value for this job. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        Prefix, used by the server, to generate a unique name ONLY IF the `name` field has not been provided. This value will also be combined with a unique suffix. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#idempotency
        """
        return pulumi.get(self, "generate_name")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecResult(dict):
    def __init__(__self__, *,
                 active_deadline_seconds: int,
                 dns_policy: str,
                 host_aliases: Sequence['outputs.GetK8sJobSpecTemplateSpecHostAliasResult'],
                 host_ipc: bool,
                 host_network: bool,
                 host_pid: bool,
                 hostname: str,
                 node_name: str,
                 node_selector: Mapping[str, str],
                 priority_class_name: str,
                 readiness_gates: Sequence['outputs.GetK8sJobSpecTemplateSpecReadinessGateResult'],
                 runtime_class_name: str,
                 scheduler_name: str,
                 security_context: 'outputs.GetK8sJobSpecTemplateSpecSecurityContextResult',
                 service_account_name: str,
                 subdomain: str,
                 termination_grace_period_seconds: int,
                 affinity: Optional['outputs.GetK8sJobSpecTemplateSpecAffinityResult'] = None,
                 automount_service_account_token: Optional[bool] = None,
                 containers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerResult']] = None,
                 dns_config: Optional['outputs.GetK8sJobSpecTemplateSpecDnsConfigResult'] = None,
                 enable_service_links: Optional[bool] = None,
                 image_pull_secrets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecImagePullSecretResult']] = None,
                 init_containers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerResult']] = None,
                 restart_policy: Optional[str] = None,
                 share_process_namespace: Optional[bool] = None,
                 tolerations: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecTolerationResult']] = None,
                 topology_spread_constraints: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecTopologySpreadConstraintResult']] = None,
                 volumes: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeResult']] = None):
        """
        :param int active_deadline_seconds: Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        :param str dns_policy: Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Defaults to 'ClusterFirst'. More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
        :param Sequence['GetK8sJobSpecTemplateSpecHostAliasArgs'] host_aliases: List of hosts and IPs that will be injected into the pod's hosts file if specified. Optional: Defaults to empty.
        :param bool host_ipc: Use the host's ipc namespace. Optional: Defaults to false.
        :param bool host_network: Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified.
        :param bool host_pid: Use the host's pid namespace.
        :param str hostname: Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
        :param str node_name: NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        :param Mapping[str, str] node_selector: NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        :param str priority_class_name: If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        :param Sequence['GetK8sJobSpecTemplateSpecReadinessGateArgs'] readiness_gates: If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        :param str runtime_class_name: RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
        :param str scheduler_name: If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        :param 'GetK8sJobSpecTemplateSpecSecurityContextArgs' security_context: SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty
        :param str service_account_name: ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.
        :param str subdomain: If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..
        :param int termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.
        :param 'GetK8sJobSpecTemplateSpecAffinityArgs' affinity: Optional pod scheduling constraints.
        :param bool automount_service_account_token: AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerArgs'] containers: List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/
        :param 'GetK8sJobSpecTemplateSpecDnsConfigArgs' dns_config: Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
        :param bool enable_service_links: Enables generating environment variables for service discovery. Defaults to true.
        :param Sequence['GetK8sJobSpecTemplateSpecImagePullSecretArgs'] image_pull_secrets: ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerArgs'] init_containers: List of init containers belonging to the pod. Init containers always run to completion and each must complete successfully before the next is started. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        :param str restart_policy: Restart policy for all containers within the pod. One of OnFailure, Never. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy.
        :param bool share_process_namespace: Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false.
        :param Sequence['GetK8sJobSpecTemplateSpecTolerationArgs'] tolerations: If specified, the pod's toleration. Optional: Defaults to empty
        :param Sequence['GetK8sJobSpecTemplateSpecTopologySpreadConstraintArgs'] topology_spread_constraints: describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeArgs'] volumes: List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
        """
        pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        pulumi.set(__self__, "dns_policy", dns_policy)
        pulumi.set(__self__, "host_aliases", host_aliases)
        pulumi.set(__self__, "host_ipc", host_ipc)
        pulumi.set(__self__, "host_network", host_network)
        pulumi.set(__self__, "host_pid", host_pid)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "node_selector", node_selector)
        pulumi.set(__self__, "priority_class_name", priority_class_name)
        pulumi.set(__self__, "readiness_gates", readiness_gates)
        pulumi.set(__self__, "runtime_class_name", runtime_class_name)
        pulumi.set(__self__, "scheduler_name", scheduler_name)
        pulumi.set(__self__, "security_context", security_context)
        pulumi.set(__self__, "service_account_name", service_account_name)
        pulumi.set(__self__, "subdomain", subdomain)
        pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if automount_service_account_token is not None:
            pulumi.set(__self__, "automount_service_account_token", automount_service_account_token)
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if dns_config is not None:
            pulumi.set(__self__, "dns_config", dns_config)
        if enable_service_links is not None:
            pulumi.set(__self__, "enable_service_links", enable_service_links)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if restart_policy is not None:
            pulumi.set(__self__, "restart_policy", restart_policy)
        if share_process_namespace is not None:
            pulumi.set(__self__, "share_process_namespace", share_process_namespace)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if topology_spread_constraints is not None:
            pulumi.set(__self__, "topology_spread_constraints", topology_spread_constraints)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> int:
        """
        Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> str:
        """
        Set DNS policy for containers within the pod. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'. Defaults to 'ClusterFirst'. More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
        """
        return pulumi.get(self, "dns_policy")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecHostAliasResult']:
        """
        List of hosts and IPs that will be injected into the pod's hosts file if specified. Optional: Defaults to empty.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="hostIpc")
    def host_ipc(self) -> bool:
        """
        Use the host's ipc namespace. Optional: Defaults to false.
        """
        return pulumi.get(self, "host_ipc")

    @property
    @pulumi.getter(name="hostNetwork")
    def host_network(self) -> bool:
        """
        Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified.
        """
        return pulumi.get(self, "host_network")

    @property
    @pulumi.getter(name="hostPid")
    def host_pid(self) -> bool:
        """
        Use the host's pid namespace.
        """
        return pulumi.get(self, "host_pid")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> str:
        """
        NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        """
        return pulumi.get(self, "node_name")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Mapping[str, str]:
        """
        NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
        """
        return pulumi.get(self, "node_selector")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> str:
        """
        If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="readinessGates")
    def readiness_gates(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecReadinessGateResult']:
        """
        If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to "True" More info: https://git.k8s.io/enhancements/keps/sig-network/0007-pod-ready%2B%2B.md
        """
        return pulumi.get(self, "readiness_gates")

    @property
    @pulumi.getter(name="runtimeClassName")
    def runtime_class_name(self) -> str:
        """
        RuntimeClassName is a feature for selecting the container runtime configuration. The container runtime configuration is used to run a Pod's containers. More info: https://kubernetes.io/docs/concepts/containers/runtime-class
        """
        return pulumi.get(self, "runtime_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> str:
        """
        If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> 'outputs.GetK8sJobSpecTemplateSpecSecurityContextResult':
        """
        SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> str:
        """
        ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md.
        """
        return pulumi.get(self, "service_account_name")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        If specified, the fully qualified Pod hostname will be "...svc.". If not specified, the pod will not have a domainname at all..
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> int:
        """
        Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecAffinityResult']:
        """
        Optional pod scheduling constraints.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="automountServiceAccountToken")
    def automount_service_account_token(self) -> Optional[bool]:
        """
        AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
        """
        return pulumi.get(self, "automount_service_account_token")

    @property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerResult']]:
        """
        List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/
        """
        return pulumi.get(self, "containers")

    @property
    @pulumi.getter(name="dnsConfig")
    def dns_config(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecDnsConfigResult']:
        """
        Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy. Optional: Defaults to empty
        """
        return pulumi.get(self, "dns_config")

    @property
    @pulumi.getter(name="enableServiceLinks")
    def enable_service_links(self) -> Optional[bool]:
        """
        Enables generating environment variables for service discovery. Defaults to true.
        """
        return pulumi.get(self, "enable_service_links")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecImagePullSecretResult']]:
        """
        ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerResult']]:
        """
        List of init containers belonging to the pod. Init containers always run to completion and each must complete successfully before the next is started. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        """
        return pulumi.get(self, "init_containers")

    @property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[str]:
        """
        Restart policy for all containers within the pod. One of OnFailure, Never. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy.
        """
        return pulumi.get(self, "restart_policy")

    @property
    @pulumi.getter(name="shareProcessNamespace")
    def share_process_namespace(self) -> Optional[bool]:
        """
        Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Defaults to false.
        """
        return pulumi.get(self, "share_process_namespace")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecTolerationResult']]:
        """
        If specified, the pod's toleration. Optional: Defaults to empty
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter(name="topologySpreadConstraints")
    def topology_spread_constraints(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecTopologySpreadConstraintResult']]:
        """
        describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints.
        """
        return pulumi.get(self, "topology_spread_constraints")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeResult']]:
        """
        List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityResult(dict):
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityResult'] = None,
                 pod_affinity: Optional['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityResult'] = None,
                 pod_anti_affinity: Optional['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecAffinityNodeAffinityArgs' node_affinity: Node affinity scheduling rules for the pod.
        :param 'GetK8sJobSpecTemplateSpecAffinityPodAffinityArgs' pod_affinity: Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        :param 'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityArgs' pod_anti_affinity: Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityResult']:
        """
        Node affinity scheduling rules for the pod.
        """
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityResult']:
        """
        Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityResult']:
        """
        Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
        """
        return pulumi.get(self, "pod_anti_affinity")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityNodeAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_execution: Optional['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult'] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param 'GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs' required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
        """
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 preference: 'outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult',
                 weight: int):
        """
        :param 'GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs' preference: A node selector term, associated with the corresponding weight.
        :param int weight: weight is in the range 1-100
        """
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> 'outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult':
        """
        A node selector term, associated with the corresponding weight.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight is in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult']] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionArgs'] match_expressions: List of node selector requirements. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult']]:
        """
        List of node selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult']] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs'] node_selector_terms: List of node selector terms. The terms are ORed.
        """
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult']]:
        """
        List of node selector terms. The terms are ORed.
        """
        return pulumi.get(self, "node_selector_terms")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult']] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs'] match_expressions: List of node selector requirements. The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult']]:
        """
        List of node selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_executions: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
                 weight: int):
        """
        :param 'GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: A pod affinity term, associated with the corresponding weight
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult':
        """
        A pod affinity term, associated with the corresponding weight
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityResult(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult'],
                 required_during_scheduling_ignored_during_executions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_executions: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_executions: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult']:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult',
                 weight: int):
        """
        :param 'GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: A pod affinity term, associated with the corresponding weight
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult':
        """
        A pod affinity term, associated with the corresponding weight
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult'],
                 namespaces: Sequence[str],
                 topology_key: str):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        :param str topology_key: empty topology key is interpreted by the scheduler as 'all topologies'
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        pulumi.set(__self__, "namespaces", namespaces)
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter
    def namespaces(self) -> Sequence[str]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        empty topology key is interpreted by the scheduler as 'all topologies'
        """
        return pulumi.get(self, "topology_key")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerResult(dict):
    def __init__(__self__, *,
                 image_pull_policy: str,
                 name: str,
                 resources: 'outputs.GetK8sJobSpecTemplateSpecContainerResourcesResult',
                 termination_message_policy: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 env_froms: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerEnvFromResult']] = None,
                 envs: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerEnvResult']] = None,
                 image: Optional[str] = None,
                 lifecycle: Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecycleResult'] = None,
                 liveness_probe: Optional['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeResult'] = None,
                 ports: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerPortResult']] = None,
                 readiness_probe: Optional['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeResult'] = None,
                 security_context: Optional['outputs.GetK8sJobSpecTemplateSpecContainerSecurityContextResult'] = None,
                 startup_probe: Optional['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeResult'] = None,
                 stdin: Optional[bool] = None,
                 stdin_once: Optional[bool] = None,
                 termination_message_path: Optional[str] = None,
                 tty: Optional[bool] = None,
                 volume_mounts: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerVolumeMountResult']] = None,
                 working_dir: Optional[str] = None):
        """
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        :param str name: Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        :param 'GetK8sJobSpecTemplateSpecContainerResourcesArgs' resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param str termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        :param Sequence[str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence[str] commands: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence['GetK8sJobSpecTemplateSpecContainerEnvFromArgs'] env_froms: List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerEnvArgs'] envs: List of environment variables to set in the container. Cannot be updated.
        :param str image: Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        :param 'GetK8sJobSpecTemplateSpecContainerLifecycleArgs' lifecycle: Actions that the management system should take in response to container lifecycle events
        :param 'GetK8sJobSpecTemplateSpecContainerLivenessProbeArgs' liveness_probe: Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param Sequence['GetK8sJobSpecTemplateSpecContainerPortArgs'] ports: List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        :param 'GetK8sJobSpecTemplateSpecContainerReadinessProbeArgs' readiness_probe: Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param 'GetK8sJobSpecTemplateSpecContainerSecurityContextArgs' security_context: Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        :param 'GetK8sJobSpecTemplateSpecContainerStartupProbeArgs' startup_probe: StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param bool stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.
        :param bool stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
        :param str termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.
        :param bool tty: Whether this container should allocate a TTY for itself
        :param Sequence['GetK8sJobSpecTemplateSpecContainerVolumeMountArgs'] volume_mounts: Pod volumes to mount into the container's filesystem. Cannot be updated.
        :param str working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> str:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetK8sJobSpecTemplateSpecContainerResourcesResult':
        """
        Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> str:
        """
        Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_policy")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerEnvFromResult']]:
        """
        List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        """
        return pulumi.get(self, "env_froms")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerEnvResult']]:
        """
        List of environment variables to set in the container. Cannot be updated.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecycleResult']:
        """
        Actions that the management system should take in response to container lifecycle events
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeResult']:
        """
        Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerPortResult']]:
        """
        List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeResult']:
        """
        Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerSecurityContextResult']:
        """
        Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeResult']:
        """
        StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[bool]:
        """
        Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.
        """
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[bool]:
        """
        Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
        """
        return pulumi.get(self, "stdin_once")

    @property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[str]:
        """
        Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_path")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        """
        Whether this container should allocate a TTY for itself
        """
        return pulumi.get(self, "tty")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerVolumeMountResult']]:
        """
        Pod volumes to mount into the container's filesystem. Cannot be updated.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromResult'] = None):
        """
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'GetK8sJobSpecTemplateSpecContainerEnvValueFromArgs' value_from: Source for the environment variable's value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromResult']:
        """
        Source for the environment variable's value
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvFromResult(dict):
    def __init__(__self__, *,
                 config_map_ref: Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvFromConfigMapRefResult'] = None,
                 prefix: Optional[str] = None,
                 secret_ref: Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvFromSecretRefResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecContainerEnvFromConfigMapRefArgs' config_map_ref: The ConfigMap to select from
        :param str prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        :param 'GetK8sJobSpecTemplateSpecContainerEnvFromSecretRefArgs' secret_ref: The Secret to select from
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvFromConfigMapRefResult']:
        """
        The ConfigMap to select from
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvFromSecretRefResult']:
        """
        The Secret to select from
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvFromConfigMapRefResult(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvFromSecretRefResult(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvValueFromResult(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefResult'] = None,
                 field_ref: Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromFieldRefResult'] = None,
                 resource_field_ref: Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRefResult'] = None,
                 secret_key_ref: Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRefResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'GetK8sJobSpecTemplateSpecContainerEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        :param 'GetK8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'GetK8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefResult']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromFieldRefResult']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRefResult']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRefResult']:
        """
        Selects a key of a secret in the pod's namespace.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvValueFromConfigMapKeyRefResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvValueFromFieldRefResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvValueFromResourceFieldRefResult(dict):
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerEnvValueFromSecretKeyRefResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key of the secret to select from. Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the secret to select from. Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecycleResult(dict):
    def __init__(__self__, *,
                 post_starts: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartResult']] = None,
                 pre_stops: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopResult']] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLifecyclePostStartArgs'] post_starts: post_start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLifecyclePreStopArgs'] pre_stops: pre_stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartResult']]:
        """
        post_start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "post_starts")

    @property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopResult']]:
        """
        pre_stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "pre_stops")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePostStartResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartExecResult'] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetResult'] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocketResult']] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecContainerLifecyclePostStartExecArgs' exec_: exec specifies the action to take.
        :param 'GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePostStartExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePostStartTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePreStopResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopExecResult'] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetResult'] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocketResult']] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecContainerLifecyclePreStopExecArgs' exec_: exec specifies the action to take.
        :param 'GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePreStopExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLifecyclePreStopTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLivenessProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecContainerLivenessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLivenessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLivenessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLivenessProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLivenessProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLivenessProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerLivenessProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerPortResult(dict):
    def __init__(__self__, *,
                 container_port: int,
                 host_ip: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param int container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        :param str host_ip: What host IP to bind the external port to.
        :param int host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        :param str name: If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        :param str protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP".
        """
        pulumi.set(__self__, "container_port", container_port)
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[str]:
        """
        What host IP to bind the external port to.
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for port. Must be UDP or TCP. Defaults to "TCP".
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerReadinessProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecContainerReadinessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerReadinessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerReadinessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerReadinessProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerReadinessProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerReadinessProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerReadinessProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerResourcesResult(dict):
    def __init__(__self__, *,
                 limits: Mapping[str, str],
                 requests: Mapping[str, str]):
        """
        :param Mapping[str, str] limits: Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Mapping[str, str]:
        """
        Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Mapping[str, str]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerSecurityContextResult(dict):
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.GetK8sJobSpecTemplateSpecContainerSecurityContextCapabilitiesResult'] = None,
                 privileged: Optional[bool] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.GetK8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptionsResult'] = None,
                 seccomp_profile: Optional['outputs.GetK8sJobSpecTemplateSpecContainerSecurityContextSeccompProfileResult'] = None):
        """
        :param bool allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
        :param 'GetK8sJobSpecTemplateSpecContainerSecurityContextCapabilitiesArgs' capabilities: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        :param bool privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        :param bool read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'GetK8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'GetK8sJobSpecTemplateSpecContainerSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        """
        AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
        """
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerSecurityContextCapabilitiesResult']:
        """
        The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        """
        Whether this container has a read-only root filesystem. Default is false.
        """
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptionsResult']:
        """
        The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerSecurityContextSeccompProfileResult']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerSecurityContextCapabilitiesResult(dict):
    def __init__(__self__, *,
                 adds: Optional[Sequence[str]] = None,
                 drops: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] adds: Added capabilities
        :param Sequence[str] drops: Removed capabilities
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[Sequence[str]]:
        """
        Added capabilities
        """
        return pulumi.get(self, "adds")

    @property
    @pulumi.getter
    def drops(self) -> Optional[Sequence[str]]:
        """
        Removed capabilities
        """
        return pulumi.get(self, "drops")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerSecurityContextSeLinuxOptionsResult(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerSecurityContextSeccompProfileResult(dict):
    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerStartupProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecContainerStartupProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerStartupProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerStartupProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerStartupProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerStartupProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerStartupProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerStartupProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecContainerVolumeMountResult(dict):
    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None):
        """
        :param str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecDnsConfigResult(dict):
    def __init__(__self__, *,
                 nameservers: Optional[Sequence[str]] = None,
                 options: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecDnsConfigOptionResult']] = None,
                 searches: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] nameservers: A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        :param Sequence['GetK8sJobSpecTemplateSpecDnsConfigOptionArgs'] options: A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        :param Sequence[str] searches: A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        """
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)

    @property
    @pulumi.getter
    def nameservers(self) -> Optional[Sequence[str]]:
        """
        A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        """
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecDnsConfigOptionResult']]:
        """
        A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def searches(self) -> Optional[Sequence[str]]:
        """
        A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        """
        return pulumi.get(self, "searches")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecDnsConfigOptionResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: Name of the option.
        :param str value: Value of the option. Optional: Defaults to empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the option.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the option. Optional: Defaults to empty.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecHostAliasResult(dict):
    def __init__(__self__, *,
                 hostnames: Sequence[str],
                 ip: str):
        """
        :param Sequence[str] hostnames: Hostnames for the IP address.
        :param str ip: IP address of the host file entry.
        """
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        Hostnames for the IP address.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP address of the host file entry.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecImagePullSecretResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerResult(dict):
    def __init__(__self__, *,
                 image_pull_policy: str,
                 name: str,
                 resources: 'outputs.GetK8sJobSpecTemplateSpecInitContainerResourcesResult',
                 termination_message_policy: str,
                 args: Optional[Sequence[str]] = None,
                 commands: Optional[Sequence[str]] = None,
                 env_froms: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvFromResult']] = None,
                 envs: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvResult']] = None,
                 image: Optional[str] = None,
                 lifecycle: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecycleResult'] = None,
                 liveness_probe: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeResult'] = None,
                 ports: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerPortResult']] = None,
                 readiness_probe: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeResult'] = None,
                 security_context: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerSecurityContextResult'] = None,
                 startup_probe: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeResult'] = None,
                 stdin: Optional[bool] = None,
                 stdin_once: Optional[bool] = None,
                 termination_message_path: Optional[str] = None,
                 tty: Optional[bool] = None,
                 volume_mounts: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerVolumeMountResult']] = None,
                 working_dir: Optional[str] = None):
        """
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        :param str name: Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        :param 'GetK8sJobSpecTemplateSpecInitContainerResourcesArgs' resources: Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        :param str termination_message_policy: Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        :param Sequence[str] args: Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence[str] commands: Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerEnvFromArgs'] env_froms: List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerEnvArgs'] envs: List of environment variables to set in the container. Cannot be updated.
        :param str image: Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        :param 'GetK8sJobSpecTemplateSpecInitContainerLifecycleArgs' lifecycle: Actions that the management system should take in response to container lifecycle events
        :param 'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeArgs' liveness_probe: Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerPortArgs'] ports: List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        :param 'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeArgs' readiness_probe: Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param 'GetK8sJobSpecTemplateSpecInitContainerSecurityContextArgs' security_context: Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        :param 'GetK8sJobSpecTemplateSpecInitContainerStartupProbeArgs' startup_probe: StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param bool stdin: Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.
        :param bool stdin_once: Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
        :param str termination_message_path: Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.
        :param bool tty: Whether this container should allocate a TTY for itself
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerVolumeMountArgs'] volume_mounts: Pod volumes to mount into the container's filesystem. Cannot be updated.
        :param str working_dir: Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> str:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images/#updating-images
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetK8sJobSpecTemplateSpecInitContainerResourcesResult':
        """
        Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> str:
        """
        Optional: Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_policy")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvFromResult']]:
        """
        List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        """
        return pulumi.get(self, "env_froms")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvResult']]:
        """
        List of environment variables to set in the container. Cannot be updated.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images/
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecycleResult']:
        """
        Actions that the management system should take in response to container lifecycle events
        """
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeResult']:
        """
        Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerPortResult']]:
        """
        List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeResult']:
        """
        Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerSecurityContextResult']:
        """
        Security options the pod should run with. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeResult']:
        """
        StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. This is an alpha feature enabled by the StartupProbe feature flag. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "startup_probe")

    @property
    @pulumi.getter
    def stdin(self) -> Optional[bool]:
        """
        Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF.
        """
        return pulumi.get(self, "stdin")

    @property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[bool]:
        """
        Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF.
        """
        return pulumi.get(self, "stdin_once")

    @property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[str]:
        """
        Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Defaults to /dev/termination-log. Cannot be updated.
        """
        return pulumi.get(self, "termination_message_path")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        """
        Whether this container should allocate a TTY for itself
        """
        return pulumi.get(self, "tty")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerVolumeMountResult']]:
        """
        Pod volumes to mount into the container's filesystem. Cannot be updated.
        """
        return pulumi.get(self, "volume_mounts")

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[str]:
        """
        Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        """
        return pulumi.get(self, "working_dir")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResult'] = None):
        """
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromArgs' value_from: Source for the environment variable's value
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResult']:
        """
        Source for the environment variable's value
        """
        return pulumi.get(self, "value_from")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvFromResult(dict):
    def __init__(__self__, *,
                 config_map_ref: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRefResult'] = None,
                 prefix: Optional[str] = None,
                 secret_ref: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvFromSecretRefResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRefArgs' config_map_ref: The ConfigMap to select from
        :param str prefix: An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        :param 'GetK8sJobSpecTemplateSpecInitContainerEnvFromSecretRefArgs' secret_ref: The Secret to select from
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRefResult']:
        """
        The ConfigMap to select from
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvFromSecretRefResult']:
        """
        The Secret to select from
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvFromConfigMapRefResult(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvFromSecretRefResult(dict):
    def __init__(__self__, *,
                 name: str,
                 optional: Optional[bool] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret must be defined
        """
        pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret must be defined
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResult(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefResult'] = None,
                 field_ref: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRefResult'] = None,
                 resource_field_ref: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefResult'] = None,
                 secret_key_ref: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        :param 'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'GetK8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefResult']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRefResult']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.podIP.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefResult']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefResult']:
        """
        Selects a key of a secret in the pod's namespace.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvValueFromConfigMapKeyRefResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the ConfigMap or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvValueFromFieldRefResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvValueFromResourceFieldRefResult(dict):
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerEnvValueFromSecretKeyRefResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str key: The key of the secret to select from. Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Specify whether the Secret or its key must be defined.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the secret to select from. Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecycleResult(dict):
    def __init__(__self__, *,
                 post_starts: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartResult']] = None,
                 pre_stops: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopResult']] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartArgs'] post_starts: post_start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopArgs'] pre_stops: pre_stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartResult']]:
        """
        post_start is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "post_starts")

    @property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopResult']]:
        """
        pre_stop is called immediately before a container is terminated. The container is terminated after the handler completes. The reason for termination is passed to the handler. Regardless of the outcome of the handler, the container is eventually terminated. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        """
        return pulumi.get(self, "pre_stops")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartExecResult'] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetResult'] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketResult']] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartExecArgs' exec_: exec specifies the action to take.
        :param 'GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePostStartTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopExecResult'] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetResult'] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketResult']] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopExecArgs' exec_: exec specifies the action to take.
        :param 'GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetArgs' http_get: Specifies the http request to perform.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLifecyclePreStopTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLivenessProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLivenessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLivenessProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLivenessProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLivenessProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerLivenessProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerPortResult(dict):
    def __init__(__self__, *,
                 container_port: int,
                 host_ip: Optional[str] = None,
                 host_port: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param int container_port: Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        :param str host_ip: What host IP to bind the external port to.
        :param int host_port: Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        :param str name: If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        :param str protocol: Protocol for port. Must be UDP or TCP. Defaults to "TCP".
        """
        pulumi.set(__self__, "container_port", container_port)
        if host_ip is not None:
            pulumi.set(__self__, "host_ip", host_ip)
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> int:
        """
        Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
        """
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> Optional[str]:
        """
        What host IP to bind the external port to.
        """
        return pulumi.get(self, "host_ip")

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[int]:
        """
        Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        """
        return pulumi.get(self, "host_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol for port. Must be UDP or TCP. Defaults to "TCP".
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerReadinessProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerReadinessProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerReadinessProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerReadinessProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerReadinessProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerReadinessProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerResourcesResult(dict):
    def __init__(__self__, *,
                 limits: Mapping[str, str],
                 requests: Mapping[str, str]):
        """
        :param Mapping[str, str] limits: Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Mapping[str, str]:
        """
        Describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Mapping[str, str]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerSecurityContextResult(dict):
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerSecurityContextCapabilitiesResult'] = None,
                 privileged: Optional[bool] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsResult'] = None,
                 seccomp_profile: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfileResult'] = None):
        """
        :param bool allow_privilege_escalation: AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
        :param 'GetK8sJobSpecTemplateSpecInitContainerSecurityContextCapabilitiesArgs' capabilities: The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        :param bool privileged: Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        :param bool read_only_root_filesystem: Whether this container has a read-only root filesystem. Default is false.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param 'GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        """
        AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
        """
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerSecurityContextCapabilitiesResult']:
        """
        The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        """
        Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
        """
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        """
        Whether this container has a read-only root filesystem. Default is false.
        """
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsResult']:
        """
        The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfileResult']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerSecurityContextCapabilitiesResult(dict):
    def __init__(__self__, *,
                 adds: Optional[Sequence[str]] = None,
                 drops: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] adds: Added capabilities
        :param Sequence[str] drops: Removed capabilities
        """
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @property
    @pulumi.getter
    def adds(self) -> Optional[Sequence[str]]:
        """
        Added capabilities
        """
        return pulumi.get(self, "adds")

    @property
    @pulumi.getter
    def drops(self) -> Optional[Sequence[str]]:
        """
        Removed capabilities
        """
        return pulumi.get(self, "drops")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeLinuxOptionsResult(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerSecurityContextSeccompProfileResult(dict):
    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerStartupProbeResult(dict):
    def __init__(__self__, *,
                 exec_: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeExecResult'] = None,
                 failure_threshold: Optional[int] = None,
                 grpcs: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeGrpcResult']] = None,
                 http_get: Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetResult'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_sockets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocketResult']] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecInitContainerStartupProbeExecArgs' exec_: exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerStartupProbeGrpcArgs'] grpcs: GRPC specifies an action involving a GRPC port.
        :param 'GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetArgs' http_get: Specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocketArgs'] tcp_sockets: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        :param int timeout_seconds: Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeExecResult']:
        """
        exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeGrpcResult']]:
        """
        GRPC specifies an action involving a GRPC port.
        """
        return pulumi.get(self, "grpcs")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetResult']:
        """
        Specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocketResult']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported
        """
        return pulumi.get(self, "tcp_sockets")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerStartupProbeExecResult(dict):
    def __init__(__self__, *,
                 commands: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] commands: Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "commands")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerStartupProbeGrpcResult(dict):
    def __init__(__self__, *,
                 port: int,
                 service: Optional[str] = None):
        """
        :param int port: Number of the port to access on the container. Number must be in the range 1 to 65535.
        :param str service: Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        pulumi.set(__self__, "port", port)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number of the port to access on the container. Number must be in the range 1 to 65535.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md). If this is not specified, the default behavior is defined by gRPC.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderResult']] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderArgs'] http_headers: Scheme to use for connecting to the host.
        :param str path: Path to access on the HTTP server.
        :param str port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str scheme: Scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderResult']]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerStartupProbeHttpGetHttpHeaderResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The header field name
        :param str value: The header field value
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerStartupProbeTcpSocketResult(dict):
    def __init__(__self__, *,
                 port: str):
        """
        :param str port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecInitContainerVolumeMountResult(dict):
    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None):
        """
        :param str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        Mount propagation mode. mount_propagation determines how mounts are propagated from the host to container and the other way around. Valid values are None (default), HostToContainer and Bidirectional.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecReadinessGateResult(dict):
    def __init__(__self__, *,
                 condition_type: str):
        """
        :param str condition_type: refers to a condition in the pod's condition list with matching type.
        """
        pulumi.set(__self__, "condition_type", condition_type)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """
        refers to a condition in the pod's condition list with matching type.
        """
        return pulumi.get(self, "condition_type")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecSecurityContextResult(dict):
    def __init__(__self__, *,
                 fs_group: Optional[str] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[str] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[str] = None,
                 se_linux_options: Optional['outputs.GetK8sJobSpecTemplateSpecSecurityContextSeLinuxOptionsResult'] = None,
                 seccomp_profile: Optional['outputs.GetK8sJobSpecTemplateSpecSecurityContextSeccompProfileResult'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecSecurityContextSysctlResult']] = None):
        """
        :param str fs_group: A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        :param str fs_group_change_policy: fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
        :param str run_as_group: The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param bool run_as_non_root: Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        :param str run_as_user: The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param 'GetK8sJobSpecTemplateSpecSecurityContextSeLinuxOptionsArgs' se_linux_options: The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        :param 'GetK8sJobSpecTemplateSpecSecurityContextSeccompProfileArgs' seccomp_profile: The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        :param Sequence[int] supplemental_groups: A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container.
        :param Sequence['GetK8sJobSpecTemplateSpecSecurityContextSysctlArgs'] sysctls: holds a list of namespaced sysctls used for the pod.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if seccomp_profile is not None:
            pulumi.set(__self__, "seccomp_profile", seccomp_profile)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[str]:
        """
        A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume.
        """
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        """
        fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
        """
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[str]:
        """
        The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        """
        Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        """
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[str]:
        """
        The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecSecurityContextSeLinuxOptionsResult']:
        """
        The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
        """
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="seccompProfile")
    def seccomp_profile(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecSecurityContextSeccompProfileResult']:
        """
        The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        """
        return pulumi.get(self, "seccomp_profile")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        """
        A list of groups applied to the first process run in each container, in addition to the container's primary GID. If unspecified, no groups will be added to any container.
        """
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecSecurityContextSysctlResult']]:
        """
        holds a list of namespaced sysctls used for the pod.
        """
        return pulumi.get(self, "sysctls")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecSecurityContextSeLinuxOptionsResult(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str level: Level is SELinux level label that applies to the container.
        :param str role: Role is a SELinux role label that applies to the container.
        :param str type: Type is a SELinux type label that applies to the container.
        :param str user: User is a SELinux user label that applies to the container.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Level is SELinux level label that applies to the container.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role is a SELinux role label that applies to the container.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type is a SELinux type label that applies to the container.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is a SELinux user label that applies to the container.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecSecurityContextSeccompProfileResult(dict):
    def __init__(__self__, *,
                 localhost_profile: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str localhost_profile: Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        :param str type: Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        if localhost_profile is not None:
            pulumi.set(__self__, "localhost_profile", localhost_profile)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="localhostProfile")
    def localhost_profile(self) -> Optional[str]:
        """
        Localhost Profile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work.
        """
        return pulumi.get(self, "localhost_profile")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type indicates which kind of seccomp profile will be applied. Valid options are: Localhost, RuntimeDefault, Unconfined.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecSecurityContextSysctlResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of a property to set.
        :param str value: Value of a property to set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of a property to set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of a property to set.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecTolerationResult(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param str key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param str operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        :param str toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param str value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[str]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecTopologySpreadConstraintResult(dict):
    def __init__(__self__, *,
                 label_selectors: Sequence['outputs.GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorResult'],
                 max_skew: Optional[int] = None,
                 topology_key: Optional[str] = None,
                 when_unsatisfiable: Optional[str] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorArgs'] label_selectors: A label query over a set of resources, in this case pods.
        :param int max_skew: describes the degree to which pods may be unevenly distributed.
        :param str topology_key: the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology.
        :param str when_unsatisfiable: indicates how to deal with a pod if it doesn't satisfy the spread constraint.
        """
        pulumi.set(__self__, "label_selectors", label_selectors)
        if max_skew is not None:
            pulumi.set(__self__, "max_skew", max_skew)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)
        if when_unsatisfiable is not None:
            pulumi.set(__self__, "when_unsatisfiable", when_unsatisfiable)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorResult']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selectors")

    @property
    @pulumi.getter(name="maxSkew")
    def max_skew(self) -> Optional[int]:
        """
        describes the degree to which pods may be unevenly distributed.
        """
        return pulumi.get(self, "max_skew")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        """
        the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology.
        """
        return pulumi.get(self, "topology_key")

    @property
    @pulumi.getter(name="whenUnsatisfiable")
    def when_unsatisfiable(self) -> Optional[str]:
        """
        indicates how to deal with a pod if it doesn't satisfy the spread constraint.
        """
        return pulumi.get(self, "when_unsatisfiable")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionArgs'] match_expressions: A list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionResult']]:
        """
        A list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecTopologySpreadConstraintLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: The label key that the selector applies to.
        :param str operator: A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        :param Sequence[str] values: An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeResult(dict):
    def __init__(__self__, *,
                 aws_elastic_block_store: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeAwsElasticBlockStoreResult'] = None,
                 azure_disk: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeAzureDiskResult'] = None,
                 azure_file: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeAzureFileResult'] = None,
                 ceph_fs: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCephFsResult'] = None,
                 cinder: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCinderResult'] = None,
                 config_map: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeConfigMapResult'] = None,
                 csi: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCsiResult'] = None,
                 downward_api: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeDownwardApiResult'] = None,
                 empty_dir: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeEmptyDirResult'] = None,
                 ephemeral: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralResult'] = None,
                 fc: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeFcResult'] = None,
                 flex_volume: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeFlexVolumeResult'] = None,
                 flocker: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeFlockerResult'] = None,
                 gce_persistent_disk: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeGcePersistentDiskResult'] = None,
                 git_repo: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeGitRepoResult'] = None,
                 glusterfs: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeGlusterfsResult'] = None,
                 host_path: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeHostPathResult'] = None,
                 iscsi: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeIscsiResult'] = None,
                 local: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeLocalResult'] = None,
                 name: Optional[str] = None,
                 nfs: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeNfsResult'] = None,
                 persistent_volume_claim: Optional['outputs.GetK8sJobSpecTemplateSpecVolumePersistentVolumeClaimResult'] = None,
                 photon_persistent_disk: Optional['outputs.GetK8sJobSpecTemplateSpecVolumePhotonPersistentDiskResult'] = None,
                 projected: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedResult'] = None,
                 quobyte: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeQuobyteResult'] = None,
                 rbd: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeRbdResult'] = None,
                 secret: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeSecretResult'] = None,
                 vsphere_volume: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeVsphereVolumeResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecVolumeAwsElasticBlockStoreArgs' aws_elastic_block_store: Represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param 'GetK8sJobSpecTemplateSpecVolumeAzureDiskArgs' azure_disk: Represents an Azure Data Disk mount on the host and bind mount to the pod.
        :param 'GetK8sJobSpecTemplateSpecVolumeAzureFileArgs' azure_file: Represents an Azure File Service mount on the host and bind mount to the pod.
        :param 'GetK8sJobSpecTemplateSpecVolumeCephFsArgs' ceph_fs: Represents a Ceph FS mount on the host that shares a pod's lifetime
        :param 'GetK8sJobSpecTemplateSpecVolumeCinderArgs' cinder: Represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param 'GetK8sJobSpecTemplateSpecVolumeConfigMapArgs' config_map: ConfigMap represents a configMap that should populate this volume
        :param 'GetK8sJobSpecTemplateSpecVolumeCsiArgs' csi: Represents a CSI Volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        :param 'GetK8sJobSpecTemplateSpecVolumeDownwardApiArgs' downward_api: DownwardAPI represents downward API about the pod that should populate this volume
        :param 'GetK8sJobSpecTemplateSpecVolumeEmptyDirArgs' empty_dir: EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        :param 'GetK8sJobSpecTemplateSpecVolumeEphemeralArgs' ephemeral: Represents an ephemeral volume that is handled by a normal storage driver. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
        :param 'GetK8sJobSpecTemplateSpecVolumeFcArgs' fc: Represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        :param 'GetK8sJobSpecTemplateSpecVolumeFlexVolumeArgs' flex_volume: Represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
        :param 'GetK8sJobSpecTemplateSpecVolumeFlockerArgs' flocker: Represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
        :param 'GetK8sJobSpecTemplateSpecVolumeGcePersistentDiskArgs' gce_persistent_disk: Represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param 'GetK8sJobSpecTemplateSpecVolumeGitRepoArgs' git_repo: GitRepo represents a git repository at a particular revision.
        :param 'GetK8sJobSpecTemplateSpecVolumeGlusterfsArgs' glusterfs: Represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        :param 'GetK8sJobSpecTemplateSpecVolumeHostPathArgs' host_path: Represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        :param 'GetK8sJobSpecTemplateSpecVolumeIscsiArgs' iscsi: Represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
        :param 'GetK8sJobSpecTemplateSpecVolumeLocalArgs' local: Represents a mounted local storage device such as a disk, partition or directory. Local volumes can only be used as a statically created PersistentVolume. Dynamic provisioning is not supported yet. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        :param str name: Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param 'GetK8sJobSpecTemplateSpecVolumeNfsArgs' nfs: Represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param 'GetK8sJobSpecTemplateSpecVolumePersistentVolumeClaimArgs' persistent_volume_claim: The specification of a persistent volume.
        :param 'GetK8sJobSpecTemplateSpecVolumePhotonPersistentDiskArgs' photon_persistent_disk: Represents a PhotonController persistent disk attached and mounted on kubelets host machine
        :param 'GetK8sJobSpecTemplateSpecVolumeProjectedArgs' projected: Projected represents a single volume that projects several volume sources into the same directory. More info: https://kubernetes.io/docs/concepts/storage/volumes/#projected
        :param 'GetK8sJobSpecTemplateSpecVolumeQuobyteArgs' quobyte: Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        :param 'GetK8sJobSpecTemplateSpecVolumeRbdArgs' rbd: Represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        :param 'GetK8sJobSpecTemplateSpecVolumeSecretArgs' secret: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param 'GetK8sJobSpecTemplateSpecVolumeVsphereVolumeArgs' vsphere_volume: Represents a vSphere volume attached and mounted on kubelets host machine
        """
        if aws_elastic_block_store is not None:
            pulumi.set(__self__, "aws_elastic_block_store", aws_elastic_block_store)
        if azure_disk is not None:
            pulumi.set(__self__, "azure_disk", azure_disk)
        if azure_file is not None:
            pulumi.set(__self__, "azure_file", azure_file)
        if ceph_fs is not None:
            pulumi.set(__self__, "ceph_fs", ceph_fs)
        if cinder is not None:
            pulumi.set(__self__, "cinder", cinder)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if csi is not None:
            pulumi.set(__self__, "csi", csi)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if empty_dir is not None:
            pulumi.set(__self__, "empty_dir", empty_dir)
        if ephemeral is not None:
            pulumi.set(__self__, "ephemeral", ephemeral)
        if fc is not None:
            pulumi.set(__self__, "fc", fc)
        if flex_volume is not None:
            pulumi.set(__self__, "flex_volume", flex_volume)
        if flocker is not None:
            pulumi.set(__self__, "flocker", flocker)
        if gce_persistent_disk is not None:
            pulumi.set(__self__, "gce_persistent_disk", gce_persistent_disk)
        if git_repo is not None:
            pulumi.set(__self__, "git_repo", git_repo)
        if glusterfs is not None:
            pulumi.set(__self__, "glusterfs", glusterfs)
        if host_path is not None:
            pulumi.set(__self__, "host_path", host_path)
        if iscsi is not None:
            pulumi.set(__self__, "iscsi", iscsi)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if photon_persistent_disk is not None:
            pulumi.set(__self__, "photon_persistent_disk", photon_persistent_disk)
        if projected is not None:
            pulumi.set(__self__, "projected", projected)
        if quobyte is not None:
            pulumi.set(__self__, "quobyte", quobyte)
        if rbd is not None:
            pulumi.set(__self__, "rbd", rbd)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if vsphere_volume is not None:
            pulumi.set(__self__, "vsphere_volume", vsphere_volume)

    @property
    @pulumi.getter(name="awsElasticBlockStore")
    def aws_elastic_block_store(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeAwsElasticBlockStoreResult']:
        """
        Represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "aws_elastic_block_store")

    @property
    @pulumi.getter(name="azureDisk")
    def azure_disk(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeAzureDiskResult']:
        """
        Represents an Azure Data Disk mount on the host and bind mount to the pod.
        """
        return pulumi.get(self, "azure_disk")

    @property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeAzureFileResult']:
        """
        Represents an Azure File Service mount on the host and bind mount to the pod.
        """
        return pulumi.get(self, "azure_file")

    @property
    @pulumi.getter(name="cephFs")
    def ceph_fs(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCephFsResult']:
        """
        Represents a Ceph FS mount on the host that shares a pod's lifetime
        """
        return pulumi.get(self, "ceph_fs")

    @property
    @pulumi.getter
    def cinder(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCinderResult']:
        """
        Represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "cinder")

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeConfigMapResult']:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_map")

    @property
    @pulumi.getter
    def csi(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCsiResult']:
        """
        Represents a CSI Volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        """
        return pulumi.get(self, "csi")

    @property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeDownwardApiResult']:
        """
        DownwardAPI represents downward API about the pod that should populate this volume
        """
        return pulumi.get(self, "downward_api")

    @property
    @pulumi.getter(name="emptyDir")
    def empty_dir(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeEmptyDirResult']:
        """
        EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        """
        return pulumi.get(self, "empty_dir")

    @property
    @pulumi.getter
    def ephemeral(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralResult']:
        """
        Represents an ephemeral volume that is handled by a normal storage driver. More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
        """
        return pulumi.get(self, "ephemeral")

    @property
    @pulumi.getter
    def fc(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeFcResult']:
        """
        Represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        """
        return pulumi.get(self, "fc")

    @property
    @pulumi.getter(name="flexVolume")
    def flex_volume(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeFlexVolumeResult']:
        """
        Represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
        """
        return pulumi.get(self, "flex_volume")

    @property
    @pulumi.getter
    def flocker(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeFlockerResult']:
        """
        Represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
        """
        return pulumi.get(self, "flocker")

    @property
    @pulumi.getter(name="gcePersistentDisk")
    def gce_persistent_disk(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeGcePersistentDiskResult']:
        """
        Represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "gce_persistent_disk")

    @property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeGitRepoResult']:
        """
        GitRepo represents a git repository at a particular revision.
        """
        return pulumi.get(self, "git_repo")

    @property
    @pulumi.getter
    def glusterfs(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeGlusterfsResult']:
        """
        Represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        """
        return pulumi.get(self, "glusterfs")

    @property
    @pulumi.getter(name="hostPath")
    def host_path(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeHostPathResult']:
        """
        Represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        """
        return pulumi.get(self, "host_path")

    @property
    @pulumi.getter
    def iscsi(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeIscsiResult']:
        """
        Represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
        """
        return pulumi.get(self, "iscsi")

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeLocalResult']:
        """
        Represents a mounted local storage device such as a disk, partition or directory. Local volumes can only be used as a statically created PersistentVolume. Dynamic provisioning is not supported yet. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def nfs(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeNfsResult']:
        """
        Represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "nfs")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumePersistentVolumeClaimResult']:
        """
        The specification of a persistent volume.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter(name="photonPersistentDisk")
    def photon_persistent_disk(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumePhotonPersistentDiskResult']:
        """
        Represents a PhotonController persistent disk attached and mounted on kubelets host machine
        """
        return pulumi.get(self, "photon_persistent_disk")

    @property
    @pulumi.getter
    def projected(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedResult']:
        """
        Projected represents a single volume that projects several volume sources into the same directory. More info: https://kubernetes.io/docs/concepts/storage/volumes/#projected
        """
        return pulumi.get(self, "projected")

    @property
    @pulumi.getter
    def quobyte(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeQuobyteResult']:
        """
        Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        """
        return pulumi.get(self, "quobyte")

    @property
    @pulumi.getter
    def rbd(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeRbdResult']:
        """
        Represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        """
        return pulumi.get(self, "rbd")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeSecretResult']:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="vsphereVolume")
    def vsphere_volume(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeVsphereVolumeResult']:
        """
        Represents a vSphere volume attached and mounted on kubelets host machine
        """
        return pulumi.get(self, "vsphere_volume")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeAwsElasticBlockStoreResult(dict):
    def __init__(__self__, *,
                 volume_id: str,
                 fs_type: Optional[str] = None,
                 partition: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str volume_id: Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        :param int partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        :param bool read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        pulumi.set(__self__, "volume_id", volume_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def partition(self) -> Optional[int]:
        """
        The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeAzureDiskResult(dict):
    def __init__(__self__, *,
                 caching_mode: str,
                 data_disk_uri: str,
                 disk_name: str,
                 kind: str,
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str caching_mode: Host Caching mode: None, Read Only, Read Write.
        :param str data_disk_uri: The URI the data disk in the blob storage
        :param str disk_name: The Name of the data disk in the blob storage
        :param str kind: The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        pulumi.set(__self__, "caching_mode", caching_mode)
        pulumi.set(__self__, "data_disk_uri", data_disk_uri)
        pulumi.set(__self__, "disk_name", disk_name)
        pulumi.set(__self__, "kind", kind)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="cachingMode")
    def caching_mode(self) -> str:
        """
        Host Caching mode: None, Read Only, Read Write.
        """
        return pulumi.get(self, "caching_mode")

    @property
    @pulumi.getter(name="dataDiskUri")
    def data_disk_uri(self) -> str:
        """
        The URI the data disk in the blob storage
        """
        return pulumi.get(self, "data_disk_uri")

    @property
    @pulumi.getter(name="diskName")
    def disk_name(self) -> str:
        """
        The Name of the data disk in the blob storage
        """
        return pulumi.get(self, "disk_name")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The type for the data disk. Expected values: Shared, Dedicated, Managed. Defaults to Shared
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeAzureFileResult(dict):
    def __init__(__self__, *,
                 secret_name: str,
                 share_name: str,
                 read_only: Optional[bool] = None,
                 secret_namespace: Optional[str] = None):
        """
        :param str secret_name: The name of secret that contains Azure Storage Account Name and Key
        :param str share_name: Share Name
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        :param str secret_namespace: The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.
        """
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "share_name", share_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_namespace is not None:
            pulumi.set(__self__, "secret_namespace", secret_namespace)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of secret that contains Azure Storage Account Name and Key
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> str:
        """
        Share Name
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretNamespace")
    def secret_namespace(self) -> Optional[str]:
        """
        The namespace of the secret that contains Azure Storage Account Name and Key. For Kubernetes up to 1.18.x the default is the same as the Pod. For Kubernetes 1.19.x and later the default is "default" namespace.
        """
        return pulumi.get(self, "secret_namespace")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeCephFsResult(dict):
    def __init__(__self__, *,
                 monitors: Sequence[str],
                 path: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 secret_file: Optional[str] = None,
                 secret_ref: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCephFsSecretRefResult'] = None,
                 user: Optional[str] = None):
        """
        :param Sequence[str] monitors: Monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str path: Used as the mounted root, rather than the full Ceph tree, default is /
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to `false` (read/write). More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str secret_file: The path to key ring for User, default is `/etc/ceph/user.secret`. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param 'GetK8sJobSpecTemplateSpecVolumeCephFsSecretRefArgs' secret_ref: Reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        :param str user: User is the rados user name, default is admin. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        pulumi.set(__self__, "monitors", monitors)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_file is not None:
            pulumi.set(__self__, "secret_file", secret_file)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def monitors(self) -> Sequence[str]:
        """
        Monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "monitors")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Used as the mounted root, rather than the full Ceph tree, default is /
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to `false` (read/write). More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretFile")
    def secret_file(self) -> Optional[str]:
        """
        The path to key ring for User, default is `/etc/ceph/user.secret`. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_file")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCephFsSecretRefResult']:
        """
        Reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User is the rados user name, default is admin. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeCephFsSecretRefResult(dict):
    def __init__(__self__, *,
                 namespace: str,
                 name: Optional[str] = None):
        """
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "namespace", namespace)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeCinderResult(dict):
    def __init__(__self__, *,
                 volume_id: str,
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str volume_id: Volume ID used to identify the volume in Cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        pulumi.set(__self__, "volume_id", volume_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        Volume ID used to identify the volume in Cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write). More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeConfigMapResult(dict):
    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeConfigMapItemResult']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeConfigMapItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Optional: Specify whether the ConfigMap or its keys must be defined.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeConfigMapItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the ConfigMap or its keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeConfigMapItemResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeCsiResult(dict):
    def __init__(__self__, *,
                 driver: str,
                 fs_type: Optional[str] = None,
                 node_publish_secret_ref: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRefResult'] = None,
                 read_only: Optional[bool] = None,
                 volume_attributes: Optional[Mapping[str, str]] = None):
        """
        :param str driver: the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param 'GetK8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRefArgs' node_publish_secret_ref: A reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls.
        :param bool read_only: Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        :param Mapping[str, str] volume_attributes: Attributes of the volume to publish.
        """
        pulumi.set(__self__, "driver", driver)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if node_publish_secret_ref is not None:
            pulumi.set(__self__, "node_publish_secret_ref", node_publish_secret_ref)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if volume_attributes is not None:
            pulumi.set(__self__, "volume_attributes", volume_attributes)

    @property
    @pulumi.getter
    def driver(self) -> str:
        """
        the name of the volume driver to use. More info: https://kubernetes.io/docs/concepts/storage/volumes/#csi
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="nodePublishSecretRef")
    def node_publish_secret_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRefResult']:
        """
        A reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls.
        """
        return pulumi.get(self, "node_publish_secret_ref")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to set the read-only property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#csi
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="volumeAttributes")
    def volume_attributes(self) -> Optional[Mapping[str, str]]:
        """
        Attributes of the volume to publish.
        """
        return pulumi.get(self, "volume_attributes")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeCsiNodePublishSecretRefResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeDownwardApiResult(dict):
    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResult']] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeDownwardApiItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResult(dict):
    def __init__(__self__, *,
                 field_ref: 'outputs.GetK8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRefResult',
                 path: str,
                 mode: Optional[str] = None,
                 resource_field_ref: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRefArgs' field_ref: Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        :param str path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param 'GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        pulumi.set(__self__, "field_ref", field_ref)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> 'outputs.GetK8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRefResult':
        """
        Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefResult']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeDownwardApiItemFieldRefResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeDownwardApiItemResourceFieldRefResult(dict):
    def __init__(__self__, *,
                 container_name: str,
                 resource: str,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "resource", resource)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeEmptyDirResult(dict):
    def __init__(__self__, *,
                 medium: Optional[str] = None,
                 size_limit: Optional[str] = None):
        """
        :param str medium: What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        :param str size_limit: Total amount of local storage required for this EmptyDir volume.
        """
        if medium is not None:
            pulumi.set(__self__, "medium", medium)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @property
    @pulumi.getter
    def medium(self) -> Optional[str]:
        """
        What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        """
        return pulumi.get(self, "medium")

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[str]:
        """
        Total amount of local storage required for this EmptyDir volume.
        """
        return pulumi.get(self, "size_limit")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeEphemeralResult(dict):
    def __init__(__self__, *,
                 volume_claim_template: 'outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateResult'):
        """
        :param 'GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateArgs' volume_claim_template: Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC.
        """
        pulumi.set(__self__, "volume_claim_template", volume_claim_template)

    @property
    @pulumi.getter(name="volumeClaimTemplate")
    def volume_claim_template(self) -> 'outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateResult':
        """
        Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC.
        """
        return pulumi.get(self, "volume_claim_template")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateResult(dict):
    def __init__(__self__, *,
                 spec: 'outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResult',
                 metadata: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataResult'] = None):
        """
        :param 'GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecArgs' spec: The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
        :param 'GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataArgs' metadata: May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
        """
        pulumi.set(__self__, "spec", spec)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResult':
        """
        The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataResult']:
        """
        May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateMetadataResult(dict):
    def __init__(__self__, *,
                 labels: Mapping[str, str],
                 annotations: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        :param Mapping[str, str] annotations: An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        pulumi.set(__self__, "labels", labels)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) the job. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        An unstructured key value map stored with the job that may be used to store arbitrary metadata. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
        """
        return pulumi.get(self, "annotations")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResult(dict):
    def __init__(__self__, *,
                 access_modes: Sequence[str],
                 resources: 'outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesResult',
                 storage_class_name: str,
                 volume_mode: str,
                 volume_name: str):
        """
        :param Sequence[str] access_modes: A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        :param 'GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesArgs' resources: A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        :param str storage_class_name: Name of the storage class requested by the claim
        :param str volume_mode: Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        :param str volume_name: The binding reference to the PersistentVolume backing this claim.
        """
        pulumi.set(__self__, "access_modes", access_modes)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "storage_class_name", storage_class_name)
        pulumi.set(__self__, "volume_mode", volume_mode)
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Sequence[str]:
        """
        A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesResult':
        """
        A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> str:
        """
        Name of the storage class requested by the claim
        """
        return pulumi.get(self, "storage_class_name")

    @property
    @pulumi.getter(name="volumeMode")
    def volume_mode(self) -> str:
        """
        Kubernetes supports two volumeModes of PersistentVolumes: `Filesystem` and `Block`.
        """
        return pulumi.get(self, "volume_mode")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> str:
        """
        The binding reference to the PersistentVolume backing this claim.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeEphemeralVolumeClaimTemplateSpecResourcesResult(dict):
    def __init__(__self__, *,
                 requests: Mapping[str, str],
                 limits: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] requests: Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        :param Mapping[str, str] limits: Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        pulumi.set(__self__, "requests", requests)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)

    @property
    @pulumi.getter
    def requests(self) -> Mapping[str, str]:
        """
        Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
        """
        return pulumi.get(self, "limits")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeFcResult(dict):
    def __init__(__self__, *,
                 lun: int,
                 target_ww_ns: Sequence[str],
                 fs_type: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param int lun: FC target lun number
        :param Sequence[str] target_ww_ns: FC target worldwide names (WWNs)
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "target_ww_ns", target_ww_ns)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def lun(self) -> int:
        """
        FC target lun number
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="targetWwNs")
    def target_ww_ns(self) -> Sequence[str]:
        """
        FC target worldwide names (WWNs)
        """
        return pulumi.get(self, "target_ww_ns")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeFlexVolumeResult(dict):
    def __init__(__self__, *,
                 driver: str,
                 fs_type: Optional[str] = None,
                 options: Optional[Mapping[str, str]] = None,
                 read_only: Optional[bool] = None,
                 secret_ref: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeFlexVolumeSecretRefResult'] = None):
        """
        :param str driver: Driver is the name of the driver to use for this volume.
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        :param Mapping[str, str] options: Extra command options if any.
        :param bool read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).
        :param 'GetK8sJobSpecTemplateSpecVolumeFlexVolumeSecretRefArgs' secret_ref: Reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        """
        pulumi.set(__self__, "driver", driver)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter
    def driver(self) -> str:
        """
        Driver is the name of the driver to use for this volume.
        """
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, str]]:
        """
        Extra command options if any.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the ReadOnly setting in VolumeMounts. Defaults to false (read/write).
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeFlexVolumeSecretRefResult']:
        """
        Reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeFlexVolumeSecretRefResult(dict):
    def __init__(__self__, *,
                 namespace: str,
                 name: Optional[str] = None):
        """
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "namespace", namespace)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeFlockerResult(dict):
    def __init__(__self__, *,
                 dataset_name: Optional[str] = None,
                 dataset_uuid: Optional[str] = None):
        """
        :param str dataset_name: Name of the dataset stored as metadata > name on the dataset for Flocker should be considered as deprecated
        :param str dataset_uuid: UUID of the dataset. This is unique identifier of a Flocker dataset
        """
        if dataset_name is not None:
            pulumi.set(__self__, "dataset_name", dataset_name)
        if dataset_uuid is not None:
            pulumi.set(__self__, "dataset_uuid", dataset_uuid)

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[str]:
        """
        Name of the dataset stored as metadata > name on the dataset for Flocker should be considered as deprecated
        """
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="datasetUuid")
    def dataset_uuid(self) -> Optional[str]:
        """
        UUID of the dataset. This is unique identifier of a Flocker dataset
        """
        return pulumi.get(self, "dataset_uuid")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeGcePersistentDiskResult(dict):
    def __init__(__self__, *,
                 pd_name: str,
                 fs_type: Optional[str] = None,
                 partition: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str pd_name: Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param int partition: The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        :param bool read_only: Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        pulumi.set(__self__, "pd_name", pd_name)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="pdName")
    def pd_name(self) -> str:
        """
        Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "pd_name")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter
    def partition(self) -> Optional[int]:
        """
        The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeGitRepoResult(dict):
    def __init__(__self__, *,
                 directory: Optional[str] = None,
                 repository: Optional[str] = None,
                 revision: Optional[str] = None):
        """
        :param str directory: Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        :param str repository: Repository URL
        :param str revision: Commit hash for the specified revision.
        """
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        """
        Target directory name. Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        """
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        Repository URL
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def revision(self) -> Optional[str]:
        """
        Commit hash for the specified revision.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeGlusterfsResult(dict):
    def __init__(__self__, *,
                 endpoints_name: str,
                 path: str,
                 read_only: Optional[bool] = None):
        """
        :param str endpoints_name: The endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        :param str path: The Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        :param bool read_only: Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        pulumi.set(__self__, "endpoints_name", endpoints_name)
        pulumi.set(__self__, "path", path)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="endpointsName")
    def endpoints_name(self) -> str:
        """
        The endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "endpoints_name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeHostPathResult(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str path: Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        :param str type: Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type for HostPath volume. Allowed values are "" (default), DirectoryOrCreate, Directory, FileOrCreate, File, Socket, CharDevice and BlockDevice
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeIscsiResult(dict):
    def __init__(__self__, *,
                 iqn: str,
                 target_portal: str,
                 fs_type: Optional[str] = None,
                 iscsi_interface: Optional[str] = None,
                 lun: Optional[int] = None,
                 read_only: Optional[bool] = None):
        """
        :param str iqn: Target iSCSI Qualified Name.
        :param str target_portal: iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        :param str iscsi_interface: iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp).
        :param int lun: iSCSI target lun number.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false.
        """
        pulumi.set(__self__, "iqn", iqn)
        pulumi.set(__self__, "target_portal", target_portal)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if iscsi_interface is not None:
            pulumi.set(__self__, "iscsi_interface", iscsi_interface)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def iqn(self) -> str:
        """
        Target iSCSI Qualified Name.
        """
        return pulumi.get(self, "iqn")

    @property
    @pulumi.getter(name="targetPortal")
    def target_portal(self) -> str:
        """
        iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        """
        return pulumi.get(self, "target_portal")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="iscsiInterface")
    def iscsi_interface(self) -> Optional[str]:
        """
        iSCSI interface name that uses an iSCSI transport. Defaults to 'default' (tcp).
        """
        return pulumi.get(self, "iscsi_interface")

    @property
    @pulumi.getter
    def lun(self) -> Optional[int]:
        """
        iSCSI target lun number.
        """
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeLocalResult(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None):
        """
        :param str path: Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#local
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeNfsResult(dict):
    def __init__(__self__, *,
                 path: str,
                 server: str,
                 read_only: Optional[bool] = None):
        """
        :param str path: Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param str server: Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        :param bool read_only: Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "server", server)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumePersistentVolumeClaimResult(dict):
    def __init__(__self__, *,
                 claim_name: Optional[str] = None,
                 read_only: Optional[bool] = None):
        """
        :param str claim_name: ClaimName is the name of a PersistentVolumeClaim in the same
        :param bool read_only: Will force the ReadOnly setting in VolumeMounts.
        """
        if claim_name is not None:
            pulumi.set(__self__, "claim_name", claim_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> Optional[str]:
        """
        ClaimName is the name of a PersistentVolumeClaim in the same
        """
        return pulumi.get(self, "claim_name")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Will force the ReadOnly setting in VolumeMounts.
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumePhotonPersistentDiskResult(dict):
    def __init__(__self__, *,
                 pd_id: str,
                 fs_type: Optional[str] = None):
        """
        :param str pd_id: ID that identifies Photon Controller persistent disk
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        pulumi.set(__self__, "pd_id", pd_id)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)

    @property
    @pulumi.getter(name="pdId")
    def pd_id(self) -> str:
        """
        ID that identifies Photon Controller persistent disk
        """
        return pulumi.get(self, "pd_id")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedResult(dict):
    def __init__(__self__, *,
                 sources: Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceResult'],
                 default_mode: Optional[str] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeProjectedSourceArgs'] sources: Source of the volume to project in the directory.
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        pulumi.set(__self__, "sources", sources)
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceResult']:
        """
        Source of the volume to project in the directory.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceResult(dict):
    def __init__(__self__, *,
                 config_maps: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapResult']] = None,
                 downward_api: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiResult'] = None,
                 secrets: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretResult']] = None,
                 service_account_token: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenResult'] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapArgs'] config_maps: ConfigMap represents a configMap that should populate this volume
        :param 'GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiArgs' downward_api: DownwardAPI represents downward API about the pod that should populate this volume
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretArgs'] secrets: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param 'GetK8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenArgs' service_account_token: A projected service account token volume
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service_account_token is not None:
            pulumi.set(__self__, "service_account_token", service_account_token)

    @property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapResult']]:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_maps")

    @property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiResult']:
        """
        DownwardAPI represents downward API about the pod that should populate this volume
        """
        return pulumi.get(self, "downward_api")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretResult']]:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="serviceAccountToken")
    def service_account_token(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenResult']:
        """
        A projected service account token volume
        """
        return pulumi.get(self, "service_account_token")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapResult(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItemResult']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param bool optional: Optional: Specify whether the ConfigMap or it's keys must be defined.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the ConfigMap or it's keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceConfigMapItemResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiResult(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResult']] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemArgs'] items: Represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResult']]:
        """
        Represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResult(dict):
    def __init__(__self__, *,
                 path: str,
                 field_ref: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefResult'] = None,
                 mode: Optional[str] = None,
                 resource_field_ref: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefResult'] = None):
        """
        :param str path: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        :param 'GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefArgs' field_ref: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        :param str mode: Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param 'GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        pulumi.set(__self__, "path", path)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefResult']:
        """
        Selects a field of the pod: only annotations, labels, name and namespace are supported.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefResult']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemFieldRefResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        """
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
        :param str field_path: Path of the field to select in the specified API version
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        Path of the field to select in the specified API version
        """
        return pulumi.get(self, "field_path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceDownwardApiItemResourceFieldRefResult(dict):
    def __init__(__self__, *,
                 container_name: str,
                 resource: str,
                 divisor: Optional[str] = None):
        """
        :param str resource: Resource to select
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "resource", resource)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretResult(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretItemResult']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        :param bool optional: Optional: Specify whether the Secret or it's keys must be defined.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the Secret or it's keys must be defined.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceSecretItemResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeProjectedSourceServiceAccountTokenResult(dict):
    def __init__(__self__, *,
                 path: str,
                 audience: Optional[str] = None,
                 expiration_seconds: Optional[int] = None):
        """
        :param str path: Path specifies a relative path to the mount point of the projected volume.
        :param str audience: Audience is the intended audience of the token
        :param int expiration_seconds: ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds).
        """
        pulumi.set(__self__, "path", path)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if expiration_seconds is not None:
            pulumi.set(__self__, "expiration_seconds", expiration_seconds)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path specifies a relative path to the mount point of the projected volume.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Audience is the intended audience of the token
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="expirationSeconds")
    def expiration_seconds(self) -> Optional[int]:
        """
        ExpirationSeconds is the expected duration of validity of the service account token. It defaults to 1 hour and must be at least 10 minutes (600 seconds).
        """
        return pulumi.get(self, "expiration_seconds")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeQuobyteResult(dict):
    def __init__(__self__, *,
                 registry: str,
                 volume: str,
                 group: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 user: Optional[str] = None):
        """
        :param str registry: Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        :param str volume: Volume is a string that references an already created Quobyte volume by name.
        :param str group: Group to map volume access to Default is no group
        :param bool read_only: Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        :param str user: User to map volume access to Defaults to serivceaccount user
        """
        pulumi.set(__self__, "registry", registry)
        pulumi.set(__self__, "volume", volume)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def registry(self) -> str:
        """
        Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        """
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter
    def volume(self) -> str:
        """
        Volume is a string that references an already created Quobyte volume by name.
        """
        return pulumi.get(self, "volume")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group to map volume access to Default is no group
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        User to map volume access to Defaults to serivceaccount user
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeRbdResult(dict):
    def __init__(__self__, *,
                 ceph_monitors: Sequence[str],
                 keyring: str,
                 rbd_image: str,
                 fs_type: Optional[str] = None,
                 rados_user: Optional[str] = None,
                 rbd_pool: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 secret_ref: Optional['outputs.GetK8sJobSpecTemplateSpecVolumeRbdSecretRefResult'] = None):
        """
        :param Sequence[str] ceph_monitors: A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str keyring: Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str rbd_image: The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str fs_type: Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        :param str rados_user: The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param str rbd_pool: The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it.
        :param bool read_only: Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        :param 'GetK8sJobSpecTemplateSpecVolumeRbdSecretRefArgs' secret_ref: Name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        pulumi.set(__self__, "ceph_monitors", ceph_monitors)
        pulumi.set(__self__, "keyring", keyring)
        pulumi.set(__self__, "rbd_image", rbd_image)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if rados_user is not None:
            pulumi.set(__self__, "rados_user", rados_user)
        if rbd_pool is not None:
            pulumi.set(__self__, "rbd_pool", rbd_pool)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="cephMonitors")
    def ceph_monitors(self) -> Sequence[str]:
        """
        A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "ceph_monitors")

    @property
    @pulumi.getter
    def keyring(self) -> str:
        """
        Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "keyring")

    @property
    @pulumi.getter(name="rbdImage")
    def rbd_image(self) -> str:
        """
        The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "rbd_image")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        """
        return pulumi.get(self, "fs_type")

    @property
    @pulumi.getter(name="radosUser")
    def rados_user(self) -> Optional[str]:
        """
        The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "rados_user")

    @property
    @pulumi.getter(name="rbdPool")
    def rbd_pool(self) -> Optional[str]:
        """
        The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it.
        """
        return pulumi.get(self, "rbd_pool")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Whether to force the read-only setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GetK8sJobSpecTemplateSpecVolumeRbdSecretRefResult']:
        """
        Name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeRbdSecretRefResult(dict):
    def __init__(__self__, *,
                 namespace: str,
                 name: Optional[str] = None):
        """
        :param str namespace: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "namespace", namespace)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeSecretResult(dict):
    def __init__(__self__, *,
                 default_mode: Optional[str] = None,
                 items: Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeSecretItemResult']] = None,
                 optional: Optional[bool] = None,
                 secret_name: Optional[str] = None):
        """
        :param str default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param Sequence['GetK8sJobSpecTemplateSpecVolumeSecretItemArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param bool optional: Optional: Specify whether the Secret or its keys must be defined.
        :param str secret_name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetK8sJobSpecTemplateSpecVolumeSecretItemResult']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Optional: Specify whether the Secret or its keys must be defined.
        """
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secrets
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeSecretItemResult(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str key: The key to project.
        :param str mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetK8sJobSpecTemplateSpecVolumeVsphereVolumeResult(dict):
    def __init__(__self__, *,
                 volume_path: str,
                 fs_type: Optional[str] = None):
        """
        :param str volume_path: Path that identifies vSphere volume vmdk
        :param str fs_type: Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        pulumi.set(__self__, "volume_path", volume_path)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)

    @property
    @pulumi.getter(name="volumePath")
    def volume_path(self) -> str:
        """
        Path that identifies vSphere volume vmdk
        """
        return pulumi.get(self, "volume_path")

    @property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[str]:
        """
        Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        """
        return pulumi.get(self, "fs_type")


@pulumi.output_type
class GetNativeHostImageTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNativeHostImagesImageResult(dict):
    def __init__(__self__, *,
                 arch: str,
                 image_id: str,
                 is_kubernetes: bool,
                 k8s_version: str,
                 name: str,
                 os: str,
                 region: str,
                 tags: Sequence['outputs.GetNativeHostImagesImageTagResult'],
                 username: str):
        """
        :param str arch: Architecture of the native host
        :param str k8s_version: K8 version of the native host
        :param str name: Name of the Duplocloud native host
        :param str os: OS of native host
        :param str username: username associated to native host
        """
        pulumi.set(__self__, "arch", arch)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "is_kubernetes", is_kubernetes)
        pulumi.set(__self__, "k8s_version", k8s_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def arch(self) -> str:
        """
        Architecture of the native host
        """
        return pulumi.get(self, "arch")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="isKubernetes")
    def is_kubernetes(self) -> bool:
        return pulumi.get(self, "is_kubernetes")

    @property
    @pulumi.getter(name="k8sVersion")
    def k8s_version(self) -> str:
        """
        K8 version of the native host
        """
        return pulumi.get(self, "k8s_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Duplocloud native host
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def os(self) -> str:
        """
        OS of native host
        """
        return pulumi.get(self, "os")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetNativeHostImagesImageTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        username associated to native host
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetNativeHostImagesImageTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNativeHostsHostResult(dict):
    def __init__(__self__, *,
                 base64_user_data: str,
                 capacity: str,
                 friendly_name: str,
                 fullname: str,
                 identity_role: str,
                 image_id: str,
                 initial_base64_user_data: str,
                 instance_id: str,
                 keypair_type: int,
                 metadatas: Sequence['outputs.GetNativeHostsHostMetadataResult'],
                 minion_tags: Sequence['outputs.GetNativeHostsHostMinionTagResult'],
                 network_interfaces: Sequence['outputs.GetNativeHostsHostNetworkInterfaceResult'],
                 private_ip_address: str,
                 public_ip_address: str,
                 status: str,
                 tags: Sequence['outputs.GetNativeHostsHostTagResult'],
                 tenant_id: str,
                 user_account: str,
                 volumes: Sequence['outputs.GetNativeHostsHostVolumeResult'],
                 agent_platform: Optional[int] = None,
                 allocated_public_ip: Optional[bool] = None,
                 cloud: Optional[int] = None,
                 custom_node_labels: Optional[Mapping[str, str]] = None,
                 encrypt_disk: Optional[bool] = None,
                 is_ebs_optimized: Optional[bool] = None,
                 is_minion: Optional[bool] = None,
                 prepend_user_data: Optional[bool] = None,
                 taints: Optional[Sequence['outputs.GetNativeHostsHostTaintResult']] = None,
                 zone: Optional[int] = None):
        """
        :param str base64_user_data: Base64 encoded EC2 user data to associated with the host.
        :param str capacity: The AWS EC2 instance type.
        :param str friendly_name: The short name of the host.
        :param str identity_role: The name of the IAM role associated with this host.
        :param str image_id: The AMI ID to use.
        :param str instance_id: The AWS EC2 instance ID of the host.
        :param int keypair_type: The numeric ID of the keypair type being used.Should be one of:
               
                  - `0` : Default
                  - `1` : RSA (deprecated - some operating systems no longer support it)
                  - `2` : ED25519
        :param Sequence['GetNativeHostsHostMetadataArgs'] metadatas: Configuration metadata used when creating the host.<br>*Note: To configure OS disk size OsDiskSize can be specified as Key and its size as value, size value should be atleast 10*
        :param Sequence['GetNativeHostsHostMinionTagArgs'] minion_tags: A map of tags to assign to the resource. Example - `AllocationTags` can be passed as tag key with any value.
        :param Sequence['GetNativeHostsHostNetworkInterfaceArgs'] network_interfaces: An optional list of custom network interface configurations to use when creating the host.
        :param str private_ip_address: The primary private IP address assigned to the host.
        :param str public_ip_address: The primary public IP address assigned to the host.
        :param str status: The current status of the host.
        :param str tenant_id: The GUID of the tenant that the host will be created in.
        :param str user_account: The name of the tenant that the host will be created in.
        :param Sequence['GetNativeHostsHostVolumeArgs'] volumes: Block to specify additional or secondary volume beyond the root device
        :param int agent_platform: The numeric ID of the container agent pool that this host is added to.
                - 0: Linux Docker/Native
               - 	4: None
               - 5: Docker Windows
               - 7: EKS Linux
               - 8: ECS
        :param bool allocated_public_ip: Whether or not to allocate a public IP.
        :param int cloud: The numeric ID of the cloud provider to launch the host in.
        :param Mapping[str, str] custom_node_labels: Specify the labels to attach to the nodes.
        :param bool prepend_user_data: Bootstrap an EKS host with Duplo's user data, prepending it to custom user data if also provided.
        :param Sequence['GetNativeHostsHostTaintArgs'] taints: Specify taints to attach to the nodes, to repel other nodes with different toleration
        :param int zone: The availability zone to launch the host in, expressed as a number and starting at 0.
        """
        pulumi.set(__self__, "base64_user_data", base64_user_data)
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "friendly_name", friendly_name)
        pulumi.set(__self__, "fullname", fullname)
        pulumi.set(__self__, "identity_role", identity_role)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "initial_base64_user_data", initial_base64_user_data)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "keypair_type", keypair_type)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "minion_tags", minion_tags)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "user_account", user_account)
        pulumi.set(__self__, "volumes", volumes)
        if agent_platform is not None:
            pulumi.set(__self__, "agent_platform", agent_platform)
        if allocated_public_ip is not None:
            pulumi.set(__self__, "allocated_public_ip", allocated_public_ip)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if custom_node_labels is not None:
            pulumi.set(__self__, "custom_node_labels", custom_node_labels)
        if encrypt_disk is not None:
            pulumi.set(__self__, "encrypt_disk", encrypt_disk)
        if is_ebs_optimized is not None:
            pulumi.set(__self__, "is_ebs_optimized", is_ebs_optimized)
        if is_minion is not None:
            pulumi.set(__self__, "is_minion", is_minion)
        if prepend_user_data is not None:
            pulumi.set(__self__, "prepend_user_data", prepend_user_data)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="base64UserData")
    def base64_user_data(self) -> str:
        """
        Base64 encoded EC2 user data to associated with the host.
        """
        return pulumi.get(self, "base64_user_data")

    @property
    @pulumi.getter
    def capacity(self) -> str:
        """
        The AWS EC2 instance type.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> str:
        """
        The short name of the host.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter
    def fullname(self) -> str:
        return pulumi.get(self, "fullname")

    @property
    @pulumi.getter(name="identityRole")
    def identity_role(self) -> str:
        """
        The name of the IAM role associated with this host.
        """
        return pulumi.get(self, "identity_role")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The AMI ID to use.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="initialBase64UserData")
    def initial_base64_user_data(self) -> str:
        return pulumi.get(self, "initial_base64_user_data")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        """
        The AWS EC2 instance ID of the host.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="keypairType")
    def keypair_type(self) -> int:
        """
        The numeric ID of the keypair type being used.Should be one of:

           - `0` : Default
           - `1` : RSA (deprecated - some operating systems no longer support it)
           - `2` : ED25519
        """
        return pulumi.get(self, "keypair_type")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetNativeHostsHostMetadataResult']:
        """
        Configuration metadata used when creating the host.<br>*Note: To configure OS disk size OsDiskSize can be specified as Key and its size as value, size value should be atleast 10*
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="minionTags")
    def minion_tags(self) -> Sequence['outputs.GetNativeHostsHostMinionTagResult']:
        """
        A map of tags to assign to the resource. Example - `AllocationTags` can be passed as tag key with any value.
        """
        return pulumi.get(self, "minion_tags")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetNativeHostsHostNetworkInterfaceResult']:
        """
        An optional list of custom network interface configurations to use when creating the host.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The primary private IP address assigned to the host.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        The primary public IP address assigned to the host.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current status of the host.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetNativeHostsHostTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The GUID of the tenant that the host will be created in.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> str:
        """
        The name of the tenant that the host will be created in.
        """
        return pulumi.get(self, "user_account")

    @property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.GetNativeHostsHostVolumeResult']:
        """
        Block to specify additional or secondary volume beyond the root device
        """
        return pulumi.get(self, "volumes")

    @property
    @pulumi.getter(name="agentPlatform")
    def agent_platform(self) -> Optional[int]:
        """
        The numeric ID of the container agent pool that this host is added to.
         - 0: Linux Docker/Native
        - 	4: None
        - 5: Docker Windows
        - 7: EKS Linux
        - 8: ECS
        """
        return pulumi.get(self, "agent_platform")

    @property
    @pulumi.getter(name="allocatedPublicIp")
    def allocated_public_ip(self) -> Optional[bool]:
        """
        Whether or not to allocate a public IP.
        """
        return pulumi.get(self, "allocated_public_ip")

    @property
    @pulumi.getter
    def cloud(self) -> Optional[int]:
        """
        The numeric ID of the cloud provider to launch the host in.
        """
        return pulumi.get(self, "cloud")

    @property
    @pulumi.getter(name="customNodeLabels")
    def custom_node_labels(self) -> Optional[Mapping[str, str]]:
        """
        Specify the labels to attach to the nodes.
        """
        return pulumi.get(self, "custom_node_labels")

    @property
    @pulumi.getter(name="encryptDisk")
    def encrypt_disk(self) -> Optional[bool]:
        return pulumi.get(self, "encrypt_disk")

    @property
    @pulumi.getter(name="isEbsOptimized")
    def is_ebs_optimized(self) -> Optional[bool]:
        return pulumi.get(self, "is_ebs_optimized")

    @property
    @pulumi.getter(name="isMinion")
    def is_minion(self) -> Optional[bool]:
        return pulumi.get(self, "is_minion")

    @property
    @pulumi.getter(name="prependUserData")
    def prepend_user_data(self) -> Optional[bool]:
        """
        Bootstrap an EKS host with Duplo's user data, prepending it to custom user data if also provided.
        """
        return pulumi.get(self, "prepend_user_data")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.GetNativeHostsHostTaintResult']]:
        """
        Specify taints to attach to the nodes, to repel other nodes with different toleration
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter
    def zone(self) -> Optional[int]:
        """
        The availability zone to launch the host in, expressed as a number and starting at 0.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetNativeHostsHostMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNativeHostsHostMinionTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNativeHostsHostNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 associate_public_ip: bool,
                 device_index: int,
                 groups: Sequence[str],
                 metadatas: Sequence['outputs.GetNativeHostsHostNetworkInterfaceMetadataResult'],
                 network_interface_id: str,
                 subnet_id: str):
        """
        :param bool associate_public_ip: Whether or not to associate a public IP with the newly created ENI.  Cannot be specified if `network_interface_id` is specified.
        :param int device_index: The device index to pass to AWS for attaching the ENI.  Starts at zero.
        :param str network_interface_id: The ID of an ENI to attach to this host.  Cannot be specified if `subnet_id` or `associate_public_ip` is specified.
        :param str subnet_id: The ID of a subnet in which to create a new ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        pulumi.set(__self__, "associate_public_ip", associate_public_ip)
        pulumi.set(__self__, "device_index", device_index)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associatePublicIp")
    def associate_public_ip(self) -> bool:
        """
        Whether or not to associate a public IP with the newly created ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        return pulumi.get(self, "associate_public_ip")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> int:
        """
        The device index to pass to AWS for attaching the ENI.  Starts at zero.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter
    def groups(self) -> Sequence[str]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetNativeHostsHostNetworkInterfaceMetadataResult']:
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        """
        The ID of an ENI to attach to this host.  Cannot be specified if `subnet_id` or `associate_public_ip` is specified.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The ID of a subnet in which to create a new ENI.  Cannot be specified if `network_interface_id` is specified.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetNativeHostsHostNetworkInterfaceMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNativeHostsHostTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNativeHostsHostTaintResult(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str effect: Update strategy of the node. Effect types <br>      - NoSchedule<br>     - PreferNoSchedule<br>     - NoExecute
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        Update strategy of the node. Effect types <br>      - NoSchedule<br>     - PreferNoSchedule<br>     - NoExecute
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNativeHostsHostVolumeResult(dict):
    def __init__(__self__, *,
                 delete_on_termination: bool,
                 iops: int,
                 name: str,
                 size: int,
                 volume_id: str,
                 volume_type: str):
        """
        :param bool delete_on_termination: Whether the volume should be deleted when the instance is terminated.
        """
        pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_id", volume_id)
        pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        """
        Whether the volume should be deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def iops(self) -> int:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetPlanCertificateResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlanCertificatesCertificateResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 name: str):
        """
        :param str arn: The ARN of the certificate
        :param str name: A domain name for which the certificate should be issued
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The ARN of the certificate
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A domain name for which the certificate should be issued
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlanConfigResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 type: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPlanImageResult(dict):
    def __init__(__self__, *,
                 image_id: str,
                 name: str,
                 os: str,
                 tags: Sequence['outputs.GetPlanImageTagResult'],
                 username: str):
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def os(self) -> str:
        return pulumi.get(self, "os")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetPlanImageTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetPlanImageTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPlanImagesImageResult(dict):
    def __init__(__self__, *,
                 image_id: str,
                 name: str,
                 os: str,
                 tags: Sequence['outputs.GetPlanImagesImageTagResult'],
                 username: str):
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def os(self) -> str:
        return pulumi.get(self, "os")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetPlanImagesImageTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetPlanImagesImageTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPlanKmsKeyResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlanKmsKeyDataResult(dict):
    def __init__(__self__, *,
                 kms_arn: str,
                 kms_id: str,
                 kms_name: str):
        pulumi.set(__self__, "kms_arn", kms_arn)
        pulumi.set(__self__, "kms_id", kms_id)
        pulumi.set(__self__, "kms_name", kms_name)

    @property
    @pulumi.getter(name="kmsArn")
    def kms_arn(self) -> str:
        return pulumi.get(self, "kms_arn")

    @property
    @pulumi.getter(name="kmsId")
    def kms_id(self) -> str:
        return pulumi.get(self, "kms_id")

    @property
    @pulumi.getter(name="kmsName")
    def kms_name(self) -> str:
        return pulumi.get(self, "kms_name")


@pulumi.output_type
class GetPlanKmsKeyV2KmsKeyResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlanKubernetesConfigResult(dict):
    def __init__(__self__, *,
                 api_server: str,
                 certificate_authority_data: str,
                 name: str,
                 provider: int,
                 region: str,
                 token: str,
                 version: str):
        pulumi.set(__self__, "api_server", api_server)
        pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> str:
        return pulumi.get(self, "api_server")

    @property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> str:
        return pulumi.get(self, "certificate_authority_data")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def provider(self) -> int:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def token(self) -> str:
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPlanMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPlanNatGatewaysNatGatewayResult(dict):
    def __init__(__self__, *,
                 addresses: Sequence['outputs.GetPlanNatGatewaysNatGatewayAddressResult'],
                 id: str,
                 state: str,
                 subnet_id: str,
                 tags: Sequence['outputs.GetPlanNatGatewaysNatGatewayTagResult'],
                 vpc_id: str):
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence['outputs.GetPlanNatGatewaysNatGatewayAddressResult']:
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetPlanNatGatewaysNatGatewayTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetPlanNatGatewaysNatGatewayAddressResult(dict):
    def __init__(__self__, *,
                 allocation_id: str,
                 network_interface_id: str,
                 private_ip: str,
                 public_ip: str):
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "network_interface_id", network_interface_id)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "public_ip", public_ip)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> str:
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> str:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class GetPlanNatGatewaysNatGatewayTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPlanSettingsDnsSettingResult(dict):
    def __init__(__self__, *,
                 domain_id: str,
                 external_dns_suffix: str,
                 ignore_global_dns: bool,
                 internal_dns_suffix: str):
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "external_dns_suffix", external_dns_suffix)
        pulumi.set(__self__, "ignore_global_dns", ignore_global_dns)
        pulumi.set(__self__, "internal_dns_suffix", internal_dns_suffix)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> str:
        return pulumi.get(self, "domain_id")

    @property
    @pulumi.getter(name="externalDnsSuffix")
    def external_dns_suffix(self) -> str:
        return pulumi.get(self, "external_dns_suffix")

    @property
    @pulumi.getter(name="ignoreGlobalDns")
    def ignore_global_dns(self) -> bool:
        return pulumi.get(self, "ignore_global_dns")

    @property
    @pulumi.getter(name="internalDnsSuffix")
    def internal_dns_suffix(self) -> str:
        return pulumi.get(self, "internal_dns_suffix")


@pulumi.output_type
class GetPlanSettingsMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPlanWafInfoResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlanWafsDataResult(dict):
    def __init__(__self__, *,
                 dashboard_url: str,
                 waf_arn: str,
                 waf_name: str):
        pulumi.set(__self__, "dashboard_url", dashboard_url)
        pulumi.set(__self__, "waf_arn", waf_arn)
        pulumi.set(__self__, "waf_name", waf_name)

    @property
    @pulumi.getter(name="dashboardUrl")
    def dashboard_url(self) -> str:
        return pulumi.get(self, "dashboard_url")

    @property
    @pulumi.getter(name="wafArn")
    def waf_arn(self) -> str:
        return pulumi.get(self, "waf_arn")

    @property
    @pulumi.getter(name="wafName")
    def waf_name(self) -> str:
        return pulumi.get(self, "waf_name")


@pulumi.output_type
class GetPlanWafsV2WafResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 dashboard_url: str,
                 name: str):
        """
        :param str arn: The ARN of the waf
        :param str dashboard_url: The dashboard url associated to waf
        :param str name: Name of the waf  issued
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "dashboard_url", dashboard_url)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The ARN of the waf
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="dashboardUrl")
    def dashboard_url(self) -> str:
        """
        The dashboard url associated to waf
        """
        return pulumi.get(self, "dashboard_url")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the waf  issued
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlansDataResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 availability_zones: Sequence[str],
                 capabilities: Mapping[str, bool],
                 certificates: Sequence['outputs.GetPlansDataCertificateResult'],
                 cloud: int,
                 cloud_config: Mapping[str, str],
                 configs: Sequence['outputs.GetPlansDataConfigResult'],
                 images: Sequence['outputs.GetPlansDataImageResult'],
                 kms_keys: Sequence['outputs.GetPlansDataKmsKeyResult'],
                 kubernetes_configs: Sequence['outputs.GetPlansDataKubernetesConfigResult'],
                 metadatas: Sequence['outputs.GetPlansDataMetadataResult'],
                 plan_id: str,
                 private_subnet_ids: Sequence[str],
                 public_subnet_ids: Sequence[str],
                 region: str,
                 vpc_id: str,
                 waf_infos: Sequence['outputs.GetPlansDataWafInfoResult']):
        """
        :param str account_id: The cloud account ID.
        :param Sequence[str] availability_zones: A list of the Availability Zones available to the plan.
        :param Mapping[str, bool] capabilities: Map of capability flags
        :param Sequence['GetPlansDataCertificateArgs'] certificates: Plan certificates that can be attached to load balancers
        :param int cloud: The numerical index of the cloud provider for this planWill be one of:
               
                  - `0` : AWS
                  - `2` : Azure
                  - `3` : GCP
        :param Mapping[str, str] cloud_config: Cloud-specific plan configuration data
        :param Sequence['GetPlansDataConfigArgs'] configs: Plan configuration data
        :param Sequence['GetPlansDataImageArgs'] images: Plan images that can be used to launch native hosts
        :param Sequence['GetPlansDataKmsKeyArgs'] kms_keys: Plan KMS keys that can be used for cloud-based encryption
        :param Sequence['GetPlansDataKubernetesConfigArgs'] kubernetes_configs: Kubernetes-specific plan configuration data
        :param Sequence['GetPlansDataMetadataArgs'] metadatas: Plan metadata
        :param str plan_id: The plan ID
        :param Sequence[str] private_subnet_ids: The private subnets for the VPC or VNet.
        :param Sequence[str] public_subnet_ids: The public subnets for the VPC or VNet.
        :param str region: The cloud provider region.
        :param str vpc_id: The VPC or VNet ID.
        :param Sequence['GetPlansDataWafInfoArgs'] waf_infos: Plan web application firewalls that can be attached to load balancers
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "cloud_config", cloud_config)
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "images", images)
        pulumi.set(__self__, "kms_keys", kms_keys)
        pulumi.set(__self__, "kubernetes_configs", kubernetes_configs)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "plan_id", plan_id)
        pulumi.set(__self__, "private_subnet_ids", private_subnet_ids)
        pulumi.set(__self__, "public_subnet_ids", public_subnet_ids)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "waf_infos", waf_infos)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        The cloud account ID.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[str]:
        """
        A list of the Availability Zones available to the plan.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter
    def capabilities(self) -> Mapping[str, bool]:
        """
        Map of capability flags
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetPlansDataCertificateResult']:
        """
        Plan certificates that can be attached to load balancers
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def cloud(self) -> int:
        """
        The numerical index of the cloud provider for this planWill be one of:

           - `0` : AWS
           - `2` : Azure
           - `3` : GCP
        """
        return pulumi.get(self, "cloud")

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Mapping[str, str]:
        """
        Cloud-specific plan configuration data
        """
        return pulumi.get(self, "cloud_config")

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetPlansDataConfigResult']:
        """
        Plan configuration data
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def images(self) -> Sequence['outputs.GetPlansDataImageResult']:
        """
        Plan images that can be used to launch native hosts
        """
        return pulumi.get(self, "images")

    @property
    @pulumi.getter(name="kmsKeys")
    def kms_keys(self) -> Sequence['outputs.GetPlansDataKmsKeyResult']:
        """
        Plan KMS keys that can be used for cloud-based encryption
        """
        return pulumi.get(self, "kms_keys")

    @property
    @pulumi.getter(name="kubernetesConfigs")
    def kubernetes_configs(self) -> Sequence['outputs.GetPlansDataKubernetesConfigResult']:
        """
        Kubernetes-specific plan configuration data
        """
        return pulumi.get(self, "kubernetes_configs")

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetPlansDataMetadataResult']:
        """
        Plan metadata
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="planId")
    def plan_id(self) -> str:
        """
        The plan ID
        """
        return pulumi.get(self, "plan_id")

    @property
    @pulumi.getter(name="privateSubnetIds")
    def private_subnet_ids(self) -> Sequence[str]:
        """
        The private subnets for the VPC or VNet.
        """
        return pulumi.get(self, "private_subnet_ids")

    @property
    @pulumi.getter(name="publicSubnetIds")
    def public_subnet_ids(self) -> Sequence[str]:
        """
        The public subnets for the VPC or VNet.
        """
        return pulumi.get(self, "public_subnet_ids")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The cloud provider region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The VPC or VNet ID.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="wafInfos")
    def waf_infos(self) -> Sequence['outputs.GetPlansDataWafInfoResult']:
        """
        Plan web application firewalls that can be attached to load balancers
        """
        return pulumi.get(self, "waf_infos")


@pulumi.output_type
class GetPlansDataCertificateResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlansDataConfigResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 type: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPlansDataImageResult(dict):
    def __init__(__self__, *,
                 image_id: str,
                 name: str,
                 os: str,
                 tags: Sequence['outputs.GetPlansDataImageTagResult'],
                 username: str):
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def os(self) -> str:
        return pulumi.get(self, "os")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetPlansDataImageTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetPlansDataImageTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPlansDataKmsKeyResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPlansDataKubernetesConfigResult(dict):
    def __init__(__self__, *,
                 api_server: str,
                 certificate_authority_data: str,
                 name: str,
                 provider: int,
                 region: str,
                 token: str,
                 version: str):
        pulumi.set(__self__, "api_server", api_server)
        pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> str:
        return pulumi.get(self, "api_server")

    @property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> str:
        return pulumi.get(self, "certificate_authority_data")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def provider(self) -> int:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def token(self) -> str:
        return pulumi.get(self, "token")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPlansDataMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetPlansDataWafInfoResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSystemFeaturesAppConfigResult(dict):
    def __init__(__self__, *,
                 key: str,
                 type: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSystemFeaturesEksVersionResult(dict):
    def __init__(__self__, *,
                 default_version: str,
                 supported_versions: Sequence[str]):
        pulumi.set(__self__, "default_version", default_version)
        pulumi.set(__self__, "supported_versions", supported_versions)

    @property
    @pulumi.getter(name="defaultVersion")
    def default_version(self) -> str:
        return pulumi.get(self, "default_version")

    @property
    @pulumi.getter(name="supportedVersions")
    def supported_versions(self) -> Sequence[str]:
        return pulumi.get(self, "supported_versions")


@pulumi.output_type
class GetTenantAwsKmsKeysKeyResult(dict):
    def __init__(__self__, *,
                 key_arn: str,
                 key_id: str,
                 key_name: str):
        pulumi.set(__self__, "key_arn", key_arn)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "key_name", key_name)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> str:
        return pulumi.get(self, "key_arn")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> str:
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        return pulumi.get(self, "key_name")


@pulumi.output_type
class GetTenantConfigMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetTenantPolicyResult(dict):
    def __init__(__self__, *,
                 allow_volume_mapping: bool,
                 block_external_ep: bool):
        pulumi.set(__self__, "allow_volume_mapping", allow_volume_mapping)
        pulumi.set(__self__, "block_external_ep", block_external_ep)

    @property
    @pulumi.getter(name="allowVolumeMapping")
    def allow_volume_mapping(self) -> bool:
        return pulumi.get(self, "allow_volume_mapping")

    @property
    @pulumi.getter(name="blockExternalEp")
    def block_external_ep(self) -> bool:
        return pulumi.get(self, "block_external_ep")


@pulumi.output_type
class GetTenantSecretTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetTenantSecretsSecretResult(dict):
    def __init__(__self__, *,
                 arn: str,
                 name: str,
                 name_suffix: str,
                 rotation_enabled: bool,
                 tags: Sequence['outputs.GetTenantSecretsSecretTagResult'],
                 tenant_id: str):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_suffix", name_suffix)
        pulumi.set(__self__, "rotation_enabled", rotation_enabled)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nameSuffix")
    def name_suffix(self) -> str:
        return pulumi.get(self, "name_suffix")

    @property
    @pulumi.getter(name="rotationEnabled")
    def rotation_enabled(self) -> bool:
        return pulumi.get(self, "rotation_enabled")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetTenantSecretsSecretTagResult']:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetTenantSecretsSecretTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetTenantTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetTenantsTenantResult(dict):
    def __init__(__self__, *,
                 id: str,
                 infra_owner: str,
                 name: str,
                 plan_id: str,
                 policies: Sequence['outputs.GetTenantsTenantPolicyResult'],
                 tags: Sequence['outputs.GetTenantsTenantTagResult']):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "infra_owner", infra_owner)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "plan_id", plan_id)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="infraOwner")
    def infra_owner(self) -> str:
        return pulumi.get(self, "infra_owner")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="planId")
    def plan_id(self) -> str:
        return pulumi.get(self, "plan_id")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetTenantsTenantPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetTenantsTenantTagResult']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTenantsTenantPolicyResult(dict):
    def __init__(__self__, *,
                 allow_volume_mapping: bool,
                 block_external_ep: bool):
        pulumi.set(__self__, "allow_volume_mapping", allow_volume_mapping)
        pulumi.set(__self__, "block_external_ep", block_external_ep)

    @property
    @pulumi.getter(name="allowVolumeMapping")
    def allow_volume_mapping(self) -> bool:
        return pulumi.get(self, "allow_volume_mapping")

    @property
    @pulumi.getter(name="blockExternalEp")
    def block_external_ep(self) -> bool:
        return pulumi.get(self, "block_external_ep")


@pulumi.output_type
class GetTenantsTenantTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


