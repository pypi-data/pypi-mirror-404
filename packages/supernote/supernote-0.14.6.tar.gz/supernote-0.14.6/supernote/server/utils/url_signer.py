"""A library for signing and verifying urls.


The UrlSigner class provides a mechanism to secure URL access by appending
a cryptographic signature (JWT) to the path. This ensures that:
- Authenticity: The URL was generated by a holder of the secret key.
- Identity: The URL is bound to a specific user (if provided).
- Integrity: The path (resource) has not been tampered with.
- Expiration: The URL is only valid for a specific time window.

We are not enforcing uniqueness. This could be added in the future by
using the nonce in the payload.

We use JSON Web Tokens (JWT) using the HS256 algorithm. This encapsulates
the payload (path, user, expiration, nonce) into a single, standard, url-safe
string. This simplifies the client-side usage (one query parameter) and
leverages standard libraries for verification and expiration handling.

Single-Use Tokens:
For strict security (default), tokens are single-use. This is implemented
via a 'whitelist' in CoordinationService. When a token is signed, its nonce
is stored. successfully verification removes (consumes) the nonce.
However, for operations like chunked uploads where the URL is reused,
verification can optionally skip consumption (`consume=False`).

Usage example:

```python
    signer = UrlSigner(secret_key="my-secret")

    # Generate a signed URL (default 15 mins expiry)
    full_url = signer.sign("/api/file/download?id=123")
    # Returns: /api/file/download?id=123&signature=eyJhbG...

    # Verify the signature
    is_valid = signer.verify("/api/file/download?id=123", signature_token)
```
"""

import datetime
import logging
import time
import urllib.parse
import uuid
from typing import Any

import jwt

from supernote.server.exceptions import InvalidSignature, SignerError
from supernote.server.services.coordination import CoordinationService

logger = logging.getLogger(__name__)

DEFAULT_EXPIRATION = datetime.timedelta(minutes=15)


class UrlSigner:
    """Sign and verify URLs using HMAC-SHA256 (via JWT)."""

    def __init__(
        self,
        secret_key: str,
        coordination_service: CoordinationService | None = None,
    ) -> None:
        """Initialize the signer with a secret key."""
        self.secret_key = secret_key
        self.algorithm = "HS256"
        self._coordination_service = coordination_service

    async def sign(
        self,
        path: str,
        user: str | None = None,
        expiration: datetime.timedelta = DEFAULT_EXPIRATION,
    ) -> str:
        """Sign a path and return the full signed URL.

        Args:
            path: The path to sign (e.g. /api/file/download/data?path=...)
            user: The user email to embed in the signature.
            expiration: Expiration duration (timedelta).

        Returns:
            The full signed URL with the signature query parameter appended.
        """
        if not path.startswith("/"):
            raise ValueError("Path must start with '/'")
        if "#" in path:
            raise ValueError("URL fragments (anchors) are not supported")

        if expiration < datetime.timedelta(seconds=0):
            raise ValueError("Expiration must be non-negative")

        now = int(time.time())
        now_ms = int(time.time() * 1000)

        exp = now + int(expiration.total_seconds())
        nonce = uuid.uuid4().hex

        # whitelist logic: store nonce before issuing token
        if self._coordination_service:
            # Key format: nonce:{user}:{nonce} for easier namespacing/debug
            # Fallback to 'anon' if no user provided
            user_key_part = user if user else "anon"
            key = f"nonce:{user_key_part}:{nonce}"

            # Store with TTL matching expiration + buffer (e.g. 1m) to ensure it lives long enough
            # We use "1" as value indicating "valid/issed"
            ttl = int(expiration.total_seconds()) + 60
            await self._coordination_service.set_value(key, "1", ttl=ttl)

        payload = {
            "path": path,
            "exp": exp,
            "nonce": nonce,
            "iat": now,
            "timestamp": now_ms,
        }
        if user:
            payload["user"] = user

        try:
            token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        except jwt.PyJWTError as err:
            raise SignerError(f"Failed to encode signature: {err}") from err

        # Check if query params exist
        separator = "&" if "?" in path else "?"
        return f"{path}{separator}timestamp={now_ms}&nonce={nonce}&signature={token}"

    async def verify(self, signed_url: str, consume: bool = True) -> dict[str, Any]:
        """Verify the signature embedded in the URL.

        Args:
            signed_url: The full path + query string containing the signature.
            consume: Whether to consume the nonce (single-use). Default True.

        Returns:
            The decoded payload if valid, None otherwise.
        """
        if not signed_url.startswith("/"):
            raise ValueError("Path must start with '/'")

        # Parse URL and extract signature
        parsed = urllib.parse.urlparse(signed_url)
        query_params = urllib.parse.parse_qs(parsed.query, keep_blank_values=True)

        if not (signatures := query_params.get("signature")):
            raise InvalidSignature(f"No signature found in URL: {signed_url}")

        signature = signatures[0]
        try:
            payload = jwt.decode(
                signature, self.secret_key, algorithms=[self.algorithm]
            )
        except jwt.ExpiredSignatureError as err:
            raise InvalidSignature(f"Signature expired: {signed_url}") from err
        except jwt.InvalidTokenError as err:
            raise InvalidSignature(f"Invalid signature: {signed_url}") from err
        except jwt.PyJWTError as err:
            raise InvalidSignature(f"Error decoding signature: {err}") from err

        if not isinstance(payload, dict):
            raise InvalidSignature(f"Invalid payload type: {type(payload)}")

        # We reconstruct the URL *without* the signature param to compare
        # against what was signed (payload['path']).
        if not (expected_path := payload.get("path")):
            raise InvalidSignature(f"No path found in payload: {payload}")

        # CONSUME NONCE (Single-Use Token)
        # Check and Remove (atomic pop if possible)
        nonce = payload.get("nonce")
        user = payload.get("user")
        if self._coordination_service and nonce:
            user_key_part = user if user else "anon"
            key = f"nonce:{user_key_part}:{nonce}"

            # Atomic Pop if consuming, otherwise just check existence
            if consume:
                val = await self._coordination_service.pop_value(key)
                if not val:
                    raise InvalidSignature(
                        f"Token invalid or already used (nonce: {nonce})"
                    )
            else:
                val = await self._coordination_service.get_value(key)
                if not val:
                    raise InvalidSignature(f"Token invalid or expired (nonce: {nonce})")

        if not signed_url.startswith(expected_path):
            raise InvalidSignature(
                f"Signed path mismatch: signed path '{expected_path}' is not prefix of request '{signed_url}'"
            )

        # Verify timestamp if present in payload
        if "timestamp" in payload:
            ts_param = query_params.get("timestamp")
            if not ts_param:
                raise InvalidSignature("Timestamp missing from URL")
            if str(payload["timestamp"]) != ts_param[0]:
                raise InvalidSignature("Timestamp mismatch")

        return payload

    @staticmethod
    def extract_signature(url: str) -> str | None:
        """Extract the signature from a signed URL."""
        parsed = urllib.parse.urlparse(url)
        qs = urllib.parse.parse_qs(parsed.query)
        return qs.get("signature", [None])[0]

    @staticmethod
    def extract_timestamp(url: str) -> str | None:
        """Extract the timestamp from a signed URL."""
        parsed = urllib.parse.urlparse(url)
        qs = urllib.parse.parse_qs(parsed.query)
        return qs.get("timestamp", [None])[0]
