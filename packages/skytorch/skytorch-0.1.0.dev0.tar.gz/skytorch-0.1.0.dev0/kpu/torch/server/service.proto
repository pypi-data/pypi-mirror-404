syntax = "proto3";

package kpu.torch;

// Tensor management service for KPU PyTorch backend
service Service {
  // Tensor lifecycle management
  rpc CreateTensor(CreateTensorRequest) returns (TensorResponse);
  rpc UpdateTensor(stream TensorChunk) returns (TensorResponse);
  rpc GetTensor(GetTensorRequest) returns (stream TensorChunk);
  rpc CopyTensor(CopyTensorRequest) returns (TensorResponse);

  // ATen operation execution
  rpc ExecuteAtenOperation(ExecuteAtenRequest) returns (ExecuteAtenResponse);
}

// Represents a chunk of serialized tensor data
message TensorChunk {
  // Tensor ID
  uint64 tensor_id = 1;

  // Chunk sequence number (for ordering)
  uint32 chunk_number = 2;

  // Binary data chunk
  bytes data = 3;

  // Total number of chunks for this tensor (set in first chunk)
  uint32 total_chunks = 4;

  // Tensor info (set on first chunk only)
  repeated int64 shape = 7;
  repeated int64 stride = 8;
  int64 storage_offset = 9;
  string dtype = 10;

  // Total serialized size in bytes (set in first chunk, for pre-allocation)
  uint64 total_bytes = 11;
}

// Response after receiving tensors
message TensorResponse {
  bool success = 1;
  string message = 2;
}

// Request to create a tensor on the server
message CreateTensorRequest {
  uint64 tensor_id = 1;
  repeated int64 shape = 2;
  string dtype = 3;
  int64 nbytes = 4;
  string device_type = 5;
  repeated int64 stride = 6;
  int64 storage_offset = 7;
  int32 device_index = 8;
  optional uint64 tensor_ref = 9;  // Reference to base tensor for views
}

// Request to get tensor data from storage
message GetTensorRequest {
  uint64 tensor_id = 1;
  repeated int64 shape = 2;
  string dtype = 3;
  repeated int64 stride = 4;
  int64 storage_offset = 5;
}

// Request to copy tensor data on the server
message CopyTensorRequest {
  uint64 src_tensor_id = 1;
  uint64 dst_tensor_id = 2;
  int64 src_offset = 3;
  int64 dst_offset = 4;
  int64 num_bytes = 5;
}

// Reference to a tensor on the server
message TensorReference {
  uint64 tensor_id = 1;
}

// Argument for ATen operations (can be tensor, scalar, or nested structure)
message AtenArgument {
  oneof value {
    TensorReference tensor = 1;
    double scalar_float = 2;
    int64 scalar_int = 3;
    bool scalar_bool = 4;
    string scalar_string = 5;
    AtenArgumentList list_value = 6;
    bool none_value = 7;  // Represents Python None
    string scalar_dtype = 8;  // torch.dtype as string (e.g., "torch.float32")
    string scalar_memory_format = 9;  // torch.memory_format as string (e.g., "torch.contiguous_format")
  }
}

// List of AtenArguments (for nested lists/tuples)
message AtenArgumentList {
  repeated AtenArgument values = 1;
  bool is_tuple = 2;  // Preserve tuple vs list distinction
}

// Request to execute an ATen operation
message ExecuteAtenRequest {
  string op_name = 1;
  repeated AtenArgument args = 2;  // Positional arguments (preserves order)
  repeated TensorReference outputs = 3;
  map<string, AtenArgument> kwargs = 4;
}

// Response after executing an ATen operation
message ExecuteAtenResponse {
  bool success = 1;
  string message = 2;
  repeated TensorReference output_tensors = 3;
}
