# This file is autogenerated. Do not modify.
# Version: 0.4.0
"""
This module defines types for programmatically constructing Foxglove `layouts <https://docs.foxglove.dev/docs/visualization/layouts>`__.

This API is currently experimental and not ready for public use.
"""

from __future__ import annotations

import json
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Literal


class _BaseModel(ABC):
    @abstractmethod
    def _to_dict(self) -> dict[str, Any]: ...

    def to_json(self) -> str:
        return json.dumps(
            self,
            allow_nan=False,
            separators=(",", ":"),
            default=_BaseModel._to_json_default,
        )

    @staticmethod
    def _to_json_default(obj: Any) -> Any:
        if isinstance(obj, _BaseModel):
            return {k: v for (k, v) in obj._to_dict().items() if v is not None}
        raise TypeError(f"{type(obj).__name__} is not JSON serializable")


class BasePanel(_BaseModel):
    """
    Abstract base class for all panels. This class cannot be instantiated directly. Use one of the provided subclasses instead, or Panel for a custom panel.
    """


VariableValue = bool | float | str | list["VariableValue"] | dict[str, "VariableValue"]

Variables = dict[str, VariableValue]


@dataclass(kw_only=True)
class UserScript(_BaseModel):
    """
    A user script saved in a layout.
    """

    name: str
    """
    The name of the user script.
    """

    source_code: str
    """
    The source code of the user script.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "name": self.name,
            "sourceCode": self.source_code,
        }


UserScripts = dict[str, UserScript]


@dataclass(kw_only=True)
class TabItem(_BaseModel):
    """
    A single tab in a tab container.
    """

    title: str
    """
    The title of the tab.
    """

    content: Content

    def _to_dict(self) -> dict[str, Any]:
        return {
            "title": self.title,
            "content": self.content,
        }


@dataclass(kw_only=True)
class TabContainer(_BaseModel):
    """
    A container for quickly switching between different groups of panels using a tab bar.
    """

    selected_tab_index: int | None = 0
    """
    The 0-based index of the tab that is selected. Defaults to 0.
    """

    tabs: list[TabItem]
    """
    The tabs to display in the container.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "tabs",
            "selectedTabIndex": self.selected_tab_index,
            "tabs": self.tabs,
        }


@dataclass(kw_only=True)
class StackItem(_BaseModel):
    """
    An item in the stack, includes the panel and the height of the item.
    """

    panel: BasePanel

    size: float
    """
    Size is a number greater than 0 that represents a proportion of the height of the stack container; e.g., 0.5 is 50% of the height of the stack container, and 1 is 100% of the height of it.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "panel": self.panel,
            "size": self.size,
        }


@dataclass(kw_only=True)
class StackContainer(_BaseModel):
    """
    A container for a vertically-scrollable stack of panels.
    """

    panels: list[StackItem]
    """
    The panels to display in the stack.
    """

    title: str | None = None
    """
    The title of the stack.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "stack",
            "panels": self.panels,
            "title": self.title,
        }


@dataclass(kw_only=True)
class SplitItem(_BaseModel):
    """
    An item in a split container with a proportion for space allocation.
    """

    proportion: float | None = 1
    """
    Proportion of space this item occupies relative to other items in the split. The actual space allocated is calculated by dividing this item's proportion by the sum of all proportions in the split. The proportion must be greater than 0. Defaults to 1.
    """

    content: Content

    def _to_dict(self) -> dict[str, Any]:
        return {
            "proportion": self.proportion,
            "content": self.content,
        }


@dataclass(kw_only=True)
class SplitContainer(_BaseModel):
    """
    A sequence of items displayed in a vertical or horizontal direction. Items are placed one next to the other (or one above the other for vertical direction), with space allocated according to their ratios.
    """

    direction: Literal["row", "column"] | None = "row"
    """
    The direction in which items are displayed in the list. Defaults to row.
    """

    items: list[SplitItem]
    """
    The items to display in the split container.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "split",
            "direction": self.direction,
            "items": self.items,
        }


Content = BasePanel | TabContainer | StackContainer | SplitContainer


@dataclass(kw_only=True)
class MarkdownConfig(_BaseModel):
    """
    Configuration for the Markdown panel.
    """

    font_size: float | None = None
    """
    Sets the base font size for the Markdown renderer.
    """

    markdown: str | None = None
    """
    The markdown content to display.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "fontSize": self.font_size,
            "markdown": self.markdown,
        }


@dataclass(kw_only=True)
class MarkdownPanel(BasePanel):
    """
    Write documentation and notes formatted using Markdown.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/markdown).
    """

    config: MarkdownConfig = field(default_factory=MarkdownConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Markdown",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


PanelConfig = dict[str, Any]


@dataclass(kw_only=True)
class Panel(BasePanel):
    """
    A schema for a generic panel; can be used as a fallback for panels that are not yet supported.
    """

    panel_type: str
    """
    A unique identifier for the panel type.
    """

    config: PanelConfig | None = None

    title: str | None = None
    """
    The title of the panel.
    """

    version: int
    """
    The version of the panel config schema.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": self.panel_type,
            "config": self.config,
            "title": self.title,
            "version": self.version,
        }


@dataclass(kw_only=True)
class StateTransitionsBaseCustomState(_BaseModel):
    """
    Display options for a discrete or continuous custom state
    """

    label: str | None = None

    color: str | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "label": self.label,
            "color": self.color,
        }


@dataclass(kw_only=True)
class StateTransitionsRangeCustomState(StateTransitionsBaseCustomState):
    """
    A range custom state for the customization strategy
    """

    value: float | None = None
    """
    Value used for comparison against message data for state detection
    """

    operator: Literal["=", "<", "<=", ">", ">="] | None = None
    """
    Operator used for comparison against message data for state detection
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "value": self.value,
            "operator": self.operator,
        }


@dataclass(kw_only=True)
class StateTransitionsRangeCustomStates(_BaseModel):
    """
    Range state customization strategy.
    """

    states: list[StateTransitionsRangeCustomState] | None = None
    """
    The list of range states to display in the panel.
    """

    otherwise: StateTransitionsBaseCustomState | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "range",
            "states": self.states,
            "otherwise": self.otherwise,
        }


@dataclass(kw_only=True)
class StateTransitionsDiscreteCustomState(StateTransitionsBaseCustomState):
    """
    A discrete state customization strategy
    """

    value: str | None = None
    """
    Value used for comparison against message data for state detection. The comparison is done using the '=' operator.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "value": self.value,
        }


@dataclass(kw_only=True)
class StateTransitionsDiscreteCustomStates(_BaseModel):
    """
    Discrete state customization strategy
    """

    states: list[StateTransitionsDiscreteCustomState] | None = None
    """
    The list of discrete states to display in the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "discrete",
            "states": self.states,
        }


StateTransitionsCustomStates = (
    StateTransitionsRangeCustomStates | StateTransitionsDiscreteCustomStates
)


@dataclass(kw_only=True)
class StateTransitionsSeries(_BaseModel):
    """
    A series to display in the panel.
    """

    value: str | None = None
    """
    Message path containing values for the series
    """

    label: str | None = None
    """
    Label displayed in the legend for the series
    """

    enabled: bool | None = None
    """
    Whether the series is enabled. If disabled, the series will not be displayed in the panel.
    """

    timestamp_method: (
        Literal["receiveTime", "publishTime", "headerStamp", "customField"] | None
    ) = None
    """
    Timestamp used for message ordering
    - receiveTime: standard timestamp used for playback message ordering across the app
    - customField: any field within the message data containing sec and nsec integers
    - headerStamp: header.stamp ROS 1 or ROS 2 field containing sec and nsec integers (and special case of 'custom field')
    - publishTime: optional MCAP-specific field
    """

    timestamp_path: str | None = None
    """
    Message path containing a timestamp field on the same topic as the y-value path
    """

    custom_states: StateTransitionsCustomStates | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "value": self.value,
            "label": self.label,
            "enabled": self.enabled,
            "timestampMethod": self.timestamp_method,
            "timestampPath": self.timestamp_path,
            "customStates": self.custom_states,
        }


@dataclass(kw_only=True)
class StateTransitionsConfig(_BaseModel):
    """
    Configuration for the State Transitions panel.
    """

    paths: list[StateTransitionsSeries] | None = None
    """
    The list of series to display in the panel.
    """

    is_synced: bool | None = None
    """
    Sync zooming and panning with other plots
    """

    x_axis_max_value: float | None = None
    """
    Minimum time value to display (in seconds)
    """

    x_axis_min_value: float | None = None
    """
    Maximum time value to display (in seconds)
    """

    x_axis_range: float | None = None
    """
    Time range in seconds
    """

    x_axis_label: str | None = None
    """
    Label displayed along the time axis
    """

    time_window_mode: Literal["automatic", "sliding", "fixed"] | None = None
    """
    Configure a sliding or fixed range of time.
    - Automatic: Last 30 seconds for live data, or the full time range for recorded data
    - Sliding: Specify a sliding time window that follows the current playback time
    - Fixed: Set fixed min and max values
    """

    playback_bar_position: Literal["center", "right"] | None = None
    """
    Position of the playback bar in the view
    """

    show_points: bool | None = None
    """
    Show a point for each incoming message
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "paths": self.paths,
            "isSynced": self.is_synced,
            "xAxisMaxValue": self.x_axis_max_value,
            "xAxisMinValue": self.x_axis_min_value,
            "xAxisRange": self.x_axis_range,
            "xAxisLabel": self.x_axis_label,
            "timeWindowMode": self.time_window_mode,
            "playbackBarPosition": self.playback_bar_position,
            "showPoints": self.show_points,
        }


@dataclass(kw_only=True)
class StateTransitionsPanel(BasePanel):
    """
    Track when values change over time.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/state-transitions).
    """

    config: StateTransitionsConfig = field(default_factory=StateTransitionsConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "StateTransitions",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class PlotSeries(_BaseModel):
    """
    A series in a Plot panel.
    """

    value: str | None = None
    """
    Message path containing y-axis values for the series
    """

    enabled: bool | None = None
    """
    Whether the series is enabled. If disabled, the series will not be displayed in the panel.
    """

    id: str | None = None
    """
    A unique identifier for the series.
    """

    color: str | None = None
    """
    Color used to plot the series
    """

    label: str | None = None
    """
    Label displayed for the series in the legend
    """

    timestamp_method: (
        Literal["receiveTime", "publishTime", "headerStamp", "customField"] | None
    ) = None
    """
    For Timestamp plots, set which source of time information is used for message ordering:
    - receiveTime is the standard timestamp used for playback message ordering across the app. For live connections, this is when the message was received; for recorded files, this is when the message was originally recorded
    - customField is a message path which can point to any field within the message data containing sec and nsec integers
    - headerStamp is a header.stamp ROS 1 or ROS 2 field containing sec and nsec integers (and special case of 'custom field', above). This typically represents when sensor data was captured
    - publishTime is an optional MCAP-specific field representing when the event occurred
    """

    timestamp_path: str | None = None
    """
    Message path containing a timestamp field on the same topic as the y-value path
    """

    show_line: bool | None = None
    """
    Show line connecting data points. (Not applicable to reference lines.)
    """

    line_size: float | None = None
    """
    Width of line connecting data points
    """

    x_value_path: str | None = None
    """
    For Message path plots: message path containing x-axis values for the series. Overrides default x-axis values if set.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "value": self.value,
            "enabled": self.enabled,
            "id": self.id,
            "color": self.color,
            "label": self.label,
            "timestampMethod": self.timestamp_method,
            "timestampPath": self.timestamp_path,
            "showLine": self.show_line,
            "lineSize": self.line_size,
            "xValuePath": self.x_value_path,
        }


@dataclass(kw_only=True)
class PlotXAxisPath(_BaseModel):
    """
    For path-based values: the message path containing default x-axis values for the series. You can also set these individually for each series.
    """

    value: str | None = None
    """
    Message path containing y-axis values for the series
    """

    enabled: bool | None = None
    """
    Whether the series is enabled. If disabled, the series will not be displayed in the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "value": self.value,
            "enabled": self.enabled,
        }


@dataclass(kw_only=True)
class PlotConfig(_BaseModel):
    """
    Configuration for the Plot panel.
    """

    paths: list[PlotSeries] | None = None
    """
    The list of series to display in the panel.
    """

    min_x_value: float | None = None
    """
    For Fixed time window: min value in seconds
    """

    max_x_value: float | None = None
    """
    For Fixed time window: max value in seconds
    """

    min_y_value: str | float | None = None
    """
    Fixed minimum value for y-axis
    """

    max_y_value: str | float | None = None
    """
    Fixed maximum value for y-axis
    """

    show_legend: bool | None = None
    """
    Display the legend
    """

    legend_display: Literal["floating", "top", "left"] | None = None
    """
    Position of the legend in relation to the chart
    """

    show_plot_values_in_legend: bool | None = None
    """
    Show the corresponding y value next to each series in the legend (either at the current playback time or at a point on user hover)
    """

    show_x_axis_labels: bool | None = None
    """
    Whether or not to display numeric values for x-axis tick marks
    """

    show_y_axis_labels: bool | None = None
    """
    Whether or not to display numeric values for y-axis tick marks
    """

    is_synced: bool | None = None
    """
    For Timestamp plots: Sync timeline to other Plot and State Transitions panels.
    """

    x_axis_val: Literal["timestamp", "index", "custom", "currentCustom"] | None = None
    """
    Type and source of data for values plotted on the x-axis:
    - Timestamp: x-values for time series data
    - Message path: numeric message fields for XY plots
    - Array index: integer indices of an array in the latest message
    """

    time_range: Literal["all", "latest"] | None = None
    """
    For Message path plots:
    - All shows data from the full time range
    - Latest shows data from the most recent message.
    """

    x_axis_path: PlotXAxisPath | None = None

    x_axis_label: str | None = None
    """
    Label displayed for the x-axis
    """

    time_window_mode: Literal["automatic", "sliding", "fixed"] | None = None
    """
    For Timestamp plots:
    - Automatic Last 30 seconds for live data, or the full time range for recorded data
    - Sliding Specify a sliding time window that follows the current playback time
    - Fixed Set fixed min and max values for the time axis
    """

    playback_bar_position: Literal["center", "right"] | None = None
    """
    For Sliding time window: either at the center or the right edge
    """

    y_axis_label: str | None = None
    """
    Label displayed for the y-axis
    """

    following_view_width: float | None = None
    """
    For Sliding time window: range of time in seconds
    """

    sidebar_dimension: float | None = None
    """
    Size of the legend in pixels, when the legend position is Left or Top
    """

    axis_scales_mode: Literal["independent", "lockedScales"] | None = None
    """
    For Message path plots:
    - Independent (the default) lets you configure min and max values for the scales independently.
    - 1:1 is useful for when axes have the same units, and will keep the scales locked together. It hides the min/max axis settings and always zooms both axes simultaneously.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "paths": self.paths,
            "minXValue": self.min_x_value,
            "maxXValue": self.max_x_value,
            "minYValue": self.min_y_value,
            "maxYValue": self.max_y_value,
            "showLegend": self.show_legend,
            "legendDisplay": self.legend_display,
            "showPlotValuesInLegend": self.show_plot_values_in_legend,
            "showXAxisLabels": self.show_x_axis_labels,
            "showYAxisLabels": self.show_y_axis_labels,
            "isSynced": self.is_synced,
            "xAxisVal": self.x_axis_val,
            "timeRange": self.time_range,
            "xAxisPath": self.x_axis_path,
            "xAxisLabel": self.x_axis_label,
            "timeWindowMode": self.time_window_mode,
            "playbackBarPosition": self.playback_bar_position,
            "yAxisLabel": self.y_axis_label,
            "followingViewWidth": self.following_view_width,
            "sidebarDimension": self.sidebar_dimension,
            "axisScalesMode": self.axis_scales_mode,
        }


@dataclass(kw_only=True)
class PlotPanel(BasePanel):
    """
    Plot numerical values over time or other values.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/plot).
    """

    config: PlotConfig = field(default_factory=PlotConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Plot",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class TransformTreePanel(BasePanel):
    """
    Display the transform tree.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/tf-tree).
    """

    config: Any | None = None

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "TransformTree",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class BaseRendererBaseSettings(_BaseModel):
    """
    Base class for entities in a 3D or Image panel.
    """

    visible: bool | None = None
    """
    Whether this renderable should be displayed in the scene.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class BaseRendererCameraTopicSettings(BaseRendererBaseSettings):
    """
    Calibration parameters for the camera image topic.
    """

    distance: float | None = None

    planar_projection_factor: float | None = None

    width: float | None = None

    color: str | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "distance": self.distance,
            "planarProjectionFactor": self.planar_projection_factor,
            "width": self.width,
            "color": self.color,
        }


@dataclass(kw_only=True)
class BaseRendererRosOccupancyGridTopicSettings(BaseRendererBaseSettings):
    """
    Settings for an OccupancyGrid topic.
    """

    min_color: str | None = None

    max_color: str | None = None

    unknown_color: str | None = None

    invalid_color: str | None = None

    color_mode: Literal["custom", "costmap", "map", "raw"] | None = None

    draw_behind: bool | None = None

    alpha: float | None = None

    frame_locked: bool | None = None
    """
    true means the grid is locked to the frame specified by its frame_id, and will move as that frame's transforms change. false means the grid is relative to the fixed frame and will not move after it is first displayed.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "minColor": self.min_color,
            "maxColor": self.max_color,
            "unknownColor": self.unknown_color,
            "invalidColor": self.invalid_color,
            "colorMode": self.color_mode,
            "drawBehind": self.draw_behind,
            "alpha": self.alpha,
            "frameLocked": self.frame_locked,
        }


@dataclass(kw_only=True)
class BaseRendererRosPolygonTopicSettings(BaseRendererBaseSettings):
    """
    Timestamped polygons made up of a series of connected points.
    """

    line_width: float | None = None

    color: str | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "lineWidth": self.line_width,
            "color": self.color,
        }


@dataclass(kw_only=True)
class BaseRendererPoseTopicSettings(BaseRendererBaseSettings):
    """
    Settings for a pose (PoseInFrame) topic.
    """

    type: Literal["axis", "arrow"] | None = None

    axis_scale: float | None = None

    arrow_scale: tuple[float, float, float] | None = None

    color: str | None = None

    show_covariance: bool | None = None

    covariance_color: str | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "type": self.type,
            "axisScale": self.axis_scale,
            "arrowScale": self.arrow_scale,
            "color": self.color,
            "showCovariance": self.show_covariance,
            "covarianceColor": self.covariance_color,
        }


@dataclass(kw_only=True)
class BaseRendererPosesTopicSettings(BaseRendererBaseSettings):
    """
    Settings for a pose array (PosesInFrame) topic.
    """

    type: Literal["axis", "arrow", "line"] | None = None

    axis_scale: float | None = None

    arrow_scale: tuple[float, float, float] | None = None

    line_width: float | None = None

    gradient: tuple[str, str] | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "type": self.type,
            "axisScale": self.axis_scale,
            "arrowScale": self.arrow_scale,
            "lineWidth": self.line_width,
            "gradient": self.gradient,
        }


@dataclass(kw_only=True)
class BaseRendererRosVoxelGridTopicSettings(BaseRendererBaseSettings):
    """
    Settings for a ROS VoxelGrid topic.
    """

    draw_behind: bool | None = None
    """
    If true the grid is rendered before the rest of the scene, so it appears behind other scene elements regardless of their relative depth. Otherwise the grid is rendered normally
    """

    color_mode: Literal["rainbow", "turbo", "gradient", "by type"] | None = None
    """
    How to color each voxel.
    """

    use_lighting: bool | None = None
    """
    Enables lighting for voxel shading in 3D view.
    """

    color_gradient: tuple[str, str] | None = None
    """
    The two colors to interpolate between, based on the "color field".
    """

    marked_and_present_color: str | None = None
    """
    RGBA color for voxels that are both marked and present.
    """

    present_color: str | None = None
    """
    RGBA color for voxels that are present but not marked.
    """

    marked_color: str | None = None
    """
    RGBA color for voxels that are marked but not present.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "drawBehind": self.draw_behind,
            "colorMode": self.color_mode,
            "useLighting": self.use_lighting,
            "colorGradient": self.color_gradient,
            "markedAndPresentColor": self.marked_and_present_color,
            "presentColor": self.present_color,
            "markedColor": self.marked_color,
        }


@dataclass(kw_only=True)
class BaseRendererSceneUpdateTopicSettings(BaseRendererBaseSettings):
    """
    A collection of primitive shapes (cubes, spheres, text, meshes, lines, etc) used to display anything from a basic bounding box to a complex 3D decision tree or road network.
    """

    show_outlines: bool | None = None
    """
    Display a wireframe outline around rendered entities.
    """

    color: str | None = None
    """
    Render all entities under this topic with this color, overriding colors defined in the entities.
    """

    selected_id_variable: str | None = None
    """
    Set a global variable with this name to the selected entity ID.
    """

    compute_vertex_normals: bool | None = None
    """
    Toggle calculation of vertex normals. Normals improve lighting and visual appearance but incur a significant performance penalty in some cases.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "showOutlines": self.show_outlines,
            "color": self.color,
            "selectedIdVariable": self.selected_id_variable,
            "computeVertexNormals": self.compute_vertex_normals,
        }


@dataclass(kw_only=True)
class BaseRendererBasePointSettings(BaseRendererBaseSettings):
    """
    Base class for pointcloud-like topic settings.
    """

    point_size: float | None = None
    """
    Size of each rendered point in pixels. Used only when the point shape is "circle" or "square".
    """

    cube_size: float | None = None
    """
    Size of each cube in 3D scene units. Used only when the point shape is "cube".
    """

    cube_outline: bool | None = False
    """
    Toggle whether to display wireframe outline around cubes. Used only when the point shape is "cube". Default: false.
    """

    point_shape: Literal["circle", "square", "cube"] | None = "circle"
    """
    Shape of each rendered point: "circle", "square", or "cube". Default: "circle".
    """

    decay_time: float | None = None
    """
    Duration of time (in sec) that each point stays rendered.
    """

    frame_locked: bool | None = None

    color_mode: (
        Literal["flat", "gradient", "colormap", "rgb", "rgba", "rgba-fields"] | None
    ) = None
    """
    One of:
    
    - **flat**: solid color
    - **colormap**: pre-defined color palette
    - **gradient**: smooth transition between two custom colors
    - **rgb**: `sensor_msgs/PointCloud2` only; use embedded color from each point's rgb field
    - **rgba**: `sensor_msgs/PointCloud2` only; use embedded color from each point's rgba field
    - **rgba-fields**: `foxglove.PointCloud` only; use embedded color from each point's red, green, blue, and alpha fields
    
    """

    flat_color: str | None = None
    """
    Hex code for color of each point. Used only when "colorMode" is set to "flat".
    """

    color_field: str | None = None
    """
    Value used for "colorMap" coloring logic; any numeric field in message such as `x`, `y`, `z`, `_auto_distance` (L2 norm of coordinates), or custom defined field. Used only if "colorMode" is not set to "flat".
    """

    gradient: tuple[str, str] | None = None
    """
    The two colors to interpolate between. Used only if "colorMode" is set to "gradient".
    """

    color_map: Literal["turbo", "rainbow"] | None = None
    """
    "Turbo" (Google) or "Rainbow" (RViz); for mapping "colorField" values to colors. Used only if "colorMode" is set to "colorMap".
    """

    explicit_alpha: float | None = None
    """
    Sets alpha value for all points. Only shown if "colorMode" is set to "colorMap" or "rgb".
    """

    min_value: float | None = None
    """
    Minimum value used to normalize incoming points' "colorField" values. Used only if "colorMode" is not set to "flat".
    """

    max_value: float | None = None
    """
    Maximum value used to normalize incoming points' "colorField" values. Used only if "colorMode" is not set to "flat".
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "pointSize": self.point_size,
            "cubeSize": self.cube_size,
            "cubeOutline": self.cube_outline,
            "pointShape": self.point_shape,
            "decayTime": self.decay_time,
            "frameLocked": self.frame_locked,
            "colorMode": self.color_mode,
            "flatColor": self.flat_color,
            "colorField": self.color_field,
            "gradient": self.gradient,
            "colorMap": self.color_map,
            "explicitAlpha": self.explicit_alpha,
            "minValue": self.min_value,
            "maxValue": self.max_value,
        }


@dataclass(kw_only=True)
class BaseRendererLaserScanTopicSettings(BaseRendererBasePointSettings):
    """
    A single scan from a planar laser range-finder.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {}


@dataclass(kw_only=True)
class BaseRendererBaseGridSettings(BaseRendererBaseSettings):
    """
    Base class for grid and voxel grid topic settings.
    """

    color_mode: Literal["flat", "gradient", "colormap", "rgba-fields"] | None = None

    flat_color: str | None = None
    """
    Hex code for color of each cell
    """

    color_field: str | None = None
    """
    Numeric field in message used for coloring logic
    """

    gradient: tuple[str, str] | None = None
    """
    The two colors to interpolate between, based on the colorField
    """

    color_map: Literal["turbo", "rainbow"] | None = None
    """
    For mapping colorField values to colors
    """

    explicit_alpha: float | None = None
    """
    Sets alpha value for all cells
    """

    min_value: float | None = None
    """
    Minimum value used to normalize incoming grid's colorField values
    """

    max_value: float | None = None
    """
    Maximum value used to normalize incoming grid's colorField values
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "colorMode": self.color_mode,
            "flatColor": self.flat_color,
            "colorField": self.color_field,
            "gradient": self.gradient,
            "colorMap": self.color_map,
            "explicitAlpha": self.explicit_alpha,
            "minValue": self.min_value,
            "maxValue": self.max_value,
        }


@dataclass(kw_only=True)
class BaseRendererGridTopicSettings(BaseRendererBaseGridSettings):
    """
    Settings for a grid topic.
    """

    draw_behind: bool | None = None
    """
    If true the grid is rendered before the rest of the scene, so it appears behind other scene elements regardless of their relative depth. Otherwise the grid is rendered normally
    """

    elevation_field: str | None = None
    """
    Optional field to displace each grid cell in the Z axis; if not set, elevation is 0 for all cells
    """

    interpolation_method: Literal["linear", "nearestNeighbor"] | None = None
    """
    Determines how elevation and color values are sampled spatially across the grid.
    """

    frame_locked: bool | None = None
    """
    true means the grid is locked to the frame specified by its frame_id, and will move as that frame's transforms change. false means the grid is relative to the fixed frame and will not move after it is first displayed.
    """

    show_lines: bool | None = None
    """
    Whether to render subtle grid cell borders
    """

    line_color: str | None = None
    """
    Color of the cell grid lines
    """

    use_lighting: bool | None = None
    """
    Enables shading from simulated directional lighting, based on elevation surface normals
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "drawBehind": self.draw_behind,
            "elevationField": self.elevation_field,
            "interpolationMethod": self.interpolation_method,
            "frameLocked": self.frame_locked,
            "showLines": self.show_lines,
            "lineColor": self.line_color,
            "useLighting": self.use_lighting,
        }


@dataclass(kw_only=True)
class BaseRendererRosGridMapTopicSettings(BaseRendererBaseSettings):
    """
    Settings for a ROS GridMap topic.
    """

    draw_behind: bool | None = None
    """
    If true the grid is rendered before the rest of the scene, so it appears behind other scene elements regardless of their relative depth. Otherwise the grid is rendered normally
    """

    interpolation_method: Literal["linear", "nearestNeighbor"] | None = None
    """
    Determines how elevation and color values are sampled spatially across the grid.
    """

    use_lighting: bool | None = None
    """
    Enables shading from simulated directional lighting, based on elevation surface normals
    """

    show_lines: bool | None = None
    """
    Whether to render subtle grid cell borders
    """

    line_color: str | None = None
    """
    Color of the cell grid lines
    """

    elevation_layer: str | None = None
    """
    Optional field to displace each grid cell in the Z axis; if not set, elevation is 0 for all cells
    """

    color_layer: str | None = None
    """
    Numeric field in message used for coloring logic
    """

    color_gradient: tuple[str, str] | None = None
    """
    The two colors to interpolate between, based on the colorLayer
    """

    color_mode: Literal["colorMap", "gradient"] | None = None

    color_map: Literal["turbo", "rainbow"] | None = None
    """
    For mapping colorLayer values to colors
    """

    explicit_alpha: float | None = None
    """
    Sets alpha value for all cells
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "drawBehind": self.draw_behind,
            "interpolationMethod": self.interpolation_method,
            "useLighting": self.use_lighting,
            "showLines": self.show_lines,
            "lineColor": self.line_color,
            "elevationLayer": self.elevation_layer,
            "colorLayer": self.color_layer,
            "colorGradient": self.color_gradient,
            "colorMode": self.color_mode,
            "colorMap": self.color_map,
            "explicitAlpha": self.explicit_alpha,
        }


@dataclass(kw_only=True)
class BaseRendererVoxelGridTopicSettings(BaseRendererBaseGridSettings):
    """
    Settings for a VoxelGrid topic.
    """

    draw_behind: bool | None = None
    """
    If true the grid is rendered before the rest of the scene, so it appears behind other scene elements regardless of their relative depth. Otherwise the grid is rendered normally
    """

    frame_locked: bool | None = None
    """
    true means the grid is locked to the frame specified by its frame_id, and will move as that frame's transforms change. false means the grid is relative to the fixed frame and will not move after it is first displayed.
    """

    use_lighting: bool | None = None
    """
    Enables shading from simulated directional lighting, based on elevation surface normals
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "drawBehind": self.draw_behind,
            "frameLocked": self.frame_locked,
            "useLighting": self.use_lighting,
        }


@dataclass(kw_only=True)
class BaseRendererUrdfLinkSettings(_BaseModel):
    """
    Settings for a URDF link.
    """

    visible: bool | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class BaseRendererUrdfBaseSettings(BaseRendererBaseSettings):
    """
    Base class for URDF settings.
    """

    display_mode: Literal["auto", "visual", "collision"] | None = None
    """
    Robot link geometries to display.
    
    - auto: Defaults to visual geometries, but falls back to collision geometries if there are no visuals
    - visual: Visual geometries
    - collision: Collision geometries
    """

    fallback_color: str | None = None
    """
    Fallback color for the URDF model, if the source doesn't contain colors.
    """

    show_axis: bool | None = None
    """
    Visualize coordinate frame axis for each URDF link.
    """

    axis_scale: float | None = None
    """
    Scale of link coordinate frame axis.
    """

    show_outlines: bool | None = None
    """
    Visualize edges of URDF link geometries.
    """

    opacity: float | None = None
    """
    Opacity of link geometries on a scale from 0 (fully transparent) to 1 (fully opaque).
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "displayMode": self.display_mode,
            "fallbackColor": self.fallback_color,
            "showAxis": self.show_axis,
            "axisScale": self.axis_scale,
            "showOutlines": self.show_outlines,
            "opacity": self.opacity,
        }


@dataclass(kw_only=True)
class BaseRendererUrdfTopicSettings(BaseRendererUrdfBaseSettings):
    """
    Settings for a URDF topic.
    """

    label: str | None = None

    links: dict[str, BaseRendererUrdfLinkSettings] | None = None
    """
    Toggle visibility of each URDF link or set a custom offset with respect to the parent link. The latter is disabled when the transform to the parent link is provided by the datasource.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "label": self.label,
            "links": self.links,
        }


@dataclass(kw_only=True)
class BaseRendererRosVelodyneScanTopicSettings(BaseRendererBasePointSettings):
    """
    Settings for a ROS VelodyneScan topic.
    """

    stixels_enabled: bool | None = None
    """
    Visualize points as stixels that extend from the point's z location to 0
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "stixelsEnabled": self.stixels_enabled,
        }


@dataclass(kw_only=True)
class BaseRendererRosMarkerNamespaceSettings(BaseRendererBaseSettings):
    """
    Settings for a ROS marker namespace.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {}


@dataclass(kw_only=True)
class BaseRendererRosMarkerTopicSettings(BaseRendererBaseSettings):
    """
    A collection of primitive shapes used to display anything from a basic bounding box to a complex 3D decision tree or road network.
    """

    color: str | None = None

    show_outlines: bool | None = None

    selected_id_variable: str | None = None

    namespaces: dict[str, BaseRendererRosMarkerNamespaceSettings] | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "color": self.color,
            "showOutlines": self.show_outlines,
            "selectedIdVariable": self.selected_id_variable,
            "namespaces": self.namespaces,
        }


@dataclass(kw_only=True)
class BaseRendererPointCloudTopicSettings(BaseRendererBasePointSettings):
    """
    A collection of N-dimensional points, which may contain additional fields with information like normals, intensity, etc.
    """

    stixels_enabled: bool | None = None
    """
    Visualize points as stixels that extend from the point's z location to 0.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "stixelsEnabled": self.stixels_enabled,
        }


@dataclass(kw_only=True)
class BaseRendererImageTopicSettings(BaseRendererBasePointSettings):
    """
    Settings for an image topic.
    """

    camera_info_topic: str | None = None

    distance: float | None = None

    planar_projection_factor: float | None = None

    render_mode: Literal["default", "planeProjection", "pointCloud"] | None = None

    projection_frame_id: str | None = None

    color: str | None = None

    point_size: float | None = None

    custom_depth_scale: float | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "cameraInfoTopic": self.camera_info_topic,
            "distance": self.distance,
            "planarProjectionFactor": self.planar_projection_factor,
            "renderMode": self.render_mode,
            "projectionFrameId": self.projection_frame_id,
            "color": self.color,
            "pointSize": self.point_size,
            "customDepthScale": self.custom_depth_scale,
        }


BaseRendererTopicSettings = (
    BaseRendererCameraTopicSettings
    | BaseRendererGridTopicSettings
    | BaseRendererLaserScanTopicSettings
    | BaseRendererPointCloudTopicSettings
    | BaseRendererPosesTopicSettings
    | BaseRendererPoseTopicSettings
    | BaseRendererRosGridMapTopicSettings
    | BaseRendererRosMarkerTopicSettings
    | BaseRendererRosOccupancyGridTopicSettings
    | BaseRendererRosPolygonTopicSettings
    | BaseRendererRosVelodyneScanTopicSettings
    | BaseRendererRosVoxelGridTopicSettings
    | BaseRendererSceneUpdateTopicSettings
    | BaseRendererUrdfTopicSettings
    | BaseRendererVoxelGridTopicSettings
    | BaseRendererImageTopicSettings
)


@dataclass(kw_only=True)
class BaseRendererLayerSettingsTransform(BaseRendererBaseSettings):
    """
    Settings for a transform frame.
    """

    xyz_offset: tuple[float, float, float] | None = None

    rpy_coefficient: tuple[float, float, float] | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "xyzOffset": self.xyz_offset,
            "rpyCoefficient": self.rpy_coefficient,
        }


@dataclass(kw_only=True)
class BaseRendererBaseLayerSettings(BaseRendererBaseSettings):
    """
    Base class for custom layer settings in a 3D or Image panel.
    """

    instance_id: str | None = None
    """
    An identifier for a unique instance of a layer.
    """

    layer_id: str | None = None
    """
    An identifier for a type of layer, such as `"foxglove.Grid"`.
    """

    label: str | None = None
    """
    The label to use for this layer in the settings tree, under "Custom Layers".
    """

    order: float | None = None
    """
    Optional value specifying order in the custom layer list
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "instanceId": self.instance_id,
            "layerId": self.layer_id,
            "label": self.label,
            "order": self.order,
        }


@dataclass(kw_only=True)
class BaseRendererGridLayerSettings(BaseRendererBaseLayerSettings):
    """
    A grid is 2D square with a fixed size and number of divisions.
    """

    draw_behind: bool | None = None

    frame_id: str | None = None

    size: float | None = None

    divisions: float | None = None

    line_width: float | None = None

    color: str | None = None

    position: tuple[float, float, float] | None = None

    rotation: tuple[float, float, float] | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "drawBehind": self.draw_behind,
            "layerId": "foxglove.Grid",
            "frameId": self.frame_id,
            "size": self.size,
            "divisions": self.divisions,
            "lineWidth": self.line_width,
            "color": self.color,
            "position": self.position,
            "rotation": self.rotation,
        }


@dataclass(kw_only=True)
class BaseRendererTiledMapLayerSettings(BaseRendererBaseLayerSettings):
    """
    A tiled map layer for displaying geographic map tiles in the 3D scene.
    """

    draw_behind: bool | None = None

    server_config: Literal["map", "satellite", "custom"] | None = None

    custom_map_tile_server: str | None = None

    opacity: float | None = None

    z_position: float | None = None
    """
    The Z-position in meters relative to the fixed frame's XY-plane.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "drawBehind": self.draw_behind,
            "layerId": "foxglove.TiledMap",
            "serverConfig": self.server_config,
            "customMapTileServer": self.custom_map_tile_server,
            "opacity": self.opacity,
            "zPosition": self.z_position,
        }


@dataclass(kw_only=True)
class BaseRendererUrdfLayerSettings(BaseRendererBaseLayerSettings):
    """
    Configuration for a URDF (Unified Robot Description Format) custom layer, which can load robot models from various sources.
    """

    source_type: Literal["url", "filePath", "param", "topic"] | None = None
    """
    The source type for the URDF data. One of:
    
    - **url**: URL to the source URDF file
    - **filePath**: Absolute file path to the source URDF file. Only supported when using the desktop app
    - **param**: Parameter containing the source URDF file
    - **topic**: Topic containing the source URDF file
    
    """

    url: str | None = None
    """
    package:// URL or http(s) URL pointing to a Unified Robot Description Format (URDF) XML file. Only shown when sourceType is `url`.
    """

    file_path: str | None = None
    """
    Absolute file path to a URDF file (desktop app only). Only shown when sourceType is `filePath`.
    """

    parameter: str | None = None
    """
    Name of the parameter containing the URDF data. Only shown when sourceType is `param`.
    """

    topic: str | None = None
    """
    Name of the topic containing the URDF data. Only shown when sourceType is `topic`.
    """

    frame_prefix: str | None = None
    """
    Prefix for robot's transforms. Also commonly known as a TF prefix.
    """

    display_mode: Literal["auto", "visual", "collision"] | None = None
    """
    Robot link geometries to display.
    
    - auto: Defaults to visual geometries, but falls back to collision geometries if there are no visuals
    - visual: Visual geometries
    - collision: Collision geometries
    """

    fallback_color: str | None = None
    """
    Fallback color for the URDF model, if the source doesn't contain colors.
    """

    show_axis: bool | None = None
    """
    Visualize coordinate frame axis for each URDF link.
    """

    axis_scale: float | None = None
    """
    Scale of link coordinate frame axis.
    """

    show_outlines: bool | None = None
    """
    Visualize edges of URDF link geometries.
    """

    opacity: float | None = None
    """
    Opacity of link geometries on a scale from 0 (fully transparent) to 1 (fully opaque).
    """

    links: dict[str, BaseRendererUrdfLinkSettings] | None = None
    """
    Toggle visibility of each URDF link or set a custom offset with respect to the parent link. The latter is disabled when the transform to the parent link is provided by the datasource.
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "layerId": "foxglove.Urdf",
            "sourceType": self.source_type,
            "url": self.url,
            "filePath": self.file_path,
            "parameter": self.parameter,
            "topic": self.topic,
            "framePrefix": self.frame_prefix,
            "displayMode": self.display_mode,
            "fallbackColor": self.fallback_color,
            "showAxis": self.show_axis,
            "axisScale": self.axis_scale,
            "showOutlines": self.show_outlines,
            "opacity": self.opacity,
            "links": self.links,
        }


BaseRendererCustomLayerSettings = (
    BaseRendererGridLayerSettings
    | BaseRendererTiledMapLayerSettings
    | BaseRendererUrdfLayerSettings
)


@dataclass(kw_only=True)
class BaseRendererSceneSettings(_BaseModel):
    """
    Scene settings for the currently rendering scene
    """

    enable_stats: bool | None = None
    """
    Display rendering performance statistics in panel
    """

    background_color: str | None = None
    """
    Background color of the scene
    """

    label_scale_factor: float | None = None
    """
    Scale factor to apply to all rendered labels
    """

    ignore_collada_up_axis: bool | None = None
    """
    Match the behavior of RViz by ignoring the <up_axis> tag in COLLADA files
    """

    mesh_up_axis: Literal["y_up", "z_up"] | None = None
    """
    The direction to use as "up" when loading meshes without orientation info (e.g. STL, OBJ)
    """

    transforms: BaseRendererTransforms | None = None

    sync_camera: bool | None = None
    """
    Sync the camera with other panels that also have this setting enabled
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "enableStats": self.enable_stats,
            "backgroundColor": self.background_color,
            "labelScaleFactor": self.label_scale_factor,
            "ignoreColladaUpAxis": self.ignore_collada_up_axis,
            "meshUpAxis": self.mesh_up_axis,
            "transforms": self.transforms,
            "syncCamera": self.sync_camera,
        }


@dataclass(kw_only=True)
class BaseRendererTransforms(_BaseModel):
    """
    Transform settings for the currently rendering scene
    """

    visible: bool | None = None
    """
    Toggle visibility of all frames
    """

    editable: bool | None = None
    """
    Toggle translation and rotation offset controls for frames
    """

    show_label: bool | None = None
    """
    Toggle visibility of frame axis labels
    """

    label_size: float | None = None
    """
    Size of frame axis labels
    """

    axis_size: float | None = None
    """
    Size of coordinate frame axes
    """

    line_width: float | None = None
    """
    Width of the connecting line between child and parent frames
    """

    line_color: str | None = None
    """
    Color of the connecting line between child and parent frames
    """

    enable_preloading: bool | None = None
    """
    Enable transform preloading
    """

    draw_behind: bool | None = None
    """
    Whether to draw the frames behind the rest of the scene
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
            "editable": self.editable,
            "showLabel": self.show_label,
            "labelSize": self.label_size,
            "axisSize": self.axis_size,
            "lineWidth": self.line_width,
            "lineColor": self.line_color,
            "enablePreloading": self.enable_preloading,
            "drawBehind": self.draw_behind,
        }


@dataclass(kw_only=True)
class BaseRendererConfig(_BaseModel):
    """
    Base configuration for the 3D and Image panels
    """

    scene: BaseRendererSceneSettings | None = None

    transforms: dict[str, BaseRendererLayerSettingsTransform] | None = None
    """
    frameId -> settings
    """

    layers: dict[str, BaseRendererCustomLayerSettings] | None = None
    """
    Settings for layers in the scene, indexed by instanceId.
    """

    topics: dict[str, BaseRendererTopicSettings] | None = None
    """
    Settings for topics, indexed by topicName
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "scene": self.scene,
            "transforms": self.transforms,
            "layers": self.layers,
            "topics": self.topics,
        }


@dataclass(kw_only=True)
class ThreeDeeCameraState(_BaseModel):
    """
    Camera settings for the currently rendering scene
    """

    distance: float | None = None
    """
    Camera distance from the origin of the display frame
    """

    perspective: bool | None = None
    """
    Toggles between 3D and 2D views of the scene. The 2D view looks down the z-axis of the fixed frame and flattens the scene against its x-y plane.
    """

    phi: float | None = None
    """
    Polar angle offset from the origin of the display frame in degrees
    """

    target: tuple[float, float, float] | None = None

    target_offset: tuple[float, float, float] | None = None
    """
    Translational offset from the origin of the display frame
    """

    target_orientation: tuple[float, float, float, float] | None = None

    theta_offset: float | None = None
    """
    Azimuthal angle offset from the origin of the display frame in degrees
    """

    fovy: float | None = None
    """
    Vertical field of view in degrees
    """

    near: float | None = None
    """
    Near clipping plane distance
    """

    far: float | None = None
    """
    Far clipping plane distance
    """

    log_depth: bool | None = None
    """
    Enable logarithmic depth buffer for more uniform depth precision. May result in rendering artifacts or performance degradation.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "distance": self.distance,
            "perspective": self.perspective,
            "phi": self.phi,
            "target": self.target,
            "targetOffset": self.target_offset,
            "targetOrientation": self.target_orientation,
            "thetaOffset": self.theta_offset,
            "fovy": self.fovy,
            "near": self.near,
            "far": self.far,
            "logDepth": self.log_depth,
        }


@dataclass(kw_only=True)
class ThreeDeePublishSettings(_BaseModel):
    """
    Publish settings for the currently rendering scene
    """

    type: Literal["pose_estimate", "pose", "point"] | None = None

    pose_topic: str | None = None
    """
    The topic on which to publish
    """

    point_topic: str | None = None
    """
    The topic on which to publish
    """

    pose_estimate_topic: str | None = None
    """
    The topic on which to publish
    """

    pose_estimate_x_deviation: float | None = None
    """
    The X standard deviation to publish with pose estimates
    """

    pose_estimate_y_deviation: float | None = None
    """
    The Y standard deviation to publish with pose estimates
    """

    pose_estimate_theta_deviation: float | None = None
    """
    The theta standard deviation to publish with pose estimates
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": self.type,
            "poseTopic": self.pose_topic,
            "pointTopic": self.point_topic,
            "poseEstimateTopic": self.pose_estimate_topic,
            "poseEstimateXDeviation": self.pose_estimate_x_deviation,
            "poseEstimateYDeviation": self.pose_estimate_y_deviation,
            "poseEstimateThetaDeviation": self.pose_estimate_theta_deviation,
        }


@dataclass(kw_only=True)
class ThreeDeeOverlaySettings(_BaseModel):
    """
    Settings for 3D panel overlays.
    """

    visible: bool | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class ThreeDeeConfig(BaseRendererConfig):
    """
    Configuration for the 3D panel
    """

    camera_state: ThreeDeeCameraState | None = None

    follow_tf: str | None = None
    """
    Coordinate frame that the scene is rendered relative to. The camera position and orientation will be relative to the origin of this frame.
    """

    fixed_frame: str | None = None
    """
    The stationary world reference relative to which all other objects in the scene are located. Elements that accumulate over time (for example, point clouds) are stored and displayed in this frame, and in 2D mode the camera faces this frame's x-y plane.
    """

    follow_mode: Literal["follow-pose", "follow-position", "follow-none"] | None = None
    """
    Viewport following behavior during playback: fixed, or the pose or position of the display frame
    """

    location_fix_topic: str | None = None
    """
    Topic containing location fix data associated with a frame in the scene. Auto will use the first available topic.
    """

    enu_frame_id: str | None = None
    """
    Defines the East-North-Up orientation of the scene. Maps and location fixes will be aligned relative to the XY plane of this frame.
    """

    publish: ThreeDeePublishSettings | None = None

    panel_overlays: dict[str, ThreeDeeOverlaySettings] | None = None
    """
    instanceId -> settings
    """

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "cameraState": self.camera_state,
            "followTf": self.follow_tf,
            "fixedFrame": self.fixed_frame,
            "followMode": self.follow_mode,
            "locationFixTopic": self.location_fix_topic,
            "enuFrameId": self.enu_frame_id,
            "publish": self.publish,
            "panelOverlays": self.panel_overlays,
        }


@dataclass(kw_only=True)
class ThreeDeePanel(BasePanel):
    """
    Display markers, camera images, meshes, URDFs, and more in a 3D scene.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/3d).
    """

    config: ThreeDeeConfig = field(default_factory=ThreeDeeConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "ThreeDee",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class ImageAnnotationSettings(_BaseModel):
    """
    Settings for an image annotation topic.
    """

    visible: bool | None = None
    """
    Whether to display the annotation.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class ImageModeConfig(_BaseModel):
    """
    Settings specific to the Image panel.
    """

    color_mode: (
        Literal["flat", "gradient", "colormap", "rgb", "rgba", "rgba-fields"] | None
    ) = None
    """
    One of: "flat", "gradient", "colormap", "rgb", "rgba", or "rgba-fields".
    """

    flat_color: str | None = None
    """
    Hex code for color of each point. Used only when "colorMode" is "flat".
    """

    color_field: str | None = None
    """
    Value used for "colorMap" coloring logic; any numeric field in the message. Used only if "colorMode" is not "flat".
    """

    gradient: tuple[str, str] | None = None
    """
    The two colors to interpolate between. Used only if "colorMode" is "gradient".
    """

    color_map: Literal["turbo", "rainbow"] | None = None
    """
    Color palette for mapping "colorField" values to colors. Used only if "colorMode" is "colormap".
    """

    explicit_alpha: float | None = None
    """
    Sets alpha value for all colors. Used only when "colorMode" is "colormap" or "rgb".
    """

    image_topic: str | None = None
    """
    Camera image or video topic to display.
    """

    image_schema_name: str | None = None
    """
    Message schema to display
    """

    calibration_topic: str | None = None
    """
    Calibration topic to use for distortion and 3D markers
    """

    annotations: dict[str, ImageAnnotationSettings] | None = None
    """
    Settings for the image annotations, indexed by topicName
    """

    synchronize: bool | None = None
    """
    Display annotations only when their messages' timestamps match
    """

    rotation: Literal[0, 90, 180, 270] | None = None
    """
    Amount of image rotation
    """

    flip_horizontal: bool | None = None
    """
    Flip image across the vertical axis
    """

    flip_vertical: bool | None = None
    """
    Flip image across the horizontal axis
    """

    video_decoder: str | None = None
    """
    Video decoder
    """

    rectify_image: bool | None = None
    """
    Whether to rectify (undistort) the image. If turned off, images will be displayed as is and 3D topic visualization will be disabled.
    """

    min_value: float | None = None
    """
    Minimum (black) value for single-channel images.
    """

    max_value: float | None = None
    """
    Maximum (white) value for single-channel images.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "colorMode": self.color_mode,
            "flatColor": self.flat_color,
            "colorField": self.color_field,
            "gradient": self.gradient,
            "colorMap": self.color_map,
            "explicitAlpha": self.explicit_alpha,
            "imageTopic": self.image_topic,
            "imageSchemaName": self.image_schema_name,
            "calibrationTopic": self.calibration_topic,
            "annotations": self.annotations,
            "synchronize": self.synchronize,
            "rotation": self.rotation,
            "flipHorizontal": self.flip_horizontal,
            "flipVertical": self.flip_vertical,
            "videoDecoder": self.video_decoder,
            "rectifyImage": self.rectify_image,
            "minValue": self.min_value,
            "maxValue": self.max_value,
        }


@dataclass(kw_only=True)
class ImageConfig(BaseRendererConfig):
    """
    Configuration for the image panel.
    """

    image_mode: ImageModeConfig | None = None

    def _to_dict(self) -> dict[str, Any]:
        return super()._to_dict() | {
            "imageMode": self.image_mode,
        }


@dataclass(kw_only=True)
class ImagePanel(BasePanel):
    """
    Display annotated images.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/image).
    """

    config: ImageConfig = field(default_factory=ImageConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Image",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class AudioConfig(_BaseModel):
    """
    Configuration for the Audio panel.
    """

    color: str | None = None
    """
    Color of the audio waveform visualization
    """

    muted: bool | None = None
    """
    Mute audio playback
    """

    topic: str | None = None
    """
    Topic containing audio messages
    """

    volume: float | None = None
    """
    Audio playback volume
    """

    sliding_view_width: float | None = None
    """
    Time range in seconds for the sliding window (live sources only)
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "color": self.color,
            "muted": self.muted,
            "topic": self.topic,
            "volume": self.volume,
            "slidingViewWidth": self.sliding_view_width,
        }


@dataclass(kw_only=True)
class AudioPanel(BasePanel):
    """
    Play audio streams.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/audio).
    """

    config: AudioConfig = field(default_factory=AudioConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Audio",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class DiagnosticsSummaryConfig(_BaseModel):
    """
    Configuration for the Diagnostic Summary panel.
    """

    min_level: float | None = None
    """
    Minimum level of diagnostic messages to display
    """

    pinned_ids: list[str] | None = None
    """
    List of diagnostic IDs to pin to the top of the list. The format is `|hardware_id|name|` or `|hardware_id|` for a hardware ID without a name.
    """

    topic_to_render: str | None = None
    """
    ROS DiagnosticArray topic to subscribe to
    """

    hardware_id_filter: str | None = None
    """
    Fuzzy filter entries by hardware ID and node names
    """

    sort_by_level: bool | None = None
    """
    Sort visible nodes by level
    """

    seconds_until_stale: float | None = None
    """
    Number of seconds after which entries will be marked as stale if no new messages are received
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "minLevel": self.min_level,
            "pinnedIds": self.pinned_ids,
            "topicToRender": self.topic_to_render,
            "hardwareIdFilter": self.hardware_id_filter,
            "sortByLevel": self.sort_by_level,
            "secondsUntilStale": self.seconds_until_stale,
        }


@dataclass(kw_only=True)
class DiagnosticsSummaryPanel(BasePanel):
    """
    Display a summary of all ROS DiagnosticArray messages.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/diagnostics).
    """

    config: DiagnosticsSummaryConfig = field(default_factory=DiagnosticsSummaryConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "DiagnosticsSummary",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class DiagnosticsDetailConfig(_BaseModel):
    """
    Configuration for the Diagnostic Detail panel.
    """

    selected_hardware_id: str | None = None
    """
    The hardware ID of the diagnostic node to display
    """

    selected_name: str | None = None
    """
    The name of the diagnostic node to display
    """

    split_fraction: float | None = None
    """
    The fraction of the panel to split between the diagnostic node and the diagnostic status
    """

    topic_to_render: str | None = None
    """
    ROS DiagnosticArray topic to subscribe to
    """

    numeric_precision: float | None = None
    """
    Number of decimal places to display for numeric values
    """

    seconds_until_stale: float | None = None
    """
    Number of seconds after which entries will be marked as stale if no new messages are received
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "selectedHardwareId": self.selected_hardware_id,
            "selectedName": self.selected_name,
            "splitFraction": self.split_fraction,
            "topicToRender": self.topic_to_render,
            "numericPrecision": self.numeric_precision,
            "secondsUntilStale": self.seconds_until_stale,
        }


@dataclass(kw_only=True)
class DiagnosticsDetailPanel(BasePanel):
    """
    Display ROS DiagnosticArray messages for a specific hardware_id.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/diagnostics).
    """

    config: DiagnosticsDetailConfig = field(default_factory=DiagnosticsDetailConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "DiagnosticsDetail",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class IndicatorRule(_BaseModel):
    """
    A rule to determine what the indicator should display
    """

    raw_value: str | None = None
    """
    Value to compare against
    """

    operator: Literal["=", "<", "<=", ">", ">="] | None = None
    """
    Operator to use for the indicator rule
    """

    color: str | None = None
    """
    Color to use when the rule matches
    """

    label: str | None = None
    """
    Label to use when the rule matches
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "rawValue": self.raw_value,
            "operator": self.operator,
            "color": self.color,
            "label": self.label,
        }


@dataclass(kw_only=True)
class IndicatorConfig(_BaseModel):
    """
    Configuration for the Indicator panel.
    """

    path: str | None = None
    """
    Message path to the data
    """

    style: Literal["bulb", "background"] | None = None
    """
    Style of indicator to display
    """

    font_size: float | None = None
    """
    Font size of the indicator
    """

    rules: list[IndicatorRule] | None = None
    """
    Range rules list to determine what the indicator should display, evaluated in order of precedence
    """

    fallback_color: str | None = None
    """
    Color to use when no other rules match
    """

    fallback_label: str | None = None
    """
    Label to use when no other rules match
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "path": self.path,
            "style": self.style,
            "fontSize": self.font_size,
            "rules": self.rules,
            "fallbackColor": self.fallback_color,
            "fallbackLabel": self.fallback_label,
        }


@dataclass(kw_only=True)
class IndicatorPanel(BasePanel):
    """
    Display a colored and/or textual indicator based on a threshold value.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/indicator).
    """

    config: IndicatorConfig = field(default_factory=IndicatorConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Indicator",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class GaugeConfig(_BaseModel):
    """
    Configuration for the Gauge panel.
    """

    path: str | None = None
    """
    Message path containing a numeric value (or string value that can be coerced to a numeric value)
    """

    style: Literal["dial", "bar"] | None = "dial"
    """
    Visual style of the gauge
    """

    min_value: float | None = None
    """
    Minimum value for the gauge
    """

    max_value: float | None = None
    """
    Maximum value for the gauge
    """

    color_mode: Literal["colormap", "gradient"] | None = None
    """
    Type of gradient to use for the gauge
    """

    color_map: Literal["red-yellow-green", "rainbow", "turbo"] | None = None
    """
    Preset gradients for the gauge
    """

    gradient: tuple[str, str] | None = None
    """
    Starting and ending color stops for custom gradient
    """

    reverse: bool | None = None
    """
    Reverse the colors of the gauge
    """

    reverse_direction: bool | None = None
    """
    Reverse the direction of the gauge (min on right, max on left)
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "path": self.path,
            "style": self.style,
            "minValue": self.min_value,
            "maxValue": self.max_value,
            "colorMode": self.color_mode,
            "colorMap": self.color_map,
            "gradient": self.gradient,
            "reverse": self.reverse,
            "reverseDirection": self.reverse_direction,
        }


@dataclass(kw_only=True)
class GaugePanel(BasePanel):
    """
    Display a colored gauge based on a continuous value.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/gauge).
    """

    config: GaugeConfig = field(default_factory=GaugeConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Gauge",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class TeleopButton(_BaseModel):
    """
    A button to teleoperate a robot
    """

    field: str | None = None
    """
    Field (linear or angular x, y, or z)
    """

    value: float | None = None
    """
    Value to publish when the button is pressed
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "field": self.field,
            "value": self.value,
        }


@dataclass(kw_only=True)
class TeleopConfig(_BaseModel):
    """
    Configuration for the Teleop panel.
    """

    topic: str | None = None
    """
    Topic on which to publish geometry_msgs/Twist or geometry_msgs/msg/Twist messages
    """

    publish_rate: float | None = None
    """
    Rate at which to publish geometry_msgs/Twist or geometry_msgs/msg/Twist messages
    """

    up_button: TeleopButton | None = None

    down_button: TeleopButton | None = None

    left_button: TeleopButton | None = None

    right_button: TeleopButton | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "topic": self.topic,
            "publishRate": self.publish_rate,
            "upButton": self.up_button,
            "downButton": self.down_button,
            "leftButton": self.left_button,
            "rightButton": self.right_button,
        }


@dataclass(kw_only=True)
class TeleopPanel(BasePanel):
    """
    Teleoperate a robot over a live connection.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/teleop).
    """

    config: TeleopConfig = field(default_factory=TeleopConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Teleop",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class MapTopicSettings(_BaseModel):
    """
    Settings for a topic displayed on the map.
    """

    history_mode: Literal["all", "none", "previous"] | None = None
    """
    Which messages to display when history (or future data via preloading) is available.
    """

    point_display_mode: Literal["dot", "pin"] | None = None
    """
    Configure GPS location display
    """

    point_size: float | None = None
    """
    Sets the diameter of points rendered on the map for this topic, in pixels
    """

    time_window_seconds: float | None = None
    """
    Time window in seconds for 'previous' mode sliding window. When left blank, shows all data from the beginning up to current playback time. When set, shows only the last N seconds of data.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "historyMode": self.history_mode,
            "pointDisplayMode": self.point_display_mode,
            "pointSize": self.point_size,
            "timeWindowSeconds": self.time_window_seconds,
        }


@dataclass(kw_only=True)
class MapLayerConfig(_BaseModel):
    """
    Configuration for a map layer displayed on top of the base map.
    """

    type: Literal[
        "street", "satellite", "custom", "shaded-relief", "seamark", "isobaths"
    ]
    """
    Type of map layer to display.
    """

    enabled: bool | None = True
    """
    Whether this layer is visible
    """

    opacity: float | None = 1
    """
    Opacity of the layer (0 to 1)
    """

    custom_tile_url: str | None = None
    """
    URL to custom map tiles when type is 'custom', following Tile Map Service specs
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": self.type,
            "enabled": self.enabled,
            "opacity": self.opacity,
            "customTileUrl": self.custom_tile_url,
        }


@dataclass(kw_only=True)
class MapConfig(_BaseModel):
    """
    Configuration for the Map panel.
    """

    custom_tile_url: str | None = None
    """
    URL to your custom map tiles following the Tile Map Service specs, e.g. https://my.custom.url/{x}/{y}/{z}.png
    """

    disabled_topics: list[str] | None = None
    """
    Topics to disable from being displayed on the map
    """

    follow_topic: str | None = None
    """
    Topic to follow in the panel viewport
    """

    follow_frame: str | None = None
    """
    The location fix to follow
    """

    layer: Literal["map", "satellite", "custom", "shaded-relief"] | None = None
    """
    Type of map to display
    """

    topic_colors: dict[str, str] | None = None
    """
    Colors for topics on the map
    """

    zoom_level: float | None = None
    """
    Zoom level of the map
    """

    max_native_zoom: float | None = None
    """
    Highest zoom supported by the custom map source
    """

    topic_config: dict[str, MapTopicSettings] | None = None
    """
    Configuration for topics on the map
    """

    layers: list[MapLayerConfig] | None = None
    """
    Additional layers displayed on top of the base map layer
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "customTileUrl": self.custom_tile_url,
            "disabledTopics": self.disabled_topics,
            "followTopic": self.follow_topic,
            "followFrame": self.follow_frame,
            "layer": self.layer,
            "topicColors": self.topic_colors,
            "zoomLevel": self.zoom_level,
            "maxNativeZoom": self.max_native_zoom,
            "topicConfig": self.topic_config,
            "layers": self.layers,
        }


@dataclass(kw_only=True)
class MapPanel(BasePanel):
    """
    Display points on a map.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/map).
    """

    config: MapConfig = field(default_factory=MapConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Map",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class ParametersPanel(BasePanel):
    """
    Read and set parameters for a data source.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/parameters).
    """

    config: Any | None = None

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Parameters",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class PublishConfig(_BaseModel):
    """
    Configuration for the Publish panel.
    """

    topic_name: str | None = None
    """
    Topic to publish to
    """

    datatype: str | None = None
    """
    Message schema to publish
    """

    button_text: str | None = None
    """
    Label for the button
    """

    button_tooltip: str | None = None
    """
    Tooltip for the button
    """

    button_color: str | None = None
    """
    Color of the button
    """

    advanced_view: bool | None = None
    """
    When enabled, editing the message is allowed and the content is displayed. When disabled, only the button is visible.
    """

    value: str | None = None
    """
    JSON blob to publish
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "topicName": self.topic_name,
            "datatype": self.datatype,
            "buttonText": self.button_text,
            "buttonTooltip": self.button_tooltip,
            "buttonColor": self.button_color,
            "advancedView": self.advanced_view,
            "value": self.value,
        }


@dataclass(kw_only=True)
class PublishPanel(BasePanel):
    """
    Publish messages to the data source (live connections only).

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/publish).
    """

    config: PublishConfig = field(default_factory=PublishConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Publish",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class ServiceCallConfig(_BaseModel):
    """
    Configuration for the Service Call panel.
    """

    service_name: str | None = None
    """
    Name of service to make a request to
    """

    request_payload: str | None = None
    """
    Request payload as JSON
    """

    layout: Literal["vertical", "horizontal"] | None = None
    """
    Positioning of request and response inputs
    """

    button_text: str | None = None
    """
    Label displayed on the button
    """

    button_tooltip: str | None = None
    """
    Text displayed when hovering over the button
    """

    button_color: str | None = None
    """
    Color of the button
    """

    editing_mode: bool | None = None
    """
    When enabled, editing the request is allowed and the response content is displayed. When disabled, only the button is visible.
    """

    timeout_seconds: float | None = None
    """
    Maximum time to wait for a response
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "serviceName": self.service_name,
            "requestPayload": self.request_payload,
            "layout": self.layout,
            "buttonText": self.button_text,
            "buttonTooltip": self.button_tooltip,
            "buttonColor": self.button_color,
            "editingMode": self.editing_mode,
            "timeoutSeconds": self.timeout_seconds,
        }


@dataclass(kw_only=True)
class ServiceCallPanel(BasePanel):
    """
    Call a service and view the service call result.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/service-call).
    """

    config: ServiceCallConfig = field(default_factory=ServiceCallConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "ServiceCall",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class RawMessagesConfig(_BaseModel):
    """
    Configuration for the Raw Messages panel.
    """

    diff_enabled: bool | None = None
    """
    Whether to enable diff mode
    """

    diff_method: Literal["custom", "previous message"] | None = None
    """
    Method to use for diffing
    """

    diff_topic_path: str | None = None
    """
    Topic path to use for diffing
    """

    expansion: Literal["all", "none"] | dict[str, Literal["c", "e"]] | None = None
    """
    Node expansion state. Can be 'all' (all nodes expanded), 'none' (all nodes collapsed), or a map of node paths to expansion states. In the map, keys are reversed node paths joined by '~', and values are 'c' (collapsed) or 'e' (expanded).
    """

    show_full_message_for_diff: bool | None = None
    """
    Whether to show the full message for diffing
    """

    topic_path: str | None = None
    """
    Message path to display
    """

    font_size: float | None = None
    """
    Font size for text display
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "diffEnabled": self.diff_enabled,
            "diffMethod": self.diff_method,
            "diffTopicPath": self.diff_topic_path,
            "expansion": self.expansion,
            "showFullMessageForDiff": self.show_full_message_for_diff,
            "topicPath": self.topic_path,
            "fontSize": self.font_size,
        }


@dataclass(kw_only=True)
class RawMessagesPanel(BasePanel):
    """
    Inspect topic messages.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/raw-messages).
    """

    config: RawMessagesConfig = field(default_factory=RawMessagesConfig)

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "RawMessages",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class LogNamespaceSettings(_BaseModel):
    """
    Settings for a namespace in the Log panel.
    """

    visible: bool | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "visible": self.visible,
        }


@dataclass(kw_only=True)
class LogConfig(_BaseModel):
    """
    Configuration for the Log panel.
    """

    search_terms: list[str] | None = None
    """
    Search terms to filter log messages
    """

    preload: bool | None = None
    """
    Attempt to preload logs for recorded sources. If the recording contains over 100,000 messages, fallback to live mode
    """

    min_log_level: float | None = None
    """
    Minimum severity of messages to display  always enforced, even if the node name is selected or the message text matches the search filter
    """

    topic_to_render: str | None = None
    """
    Topic to display log messages from
    """

    name_filter: dict[str, LogNamespaceSettings] | None = None
    """
    Settings for each namespace, indexed by name
    """

    font_size: float | None = None
    """
    Font size for text display
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "searchTerms": self.search_terms,
            "preload": self.preload,
            "minLogLevel": self.min_log_level,
            "topicToRender": self.topic_to_render,
            "nameFilter": self.name_filter,
            "fontSize": self.font_size,
        }


@dataclass(kw_only=True)
class LogPanel(BasePanel):
    """
    Display logs by node and severity level.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/log).
    """

    config: LogConfig = field(default_factory=LogConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Log",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class TableConfig(_BaseModel):
    """
    Configuration for the Table panel.
    """

    topic_path: str | None = None
    """
    Message path to display
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "topicPath": self.topic_path,
        }


@dataclass(kw_only=True)
class TablePanel(BasePanel):
    """
    Display topic messages in a tabular format.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/table).
    """

    config: TableConfig = field(default_factory=TableConfig)

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "Table",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class TopicGraphPanel(BasePanel):
    """
    Display a graph of active nodes, topics, and services.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/topic-graph).
    """

    config: Any | None = None

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "TopicGraph",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class DataSourceInfoPanel(BasePanel):
    """
    View details like topics and timestamps for the current data source.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/data-source-info).
    """

    config: Any | None = None

    title: Any | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "DataSourceInfo",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class VariableSliderProps(_BaseModel):
    """
    Settings for the slider
    """

    min: float | None = None
    """
    Minimum value of the slider
    """

    max: float | None = None
    """
    Maximum value of the slider
    """

    step: float | None = None
    """
    Size of each incremental step in the slider
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "min": self.min,
            "max": self.max,
            "step": self.step,
        }


@dataclass(kw_only=True)
class VariableSliderConfig(_BaseModel):
    """
    Configuration for the Variable Slider panel.
    """

    global_variable_name: str | None = None
    """
    Name of variable
    """

    slider_props: VariableSliderProps | None = None

    def _to_dict(self) -> dict[str, Any]:
        return {
            "globalVariableName": self.global_variable_name,
            "sliderProps": self.slider_props,
        }


@dataclass(kw_only=True)
class VariableSliderPanel(BasePanel):
    """
    Update numerical variable values for a layout.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/variable-slider).
    """

    config: VariableSliderConfig = field(default_factory=VariableSliderConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "VariableSlider",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class UserScriptsConfig(_BaseModel):
    """
    Configuration for the User Scripts panel.
    """

    selected_node_id: str | None = None
    """
    The ID of the selected script.
    """

    auto_format_on_save: bool | None = None
    """
    Whether to automatically format the code on save.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "selectedNodeId": self.selected_node_id,
            "autoFormatOnSave": self.auto_format_on_save,
        }


@dataclass(kw_only=True)
class UserScriptsPanel(BasePanel):
    """
    Write custom data transformations in TypeScript.

    For more information, see [the documentation](https://docs.foxglove.dev/docs/visualization/panels/user-scripts).
    """

    config: UserScriptsConfig = field(default_factory=UserScriptsConfig)

    title: str | None = None
    """
    The title of the panel.
    """

    def _to_dict(self) -> dict[str, Any]:
        return {
            "type": "panel",
            "panelType": "UserScripts",
            "config": self.config,
            "title": self.title,
            "version": 1,
        }


@dataclass(kw_only=True)
class Layout(_BaseModel):
    """
    A Foxglove layout, which describes the arrangement of panels and their configuration.
    """

    variables: Variables | None = None

    user_scripts: UserScripts | None = None

    content: Content

    def _to_dict(self) -> dict[str, Any]:
        return {
            "version": 1,
            "variables": self.variables,
            "userScripts": self.user_scripts,
            "content": self.content,
        }
