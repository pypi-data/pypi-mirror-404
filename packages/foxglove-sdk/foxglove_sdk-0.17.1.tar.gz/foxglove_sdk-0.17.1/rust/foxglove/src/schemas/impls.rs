// This file is @generated by foxglove_proto_gen
use crate::schemas::{descriptors, foxglove::*};
use crate::{Schema, Decode, Encode};
use bytes::BufMut;

#[cfg(feature = "derive")]
use prost::Message as _;
#[cfg(feature = "derive")]
use crate::protobuf::ProtobufField;

impl Encode for ArrowPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.ArrowPrimitive",
            "protobuf",
            descriptors::ARROW_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for ArrowPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for ArrowPrimitive {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.ArrowPrimitive".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::ARROW_PRIMITIVE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for CameraCalibration {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CameraCalibration",
            "protobuf",
            descriptors::CAMERA_CALIBRATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CameraCalibration {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for CameraCalibration {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.CameraCalibration".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::CAMERA_CALIBRATION)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for CircleAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CircleAnnotation",
            "protobuf",
            descriptors::CIRCLE_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CircleAnnotation {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for CircleAnnotation {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.CircleAnnotation".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::CIRCLE_ANNOTATION)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Color {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Color",
            "protobuf",
            descriptors::COLOR,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Color {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Color {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Color".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::COLOR)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for CompressedImage {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CompressedImage",
            "protobuf",
            descriptors::COMPRESSED_IMAGE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CompressedImage {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for CompressedImage {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.CompressedImage".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::COMPRESSED_IMAGE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for CompressedVideo {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CompressedVideo",
            "protobuf",
            descriptors::COMPRESSED_VIDEO,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CompressedVideo {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for CompressedVideo {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.CompressedVideo".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::COMPRESSED_VIDEO)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for CubePrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CubePrimitive",
            "protobuf",
            descriptors::CUBE_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CubePrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for CubePrimitive {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.CubePrimitive".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::CUBE_PRIMITIVE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for CylinderPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.CylinderPrimitive",
            "protobuf",
            descriptors::CYLINDER_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for CylinderPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for CylinderPrimitive {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.CylinderPrimitive".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::CYLINDER_PRIMITIVE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for FrameTransform {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.FrameTransform",
            "protobuf",
            descriptors::FRAME_TRANSFORM,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for FrameTransform {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for FrameTransform {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.FrameTransform".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::FRAME_TRANSFORM)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for FrameTransforms {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.FrameTransforms",
            "protobuf",
            descriptors::FRAME_TRANSFORMS,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for FrameTransforms {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for FrameTransforms {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.FrameTransforms".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::FRAME_TRANSFORMS)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for GeoJson {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.GeoJSON",
            "protobuf",
            descriptors::GEO_JSON,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for GeoJson {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for GeoJson {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.GeoJSON".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::GEO_JSON)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Grid {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Grid",
            "protobuf",
            descriptors::GRID,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Grid {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Grid {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Grid".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::GRID)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for ImageAnnotations {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.ImageAnnotations",
            "protobuf",
            descriptors::IMAGE_ANNOTATIONS,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for ImageAnnotations {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for ImageAnnotations {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.ImageAnnotations".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::IMAGE_ANNOTATIONS)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for KeyValuePair {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.KeyValuePair",
            "protobuf",
            descriptors::KEY_VALUE_PAIR,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for KeyValuePair {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for KeyValuePair {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.KeyValuePair".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::KEY_VALUE_PAIR)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for LaserScan {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LaserScan",
            "protobuf",
            descriptors::LASER_SCAN,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for LaserScan {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for LaserScan {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.LaserScan".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::LASER_SCAN)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for LinePrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LinePrimitive",
            "protobuf",
            descriptors::LINE_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for LinePrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for LinePrimitive {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.LinePrimitive".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::LINE_PRIMITIVE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for LocationFix {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LocationFix",
            "protobuf",
            descriptors::LOCATION_FIX,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for LocationFix {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for LocationFix {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.LocationFix".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::LOCATION_FIX)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for LocationFixes {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.LocationFixes",
            "protobuf",
            descriptors::LOCATION_FIXES,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for LocationFixes {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for LocationFixes {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.LocationFixes".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::LOCATION_FIXES)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Log {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Log",
            "protobuf",
            descriptors::LOG,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Log {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Log {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Log".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::LOG)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for ModelPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.ModelPrimitive",
            "protobuf",
            descriptors::MODEL_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for ModelPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for ModelPrimitive {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.ModelPrimitive".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::MODEL_PRIMITIVE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for PackedElementField {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PackedElementField",
            "protobuf",
            descriptors::PACKED_ELEMENT_FIELD,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PackedElementField {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for PackedElementField {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.PackedElementField".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::PACKED_ELEMENT_FIELD)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Point2 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Point2",
            "protobuf",
            descriptors::POINT2,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Point2 {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Point2 {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Point2".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::POINT2)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Point3 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Point3",
            "protobuf",
            descriptors::POINT3,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Point3 {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Point3 {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Point3".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::POINT3)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Point3InFrame {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Point3InFrame",
            "protobuf",
            descriptors::POINT3_IN_FRAME,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Point3InFrame {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Point3InFrame {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Point3InFrame".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::POINT3_IN_FRAME)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for PointCloud {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PointCloud",
            "protobuf",
            descriptors::POINT_CLOUD,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PointCloud {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for PointCloud {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.PointCloud".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::POINT_CLOUD)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for PointsAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PointsAnnotation",
            "protobuf",
            descriptors::POINTS_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PointsAnnotation {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for PointsAnnotation {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.PointsAnnotation".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::POINTS_ANNOTATION)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Pose {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Pose",
            "protobuf",
            descriptors::POSE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Pose {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Pose {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Pose".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::POSE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for PoseInFrame {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PoseInFrame",
            "protobuf",
            descriptors::POSE_IN_FRAME,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PoseInFrame {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for PoseInFrame {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.PoseInFrame".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::POSE_IN_FRAME)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for PosesInFrame {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.PosesInFrame",
            "protobuf",
            descriptors::POSES_IN_FRAME,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for PosesInFrame {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for PosesInFrame {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.PosesInFrame".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::POSES_IN_FRAME)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Quaternion {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Quaternion",
            "protobuf",
            descriptors::QUATERNION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Quaternion {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Quaternion {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Quaternion".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::QUATERNION)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for RawAudio {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.RawAudio",
            "protobuf",
            descriptors::RAW_AUDIO,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for RawAudio {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for RawAudio {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.RawAudio".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::RAW_AUDIO)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for RawImage {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.RawImage",
            "protobuf",
            descriptors::RAW_IMAGE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for RawImage {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for RawImage {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.RawImage".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::RAW_IMAGE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for SceneEntity {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneEntity",
            "protobuf",
            descriptors::SCENE_ENTITY,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for SceneEntity {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for SceneEntity {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.SceneEntity".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::SCENE_ENTITY)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for SceneEntityDeletion {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneEntityDeletion",
            "protobuf",
            descriptors::SCENE_ENTITY_DELETION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for SceneEntityDeletion {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for SceneEntityDeletion {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.SceneEntityDeletion".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::SCENE_ENTITY_DELETION)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for SceneUpdate {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SceneUpdate",
            "protobuf",
            descriptors::SCENE_UPDATE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for SceneUpdate {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for SceneUpdate {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.SceneUpdate".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::SCENE_UPDATE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for SpherePrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.SpherePrimitive",
            "protobuf",
            descriptors::SPHERE_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for SpherePrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for SpherePrimitive {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.SpherePrimitive".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::SPHERE_PRIMITIVE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for TextAnnotation {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.TextAnnotation",
            "protobuf",
            descriptors::TEXT_ANNOTATION,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for TextAnnotation {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for TextAnnotation {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.TextAnnotation".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::TEXT_ANNOTATION)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for TextPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.TextPrimitive",
            "protobuf",
            descriptors::TEXT_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for TextPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for TextPrimitive {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.TextPrimitive".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::TEXT_PRIMITIVE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for TriangleListPrimitive {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.TriangleListPrimitive",
            "protobuf",
            descriptors::TRIANGLE_LIST_PRIMITIVE,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for TriangleListPrimitive {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for TriangleListPrimitive {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.TriangleListPrimitive".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::TRIANGLE_LIST_PRIMITIVE)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Vector2 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Vector2",
            "protobuf",
            descriptors::VECTOR2,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Vector2 {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Vector2 {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Vector2".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::VECTOR2)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for Vector3 {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.Vector3",
            "protobuf",
            descriptors::VECTOR3,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for Vector3 {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for Vector3 {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.Vector3".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::VECTOR3)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}

impl Encode for VoxelGrid {
    type Error = ::prost::EncodeError;

    fn get_schema() -> Option<Schema> {
        Some(Schema::new(
            "foxglove.VoxelGrid",
            "protobuf",
            descriptors::VOXEL_GRID,
        ))
    }

    fn get_message_encoding() -> String {
        "protobuf".to_string()
    }

    fn encode(&self, buf: &mut impl BufMut) -> Result<(), prost::EncodeError> {
        ::prost::Message::encode(self, buf)
    }

    fn encoded_len(&self) -> Option<usize> { Some(::prost::Message::encoded_len(self)) }
}

#[doc(hidden)]
impl Decode for VoxelGrid {
    type Error = ::prost::DecodeError;

    /// Decode a message from a serialized buffer.
    fn decode(buf: impl bytes::Buf) -> Result<Self, ::prost::DecodeError> {
        ::prost::Message::decode(buf)
    }
}

#[cfg(feature = "derive")]
impl ProtobufField for VoxelGrid {
    fn field_type() -> ::prost_types::field_descriptor_proto::Type {
        ::prost_types::field_descriptor_proto::Type::Message
    }

    fn wire_type() -> u32 {
        ::prost::encoding::WireType::LengthDelimited as u32
    }

    fn write(&self, buf: &mut impl BufMut) {
        let len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encode_varint(len as u64, buf);
        ::prost::Message::encode_raw(self, buf);
    }

    fn type_name() -> Option<String> {
        Some(".foxglove.VoxelGrid".to_string())
    }

    fn file_descriptors() -> Vec<::prost_types::FileDescriptorProto> {
        let fds = ::prost_types::FileDescriptorSet::decode(descriptors::VOXEL_GRID)
            .expect("invalid file descriptor set");
        fds.file
    }

    fn encoded_len(&self) -> usize {
        let inner_len = ::prost::Message::encoded_len(self);
        ::prost::encoding::encoded_len_varint(inner_len as u64) + inner_len
    }
}
