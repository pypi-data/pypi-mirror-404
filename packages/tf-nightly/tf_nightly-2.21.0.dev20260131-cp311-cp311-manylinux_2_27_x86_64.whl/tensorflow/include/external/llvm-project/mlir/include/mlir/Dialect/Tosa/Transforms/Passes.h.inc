/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_TOSAARITHCONSTANTTOTOSACONSTPASS
#define GEN_PASS_DECL_TOSAATTACHTARGET
#define GEN_PASS_DECL_TOSACONVERTINTEGERTYPETOSIGNLESS
#define GEN_PASS_DECL_TOSAINFERSHAPESPASS
#define GEN_PASS_DECL_TOSAINPUTSHAPE
#define GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#define GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#define GEN_PASS_DECL_TOSANARROWF64TOF32PASS
#define GEN_PASS_DECL_TOSANARROWI64TOI32PASS
#define GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#define GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#define GEN_PASS_DECL_TOSAVALIDATION
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// TosaArithConstantToTosaConstPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAARITHCONSTANTTOTOSACONSTPASS
std::unique_ptr<::mlir::Pass> createTosaArithConstantToTosaConstPass();
#undef GEN_PASS_DECL_TOSAARITHCONSTANTTOTOSACONSTPASS
#endif // GEN_PASS_DECL_TOSAARITHCONSTANTTOTOSACONSTPASS
#ifdef GEN_PASS_DEF_TOSAARITHCONSTANTTOTOSACONSTPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaArithConstantToTosaConstPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaArithConstantToTosaConstPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaArithConstantToTosaConstPassBase;

  TosaArithConstantToTosaConstPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaArithConstantToTosaConstPassBase(const TosaArithConstantToTosaConstPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaArithConstantToTosaConstPassBase& operator=(const TosaArithConstantToTosaConstPassBase &) = delete;
  TosaArithConstantToTosaConstPassBase(TosaArithConstantToTosaConstPassBase &&) = delete;
  TosaArithConstantToTosaConstPassBase& operator=(TosaArithConstantToTosaConstPassBase &&) = delete;
  ~TosaArithConstantToTosaConstPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-arith-const-to-tosa-const");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-arith-const-to-tosa-const"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert tensor arith.constant operations into tosa.const)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaArithConstantToTosaConstPass");
  }
  ::llvm::StringRef getName() const override { return "TosaArithConstantToTosaConstPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaArithConstantToTosaConstPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaArithConstantToTosaConstPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaArithConstantToTosaConstPass() {
  return impl::createTosaArithConstantToTosaConstPass();
}
#undef GEN_PASS_DEF_TOSAARITHCONSTANTTOTOSACONSTPASS
#endif // GEN_PASS_DEF_TOSAARITHCONSTANTTOTOSACONSTPASS

//===----------------------------------------------------------------------===//
// TosaAttachTarget
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAATTACHTARGET
struct TosaAttachTargetOptions {
  mlir::tosa::SpecificationVersion specificationVersion = mlir::tosa::SpecificationVersion::V_1_0;
  mlir::tosa::Level level = mlir::tosa::Level::eightK;
  ::llvm::SmallVector<std::string> profiles;
  ::llvm::SmallVector<std::string> extensions;
};
std::unique_ptr<::mlir::Pass> createTosaAttachTarget();
std::unique_ptr<::mlir::Pass> createTosaAttachTarget(TosaAttachTargetOptions options);
#undef GEN_PASS_DECL_TOSAATTACHTARGET
#endif // GEN_PASS_DECL_TOSAATTACHTARGET
#ifdef GEN_PASS_DEF_TOSAATTACHTARGET

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaAttachTarget();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaAttachTarget(TosaAttachTargetOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaAttachTargetBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = TosaAttachTargetBase;

  TosaAttachTargetBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaAttachTargetBase(const TosaAttachTargetBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}
  TosaAttachTargetBase& operator=(const TosaAttachTargetBase &) = delete;
  TosaAttachTargetBase(TosaAttachTargetBase &&) = delete;
  TosaAttachTargetBase& operator=(TosaAttachTargetBase &&) = delete;
  ~TosaAttachTargetBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-attach-target");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-attach-target"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Attach tosa.target_env information to the given module.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaAttachTarget");
  }
  ::llvm::StringRef getName() const override { return "TosaAttachTarget"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaAttachTargetBase<DerivedT>)

  TosaAttachTargetBase(TosaAttachTargetOptions options) : TosaAttachTargetBase() {
    specificationVersion = std::move(options.specificationVersion);
    level = std::move(options.level);
    profiles = std::move(options.profiles);
    extensions = std::move(options.extensions);
  }
protected:
  ::mlir::Pass::Option<mlir::tosa::SpecificationVersion> specificationVersion{*this, "specification_version", ::llvm::cl::desc(R"PO(The specification version that TOSA operators should conform to.)PO"), ::llvm::cl::init(mlir::tosa::SpecificationVersion::V_1_0), ::llvm::cl::values(
                clEnumValN(mlir::tosa::SpecificationVersion::V_1_0, "1.0", "TOSA Specification version 1.0"),
                clEnumValN(mlir::tosa::SpecificationVersion::V_1_1_DRAFT, "1.1.draft", "TOSA Specification version 1.1.draft")
              )};
  ::mlir::Pass::Option<mlir::tosa::Level> level{*this, "level", ::llvm::cl::desc(R"PO(The TOSA level that operators should conform to. A TOSA level defines operator argument ranges that an implementation shall support.)PO"), ::llvm::cl::init(mlir::tosa::Level::eightK), ::llvm::cl::values(
                clEnumValN(mlir::tosa::Level::eightK, "8k",
                  "Ranges are expected to be sufficient for applications with frame "
                  "sizes up to 8K."),
                clEnumValN(mlir::tosa::Level::none, "none",
                  "Allows the full range of arguments specified by the operations according "
                  "to the operation data types.")
                )};
  ::mlir::Pass::ListOption<std::string> profiles{*this, "profiles", ::llvm::cl::desc(R"PO(The TOSA profile(s) that operators should conform to. TOSA profiles enable efficient implementation on different classes of device. Each profile is an independent set of operations and data type combinations.)PO")};
  ::mlir::Pass::ListOption<std::string> extensions{*this, "extensions", ::llvm::cl::desc(R"PO(The TOSA extension(s) that operators should conform to. TOSA profile extensions define optional operation and data type combinations.)PO")};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaAttachTarget() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaAttachTarget(TosaAttachTargetOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaAttachTarget() {
  return impl::createTosaAttachTarget();
}

std::unique_ptr<::mlir::Pass> createTosaAttachTarget(TosaAttachTargetOptions options) {
  return impl::createTosaAttachTarget(std::move(options));
}
#undef GEN_PASS_DEF_TOSAATTACHTARGET
#endif // GEN_PASS_DEF_TOSAATTACHTARGET

//===----------------------------------------------------------------------===//
// TosaConvertIntegerTypeToSignless
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSACONVERTINTEGERTYPETOSIGNLESS
std::unique_ptr<::mlir::Pass> createTosaConvertIntegerTypeToSignless();
#undef GEN_PASS_DECL_TOSACONVERTINTEGERTYPETOSIGNLESS
#endif // GEN_PASS_DECL_TOSACONVERTINTEGERTYPETOSIGNLESS
#ifdef GEN_PASS_DEF_TOSACONVERTINTEGERTYPETOSIGNLESS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaConvertIntegerTypeToSignless();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaConvertIntegerTypeToSignlessBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaConvertIntegerTypeToSignlessBase;

  TosaConvertIntegerTypeToSignlessBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaConvertIntegerTypeToSignlessBase(const TosaConvertIntegerTypeToSignlessBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaConvertIntegerTypeToSignlessBase& operator=(const TosaConvertIntegerTypeToSignlessBase &) = delete;
  TosaConvertIntegerTypeToSignlessBase(TosaConvertIntegerTypeToSignlessBase &&) = delete;
  TosaConvertIntegerTypeToSignlessBase& operator=(TosaConvertIntegerTypeToSignlessBase &&) = delete;
  ~TosaConvertIntegerTypeToSignlessBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-convert-integer-type-to-signless");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-convert-integer-type-to-signless"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert integer types to signless)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaConvertIntegerTypeToSignless");
  }
  ::llvm::StringRef getName() const override { return "TosaConvertIntegerTypeToSignless"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaConvertIntegerTypeToSignlessBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaConvertIntegerTypeToSignless() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaConvertIntegerTypeToSignless() {
  return impl::createTosaConvertIntegerTypeToSignless();
}
#undef GEN_PASS_DEF_TOSACONVERTINTEGERTYPETOSIGNLESS
#endif // GEN_PASS_DEF_TOSACONVERTINTEGERTYPETOSIGNLESS

//===----------------------------------------------------------------------===//
// TosaInferShapesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAINFERSHAPESPASS
std::unique_ptr<::mlir::Pass> createTosaInferShapesPass();
#undef GEN_PASS_DECL_TOSAINFERSHAPESPASS
#endif // GEN_PASS_DECL_TOSAINFERSHAPESPASS
#ifdef GEN_PASS_DEF_TOSAINFERSHAPESPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaInferShapesPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaInferShapesPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaInferShapesPassBase;

  TosaInferShapesPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaInferShapesPassBase(const TosaInferShapesPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaInferShapesPassBase& operator=(const TosaInferShapesPassBase &) = delete;
  TosaInferShapesPassBase(TosaInferShapesPassBase &&) = delete;
  TosaInferShapesPassBase& operator=(TosaInferShapesPassBase &&) = delete;
  ~TosaInferShapesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-infer-shapes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-infer-shapes"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Propagate shapes across TOSA operations)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaInferShapesPass");
  }
  ::llvm::StringRef getName() const override { return "TosaInferShapesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tensor::TensorDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaInferShapesPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaInferShapesPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaInferShapesPass() {
  return impl::createTosaInferShapesPass();
}
#undef GEN_PASS_DEF_TOSAINFERSHAPESPASS
#endif // GEN_PASS_DEF_TOSAINFERSHAPESPASS

//===----------------------------------------------------------------------===//
// TosaInputShape
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAINPUTSHAPE
struct TosaInputShapeOptions {
  ::llvm::SmallVector<std::string> args;
};
#undef GEN_PASS_DECL_TOSAINPUTSHAPE
#endif // GEN_PASS_DECL_TOSAINPUTSHAPE
#ifdef GEN_PASS_DEF_TOSAINPUTSHAPE
namespace impl {

template <typename DerivedT>
class TosaInputShapeBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaInputShapeBase;

  TosaInputShapeBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaInputShapeBase(const TosaInputShapeBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaInputShapeBase& operator=(const TosaInputShapeBase &) = delete;
  TosaInputShapeBase(TosaInputShapeBase &&) = delete;
  TosaInputShapeBase& operator=(TosaInputShapeBase &&) = delete;
  ~TosaInputShapeBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-experimental-input-shape");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-experimental-input-shape"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Override dynamic function arguments to specified static shapes.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaInputShape");
  }
  ::llvm::StringRef getName() const override { return "TosaInputShape"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaInputShapeBase<DerivedT>)

  TosaInputShapeBase(TosaInputShapeOptions options) : TosaInputShapeBase() {
    args = std::move(options.args);
  }
protected:
  ::mlir::Pass::ListOption<std::string> args{*this, "args", ::llvm::cl::desc(R"PO(Comma-separated list of shape descriptions. Each description contains the argument name, a colon, and a shape with dimensions separated by x)PO")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TOSAINPUTSHAPE
#endif // GEN_PASS_DEF_TOSAINPUTSHAPE

//===----------------------------------------------------------------------===//
// TosaLayerwiseConstantFoldPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
struct TosaLayerwiseConstantFoldPassOptions {
  bool aggressiveReduceConstant = false;
};
std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass();
std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options);
#undef GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#endif // GEN_PASS_DECL_TOSALAYERWISECONSTANTFOLDPASS
#ifdef GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaLayerwiseConstantFoldPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaLayerwiseConstantFoldPassBase;

  TosaLayerwiseConstantFoldPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaLayerwiseConstantFoldPassBase(const TosaLayerwiseConstantFoldPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaLayerwiseConstantFoldPassBase& operator=(const TosaLayerwiseConstantFoldPassBase &) = delete;
  TosaLayerwiseConstantFoldPassBase(TosaLayerwiseConstantFoldPassBase &&) = delete;
  TosaLayerwiseConstantFoldPassBase& operator=(TosaLayerwiseConstantFoldPassBase &&) = delete;
  ~TosaLayerwiseConstantFoldPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-layerwise-constant-fold");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-layerwise-constant-fold"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Fold layerwise operations on constant tensors)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaLayerwiseConstantFoldPass");
  }
  ::llvm::StringRef getName() const override { return "TosaLayerwiseConstantFoldPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaLayerwiseConstantFoldPassBase<DerivedT>)

  TosaLayerwiseConstantFoldPassBase(TosaLayerwiseConstantFoldPassOptions options) : TosaLayerwiseConstantFoldPassBase() {
    aggressiveReduceConstant = std::move(options.aggressiveReduceConstant);
  }
protected:
  ::mlir::Pass::Option<bool> aggressiveReduceConstant{*this, "aggressive-reduce-constant", ::llvm::cl::desc(R"PO(Always perform the reduce constant optimizationMay add more tosa.const but would reduce runtime calculations)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass() {
  return impl::createTosaLayerwiseConstantFoldPass();
}

std::unique_ptr<::mlir::Pass> createTosaLayerwiseConstantFoldPass(TosaLayerwiseConstantFoldPassOptions options) {
  return impl::createTosaLayerwiseConstantFoldPass(std::move(options));
}
#undef GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS
#endif // GEN_PASS_DEF_TOSALAYERWISECONSTANTFOLDPASS

//===----------------------------------------------------------------------===//
// TosaMakeBroadcastablePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass();
#undef GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#endif // GEN_PASS_DECL_TOSAMAKEBROADCASTABLEPASS
#ifdef GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaMakeBroadcastablePassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaMakeBroadcastablePassBase;

  TosaMakeBroadcastablePassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaMakeBroadcastablePassBase(const TosaMakeBroadcastablePassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaMakeBroadcastablePassBase& operator=(const TosaMakeBroadcastablePassBase &) = delete;
  TosaMakeBroadcastablePassBase(TosaMakeBroadcastablePassBase &&) = delete;
  TosaMakeBroadcastablePassBase& operator=(TosaMakeBroadcastablePassBase &&) = delete;
  ~TosaMakeBroadcastablePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-make-broadcastable");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-make-broadcastable"; }

  ::llvm::StringRef getDescription() const override { return R"PD(TOSA rank Reshape to enable Broadcasting)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaMakeBroadcastablePass");
  }
  ::llvm::StringRef getName() const override { return "TosaMakeBroadcastablePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaMakeBroadcastablePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaMakeBroadcastablePass() {
  return impl::createTosaMakeBroadcastablePass();
}
#undef GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS
#endif // GEN_PASS_DEF_TOSAMAKEBROADCASTABLEPASS

//===----------------------------------------------------------------------===//
// TosaNarrowF64ToF32Pass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSANARROWF64TOF32PASS
struct TosaNarrowF64ToF32PassOptions {
  bool aggressiveRewrite = false;
  bool convertFunctionBoundaries = false;
};
std::unique_ptr<::mlir::Pass> createTosaNarrowF64ToF32Pass();
std::unique_ptr<::mlir::Pass> createTosaNarrowF64ToF32Pass(TosaNarrowF64ToF32PassOptions options);
#undef GEN_PASS_DECL_TOSANARROWF64TOF32PASS
#endif // GEN_PASS_DECL_TOSANARROWF64TOF32PASS
#ifdef GEN_PASS_DEF_TOSANARROWF64TOF32PASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaNarrowF64ToF32Pass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaNarrowF64ToF32Pass(TosaNarrowF64ToF32PassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaNarrowF64ToF32PassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaNarrowF64ToF32PassBase;

  TosaNarrowF64ToF32PassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaNarrowF64ToF32PassBase(const TosaNarrowF64ToF32PassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaNarrowF64ToF32PassBase& operator=(const TosaNarrowF64ToF32PassBase &) = delete;
  TosaNarrowF64ToF32PassBase(TosaNarrowF64ToF32PassBase &&) = delete;
  TosaNarrowF64ToF32PassBase& operator=(TosaNarrowF64ToF32PassBase &&) = delete;
  ~TosaNarrowF64ToF32PassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-narrow-f64-to-f32");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-narrow-f64-to-f32"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Narrow F64 TOSA operations to F32)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaNarrowF64ToF32Pass");
  }
  ::llvm::StringRef getName() const override { return "TosaNarrowF64ToF32Pass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaNarrowF64ToF32PassBase<DerivedT>)

  TosaNarrowF64ToF32PassBase(TosaNarrowF64ToF32PassOptions options) : TosaNarrowF64ToF32PassBase() {
    aggressiveRewrite = std::move(options.aggressiveRewrite);
    convertFunctionBoundaries = std::move(options.convertFunctionBoundaries);
  }
protected:
  ::mlir::Pass::Option<bool> aggressiveRewrite{*this, "aggressive-rewrite", ::llvm::cl::desc(R"PO(If enabled, all TOSA operations are rewritten, regardless or whether the narrowingis safe. This option may lead to data loss if not used carefully.)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> convertFunctionBoundaries{*this, "convert-function-boundaries", ::llvm::cl::desc(R"PO(If enabled, the pass will convert function I/O types as well. Otherwise casts willbe inserted at the I/O boundaries.)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaNarrowF64ToF32Pass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaNarrowF64ToF32Pass(TosaNarrowF64ToF32PassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaNarrowF64ToF32Pass() {
  return impl::createTosaNarrowF64ToF32Pass();
}

std::unique_ptr<::mlir::Pass> createTosaNarrowF64ToF32Pass(TosaNarrowF64ToF32PassOptions options) {
  return impl::createTosaNarrowF64ToF32Pass(std::move(options));
}
#undef GEN_PASS_DEF_TOSANARROWF64TOF32PASS
#endif // GEN_PASS_DEF_TOSANARROWF64TOF32PASS

//===----------------------------------------------------------------------===//
// TosaNarrowI64ToI32Pass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSANARROWI64TOI32PASS
struct TosaNarrowI64ToI32PassOptions {
  bool aggressiveRewrite = false;
  bool convertFunctionBoundaries = false;
};
std::unique_ptr<::mlir::Pass> createTosaNarrowI64ToI32Pass();
std::unique_ptr<::mlir::Pass> createTosaNarrowI64ToI32Pass(TosaNarrowI64ToI32PassOptions options);
#undef GEN_PASS_DECL_TOSANARROWI64TOI32PASS
#endif // GEN_PASS_DECL_TOSANARROWI64TOI32PASS
#ifdef GEN_PASS_DEF_TOSANARROWI64TOI32PASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaNarrowI64ToI32Pass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaNarrowI64ToI32Pass(TosaNarrowI64ToI32PassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaNarrowI64ToI32PassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaNarrowI64ToI32PassBase;

  TosaNarrowI64ToI32PassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaNarrowI64ToI32PassBase(const TosaNarrowI64ToI32PassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaNarrowI64ToI32PassBase& operator=(const TosaNarrowI64ToI32PassBase &) = delete;
  TosaNarrowI64ToI32PassBase(TosaNarrowI64ToI32PassBase &&) = delete;
  TosaNarrowI64ToI32PassBase& operator=(TosaNarrowI64ToI32PassBase &&) = delete;
  ~TosaNarrowI64ToI32PassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-narrow-i64-to-i32");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-narrow-i64-to-i32"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Narrow I64 TOSA operations to I32)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaNarrowI64ToI32Pass");
  }
  ::llvm::StringRef getName() const override { return "TosaNarrowI64ToI32Pass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<func::FuncDialect>();
    registry.insert<tosa::TosaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaNarrowI64ToI32PassBase<DerivedT>)

  TosaNarrowI64ToI32PassBase(TosaNarrowI64ToI32PassOptions options) : TosaNarrowI64ToI32PassBase() {
    aggressiveRewrite = std::move(options.aggressiveRewrite);
    convertFunctionBoundaries = std::move(options.convertFunctionBoundaries);
  }
protected:
  ::mlir::Pass::Option<bool> aggressiveRewrite{*this, "aggressive-rewrite", ::llvm::cl::desc(R"PO(If enabled, all TOSA operations are rewritten, regardless or whether the narrowingis safe. This option may lead to data loss if not used carefully.)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> convertFunctionBoundaries{*this, "convert-function-boundaries", ::llvm::cl::desc(R"PO(If enabled, the pass will convert function I/O types as well. Otherwise casts willbe inserted at the I/O boundaries.)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaNarrowI64ToI32Pass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaNarrowI64ToI32Pass(TosaNarrowI64ToI32PassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaNarrowI64ToI32Pass() {
  return impl::createTosaNarrowI64ToI32Pass();
}

std::unique_ptr<::mlir::Pass> createTosaNarrowI64ToI32Pass(TosaNarrowI64ToI32PassOptions options) {
  return impl::createTosaNarrowI64ToI32Pass(std::move(options));
}
#undef GEN_PASS_DEF_TOSANARROWI64TOI32PASS
#endif // GEN_PASS_DEF_TOSANARROWI64TOI32PASS

//===----------------------------------------------------------------------===//
// TosaOptionalDecompositionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass();
#undef GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#endif // GEN_PASS_DECL_TOSAOPTIONALDECOMPOSITIONSPASS
#ifdef GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaOptionalDecompositionsPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaOptionalDecompositionsPassBase;

  TosaOptionalDecompositionsPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaOptionalDecompositionsPassBase(const TosaOptionalDecompositionsPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaOptionalDecompositionsPassBase& operator=(const TosaOptionalDecompositionsPassBase &) = delete;
  TosaOptionalDecompositionsPassBase(TosaOptionalDecompositionsPassBase &&) = delete;
  TosaOptionalDecompositionsPassBase& operator=(TosaOptionalDecompositionsPassBase &&) = delete;
  ~TosaOptionalDecompositionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-optional-decompositions");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-optional-decompositions"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Applies Tosa operations optional decompositions)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaOptionalDecompositionsPass");
  }
  ::llvm::StringRef getName() const override { return "TosaOptionalDecompositionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaOptionalDecompositionsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaOptionalDecompositionsPass() {
  return impl::createTosaOptionalDecompositionsPass();
}
#undef GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS
#endif // GEN_PASS_DEF_TOSAOPTIONALDECOMPOSITIONSPASS

//===----------------------------------------------------------------------===//
// TosaReduceTransposes
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAREDUCETRANSPOSES
std::unique_ptr<::mlir::Pass> createTosaReduceTransposes();
#undef GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#endif // GEN_PASS_DECL_TOSAREDUCETRANSPOSES
#ifdef GEN_PASS_DEF_TOSAREDUCETRANSPOSES

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaReduceTransposes();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaReduceTransposesBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaReduceTransposesBase;

  TosaReduceTransposesBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaReduceTransposesBase(const TosaReduceTransposesBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}
  TosaReduceTransposesBase& operator=(const TosaReduceTransposesBase &) = delete;
  TosaReduceTransposesBase(TosaReduceTransposesBase &&) = delete;
  TosaReduceTransposesBase& operator=(TosaReduceTransposesBase &&) = delete;
  ~TosaReduceTransposesBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-reduce-transposes");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-reduce-transposes"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Reduce transposes through other operators)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaReduceTransposes");
  }
  ::llvm::StringRef getName() const override { return "TosaReduceTransposes"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaReduceTransposesBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaReduceTransposes() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaReduceTransposes() {
  return impl::createTosaReduceTransposes();
}
#undef GEN_PASS_DEF_TOSAREDUCETRANSPOSES
#endif // GEN_PASS_DEF_TOSAREDUCETRANSPOSES

//===----------------------------------------------------------------------===//
// TosaValidation
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSAVALIDATION
struct TosaValidationOptions {
  bool strictOpSpecAlignment = false;
  bool allowInvalidOpDatatypeCombinations = false;
};
std::unique_ptr<::mlir::Pass> createTosaValidation();
std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options);
#undef GEN_PASS_DECL_TOSAVALIDATION
#endif // GEN_PASS_DECL_TOSAVALIDATION
#ifdef GEN_PASS_DEF_TOSAVALIDATION

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaValidation();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaValidationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TosaValidationBase;

  TosaValidationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaValidationBase(const TosaValidationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TosaValidationBase& operator=(const TosaValidationBase &) = delete;
  TosaValidationBase(TosaValidationBase &&) = delete;
  TosaValidationBase& operator=(TosaValidationBase &&) = delete;
  ~TosaValidationBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-validate");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-validate"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Validates TOSA dialect)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaValidation");
  }
  ::llvm::StringRef getName() const override { return "TosaValidation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaValidationBase<DerivedT>)

  TosaValidationBase(TosaValidationOptions options) : TosaValidationBase() {
    strictOpSpecAlignment = std::move(options.strictOpSpecAlignment);
    allowInvalidOpDatatypeCombinations = std::move(options.allowInvalidOpDatatypeCombinations);
  }
protected:
  ::mlir::Pass::Option<bool> strictOpSpecAlignment{*this, "strict-op-spec-alignment", ::llvm::cl::desc(R"PO(Verify if the properties of certain operations align the spec requirement)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> allowInvalidOpDatatypeCombinations{*this, "allow-invalid-op-datatype-combinations", ::llvm::cl::desc(R"PO(Disable checks for operations that are determined to be invalid due to their operand/result datatypes not aligning with the 'Supported Data Types' sections of the specifciation)PO"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createTosaValidation() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaValidation() {
  return impl::createTosaValidation();
}

std::unique_ptr<::mlir::Pass> createTosaValidation(TosaValidationOptions options) {
  return impl::createTosaValidation(std::move(options));
}
#undef GEN_PASS_DEF_TOSAVALIDATION
#endif // GEN_PASS_DEF_TOSAVALIDATION
#ifdef GEN_PASS_REGISTRATION
// Generate registrations for all passes.
#define GEN_PASS_REGISTRATION_TOSAARITHCONSTANTTOTOSACONSTPASS
#define GEN_PASS_REGISTRATION_TOSAATTACHTARGET
#define GEN_PASS_REGISTRATION_TOSACONVERTINTEGERTYPETOSIGNLESS
#define GEN_PASS_REGISTRATION_TOSAINFERSHAPESPASS
#define GEN_PASS_REGISTRATION_TOSAINPUTSHAPE
#define GEN_PASS_REGISTRATION_TOSALAYERWISECONSTANTFOLDPASS
#define GEN_PASS_REGISTRATION_TOSAMAKEBROADCASTABLEPASS
#define GEN_PASS_REGISTRATION_TOSANARROWF64TOF32PASS
#define GEN_PASS_REGISTRATION_TOSANARROWI64TOI32PASS
#define GEN_PASS_REGISTRATION_TOSAOPTIONALDECOMPOSITIONSPASS
#define GEN_PASS_REGISTRATION_TOSAREDUCETRANSPOSES
#define GEN_PASS_REGISTRATION_TOSAVALIDATION
#endif // GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// TosaArithConstantToTosaConstPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSAARITHCONSTANTTOTOSACONSTPASS

inline void registerTosaArithConstantToTosaConstPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaArithConstantToTosaConstPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaArithConstantToTosaConstPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaArithConstantToTosaConstPass();
  });
}

#undef GEN_PASS_REGISTRATION_TOSAARITHCONSTANTTOTOSACONSTPASS
#endif // GEN_PASS_REGISTRATION_TOSAARITHCONSTANTTOTOSACONSTPASS

//===----------------------------------------------------------------------===//
// TosaAttachTarget Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSAATTACHTARGET

inline void registerTosaAttachTarget() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaAttachTarget();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaAttachTargetPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaAttachTarget();
  });
}

#undef GEN_PASS_REGISTRATION_TOSAATTACHTARGET
#endif // GEN_PASS_REGISTRATION_TOSAATTACHTARGET

//===----------------------------------------------------------------------===//
// TosaConvertIntegerTypeToSignless Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSACONVERTINTEGERTYPETOSIGNLESS

inline void registerTosaConvertIntegerTypeToSignless() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaConvertIntegerTypeToSignless();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaConvertIntegerTypeToSignlessPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaConvertIntegerTypeToSignless();
  });
}

#undef GEN_PASS_REGISTRATION_TOSACONVERTINTEGERTYPETOSIGNLESS
#endif // GEN_PASS_REGISTRATION_TOSACONVERTINTEGERTYPETOSIGNLESS

//===----------------------------------------------------------------------===//
// TosaInferShapesPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSAINFERSHAPESPASS

inline void registerTosaInferShapesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaInferShapesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaInferShapesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaInferShapesPass();
  });
}

#undef GEN_PASS_REGISTRATION_TOSAINFERSHAPESPASS
#endif // GEN_PASS_REGISTRATION_TOSAINFERSHAPESPASS

//===----------------------------------------------------------------------===//
// TosaInputShape Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSAINPUTSHAPE

inline void registerTosaInputShape() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tosa::createTosaInputShapePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaInputShapePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return tosa::createTosaInputShapePass();
  });
}

#undef GEN_PASS_REGISTRATION_TOSAINPUTSHAPE
#endif // GEN_PASS_REGISTRATION_TOSAINPUTSHAPE

//===----------------------------------------------------------------------===//
// TosaLayerwiseConstantFoldPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSALAYERWISECONSTANTFOLDPASS

inline void registerTosaLayerwiseConstantFoldPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaLayerwiseConstantFoldPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaLayerwiseConstantFoldPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaLayerwiseConstantFoldPass();
  });
}

#undef GEN_PASS_REGISTRATION_TOSALAYERWISECONSTANTFOLDPASS
#endif // GEN_PASS_REGISTRATION_TOSALAYERWISECONSTANTFOLDPASS

//===----------------------------------------------------------------------===//
// TosaMakeBroadcastablePass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSAMAKEBROADCASTABLEPASS

inline void registerTosaMakeBroadcastablePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaMakeBroadcastablePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaMakeBroadcastablePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaMakeBroadcastablePass();
  });
}

#undef GEN_PASS_REGISTRATION_TOSAMAKEBROADCASTABLEPASS
#endif // GEN_PASS_REGISTRATION_TOSAMAKEBROADCASTABLEPASS

//===----------------------------------------------------------------------===//
// TosaNarrowF64ToF32Pass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSANARROWF64TOF32PASS

inline void registerTosaNarrowF64ToF32Pass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaNarrowF64ToF32Pass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaNarrowF64ToF32PassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaNarrowF64ToF32Pass();
  });
}

#undef GEN_PASS_REGISTRATION_TOSANARROWF64TOF32PASS
#endif // GEN_PASS_REGISTRATION_TOSANARROWF64TOF32PASS

//===----------------------------------------------------------------------===//
// TosaNarrowI64ToI32Pass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSANARROWI64TOI32PASS

inline void registerTosaNarrowI64ToI32Pass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaNarrowI64ToI32Pass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaNarrowI64ToI32PassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaNarrowI64ToI32Pass();
  });
}

#undef GEN_PASS_REGISTRATION_TOSANARROWI64TOI32PASS
#endif // GEN_PASS_REGISTRATION_TOSANARROWI64TOI32PASS

//===----------------------------------------------------------------------===//
// TosaOptionalDecompositionsPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSAOPTIONALDECOMPOSITIONSPASS

inline void registerTosaOptionalDecompositionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaOptionalDecompositionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaOptionalDecompositionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaOptionalDecompositionsPass();
  });
}

#undef GEN_PASS_REGISTRATION_TOSAOPTIONALDECOMPOSITIONSPASS
#endif // GEN_PASS_REGISTRATION_TOSAOPTIONALDECOMPOSITIONSPASS

//===----------------------------------------------------------------------===//
// TosaReduceTransposes Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSAREDUCETRANSPOSES

inline void registerTosaReduceTransposes() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaReduceTransposes();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaReduceTransposesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaReduceTransposes();
  });
}

#undef GEN_PASS_REGISTRATION_TOSAREDUCETRANSPOSES
#endif // GEN_PASS_REGISTRATION_TOSAREDUCETRANSPOSES

//===----------------------------------------------------------------------===//
// TosaValidation Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TOSAVALIDATION

inline void registerTosaValidation() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaValidation();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaValidationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaValidation();
  });
}

#undef GEN_PASS_REGISTRATION_TOSAVALIDATION
#endif // GEN_PASS_REGISTRATION_TOSAVALIDATION
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// Tosa Registration
//===----------------------------------------------------------------------===//

inline void registerTosaPasses() {
  registerTosaArithConstantToTosaConstPass();
  registerTosaAttachTarget();
  registerTosaConvertIntegerTypeToSignless();
  registerTosaInferShapesPass();
  registerTosaInputShape();
  registerTosaLayerwiseConstantFoldPass();
  registerTosaMakeBroadcastablePass();
  registerTosaNarrowF64ToF32Pass();
  registerTosaNarrowI64ToI32Pass();
  registerTosaOptionalDecompositionsPass();
  registerTosaReduceTransposes();
  registerTosaValidation();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
#ifdef GEN_PASS_CLASSES
#error "GEN_PASS_CLASSES is deprecated; use per-pass macros"
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
