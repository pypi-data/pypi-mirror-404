/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_GLUONCANONICALIZE
#define GEN_PASS_DECL_GLUONINFERCOALESCEDENCODINGSPASS
#define GEN_PASS_DECL_GLUONINLINE
#define GEN_PASS_DECL_GLUONRESOLVEAUTOENCODINGSPASS
#define GEN_PASS_DECL_GLUONSIMPLIFYCONTROLFLOW
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// GluonCanonicalize
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GLUONCANONICALIZE
std::unique_ptr<::mlir::Pass> createGluonCanonicalize();
#undef GEN_PASS_DECL_GLUONCANONICALIZE
#endif // GEN_PASS_DECL_GLUONCANONICALIZE
#ifdef GEN_PASS_DEF_GLUONCANONICALIZE

namespace impl {
  std::unique_ptr<::mlir::Pass> createGluonCanonicalize();
} // namespace impl
namespace impl {

template <typename DerivedT>
class GluonCanonicalizeBase : public ::mlir::OperationPass<> {
public:
  using Base = GluonCanonicalizeBase;

  GluonCanonicalizeBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GluonCanonicalizeBase(const GluonCanonicalizeBase &other) : ::mlir::OperationPass<>(other) {}
  GluonCanonicalizeBase& operator=(const GluonCanonicalizeBase &) = delete;
  GluonCanonicalizeBase(GluonCanonicalizeBase &&) = delete;
  GluonCanonicalizeBase& operator=(GluonCanonicalizeBase &&) = delete;
  ~GluonCanonicalizeBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gluon-canonicalize");
  }
  ::llvm::StringRef getArgument() const override { return "gluon-canonicalize"; }

  ::llvm::StringRef getDescription() const override { return R"PD(reduced set of simplifications for TTGIR)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GluonCanonicalize");
  }
  ::llvm::StringRef getName() const override { return "GluonCanonicalize"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::cf::ControlFlowDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GluonCanonicalizeBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createGluonCanonicalize() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGluonCanonicalize() {
  return impl::createGluonCanonicalize();
}
#undef GEN_PASS_DEF_GLUONCANONICALIZE
#endif // GEN_PASS_DEF_GLUONCANONICALIZE

//===----------------------------------------------------------------------===//
// GluonInferCoalescedEncodingsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GLUONINFERCOALESCEDENCODINGSPASS
std::unique_ptr<::mlir::Pass> createGluonInferCoalescedEncodingsPass();
#undef GEN_PASS_DECL_GLUONINFERCOALESCEDENCODINGSPASS
#endif // GEN_PASS_DECL_GLUONINFERCOALESCEDENCODINGSPASS
#ifdef GEN_PASS_DEF_GLUONINFERCOALESCEDENCODINGSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createGluonInferCoalescedEncodingsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class GluonInferCoalescedEncodingsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = GluonInferCoalescedEncodingsPassBase;

  GluonInferCoalescedEncodingsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GluonInferCoalescedEncodingsPassBase(const GluonInferCoalescedEncodingsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  GluonInferCoalescedEncodingsPassBase& operator=(const GluonInferCoalescedEncodingsPassBase &) = delete;
  GluonInferCoalescedEncodingsPassBase(GluonInferCoalescedEncodingsPassBase &&) = delete;
  GluonInferCoalescedEncodingsPassBase& operator=(GluonInferCoalescedEncodingsPassBase &&) = delete;
  ~GluonInferCoalescedEncodingsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gluon-infer-coalesced-encodings");
  }
  ::llvm::StringRef getArgument() const override { return "gluon-infer-coalesced-encodings"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Infer coalesced encodings based on axis analysis)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GluonInferCoalescedEncodingsPass");
  }
  ::llvm::StringRef getName() const override { return "GluonInferCoalescedEncodingsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GluonInferCoalescedEncodingsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createGluonInferCoalescedEncodingsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGluonInferCoalescedEncodingsPass() {
  return impl::createGluonInferCoalescedEncodingsPass();
}
#undef GEN_PASS_DEF_GLUONINFERCOALESCEDENCODINGSPASS
#endif // GEN_PASS_DEF_GLUONINFERCOALESCEDENCODINGSPASS

//===----------------------------------------------------------------------===//
// GluonInline
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GLUONINLINE
std::unique_ptr<::mlir::Pass> createGluonInline();
#undef GEN_PASS_DECL_GLUONINLINE
#endif // GEN_PASS_DECL_GLUONINLINE
#ifdef GEN_PASS_DEF_GLUONINLINE

namespace impl {
  std::unique_ptr<::mlir::Pass> createGluonInline();
} // namespace impl
namespace impl {

template <typename DerivedT>
class GluonInlineBase : public ::mlir::OperationPass<> {
public:
  using Base = GluonInlineBase;

  GluonInlineBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GluonInlineBase(const GluonInlineBase &other) : ::mlir::OperationPass<>(other) {}
  GluonInlineBase& operator=(const GluonInlineBase &) = delete;
  GluonInlineBase(GluonInlineBase &&) = delete;
  GluonInlineBase& operator=(GluonInlineBase &&) = delete;
  ~GluonInlineBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gluon-inline");
  }
  ::llvm::StringRef getArgument() const override { return "gluon-inline"; }

  ::llvm::StringRef getDescription() const override { return R"PD(reduced set of simplifications for TTGIR)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GluonInline");
  }
  ::llvm::StringRef getName() const override { return "GluonInline"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GluonInlineBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createGluonInline() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGluonInline() {
  return impl::createGluonInline();
}
#undef GEN_PASS_DEF_GLUONINLINE
#endif // GEN_PASS_DEF_GLUONINLINE

//===----------------------------------------------------------------------===//
// GluonResolveAutoEncodingsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GLUONRESOLVEAUTOENCODINGSPASS
std::unique_ptr<::mlir::Pass> createGluonResolveAutoEncodingsPass();
#undef GEN_PASS_DECL_GLUONRESOLVEAUTOENCODINGSPASS
#endif // GEN_PASS_DECL_GLUONRESOLVEAUTOENCODINGSPASS
#ifdef GEN_PASS_DEF_GLUONRESOLVEAUTOENCODINGSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createGluonResolveAutoEncodingsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class GluonResolveAutoEncodingsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = GluonResolveAutoEncodingsPassBase;

  GluonResolveAutoEncodingsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  GluonResolveAutoEncodingsPassBase(const GluonResolveAutoEncodingsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  GluonResolveAutoEncodingsPassBase& operator=(const GluonResolveAutoEncodingsPassBase &) = delete;
  GluonResolveAutoEncodingsPassBase(GluonResolveAutoEncodingsPassBase &&) = delete;
  GluonResolveAutoEncodingsPassBase& operator=(GluonResolveAutoEncodingsPassBase &&) = delete;
  ~GluonResolveAutoEncodingsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gluon-resolve-auto-encodings");
  }
  ::llvm::StringRef getArgument() const override { return "gluon-resolve-auto-encodings"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Resolve automatic encodings)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GluonResolveAutoEncodingsPass");
  }
  ::llvm::StringRef getName() const override { return "GluonResolveAutoEncodingsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GluonResolveAutoEncodingsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createGluonResolveAutoEncodingsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGluonResolveAutoEncodingsPass() {
  return impl::createGluonResolveAutoEncodingsPass();
}
#undef GEN_PASS_DEF_GLUONRESOLVEAUTOENCODINGSPASS
#endif // GEN_PASS_DEF_GLUONRESOLVEAUTOENCODINGSPASS

//===----------------------------------------------------------------------===//
// GluonSimplifyControlFlow
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GLUONSIMPLIFYCONTROLFLOW
std::unique_ptr<::mlir::Pass> createGluonSimplifyControlFlow();
#undef GEN_PASS_DECL_GLUONSIMPLIFYCONTROLFLOW
#endif // GEN_PASS_DECL_GLUONSIMPLIFYCONTROLFLOW
#ifdef GEN_PASS_DEF_GLUONSIMPLIFYCONTROLFLOW

namespace impl {
  std::unique_ptr<::mlir::Pass> createGluonSimplifyControlFlow();
} // namespace impl
namespace impl {

template <typename DerivedT>
class GluonSimplifyControlFlowBase : public ::mlir::OperationPass<> {
public:
  using Base = GluonSimplifyControlFlowBase;

  GluonSimplifyControlFlowBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GluonSimplifyControlFlowBase(const GluonSimplifyControlFlowBase &other) : ::mlir::OperationPass<>(other) {}
  GluonSimplifyControlFlowBase& operator=(const GluonSimplifyControlFlowBase &) = delete;
  GluonSimplifyControlFlowBase(GluonSimplifyControlFlowBase &&) = delete;
  GluonSimplifyControlFlowBase& operator=(GluonSimplifyControlFlowBase &&) = delete;
  ~GluonSimplifyControlFlowBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gluon-slimplify-control-flow");
  }
  ::llvm::StringRef getArgument() const override { return "gluon-slimplify-control-flow"; }

  ::llvm::StringRef getDescription() const override { return R"PD(simplications for control flow ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GluonSimplifyControlFlow");
  }
  ::llvm::StringRef getName() const override { return "GluonSimplifyControlFlow"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GluonSimplifyControlFlowBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createGluonSimplifyControlFlow() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createGluonSimplifyControlFlow() {
  return impl::createGluonSimplifyControlFlow();
}
#undef GEN_PASS_DEF_GLUONSIMPLIFYCONTROLFLOW
#endif // GEN_PASS_DEF_GLUONSIMPLIFYCONTROLFLOW
#ifdef GEN_PASS_REGISTRATION
// Generate registrations for all passes.
#define GEN_PASS_REGISTRATION_GLUONCANONICALIZE
#define GEN_PASS_REGISTRATION_GLUONINFERCOALESCEDENCODINGSPASS
#define GEN_PASS_REGISTRATION_GLUONINLINE
#define GEN_PASS_REGISTRATION_GLUONRESOLVEAUTOENCODINGSPASS
#define GEN_PASS_REGISTRATION_GLUONSIMPLIFYCONTROLFLOW
#endif // GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// GluonCanonicalize Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_GLUONCANONICALIZE

inline void registerGluonCanonicalize() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonCanonicalize();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGluonCanonicalizePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonCanonicalize();
  });
}

#undef GEN_PASS_REGISTRATION_GLUONCANONICALIZE
#endif // GEN_PASS_REGISTRATION_GLUONCANONICALIZE

//===----------------------------------------------------------------------===//
// GluonInferCoalescedEncodingsPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_GLUONINFERCOALESCEDENCODINGSPASS

inline void registerGluonInferCoalescedEncodingsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonInferCoalescedEncodingsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGluonInferCoalescedEncodingsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonInferCoalescedEncodingsPass();
  });
}

#undef GEN_PASS_REGISTRATION_GLUONINFERCOALESCEDENCODINGSPASS
#endif // GEN_PASS_REGISTRATION_GLUONINFERCOALESCEDENCODINGSPASS

//===----------------------------------------------------------------------===//
// GluonInline Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_GLUONINLINE

inline void registerGluonInline() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonInline();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGluonInlinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonInline();
  });
}

#undef GEN_PASS_REGISTRATION_GLUONINLINE
#endif // GEN_PASS_REGISTRATION_GLUONINLINE

//===----------------------------------------------------------------------===//
// GluonResolveAutoEncodingsPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_GLUONRESOLVEAUTOENCODINGSPASS

inline void registerGluonResolveAutoEncodingsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonResolveAutoEncodingsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGluonResolveAutoEncodingsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonResolveAutoEncodingsPass();
  });
}

#undef GEN_PASS_REGISTRATION_GLUONRESOLVEAUTOENCODINGSPASS
#endif // GEN_PASS_REGISTRATION_GLUONRESOLVEAUTOENCODINGSPASS

//===----------------------------------------------------------------------===//
// GluonSimplifyControlFlow Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_GLUONSIMPLIFYCONTROLFLOW

inline void registerGluonSimplifyControlFlow() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonSimplifyControlFlow();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGluonSimplifyControlFlowPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createGluonSimplifyControlFlow();
  });
}

#undef GEN_PASS_REGISTRATION_GLUONSIMPLIFYCONTROLFLOW
#endif // GEN_PASS_REGISTRATION_GLUONSIMPLIFYCONTROLFLOW
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// Gluon Registration
//===----------------------------------------------------------------------===//

inline void registerGluonPasses() {
  registerGluonCanonicalize();
  registerGluonInferCoalescedEncodingsPass();
  registerGluonInline();
  registerGluonResolveAutoEncodingsPass();
  registerGluonSimplifyControlFlow();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
#ifdef GEN_PASS_CLASSES
#error "GEN_PASS_CLASSES is deprecated; use per-pass macros"
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
