/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_CONVERTELEMENTWISE0DTENSORTOSCALARPASS
#define GEN_PASS_DECL_STABLEHLOLOWERTOARITHPASS
#define GEN_PASS_DECL_STABLEHLOLOWERTOXTILEPASS
#define GEN_PASS_DECL_VERIFYLEGALXTILEOPSPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ConvertElementwise0DTensorToScalarPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTELEMENTWISE0DTENSORTOSCALARPASS
std::unique_ptr<::mlir::Pass> createConvertElementwise0DTensorToScalarPass();
#undef GEN_PASS_DECL_CONVERTELEMENTWISE0DTENSORTOSCALARPASS
#endif // GEN_PASS_DECL_CONVERTELEMENTWISE0DTENSORTOSCALARPASS
#ifdef GEN_PASS_DEF_CONVERTELEMENTWISE0DTENSORTOSCALARPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createConvertElementwise0DTensorToScalarPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ConvertElementwise0DTensorToScalarPassBase : public ::mlir::OperationPass<> {
public:
  using Base = ConvertElementwise0DTensorToScalarPassBase;

  ConvertElementwise0DTensorToScalarPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertElementwise0DTensorToScalarPassBase(const ConvertElementwise0DTensorToScalarPassBase &other) : ::mlir::OperationPass<>(other) {}
  ConvertElementwise0DTensorToScalarPassBase& operator=(const ConvertElementwise0DTensorToScalarPassBase &) = delete;
  ConvertElementwise0DTensorToScalarPassBase(ConvertElementwise0DTensorToScalarPassBase &&) = delete;
  ConvertElementwise0DTensorToScalarPassBase& operator=(ConvertElementwise0DTensorToScalarPassBase &&) = delete;
  ~ConvertElementwise0DTensorToScalarPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-elementwise-0d-tensor-to-scalar");
  }
  ::llvm::StringRef getArgument() const override { return "convert-elementwise-0d-tensor-to-scalar"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers 0D tensors of elementwise ops to scalars.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertElementwise0DTensorToScalarPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertElementwise0DTensorToScalarPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertElementwise0DTensorToScalarPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createConvertElementwise0DTensorToScalarPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createConvertElementwise0DTensorToScalarPass() {
  return impl::createConvertElementwise0DTensorToScalarPass();
}
#undef GEN_PASS_DEF_CONVERTELEMENTWISE0DTENSORTOSCALARPASS
#endif // GEN_PASS_DEF_CONVERTELEMENTWISE0DTENSORTOSCALARPASS

//===----------------------------------------------------------------------===//
// StablehloLowerToArithPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOLOWERTOARITHPASS
std::unique_ptr<::mlir::Pass> createStablehloLowerToArithPass();
#undef GEN_PASS_DECL_STABLEHLOLOWERTOARITHPASS
#endif // GEN_PASS_DECL_STABLEHLOLOWERTOARITHPASS
#ifdef GEN_PASS_DEF_STABLEHLOLOWERTOARITHPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloLowerToArithPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloLowerToArithPassBase : public ::mlir::OperationPass<> {
public:
  using Base = StablehloLowerToArithPassBase;

  StablehloLowerToArithPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLowerToArithPassBase(const StablehloLowerToArithPassBase &other) : ::mlir::OperationPass<>(other) {}
  StablehloLowerToArithPassBase& operator=(const StablehloLowerToArithPassBase &) = delete;
  StablehloLowerToArithPassBase(StablehloLowerToArithPassBase &&) = delete;
  StablehloLowerToArithPassBase& operator=(StablehloLowerToArithPassBase &&) = delete;
  ~StablehloLowerToArithPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-lower-to-arith");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-lower-to-arith"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers certain stablehlo ops to arith ops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLowerToArithPass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLowerToArithPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLowerToArithPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloLowerToArithPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloLowerToArithPass() {
  return impl::createStablehloLowerToArithPass();
}
#undef GEN_PASS_DEF_STABLEHLOLOWERTOARITHPASS
#endif // GEN_PASS_DEF_STABLEHLOLOWERTOARITHPASS

//===----------------------------------------------------------------------===//
// StablehloLowerToXtilePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOLOWERTOXTILEPASS
std::unique_ptr<::mlir::Pass> createStablehloLowerToXtilePass();
#undef GEN_PASS_DECL_STABLEHLOLOWERTOXTILEPASS
#endif // GEN_PASS_DECL_STABLEHLOLOWERTOXTILEPASS
#ifdef GEN_PASS_DEF_STABLEHLOLOWERTOXTILEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createStablehloLowerToXtilePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class StablehloLowerToXtilePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = StablehloLowerToXtilePassBase;

  StablehloLowerToXtilePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StablehloLowerToXtilePassBase(const StablehloLowerToXtilePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  StablehloLowerToXtilePassBase& operator=(const StablehloLowerToXtilePassBase &) = delete;
  StablehloLowerToXtilePassBase(StablehloLowerToXtilePassBase &&) = delete;
  StablehloLowerToXtilePassBase& operator=(StablehloLowerToXtilePassBase &&) = delete;
  ~StablehloLowerToXtilePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-lower-to-xtile");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-lower-to-xtile"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers stablehlo ops to Xtile.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StablehloLowerToXtilePass");
  }
  ::llvm::StringRef getName() const override { return "StablehloLowerToXtilePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StablehloLowerToXtilePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createStablehloLowerToXtilePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createStablehloLowerToXtilePass() {
  return impl::createStablehloLowerToXtilePass();
}
#undef GEN_PASS_DEF_STABLEHLOLOWERTOXTILEPASS
#endif // GEN_PASS_DEF_STABLEHLOLOWERTOXTILEPASS

//===----------------------------------------------------------------------===//
// VerifyLegalXTileOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VERIFYLEGALXTILEOPSPASS
std::unique_ptr<::mlir::Pass> createVerifyLegalXTileOpsPass();
#undef GEN_PASS_DECL_VERIFYLEGALXTILEOPSPASS
#endif // GEN_PASS_DECL_VERIFYLEGALXTILEOPSPASS
#ifdef GEN_PASS_DEF_VERIFYLEGALXTILEOPSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createVerifyLegalXTileOpsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class VerifyLegalXTileOpsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = VerifyLegalXTileOpsPassBase;

  VerifyLegalXTileOpsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VerifyLegalXTileOpsPassBase(const VerifyLegalXTileOpsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  VerifyLegalXTileOpsPassBase& operator=(const VerifyLegalXTileOpsPassBase &) = delete;
  VerifyLegalXTileOpsPassBase(VerifyLegalXTileOpsPassBase &&) = delete;
  VerifyLegalXTileOpsPassBase& operator=(VerifyLegalXTileOpsPassBase &&) = delete;
  ~VerifyLegalXTileOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-verify-legal-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-verify-legal-ops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Verify that all ops in the module are legal)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VerifyLegalXTileOpsPass");
  }
  ::llvm::StringRef getName() const override { return "VerifyLegalXTileOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VerifyLegalXTileOpsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createVerifyLegalXTileOpsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createVerifyLegalXTileOpsPass() {
  return impl::createVerifyLegalXTileOpsPass();
}
#undef GEN_PASS_DEF_VERIFYLEGALXTILEOPSPASS
#endif // GEN_PASS_DEF_VERIFYLEGALXTILEOPSPASS
#ifdef GEN_PASS_REGISTRATION
// Generate registrations for all passes.
#define GEN_PASS_REGISTRATION_CONVERTELEMENTWISE0DTENSORTOSCALARPASS
#define GEN_PASS_REGISTRATION_STABLEHLOLOWERTOARITHPASS
#define GEN_PASS_REGISTRATION_STABLEHLOLOWERTOXTILEPASS
#define GEN_PASS_REGISTRATION_VERIFYLEGALXTILEOPSPASS
#endif // GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ConvertElementwise0DTensorToScalarPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_CONVERTELEMENTWISE0DTENSORTOSCALARPASS

inline void registerConvertElementwise0DTensorToScalarPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertElementwise0DTensorToScalarPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertElementwise0DTensorToScalarPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createConvertElementwise0DTensorToScalarPass();
  });
}

#undef GEN_PASS_REGISTRATION_CONVERTELEMENTWISE0DTENSORTOSCALARPASS
#endif // GEN_PASS_REGISTRATION_CONVERTELEMENTWISE0DTENSORTOSCALARPASS

//===----------------------------------------------------------------------===//
// StablehloLowerToArithPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_STABLEHLOLOWERTOARITHPASS

inline void registerStablehloLowerToArithPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLowerToArithPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloLowerToArithPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLowerToArithPass();
  });
}

#undef GEN_PASS_REGISTRATION_STABLEHLOLOWERTOARITHPASS
#endif // GEN_PASS_REGISTRATION_STABLEHLOLOWERTOARITHPASS

//===----------------------------------------------------------------------===//
// StablehloLowerToXtilePass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_STABLEHLOLOWERTOXTILEPASS

inline void registerStablehloLowerToXtilePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLowerToXtilePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStablehloLowerToXtilePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createStablehloLowerToXtilePass();
  });
}

#undef GEN_PASS_REGISTRATION_STABLEHLOLOWERTOXTILEPASS
#endif // GEN_PASS_REGISTRATION_STABLEHLOLOWERTOXTILEPASS

//===----------------------------------------------------------------------===//
// VerifyLegalXTileOpsPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_VERIFYLEGALXTILEOPSPASS

inline void registerVerifyLegalXTileOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVerifyLegalXTileOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVerifyLegalXTileOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVerifyLegalXTileOpsPass();
  });
}

#undef GEN_PASS_REGISTRATION_VERIFYLEGALXTILEOPSPASS
#endif // GEN_PASS_REGISTRATION_VERIFYLEGALXTILEOPSPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// XTileTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerXTileTransformsPasses() {
  registerConvertElementwise0DTensorToScalarPass();
  registerStablehloLowerToArithPass();
  registerStablehloLowerToXtilePass();
  registerVerifyLegalXTileOpsPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
#ifdef GEN_PASS_CLASSES
#error "GEN_PASS_CLASSES is deprecated; use per-pass macros"
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
