// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: xla/service/cpu/backend_config.proto
// Protobuf C++ Version: 6.31.1

#ifndef xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto_2epb_2eh
#define xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "xla/backends/cpu/xnn_fusion_options.pb.h"
#include "xla/backends/cpu/ynn_fusion_options.pb.h"
#include "xla/service/cpu/onednn_config.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable descriptor_table_xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto;
}  // extern "C"
namespace xla {
namespace cpu {
class BackendConfig;
struct BackendConfigDefaultTypeInternal;
PROTOBUF_EXPORT extern BackendConfigDefaultTypeInternal _BackendConfig_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull BackendConfig_class_data_;
class CustomCallBackendConfig;
struct CustomCallBackendConfigDefaultTypeInternal;
PROTOBUF_EXPORT extern CustomCallBackendConfigDefaultTypeInternal _CustomCallBackendConfig_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull CustomCallBackendConfig_class_data_;
class FusionBackendConfig;
struct FusionBackendConfigDefaultTypeInternal;
PROTOBUF_EXPORT extern FusionBackendConfigDefaultTypeInternal _FusionBackendConfig_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull FusionBackendConfig_class_data_;
class LlvmKernelOptions;
struct LlvmKernelOptionsDefaultTypeInternal;
PROTOBUF_EXPORT extern LlvmKernelOptionsDefaultTypeInternal _LlvmKernelOptions_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull LlvmKernelOptions_class_data_;
}  // namespace cpu
}  // namespace xla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xla {
namespace cpu {

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT LlvmKernelOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.LlvmKernelOptions) */ {
 public:
  inline LlvmKernelOptions() : LlvmKernelOptions(nullptr) {}
  ~LlvmKernelOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LlvmKernelOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LlvmKernelOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LlvmKernelOptions(::google::protobuf::internal::ConstantInitialized);

  inline LlvmKernelOptions(const LlvmKernelOptions& from) : LlvmKernelOptions(nullptr, from) {}
  inline LlvmKernelOptions(LlvmKernelOptions&& from) noexcept
      : LlvmKernelOptions(nullptr, ::std::move(from)) {}
  inline LlvmKernelOptions& operator=(const LlvmKernelOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline LlvmKernelOptions& operator=(LlvmKernelOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LlvmKernelOptions& default_instance() {
    return *reinterpret_cast<const LlvmKernelOptions*>(
        &_LlvmKernelOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(LlvmKernelOptions& a, LlvmKernelOptions& b) { a.Swap(&b); }
  inline void Swap(LlvmKernelOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LlvmKernelOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LlvmKernelOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LlvmKernelOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LlvmKernelOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LlvmKernelOptions& from) { LlvmKernelOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LlvmKernelOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.cpu.LlvmKernelOptions"; }

 protected:
  explicit LlvmKernelOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LlvmKernelOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LlvmKernelOptions& from);
  LlvmKernelOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LlvmKernelOptions&& from) noexcept
      : LlvmKernelOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSlpVectorizerDisabledFieldNumber = 1,
    kDisableLoopUnrollingFieldNumber = 2,
    kOptimizeForSizeFieldNumber = 3,
    kDisablePlatformDependentMathFieldNumber = 4,
  };
  // bool slp_vectorizer_disabled = 1;
  void clear_slp_vectorizer_disabled() ;
  bool slp_vectorizer_disabled() const;
  void set_slp_vectorizer_disabled(bool value);

  private:
  bool _internal_slp_vectorizer_disabled() const;
  void _internal_set_slp_vectorizer_disabled(bool value);

  public:
  // bool disable_loop_unrolling = 2;
  void clear_disable_loop_unrolling() ;
  bool disable_loop_unrolling() const;
  void set_disable_loop_unrolling(bool value);

  private:
  bool _internal_disable_loop_unrolling() const;
  void _internal_set_disable_loop_unrolling(bool value);

  public:
  // bool optimize_for_size = 3;
  void clear_optimize_for_size() ;
  bool optimize_for_size() const;
  void set_optimize_for_size(bool value);

  private:
  bool _internal_optimize_for_size() const;
  void _internal_set_optimize_for_size(bool value);

  public:
  // bool disable_platform_dependent_math = 4;
  void clear_disable_platform_dependent_math() ;
  bool disable_platform_dependent_math() const;
  void set_disable_platform_dependent_math(bool value);

  private:
  bool _internal_disable_platform_dependent_math() const;
  void _internal_set_disable_platform_dependent_math(bool value);

  public:
  // @@protoc_insertion_point(class_scope:xla.cpu.LlvmKernelOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LlvmKernelOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool slp_vectorizer_disabled_;
    bool disable_loop_unrolling_;
    bool optimize_for_size_;
    bool disable_platform_dependent_math_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull LlvmKernelOptions_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT CustomCallBackendConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.CustomCallBackendConfig) */ {
 public:
  inline CustomCallBackendConfig() : CustomCallBackendConfig(nullptr) {}
  ~CustomCallBackendConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CustomCallBackendConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CustomCallBackendConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CustomCallBackendConfig(::google::protobuf::internal::ConstantInitialized);

  inline CustomCallBackendConfig(const CustomCallBackendConfig& from) : CustomCallBackendConfig(nullptr, from) {}
  inline CustomCallBackendConfig(CustomCallBackendConfig&& from) noexcept
      : CustomCallBackendConfig(nullptr, ::std::move(from)) {}
  inline CustomCallBackendConfig& operator=(const CustomCallBackendConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomCallBackendConfig& operator=(CustomCallBackendConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomCallBackendConfig& default_instance() {
    return *reinterpret_cast<const CustomCallBackendConfig*>(
        &_CustomCallBackendConfig_default_instance_);
  }
  enum RawBackendConfigOneofCase {
    kOpaque = 1,
    kAttributes = 2,
    RAW_BACKEND_CONFIG_ONEOF_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CustomCallBackendConfig& a, CustomCallBackendConfig& b) { a.Swap(&b); }
  inline void Swap(CustomCallBackendConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomCallBackendConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomCallBackendConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CustomCallBackendConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CustomCallBackendConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CustomCallBackendConfig& from) { CustomCallBackendConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CustomCallBackendConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.cpu.CustomCallBackendConfig"; }

 protected:
  explicit CustomCallBackendConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  CustomCallBackendConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const CustomCallBackendConfig& from);
  CustomCallBackendConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, CustomCallBackendConfig&& from) noexcept
      : CustomCallBackendConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOpaqueFieldNumber = 1,
    kAttributesFieldNumber = 2,
  };
  // string opaque = 1;
  bool has_opaque() const;
  void clear_opaque() ;
  const ::std::string& opaque() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_opaque(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_opaque();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_opaque();
  void set_allocated_opaque(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_opaque() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_opaque(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_opaque();

  public:
  // string attributes = 2;
  bool has_attributes() const;
  void clear_attributes() ;
  const ::std::string& attributes() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_attributes(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_attributes();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_attributes();
  void set_allocated_attributes(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_attributes() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_attributes(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_attributes();

  public:
  void clear_raw_backend_config_oneof();
  RawBackendConfigOneofCase raw_backend_config_oneof_case() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.CustomCallBackendConfig)
 private:
  class _Internal;
  void set_has_opaque();
  void set_has_attributes();
  inline bool has_raw_backend_config_oneof() const;
  inline void clear_has_raw_backend_config_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const CustomCallBackendConfig& from_msg);
    union RawBackendConfigOneofUnion {
      constexpr RawBackendConfigOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr opaque_;
      ::google::protobuf::internal::ArenaStringPtr attributes_;
    } raw_backend_config_oneof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull CustomCallBackendConfig_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT FusionBackendConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.FusionBackendConfig) */ {
 public:
  inline FusionBackendConfig() : FusionBackendConfig(nullptr) {}
  ~FusionBackendConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FusionBackendConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FusionBackendConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FusionBackendConfig(::google::protobuf::internal::ConstantInitialized);

  inline FusionBackendConfig(const FusionBackendConfig& from) : FusionBackendConfig(nullptr, from) {}
  inline FusionBackendConfig(FusionBackendConfig&& from) noexcept
      : FusionBackendConfig(nullptr, ::std::move(from)) {}
  inline FusionBackendConfig& operator=(const FusionBackendConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline FusionBackendConfig& operator=(FusionBackendConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FusionBackendConfig& default_instance() {
    return *reinterpret_cast<const FusionBackendConfig*>(
        &_FusionBackendConfig_default_instance_);
  }
  enum CustomFusionConfigOneofCase {
    kXnnFusionOptions = 2,
    kYnnFusionOptions = 3,
    CUSTOM_FUSION_CONFIG_ONEOF_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(FusionBackendConfig& a, FusionBackendConfig& b) { a.Swap(&b); }
  inline void Swap(FusionBackendConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FusionBackendConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FusionBackendConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FusionBackendConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FusionBackendConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FusionBackendConfig& from) { FusionBackendConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FusionBackendConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.cpu.FusionBackendConfig"; }

 protected:
  explicit FusionBackendConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FusionBackendConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FusionBackendConfig& from);
  FusionBackendConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FusionBackendConfig&& from) noexcept
      : FusionBackendConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKindFieldNumber = 1,
    kXnnFusionOptionsFieldNumber = 2,
    kYnnFusionOptionsFieldNumber = 3,
  };
  // string kind = 1;
  void clear_kind() ;
  const ::std::string& kind() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_kind(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_kind();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_kind();
  void set_allocated_kind(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_kind() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_kind(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_kind();

  public:
  // .xla.cpu.XnnFusionOptions xnn_fusion_options = 2;
  bool has_xnn_fusion_options() const;
  private:
  bool _internal_has_xnn_fusion_options() const;

  public:
  void clear_xnn_fusion_options() ;
  const ::xla::cpu::XnnFusionOptions& xnn_fusion_options() const;
  [[nodiscard]] ::xla::cpu::XnnFusionOptions* PROTOBUF_NULLABLE release_xnn_fusion_options();
  ::xla::cpu::XnnFusionOptions* PROTOBUF_NONNULL mutable_xnn_fusion_options();
  void set_allocated_xnn_fusion_options(::xla::cpu::XnnFusionOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_xnn_fusion_options(::xla::cpu::XnnFusionOptions* PROTOBUF_NULLABLE value);
  ::xla::cpu::XnnFusionOptions* PROTOBUF_NULLABLE unsafe_arena_release_xnn_fusion_options();

  private:
  const ::xla::cpu::XnnFusionOptions& _internal_xnn_fusion_options() const;
  ::xla::cpu::XnnFusionOptions* PROTOBUF_NONNULL _internal_mutable_xnn_fusion_options();

  public:
  // .xla.cpu.YnnFusionOptions ynn_fusion_options = 3;
  bool has_ynn_fusion_options() const;
  private:
  bool _internal_has_ynn_fusion_options() const;

  public:
  void clear_ynn_fusion_options() ;
  const ::xla::cpu::YnnFusionOptions& ynn_fusion_options() const;
  [[nodiscard]] ::xla::cpu::YnnFusionOptions* PROTOBUF_NULLABLE release_ynn_fusion_options();
  ::xla::cpu::YnnFusionOptions* PROTOBUF_NONNULL mutable_ynn_fusion_options();
  void set_allocated_ynn_fusion_options(::xla::cpu::YnnFusionOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_ynn_fusion_options(::xla::cpu::YnnFusionOptions* PROTOBUF_NULLABLE value);
  ::xla::cpu::YnnFusionOptions* PROTOBUF_NULLABLE unsafe_arena_release_ynn_fusion_options();

  private:
  const ::xla::cpu::YnnFusionOptions& _internal_ynn_fusion_options() const;
  ::xla::cpu::YnnFusionOptions* PROTOBUF_NONNULL _internal_mutable_ynn_fusion_options();

  public:
  void clear_custom_fusion_config_oneof();
  CustomFusionConfigOneofCase custom_fusion_config_oneof_case() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.FusionBackendConfig)
 private:
  class _Internal;
  void set_has_xnn_fusion_options();
  void set_has_ynn_fusion_options();
  inline bool has_custom_fusion_config_oneof() const;
  inline void clear_has_custom_fusion_config_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   2, 40,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FusionBackendConfig& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr kind_;
    union CustomFusionConfigOneofUnion {
      constexpr CustomFusionConfigOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::xla::cpu::XnnFusionOptions* PROTOBUF_NULLABLE xnn_fusion_options_;
      ::xla::cpu::YnnFusionOptions* PROTOBUF_NULLABLE ynn_fusion_options_;
    } custom_fusion_config_oneof_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull FusionBackendConfig_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT BackendConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.cpu.BackendConfig) */ {
 public:
  inline BackendConfig() : BackendConfig(nullptr) {}
  ~BackendConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BackendConfig* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BackendConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BackendConfig(::google::protobuf::internal::ConstantInitialized);

  inline BackendConfig(const BackendConfig& from) : BackendConfig(nullptr, from) {}
  inline BackendConfig(BackendConfig&& from) noexcept
      : BackendConfig(nullptr, ::std::move(from)) {}
  inline BackendConfig& operator=(const BackendConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackendConfig& operator=(BackendConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackendConfig& default_instance() {
    return *reinterpret_cast<const BackendConfig*>(
        &_BackendConfig_default_instance_);
  }
  enum BackendConfigOneofCase {
    kOnednnMatmulConfig = 2,
    kOnednnLayerNormConfig = 3,
    kOnednnSoftmaxConfig = 4,
    kOnednnConvConfig = 5,
    kCustomCallConfig = 6,
    kFusionConfig = 7,
    kLlvmKernelOptions = 8,
    BACKEND_CONFIG_ONEOF_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(BackendConfig& a, BackendConfig& b) { a.Swap(&b); }
  inline void Swap(BackendConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackendConfig* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackendConfig* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BackendConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BackendConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BackendConfig& from) { BackendConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BackendConfig* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.cpu.BackendConfig"; }

 protected:
  explicit BackendConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  BackendConfig(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const BackendConfig& from);
  BackendConfig(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, BackendConfig&& from) noexcept
      : BackendConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOuterDimensionPartitionsFieldNumber = 1,
    kOnednnMatmulConfigFieldNumber = 2,
    kOnednnLayerNormConfigFieldNumber = 3,
    kOnednnSoftmaxConfigFieldNumber = 4,
    kOnednnConvConfigFieldNumber = 5,
    kCustomCallConfigFieldNumber = 6,
    kFusionConfigFieldNumber = 7,
    kLlvmKernelOptionsFieldNumber = 8,
  };
  // repeated int64 outer_dimension_partitions = 1;
  int outer_dimension_partitions_size() const;
  private:
  int _internal_outer_dimension_partitions_size() const;

  public:
  void clear_outer_dimension_partitions() ;
  ::int64_t outer_dimension_partitions(int index) const;
  void set_outer_dimension_partitions(int index, ::int64_t value);
  void add_outer_dimension_partitions(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& outer_dimension_partitions() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL mutable_outer_dimension_partitions();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_outer_dimension_partitions() const;
  ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL _internal_mutable_outer_dimension_partitions();

  public:
  // .xla.cpu.OneDnnMatMulConfig onednn_matmul_config = 2;
  bool has_onednn_matmul_config() const;
  private:
  bool _internal_has_onednn_matmul_config() const;

  public:
  void clear_onednn_matmul_config() ;
  const ::xla::cpu::OneDnnMatMulConfig& onednn_matmul_config() const;
  [[nodiscard]] ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NULLABLE release_onednn_matmul_config();
  ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NONNULL mutable_onednn_matmul_config();
  void set_allocated_onednn_matmul_config(::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_onednn_matmul_config(::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NULLABLE value);
  ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NULLABLE unsafe_arena_release_onednn_matmul_config();

  private:
  const ::xla::cpu::OneDnnMatMulConfig& _internal_onednn_matmul_config() const;
  ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NONNULL _internal_mutable_onednn_matmul_config();

  public:
  // .xla.cpu.OneDnnNormConfig onednn_layer_norm_config = 3;
  bool has_onednn_layer_norm_config() const;
  private:
  bool _internal_has_onednn_layer_norm_config() const;

  public:
  void clear_onednn_layer_norm_config() ;
  const ::xla::cpu::OneDnnNormConfig& onednn_layer_norm_config() const;
  [[nodiscard]] ::xla::cpu::OneDnnNormConfig* PROTOBUF_NULLABLE release_onednn_layer_norm_config();
  ::xla::cpu::OneDnnNormConfig* PROTOBUF_NONNULL mutable_onednn_layer_norm_config();
  void set_allocated_onednn_layer_norm_config(::xla::cpu::OneDnnNormConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_onednn_layer_norm_config(::xla::cpu::OneDnnNormConfig* PROTOBUF_NULLABLE value);
  ::xla::cpu::OneDnnNormConfig* PROTOBUF_NULLABLE unsafe_arena_release_onednn_layer_norm_config();

  private:
  const ::xla::cpu::OneDnnNormConfig& _internal_onednn_layer_norm_config() const;
  ::xla::cpu::OneDnnNormConfig* PROTOBUF_NONNULL _internal_mutable_onednn_layer_norm_config();

  public:
  // .xla.cpu.OneDnnSoftmaxConfig onednn_softmax_config = 4;
  bool has_onednn_softmax_config() const;
  private:
  bool _internal_has_onednn_softmax_config() const;

  public:
  void clear_onednn_softmax_config() ;
  const ::xla::cpu::OneDnnSoftmaxConfig& onednn_softmax_config() const;
  [[nodiscard]] ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NULLABLE release_onednn_softmax_config();
  ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NONNULL mutable_onednn_softmax_config();
  void set_allocated_onednn_softmax_config(::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_onednn_softmax_config(::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NULLABLE value);
  ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NULLABLE unsafe_arena_release_onednn_softmax_config();

  private:
  const ::xla::cpu::OneDnnSoftmaxConfig& _internal_onednn_softmax_config() const;
  ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NONNULL _internal_mutable_onednn_softmax_config();

  public:
  // .xla.cpu.OneDnnConvolutionConfig onednn_conv_config = 5;
  bool has_onednn_conv_config() const;
  private:
  bool _internal_has_onednn_conv_config() const;

  public:
  void clear_onednn_conv_config() ;
  const ::xla::cpu::OneDnnConvolutionConfig& onednn_conv_config() const;
  [[nodiscard]] ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NULLABLE release_onednn_conv_config();
  ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NONNULL mutable_onednn_conv_config();
  void set_allocated_onednn_conv_config(::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_onednn_conv_config(::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NULLABLE value);
  ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NULLABLE unsafe_arena_release_onednn_conv_config();

  private:
  const ::xla::cpu::OneDnnConvolutionConfig& _internal_onednn_conv_config() const;
  ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NONNULL _internal_mutable_onednn_conv_config();

  public:
  // .xla.cpu.CustomCallBackendConfig custom_call_config = 6;
  bool has_custom_call_config() const;
  private:
  bool _internal_has_custom_call_config() const;

  public:
  void clear_custom_call_config() ;
  const ::xla::cpu::CustomCallBackendConfig& custom_call_config() const;
  [[nodiscard]] ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NULLABLE release_custom_call_config();
  ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NONNULL mutable_custom_call_config();
  void set_allocated_custom_call_config(::xla::cpu::CustomCallBackendConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_custom_call_config(::xla::cpu::CustomCallBackendConfig* PROTOBUF_NULLABLE value);
  ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NULLABLE unsafe_arena_release_custom_call_config();

  private:
  const ::xla::cpu::CustomCallBackendConfig& _internal_custom_call_config() const;
  ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NONNULL _internal_mutable_custom_call_config();

  public:
  // .xla.cpu.FusionBackendConfig fusion_config = 7;
  bool has_fusion_config() const;
  private:
  bool _internal_has_fusion_config() const;

  public:
  void clear_fusion_config() ;
  const ::xla::cpu::FusionBackendConfig& fusion_config() const;
  [[nodiscard]] ::xla::cpu::FusionBackendConfig* PROTOBUF_NULLABLE release_fusion_config();
  ::xla::cpu::FusionBackendConfig* PROTOBUF_NONNULL mutable_fusion_config();
  void set_allocated_fusion_config(::xla::cpu::FusionBackendConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_fusion_config(::xla::cpu::FusionBackendConfig* PROTOBUF_NULLABLE value);
  ::xla::cpu::FusionBackendConfig* PROTOBUF_NULLABLE unsafe_arena_release_fusion_config();

  private:
  const ::xla::cpu::FusionBackendConfig& _internal_fusion_config() const;
  ::xla::cpu::FusionBackendConfig* PROTOBUF_NONNULL _internal_mutable_fusion_config();

  public:
  // .xla.cpu.LlvmKernelOptions llvm_kernel_options = 8;
  bool has_llvm_kernel_options() const;
  private:
  bool _internal_has_llvm_kernel_options() const;

  public:
  void clear_llvm_kernel_options() ;
  const ::xla::cpu::LlvmKernelOptions& llvm_kernel_options() const;
  [[nodiscard]] ::xla::cpu::LlvmKernelOptions* PROTOBUF_NULLABLE release_llvm_kernel_options();
  ::xla::cpu::LlvmKernelOptions* PROTOBUF_NONNULL mutable_llvm_kernel_options();
  void set_allocated_llvm_kernel_options(::xla::cpu::LlvmKernelOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_llvm_kernel_options(::xla::cpu::LlvmKernelOptions* PROTOBUF_NULLABLE value);
  ::xla::cpu::LlvmKernelOptions* PROTOBUF_NULLABLE unsafe_arena_release_llvm_kernel_options();

  private:
  const ::xla::cpu::LlvmKernelOptions& _internal_llvm_kernel_options() const;
  ::xla::cpu::LlvmKernelOptions* PROTOBUF_NONNULL _internal_mutable_llvm_kernel_options();

  public:
  void clear_backend_config_oneof();
  BackendConfigOneofCase backend_config_oneof_case() const;
  // @@protoc_insertion_point(class_scope:xla.cpu.BackendConfig)
 private:
  class _Internal;
  void set_has_onednn_matmul_config();
  void set_has_onednn_layer_norm_config();
  void set_has_onednn_softmax_config();
  void set_has_onednn_conv_config();
  void set_has_custom_call_config();
  void set_has_fusion_config();
  void set_has_llvm_kernel_options();
  inline bool has_backend_config_oneof() const;
  inline void clear_has_backend_config_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 8,
                                   7, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const BackendConfig& from_msg);
    ::google::protobuf::RepeatedField<::int64_t> outer_dimension_partitions_;
    ::google::protobuf::internal::CachedSize _outer_dimension_partitions_cached_byte_size_;
    union BackendConfigOneofUnion {
      constexpr BackendConfigOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE onednn_matmul_config_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE onednn_layer_norm_config_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE onednn_softmax_config_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE onednn_conv_config_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE custom_call_config_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE fusion_config_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE llvm_kernel_options_;
    } backend_config_oneof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull BackendConfig_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CustomCallBackendConfig

// string opaque = 1;
inline bool CustomCallBackendConfig::has_opaque() const {
  return raw_backend_config_oneof_case() == kOpaque;
}
inline void CustomCallBackendConfig::set_has_opaque() {
  _impl_._oneof_case_[0] = kOpaque;
}
inline void CustomCallBackendConfig::clear_opaque() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (raw_backend_config_oneof_case() == kOpaque) {
    _impl_.raw_backend_config_oneof_.opaque_.Destroy();
    clear_has_raw_backend_config_oneof();
  }
}
inline const ::std::string& CustomCallBackendConfig::opaque() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CustomCallBackendConfig.opaque)
  return _internal_opaque();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CustomCallBackendConfig::set_opaque(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (raw_backend_config_oneof_case() != kOpaque) {
    clear_raw_backend_config_oneof();

    set_has_opaque();
    _impl_.raw_backend_config_oneof_.opaque_.InitDefault();
  }
  _impl_.raw_backend_config_oneof_.opaque_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.CustomCallBackendConfig.opaque)
}
inline ::std::string* PROTOBUF_NONNULL CustomCallBackendConfig::mutable_opaque()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_opaque();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CustomCallBackendConfig.opaque)
  return _s;
}
inline const ::std::string& CustomCallBackendConfig::_internal_opaque() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (raw_backend_config_oneof_case() != kOpaque) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.raw_backend_config_oneof_.opaque_.Get();
}
inline void CustomCallBackendConfig::_internal_set_opaque(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (raw_backend_config_oneof_case() != kOpaque) {
    clear_raw_backend_config_oneof();

    set_has_opaque();
    _impl_.raw_backend_config_oneof_.opaque_.InitDefault();
  }
  _impl_.raw_backend_config_oneof_.opaque_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CustomCallBackendConfig::_internal_mutable_opaque() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (raw_backend_config_oneof_case() != kOpaque) {
    clear_raw_backend_config_oneof();

    set_has_opaque();
    _impl_.raw_backend_config_oneof_.opaque_.InitDefault();
  }
  return _impl_.raw_backend_config_oneof_.opaque_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CustomCallBackendConfig::release_opaque() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CustomCallBackendConfig.opaque)
  if (raw_backend_config_oneof_case() != kOpaque) {
    return nullptr;
  }
  clear_has_raw_backend_config_oneof();
  return _impl_.raw_backend_config_oneof_.opaque_.Release();
}
inline void CustomCallBackendConfig::set_allocated_opaque(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_raw_backend_config_oneof()) {
    clear_raw_backend_config_oneof();
  }
  if (value != nullptr) {
    set_has_opaque();
    _impl_.raw_backend_config_oneof_.opaque_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CustomCallBackendConfig.opaque)
}

// string attributes = 2;
inline bool CustomCallBackendConfig::has_attributes() const {
  return raw_backend_config_oneof_case() == kAttributes;
}
inline void CustomCallBackendConfig::set_has_attributes() {
  _impl_._oneof_case_[0] = kAttributes;
}
inline void CustomCallBackendConfig::clear_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (raw_backend_config_oneof_case() == kAttributes) {
    _impl_.raw_backend_config_oneof_.attributes_.Destroy();
    clear_has_raw_backend_config_oneof();
  }
}
inline const ::std::string& CustomCallBackendConfig::attributes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.CustomCallBackendConfig.attributes)
  return _internal_attributes();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void CustomCallBackendConfig::set_attributes(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (raw_backend_config_oneof_case() != kAttributes) {
    clear_raw_backend_config_oneof();

    set_has_attributes();
    _impl_.raw_backend_config_oneof_.attributes_.InitDefault();
  }
  _impl_.raw_backend_config_oneof_.attributes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.CustomCallBackendConfig.attributes)
}
inline ::std::string* PROTOBUF_NONNULL CustomCallBackendConfig::mutable_attributes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:xla.cpu.CustomCallBackendConfig.attributes)
  return _s;
}
inline const ::std::string& CustomCallBackendConfig::_internal_attributes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (raw_backend_config_oneof_case() != kAttributes) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.raw_backend_config_oneof_.attributes_.Get();
}
inline void CustomCallBackendConfig::_internal_set_attributes(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (raw_backend_config_oneof_case() != kAttributes) {
    clear_raw_backend_config_oneof();

    set_has_attributes();
    _impl_.raw_backend_config_oneof_.attributes_.InitDefault();
  }
  _impl_.raw_backend_config_oneof_.attributes_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL CustomCallBackendConfig::_internal_mutable_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (raw_backend_config_oneof_case() != kAttributes) {
    clear_raw_backend_config_oneof();

    set_has_attributes();
    _impl_.raw_backend_config_oneof_.attributes_.InitDefault();
  }
  return _impl_.raw_backend_config_oneof_.attributes_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE CustomCallBackendConfig::release_attributes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.CustomCallBackendConfig.attributes)
  if (raw_backend_config_oneof_case() != kAttributes) {
    return nullptr;
  }
  clear_has_raw_backend_config_oneof();
  return _impl_.raw_backend_config_oneof_.attributes_.Release();
}
inline void CustomCallBackendConfig::set_allocated_attributes(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_raw_backend_config_oneof()) {
    clear_raw_backend_config_oneof();
  }
  if (value != nullptr) {
    set_has_attributes();
    _impl_.raw_backend_config_oneof_.attributes_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.CustomCallBackendConfig.attributes)
}

inline bool CustomCallBackendConfig::has_raw_backend_config_oneof() const {
  return raw_backend_config_oneof_case() != RAW_BACKEND_CONFIG_ONEOF_NOT_SET;
}
inline void CustomCallBackendConfig::clear_has_raw_backend_config_oneof() {
  _impl_._oneof_case_[0] = RAW_BACKEND_CONFIG_ONEOF_NOT_SET;
}
inline CustomCallBackendConfig::RawBackendConfigOneofCase CustomCallBackendConfig::raw_backend_config_oneof_case() const {
  return CustomCallBackendConfig::RawBackendConfigOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FusionBackendConfig

// string kind = 1;
inline void FusionBackendConfig::clear_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.kind_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& FusionBackendConfig::kind() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.FusionBackendConfig.kind)
  return _internal_kind();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FusionBackendConfig::set_kind(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kind_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:xla.cpu.FusionBackendConfig.kind)
}
inline ::std::string* PROTOBUF_NONNULL FusionBackendConfig::mutable_kind()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:xla.cpu.FusionBackendConfig.kind)
  return _s;
}
inline const ::std::string& FusionBackendConfig::_internal_kind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.kind_.Get();
}
inline void FusionBackendConfig::_internal_set_kind(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kind_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FusionBackendConfig::_internal_mutable_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.kind_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FusionBackendConfig::release_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.cpu.FusionBackendConfig.kind)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.kind_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.kind_.Set("", GetArena());
  }
  return released;
}
inline void FusionBackendConfig::set_allocated_kind(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.kind_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.kind_.IsDefault()) {
    _impl_.kind_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:xla.cpu.FusionBackendConfig.kind)
}

// .xla.cpu.XnnFusionOptions xnn_fusion_options = 2;
inline bool FusionBackendConfig::has_xnn_fusion_options() const {
  return custom_fusion_config_oneof_case() == kXnnFusionOptions;
}
inline bool FusionBackendConfig::_internal_has_xnn_fusion_options() const {
  return custom_fusion_config_oneof_case() == kXnnFusionOptions;
}
inline void FusionBackendConfig::set_has_xnn_fusion_options() {
  _impl_._oneof_case_[0] = kXnnFusionOptions;
}
inline ::xla::cpu::XnnFusionOptions* PROTOBUF_NULLABLE FusionBackendConfig::release_xnn_fusion_options() {
  // @@protoc_insertion_point(field_release:xla.cpu.FusionBackendConfig.xnn_fusion_options)
  if (custom_fusion_config_oneof_case() == kXnnFusionOptions) {
    clear_has_custom_fusion_config_oneof();
    auto* temp = _impl_.custom_fusion_config_oneof_.xnn_fusion_options_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.custom_fusion_config_oneof_.xnn_fusion_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::XnnFusionOptions& FusionBackendConfig::_internal_xnn_fusion_options() const {
  return custom_fusion_config_oneof_case() == kXnnFusionOptions ? *_impl_.custom_fusion_config_oneof_.xnn_fusion_options_ : reinterpret_cast<::xla::cpu::XnnFusionOptions&>(::xla::cpu::_XnnFusionOptions_default_instance_);
}
inline const ::xla::cpu::XnnFusionOptions& FusionBackendConfig::xnn_fusion_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.FusionBackendConfig.xnn_fusion_options)
  return _internal_xnn_fusion_options();
}
inline ::xla::cpu::XnnFusionOptions* PROTOBUF_NULLABLE FusionBackendConfig::unsafe_arena_release_xnn_fusion_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.FusionBackendConfig.xnn_fusion_options)
  if (custom_fusion_config_oneof_case() == kXnnFusionOptions) {
    clear_has_custom_fusion_config_oneof();
    auto* temp = _impl_.custom_fusion_config_oneof_.xnn_fusion_options_;
    _impl_.custom_fusion_config_oneof_.xnn_fusion_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FusionBackendConfig::unsafe_arena_set_allocated_xnn_fusion_options(
    ::xla::cpu::XnnFusionOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_custom_fusion_config_oneof();
  if (value) {
    set_has_xnn_fusion_options();
    _impl_.custom_fusion_config_oneof_.xnn_fusion_options_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.FusionBackendConfig.xnn_fusion_options)
}
inline ::xla::cpu::XnnFusionOptions* PROTOBUF_NONNULL FusionBackendConfig::_internal_mutable_xnn_fusion_options() {
  if (custom_fusion_config_oneof_case() != kXnnFusionOptions) {
    clear_custom_fusion_config_oneof();
    set_has_xnn_fusion_options();
    _impl_.custom_fusion_config_oneof_.xnn_fusion_options_ = 
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::XnnFusionOptions>(GetArena());
  }
  return _impl_.custom_fusion_config_oneof_.xnn_fusion_options_;
}
inline ::xla::cpu::XnnFusionOptions* PROTOBUF_NONNULL FusionBackendConfig::mutable_xnn_fusion_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::XnnFusionOptions* _msg = _internal_mutable_xnn_fusion_options();
  // @@protoc_insertion_point(field_mutable:xla.cpu.FusionBackendConfig.xnn_fusion_options)
  return _msg;
}

// .xla.cpu.YnnFusionOptions ynn_fusion_options = 3;
inline bool FusionBackendConfig::has_ynn_fusion_options() const {
  return custom_fusion_config_oneof_case() == kYnnFusionOptions;
}
inline bool FusionBackendConfig::_internal_has_ynn_fusion_options() const {
  return custom_fusion_config_oneof_case() == kYnnFusionOptions;
}
inline void FusionBackendConfig::set_has_ynn_fusion_options() {
  _impl_._oneof_case_[0] = kYnnFusionOptions;
}
inline ::xla::cpu::YnnFusionOptions* PROTOBUF_NULLABLE FusionBackendConfig::release_ynn_fusion_options() {
  // @@protoc_insertion_point(field_release:xla.cpu.FusionBackendConfig.ynn_fusion_options)
  if (custom_fusion_config_oneof_case() == kYnnFusionOptions) {
    clear_has_custom_fusion_config_oneof();
    auto* temp = _impl_.custom_fusion_config_oneof_.ynn_fusion_options_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.custom_fusion_config_oneof_.ynn_fusion_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::YnnFusionOptions& FusionBackendConfig::_internal_ynn_fusion_options() const {
  return custom_fusion_config_oneof_case() == kYnnFusionOptions ? *_impl_.custom_fusion_config_oneof_.ynn_fusion_options_ : reinterpret_cast<::xla::cpu::YnnFusionOptions&>(::xla::cpu::_YnnFusionOptions_default_instance_);
}
inline const ::xla::cpu::YnnFusionOptions& FusionBackendConfig::ynn_fusion_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.FusionBackendConfig.ynn_fusion_options)
  return _internal_ynn_fusion_options();
}
inline ::xla::cpu::YnnFusionOptions* PROTOBUF_NULLABLE FusionBackendConfig::unsafe_arena_release_ynn_fusion_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.FusionBackendConfig.ynn_fusion_options)
  if (custom_fusion_config_oneof_case() == kYnnFusionOptions) {
    clear_has_custom_fusion_config_oneof();
    auto* temp = _impl_.custom_fusion_config_oneof_.ynn_fusion_options_;
    _impl_.custom_fusion_config_oneof_.ynn_fusion_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FusionBackendConfig::unsafe_arena_set_allocated_ynn_fusion_options(
    ::xla::cpu::YnnFusionOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_custom_fusion_config_oneof();
  if (value) {
    set_has_ynn_fusion_options();
    _impl_.custom_fusion_config_oneof_.ynn_fusion_options_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.FusionBackendConfig.ynn_fusion_options)
}
inline ::xla::cpu::YnnFusionOptions* PROTOBUF_NONNULL FusionBackendConfig::_internal_mutable_ynn_fusion_options() {
  if (custom_fusion_config_oneof_case() != kYnnFusionOptions) {
    clear_custom_fusion_config_oneof();
    set_has_ynn_fusion_options();
    _impl_.custom_fusion_config_oneof_.ynn_fusion_options_ = 
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::YnnFusionOptions>(GetArena());
  }
  return _impl_.custom_fusion_config_oneof_.ynn_fusion_options_;
}
inline ::xla::cpu::YnnFusionOptions* PROTOBUF_NONNULL FusionBackendConfig::mutable_ynn_fusion_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::YnnFusionOptions* _msg = _internal_mutable_ynn_fusion_options();
  // @@protoc_insertion_point(field_mutable:xla.cpu.FusionBackendConfig.ynn_fusion_options)
  return _msg;
}

inline bool FusionBackendConfig::has_custom_fusion_config_oneof() const {
  return custom_fusion_config_oneof_case() != CUSTOM_FUSION_CONFIG_ONEOF_NOT_SET;
}
inline void FusionBackendConfig::clear_has_custom_fusion_config_oneof() {
  _impl_._oneof_case_[0] = CUSTOM_FUSION_CONFIG_ONEOF_NOT_SET;
}
inline FusionBackendConfig::CustomFusionConfigOneofCase FusionBackendConfig::custom_fusion_config_oneof_case() const {
  return FusionBackendConfig::CustomFusionConfigOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LlvmKernelOptions

// bool slp_vectorizer_disabled = 1;
inline void LlvmKernelOptions::clear_slp_vectorizer_disabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slp_vectorizer_disabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool LlvmKernelOptions::slp_vectorizer_disabled() const {
  // @@protoc_insertion_point(field_get:xla.cpu.LlvmKernelOptions.slp_vectorizer_disabled)
  return _internal_slp_vectorizer_disabled();
}
inline void LlvmKernelOptions::set_slp_vectorizer_disabled(bool value) {
  _internal_set_slp_vectorizer_disabled(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:xla.cpu.LlvmKernelOptions.slp_vectorizer_disabled)
}
inline bool LlvmKernelOptions::_internal_slp_vectorizer_disabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slp_vectorizer_disabled_;
}
inline void LlvmKernelOptions::_internal_set_slp_vectorizer_disabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slp_vectorizer_disabled_ = value;
}

// bool disable_loop_unrolling = 2;
inline void LlvmKernelOptions::clear_disable_loop_unrolling() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_loop_unrolling_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool LlvmKernelOptions::disable_loop_unrolling() const {
  // @@protoc_insertion_point(field_get:xla.cpu.LlvmKernelOptions.disable_loop_unrolling)
  return _internal_disable_loop_unrolling();
}
inline void LlvmKernelOptions::set_disable_loop_unrolling(bool value) {
  _internal_set_disable_loop_unrolling(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:xla.cpu.LlvmKernelOptions.disable_loop_unrolling)
}
inline bool LlvmKernelOptions::_internal_disable_loop_unrolling() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_loop_unrolling_;
}
inline void LlvmKernelOptions::_internal_set_disable_loop_unrolling(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_loop_unrolling_ = value;
}

// bool optimize_for_size = 3;
inline void LlvmKernelOptions::clear_optimize_for_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.optimize_for_size_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool LlvmKernelOptions::optimize_for_size() const {
  // @@protoc_insertion_point(field_get:xla.cpu.LlvmKernelOptions.optimize_for_size)
  return _internal_optimize_for_size();
}
inline void LlvmKernelOptions::set_optimize_for_size(bool value) {
  _internal_set_optimize_for_size(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:xla.cpu.LlvmKernelOptions.optimize_for_size)
}
inline bool LlvmKernelOptions::_internal_optimize_for_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.optimize_for_size_;
}
inline void LlvmKernelOptions::_internal_set_optimize_for_size(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.optimize_for_size_ = value;
}

// bool disable_platform_dependent_math = 4;
inline void LlvmKernelOptions::clear_disable_platform_dependent_math() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_platform_dependent_math_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool LlvmKernelOptions::disable_platform_dependent_math() const {
  // @@protoc_insertion_point(field_get:xla.cpu.LlvmKernelOptions.disable_platform_dependent_math)
  return _internal_disable_platform_dependent_math();
}
inline void LlvmKernelOptions::set_disable_platform_dependent_math(bool value) {
  _internal_set_disable_platform_dependent_math(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:xla.cpu.LlvmKernelOptions.disable_platform_dependent_math)
}
inline bool LlvmKernelOptions::_internal_disable_platform_dependent_math() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_platform_dependent_math_;
}
inline void LlvmKernelOptions::_internal_set_disable_platform_dependent_math(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_platform_dependent_math_ = value;
}

// -------------------------------------------------------------------

// BackendConfig

// repeated int64 outer_dimension_partitions = 1;
inline int BackendConfig::_internal_outer_dimension_partitions_size() const {
  return _internal_outer_dimension_partitions().size();
}
inline int BackendConfig::outer_dimension_partitions_size() const {
  return _internal_outer_dimension_partitions_size();
}
inline void BackendConfig::clear_outer_dimension_partitions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.outer_dimension_partitions_.Clear();
}
inline ::int64_t BackendConfig::outer_dimension_partitions(int index) const {
  // @@protoc_insertion_point(field_get:xla.cpu.BackendConfig.outer_dimension_partitions)
  return _internal_outer_dimension_partitions().Get(index);
}
inline void BackendConfig::set_outer_dimension_partitions(int index, ::int64_t value) {
  _internal_mutable_outer_dimension_partitions()->Set(index, value);
  // @@protoc_insertion_point(field_set:xla.cpu.BackendConfig.outer_dimension_partitions)
}
inline void BackendConfig::add_outer_dimension_partitions(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_outer_dimension_partitions()->Add(value);
  // @@protoc_insertion_point(field_add:xla.cpu.BackendConfig.outer_dimension_partitions)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& BackendConfig::outer_dimension_partitions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.cpu.BackendConfig.outer_dimension_partitions)
  return _internal_outer_dimension_partitions();
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL BackendConfig::mutable_outer_dimension_partitions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.cpu.BackendConfig.outer_dimension_partitions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_outer_dimension_partitions();
}
inline const ::google::protobuf::RepeatedField<::int64_t>&
BackendConfig::_internal_outer_dimension_partitions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.outer_dimension_partitions_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* PROTOBUF_NONNULL
BackendConfig::_internal_mutable_outer_dimension_partitions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.outer_dimension_partitions_;
}

// .xla.cpu.OneDnnMatMulConfig onednn_matmul_config = 2;
inline bool BackendConfig::has_onednn_matmul_config() const {
  return backend_config_oneof_case() == kOnednnMatmulConfig;
}
inline bool BackendConfig::_internal_has_onednn_matmul_config() const {
  return backend_config_oneof_case() == kOnednnMatmulConfig;
}
inline void BackendConfig::set_has_onednn_matmul_config() {
  _impl_._oneof_case_[0] = kOnednnMatmulConfig;
}
inline ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NULLABLE BackendConfig::release_onednn_matmul_config() {
  // @@protoc_insertion_point(field_release:xla.cpu.BackendConfig.onednn_matmul_config)
  if (backend_config_oneof_case() == kOnednnMatmulConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::OneDnnMatMulConfig*>(_impl_.backend_config_oneof_.onednn_matmul_config_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.backend_config_oneof_.onednn_matmul_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::OneDnnMatMulConfig& BackendConfig::_internal_onednn_matmul_config() const {
  return backend_config_oneof_case() == kOnednnMatmulConfig ? *reinterpret_cast<::xla::cpu::OneDnnMatMulConfig*>(_impl_.backend_config_oneof_.onednn_matmul_config_) : reinterpret_cast<::xla::cpu::OneDnnMatMulConfig&>(::xla::cpu::_OneDnnMatMulConfig_default_instance_);
}
inline const ::xla::cpu::OneDnnMatMulConfig& BackendConfig::onednn_matmul_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.BackendConfig.onednn_matmul_config)
  return _internal_onednn_matmul_config();
}
inline ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NULLABLE BackendConfig::unsafe_arena_release_onednn_matmul_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.BackendConfig.onednn_matmul_config)
  if (backend_config_oneof_case() == kOnednnMatmulConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::OneDnnMatMulConfig*>(_impl_.backend_config_oneof_.onednn_matmul_config_);
    _impl_.backend_config_oneof_.onednn_matmul_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BackendConfig::unsafe_arena_set_allocated_onednn_matmul_config(
    ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_backend_config_oneof();
  if (value) {
    set_has_onednn_matmul_config();
    _impl_.backend_config_oneof_.onednn_matmul_config_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.BackendConfig.onednn_matmul_config)
}
inline ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NONNULL BackendConfig::_internal_mutable_onednn_matmul_config() {
  if (backend_config_oneof_case() != kOnednnMatmulConfig) {
    clear_backend_config_oneof();
    set_has_onednn_matmul_config();
    _impl_.backend_config_oneof_.onednn_matmul_config_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OneDnnMatMulConfig>(GetArena()));
  }
  return reinterpret_cast<::xla::cpu::OneDnnMatMulConfig*>(_impl_.backend_config_oneof_.onednn_matmul_config_);
}
inline ::xla::cpu::OneDnnMatMulConfig* PROTOBUF_NONNULL BackendConfig::mutable_onednn_matmul_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::OneDnnMatMulConfig* _msg = _internal_mutable_onednn_matmul_config();
  // @@protoc_insertion_point(field_mutable:xla.cpu.BackendConfig.onednn_matmul_config)
  return _msg;
}

// .xla.cpu.OneDnnNormConfig onednn_layer_norm_config = 3;
inline bool BackendConfig::has_onednn_layer_norm_config() const {
  return backend_config_oneof_case() == kOnednnLayerNormConfig;
}
inline bool BackendConfig::_internal_has_onednn_layer_norm_config() const {
  return backend_config_oneof_case() == kOnednnLayerNormConfig;
}
inline void BackendConfig::set_has_onednn_layer_norm_config() {
  _impl_._oneof_case_[0] = kOnednnLayerNormConfig;
}
inline ::xla::cpu::OneDnnNormConfig* PROTOBUF_NULLABLE BackendConfig::release_onednn_layer_norm_config() {
  // @@protoc_insertion_point(field_release:xla.cpu.BackendConfig.onednn_layer_norm_config)
  if (backend_config_oneof_case() == kOnednnLayerNormConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::OneDnnNormConfig*>(_impl_.backend_config_oneof_.onednn_layer_norm_config_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.backend_config_oneof_.onednn_layer_norm_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::OneDnnNormConfig& BackendConfig::_internal_onednn_layer_norm_config() const {
  return backend_config_oneof_case() == kOnednnLayerNormConfig ? *reinterpret_cast<::xla::cpu::OneDnnNormConfig*>(_impl_.backend_config_oneof_.onednn_layer_norm_config_) : reinterpret_cast<::xla::cpu::OneDnnNormConfig&>(::xla::cpu::_OneDnnNormConfig_default_instance_);
}
inline const ::xla::cpu::OneDnnNormConfig& BackendConfig::onednn_layer_norm_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.BackendConfig.onednn_layer_norm_config)
  return _internal_onednn_layer_norm_config();
}
inline ::xla::cpu::OneDnnNormConfig* PROTOBUF_NULLABLE BackendConfig::unsafe_arena_release_onednn_layer_norm_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.BackendConfig.onednn_layer_norm_config)
  if (backend_config_oneof_case() == kOnednnLayerNormConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::OneDnnNormConfig*>(_impl_.backend_config_oneof_.onednn_layer_norm_config_);
    _impl_.backend_config_oneof_.onednn_layer_norm_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BackendConfig::unsafe_arena_set_allocated_onednn_layer_norm_config(
    ::xla::cpu::OneDnnNormConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_backend_config_oneof();
  if (value) {
    set_has_onednn_layer_norm_config();
    _impl_.backend_config_oneof_.onednn_layer_norm_config_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.BackendConfig.onednn_layer_norm_config)
}
inline ::xla::cpu::OneDnnNormConfig* PROTOBUF_NONNULL BackendConfig::_internal_mutable_onednn_layer_norm_config() {
  if (backend_config_oneof_case() != kOnednnLayerNormConfig) {
    clear_backend_config_oneof();
    set_has_onednn_layer_norm_config();
    _impl_.backend_config_oneof_.onednn_layer_norm_config_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OneDnnNormConfig>(GetArena()));
  }
  return reinterpret_cast<::xla::cpu::OneDnnNormConfig*>(_impl_.backend_config_oneof_.onednn_layer_norm_config_);
}
inline ::xla::cpu::OneDnnNormConfig* PROTOBUF_NONNULL BackendConfig::mutable_onednn_layer_norm_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::OneDnnNormConfig* _msg = _internal_mutable_onednn_layer_norm_config();
  // @@protoc_insertion_point(field_mutable:xla.cpu.BackendConfig.onednn_layer_norm_config)
  return _msg;
}

// .xla.cpu.OneDnnSoftmaxConfig onednn_softmax_config = 4;
inline bool BackendConfig::has_onednn_softmax_config() const {
  return backend_config_oneof_case() == kOnednnSoftmaxConfig;
}
inline bool BackendConfig::_internal_has_onednn_softmax_config() const {
  return backend_config_oneof_case() == kOnednnSoftmaxConfig;
}
inline void BackendConfig::set_has_onednn_softmax_config() {
  _impl_._oneof_case_[0] = kOnednnSoftmaxConfig;
}
inline ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NULLABLE BackendConfig::release_onednn_softmax_config() {
  // @@protoc_insertion_point(field_release:xla.cpu.BackendConfig.onednn_softmax_config)
  if (backend_config_oneof_case() == kOnednnSoftmaxConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::OneDnnSoftmaxConfig*>(_impl_.backend_config_oneof_.onednn_softmax_config_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.backend_config_oneof_.onednn_softmax_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::OneDnnSoftmaxConfig& BackendConfig::_internal_onednn_softmax_config() const {
  return backend_config_oneof_case() == kOnednnSoftmaxConfig ? *reinterpret_cast<::xla::cpu::OneDnnSoftmaxConfig*>(_impl_.backend_config_oneof_.onednn_softmax_config_) : reinterpret_cast<::xla::cpu::OneDnnSoftmaxConfig&>(::xla::cpu::_OneDnnSoftmaxConfig_default_instance_);
}
inline const ::xla::cpu::OneDnnSoftmaxConfig& BackendConfig::onednn_softmax_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.BackendConfig.onednn_softmax_config)
  return _internal_onednn_softmax_config();
}
inline ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NULLABLE BackendConfig::unsafe_arena_release_onednn_softmax_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.BackendConfig.onednn_softmax_config)
  if (backend_config_oneof_case() == kOnednnSoftmaxConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::OneDnnSoftmaxConfig*>(_impl_.backend_config_oneof_.onednn_softmax_config_);
    _impl_.backend_config_oneof_.onednn_softmax_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BackendConfig::unsafe_arena_set_allocated_onednn_softmax_config(
    ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_backend_config_oneof();
  if (value) {
    set_has_onednn_softmax_config();
    _impl_.backend_config_oneof_.onednn_softmax_config_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.BackendConfig.onednn_softmax_config)
}
inline ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NONNULL BackendConfig::_internal_mutable_onednn_softmax_config() {
  if (backend_config_oneof_case() != kOnednnSoftmaxConfig) {
    clear_backend_config_oneof();
    set_has_onednn_softmax_config();
    _impl_.backend_config_oneof_.onednn_softmax_config_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OneDnnSoftmaxConfig>(GetArena()));
  }
  return reinterpret_cast<::xla::cpu::OneDnnSoftmaxConfig*>(_impl_.backend_config_oneof_.onednn_softmax_config_);
}
inline ::xla::cpu::OneDnnSoftmaxConfig* PROTOBUF_NONNULL BackendConfig::mutable_onednn_softmax_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::OneDnnSoftmaxConfig* _msg = _internal_mutable_onednn_softmax_config();
  // @@protoc_insertion_point(field_mutable:xla.cpu.BackendConfig.onednn_softmax_config)
  return _msg;
}

// .xla.cpu.OneDnnConvolutionConfig onednn_conv_config = 5;
inline bool BackendConfig::has_onednn_conv_config() const {
  return backend_config_oneof_case() == kOnednnConvConfig;
}
inline bool BackendConfig::_internal_has_onednn_conv_config() const {
  return backend_config_oneof_case() == kOnednnConvConfig;
}
inline void BackendConfig::set_has_onednn_conv_config() {
  _impl_._oneof_case_[0] = kOnednnConvConfig;
}
inline ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NULLABLE BackendConfig::release_onednn_conv_config() {
  // @@protoc_insertion_point(field_release:xla.cpu.BackendConfig.onednn_conv_config)
  if (backend_config_oneof_case() == kOnednnConvConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::OneDnnConvolutionConfig*>(_impl_.backend_config_oneof_.onednn_conv_config_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.backend_config_oneof_.onednn_conv_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::OneDnnConvolutionConfig& BackendConfig::_internal_onednn_conv_config() const {
  return backend_config_oneof_case() == kOnednnConvConfig ? *reinterpret_cast<::xla::cpu::OneDnnConvolutionConfig*>(_impl_.backend_config_oneof_.onednn_conv_config_) : reinterpret_cast<::xla::cpu::OneDnnConvolutionConfig&>(::xla::cpu::_OneDnnConvolutionConfig_default_instance_);
}
inline const ::xla::cpu::OneDnnConvolutionConfig& BackendConfig::onednn_conv_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.BackendConfig.onednn_conv_config)
  return _internal_onednn_conv_config();
}
inline ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NULLABLE BackendConfig::unsafe_arena_release_onednn_conv_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.BackendConfig.onednn_conv_config)
  if (backend_config_oneof_case() == kOnednnConvConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::OneDnnConvolutionConfig*>(_impl_.backend_config_oneof_.onednn_conv_config_);
    _impl_.backend_config_oneof_.onednn_conv_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BackendConfig::unsafe_arena_set_allocated_onednn_conv_config(
    ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_backend_config_oneof();
  if (value) {
    set_has_onednn_conv_config();
    _impl_.backend_config_oneof_.onednn_conv_config_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.BackendConfig.onednn_conv_config)
}
inline ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NONNULL BackendConfig::_internal_mutable_onednn_conv_config() {
  if (backend_config_oneof_case() != kOnednnConvConfig) {
    clear_backend_config_oneof();
    set_has_onednn_conv_config();
    _impl_.backend_config_oneof_.onednn_conv_config_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::OneDnnConvolutionConfig>(GetArena()));
  }
  return reinterpret_cast<::xla::cpu::OneDnnConvolutionConfig*>(_impl_.backend_config_oneof_.onednn_conv_config_);
}
inline ::xla::cpu::OneDnnConvolutionConfig* PROTOBUF_NONNULL BackendConfig::mutable_onednn_conv_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::OneDnnConvolutionConfig* _msg = _internal_mutable_onednn_conv_config();
  // @@protoc_insertion_point(field_mutable:xla.cpu.BackendConfig.onednn_conv_config)
  return _msg;
}

// .xla.cpu.CustomCallBackendConfig custom_call_config = 6;
inline bool BackendConfig::has_custom_call_config() const {
  return backend_config_oneof_case() == kCustomCallConfig;
}
inline bool BackendConfig::_internal_has_custom_call_config() const {
  return backend_config_oneof_case() == kCustomCallConfig;
}
inline void BackendConfig::set_has_custom_call_config() {
  _impl_._oneof_case_[0] = kCustomCallConfig;
}
inline void BackendConfig::clear_custom_call_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (backend_config_oneof_case() == kCustomCallConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.backend_config_oneof_.custom_call_config_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.backend_config_oneof_.custom_call_config_);
    }
    clear_has_backend_config_oneof();
  }
}
inline ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NULLABLE BackendConfig::release_custom_call_config() {
  // @@protoc_insertion_point(field_release:xla.cpu.BackendConfig.custom_call_config)
  if (backend_config_oneof_case() == kCustomCallConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::CustomCallBackendConfig*>(_impl_.backend_config_oneof_.custom_call_config_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.backend_config_oneof_.custom_call_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::CustomCallBackendConfig& BackendConfig::_internal_custom_call_config() const {
  return backend_config_oneof_case() == kCustomCallConfig ? *reinterpret_cast<::xla::cpu::CustomCallBackendConfig*>(_impl_.backend_config_oneof_.custom_call_config_) : reinterpret_cast<::xla::cpu::CustomCallBackendConfig&>(::xla::cpu::_CustomCallBackendConfig_default_instance_);
}
inline const ::xla::cpu::CustomCallBackendConfig& BackendConfig::custom_call_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.BackendConfig.custom_call_config)
  return _internal_custom_call_config();
}
inline ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NULLABLE BackendConfig::unsafe_arena_release_custom_call_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.BackendConfig.custom_call_config)
  if (backend_config_oneof_case() == kCustomCallConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::CustomCallBackendConfig*>(_impl_.backend_config_oneof_.custom_call_config_);
    _impl_.backend_config_oneof_.custom_call_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BackendConfig::unsafe_arena_set_allocated_custom_call_config(
    ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_backend_config_oneof();
  if (value) {
    set_has_custom_call_config();
    _impl_.backend_config_oneof_.custom_call_config_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.BackendConfig.custom_call_config)
}
inline ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NONNULL BackendConfig::_internal_mutable_custom_call_config() {
  if (backend_config_oneof_case() != kCustomCallConfig) {
    clear_backend_config_oneof();
    set_has_custom_call_config();
    _impl_.backend_config_oneof_.custom_call_config_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::CustomCallBackendConfig>(GetArena()));
  }
  return reinterpret_cast<::xla::cpu::CustomCallBackendConfig*>(_impl_.backend_config_oneof_.custom_call_config_);
}
inline ::xla::cpu::CustomCallBackendConfig* PROTOBUF_NONNULL BackendConfig::mutable_custom_call_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::CustomCallBackendConfig* _msg = _internal_mutable_custom_call_config();
  // @@protoc_insertion_point(field_mutable:xla.cpu.BackendConfig.custom_call_config)
  return _msg;
}

// .xla.cpu.FusionBackendConfig fusion_config = 7;
inline bool BackendConfig::has_fusion_config() const {
  return backend_config_oneof_case() == kFusionConfig;
}
inline bool BackendConfig::_internal_has_fusion_config() const {
  return backend_config_oneof_case() == kFusionConfig;
}
inline void BackendConfig::set_has_fusion_config() {
  _impl_._oneof_case_[0] = kFusionConfig;
}
inline void BackendConfig::clear_fusion_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (backend_config_oneof_case() == kFusionConfig) {
    if (GetArena() == nullptr) {
      delete _impl_.backend_config_oneof_.fusion_config_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.backend_config_oneof_.fusion_config_);
    }
    clear_has_backend_config_oneof();
  }
}
inline ::xla::cpu::FusionBackendConfig* PROTOBUF_NULLABLE BackendConfig::release_fusion_config() {
  // @@protoc_insertion_point(field_release:xla.cpu.BackendConfig.fusion_config)
  if (backend_config_oneof_case() == kFusionConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::FusionBackendConfig*>(_impl_.backend_config_oneof_.fusion_config_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.backend_config_oneof_.fusion_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::FusionBackendConfig& BackendConfig::_internal_fusion_config() const {
  return backend_config_oneof_case() == kFusionConfig ? *reinterpret_cast<::xla::cpu::FusionBackendConfig*>(_impl_.backend_config_oneof_.fusion_config_) : reinterpret_cast<::xla::cpu::FusionBackendConfig&>(::xla::cpu::_FusionBackendConfig_default_instance_);
}
inline const ::xla::cpu::FusionBackendConfig& BackendConfig::fusion_config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.BackendConfig.fusion_config)
  return _internal_fusion_config();
}
inline ::xla::cpu::FusionBackendConfig* PROTOBUF_NULLABLE BackendConfig::unsafe_arena_release_fusion_config() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.BackendConfig.fusion_config)
  if (backend_config_oneof_case() == kFusionConfig) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::FusionBackendConfig*>(_impl_.backend_config_oneof_.fusion_config_);
    _impl_.backend_config_oneof_.fusion_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BackendConfig::unsafe_arena_set_allocated_fusion_config(
    ::xla::cpu::FusionBackendConfig* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_backend_config_oneof();
  if (value) {
    set_has_fusion_config();
    _impl_.backend_config_oneof_.fusion_config_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.BackendConfig.fusion_config)
}
inline ::xla::cpu::FusionBackendConfig* PROTOBUF_NONNULL BackendConfig::_internal_mutable_fusion_config() {
  if (backend_config_oneof_case() != kFusionConfig) {
    clear_backend_config_oneof();
    set_has_fusion_config();
    _impl_.backend_config_oneof_.fusion_config_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::FusionBackendConfig>(GetArena()));
  }
  return reinterpret_cast<::xla::cpu::FusionBackendConfig*>(_impl_.backend_config_oneof_.fusion_config_);
}
inline ::xla::cpu::FusionBackendConfig* PROTOBUF_NONNULL BackendConfig::mutable_fusion_config()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::FusionBackendConfig* _msg = _internal_mutable_fusion_config();
  // @@protoc_insertion_point(field_mutable:xla.cpu.BackendConfig.fusion_config)
  return _msg;
}

// .xla.cpu.LlvmKernelOptions llvm_kernel_options = 8;
inline bool BackendConfig::has_llvm_kernel_options() const {
  return backend_config_oneof_case() == kLlvmKernelOptions;
}
inline bool BackendConfig::_internal_has_llvm_kernel_options() const {
  return backend_config_oneof_case() == kLlvmKernelOptions;
}
inline void BackendConfig::set_has_llvm_kernel_options() {
  _impl_._oneof_case_[0] = kLlvmKernelOptions;
}
inline void BackendConfig::clear_llvm_kernel_options() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (backend_config_oneof_case() == kLlvmKernelOptions) {
    if (GetArena() == nullptr) {
      delete _impl_.backend_config_oneof_.llvm_kernel_options_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.backend_config_oneof_.llvm_kernel_options_);
    }
    clear_has_backend_config_oneof();
  }
}
inline ::xla::cpu::LlvmKernelOptions* PROTOBUF_NULLABLE BackendConfig::release_llvm_kernel_options() {
  // @@protoc_insertion_point(field_release:xla.cpu.BackendConfig.llvm_kernel_options)
  if (backend_config_oneof_case() == kLlvmKernelOptions) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::LlvmKernelOptions*>(_impl_.backend_config_oneof_.llvm_kernel_options_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.backend_config_oneof_.llvm_kernel_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::cpu::LlvmKernelOptions& BackendConfig::_internal_llvm_kernel_options() const {
  return backend_config_oneof_case() == kLlvmKernelOptions ? *reinterpret_cast<::xla::cpu::LlvmKernelOptions*>(_impl_.backend_config_oneof_.llvm_kernel_options_) : reinterpret_cast<::xla::cpu::LlvmKernelOptions&>(::xla::cpu::_LlvmKernelOptions_default_instance_);
}
inline const ::xla::cpu::LlvmKernelOptions& BackendConfig::llvm_kernel_options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.cpu.BackendConfig.llvm_kernel_options)
  return _internal_llvm_kernel_options();
}
inline ::xla::cpu::LlvmKernelOptions* PROTOBUF_NULLABLE BackendConfig::unsafe_arena_release_llvm_kernel_options() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.cpu.BackendConfig.llvm_kernel_options)
  if (backend_config_oneof_case() == kLlvmKernelOptions) {
    clear_has_backend_config_oneof();
    auto* temp = reinterpret_cast<::xla::cpu::LlvmKernelOptions*>(_impl_.backend_config_oneof_.llvm_kernel_options_);
    _impl_.backend_config_oneof_.llvm_kernel_options_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BackendConfig::unsafe_arena_set_allocated_llvm_kernel_options(
    ::xla::cpu::LlvmKernelOptions* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_backend_config_oneof();
  if (value) {
    set_has_llvm_kernel_options();
    _impl_.backend_config_oneof_.llvm_kernel_options_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.cpu.BackendConfig.llvm_kernel_options)
}
inline ::xla::cpu::LlvmKernelOptions* PROTOBUF_NONNULL BackendConfig::_internal_mutable_llvm_kernel_options() {
  if (backend_config_oneof_case() != kLlvmKernelOptions) {
    clear_backend_config_oneof();
    set_has_llvm_kernel_options();
    _impl_.backend_config_oneof_.llvm_kernel_options_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::xla::cpu::LlvmKernelOptions>(GetArena()));
  }
  return reinterpret_cast<::xla::cpu::LlvmKernelOptions*>(_impl_.backend_config_oneof_.llvm_kernel_options_);
}
inline ::xla::cpu::LlvmKernelOptions* PROTOBUF_NONNULL BackendConfig::mutable_llvm_kernel_options()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::cpu::LlvmKernelOptions* _msg = _internal_mutable_llvm_kernel_options();
  // @@protoc_insertion_point(field_mutable:xla.cpu.BackendConfig.llvm_kernel_options)
  return _msg;
}

inline bool BackendConfig::has_backend_config_oneof() const {
  return backend_config_oneof_case() != BACKEND_CONFIG_ONEOF_NOT_SET;
}
inline void BackendConfig::clear_has_backend_config_oneof() {
  _impl_._oneof_case_[0] = BACKEND_CONFIG_ONEOF_NOT_SET;
}
inline BackendConfig::BackendConfigOneofCase BackendConfig::backend_config_oneof_case() const {
  return BackendConfig::BackendConfigOneofCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace cpu
}  // namespace xla


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // xla_2fservice_2fcpu_2fbackend_5fconfig_2eproto_2epb_2eh
