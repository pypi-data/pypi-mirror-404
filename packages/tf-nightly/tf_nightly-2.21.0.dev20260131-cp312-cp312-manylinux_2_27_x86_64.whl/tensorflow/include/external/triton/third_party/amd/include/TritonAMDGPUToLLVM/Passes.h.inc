/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ALLOCATEAMDGPUSHAREDMEMORY
#define GEN_PASS_DECL_CONVERTBUILTINFUNCTOLLVM
#define GEN_PASS_DECL_CONVERTTRITONAMDGPUTOLLVM
#define GEN_PASS_DECL_CONVERTWARPPIPELINE
#define GEN_PASS_DECL_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM
#define GEN_PASS_DECL_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#define GEN_PASS_DECL_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AllocateAMDGPUSharedMemory
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ALLOCATEAMDGPUSHAREDMEMORY
std::unique_ptr<::mlir::Pass> createAllocateAMDGPUSharedMemory();
#undef GEN_PASS_DECL_ALLOCATEAMDGPUSHAREDMEMORY
#endif // GEN_PASS_DECL_ALLOCATEAMDGPUSHAREDMEMORY
#ifdef GEN_PASS_DEF_ALLOCATEAMDGPUSHAREDMEMORY

namespace impl {
  std::unique_ptr<::mlir::Pass> createAllocateAMDGPUSharedMemory();
} // namespace impl
namespace impl {

template <typename DerivedT>
class AllocateAMDGPUSharedMemoryBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AllocateAMDGPUSharedMemoryBase;

  AllocateAMDGPUSharedMemoryBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AllocateAMDGPUSharedMemoryBase(const AllocateAMDGPUSharedMemoryBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  AllocateAMDGPUSharedMemoryBase& operator=(const AllocateAMDGPUSharedMemoryBase &) = delete;
  AllocateAMDGPUSharedMemoryBase(AllocateAMDGPUSharedMemoryBase &&) = delete;
  AllocateAMDGPUSharedMemoryBase& operator=(AllocateAMDGPUSharedMemoryBase &&) = delete;
  ~AllocateAMDGPUSharedMemoryBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("allocate-amdgpu-shared-memory");
  }
  ::llvm::StringRef getArgument() const override { return "allocate-amdgpu-shared-memory"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Add metadata for shared memory allocation)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AllocateAMDGPUSharedMemory");
  }
  ::llvm::StringRef getName() const override { return "AllocateAMDGPUSharedMemory"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AllocateAMDGPUSharedMemoryBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createAllocateAMDGPUSharedMemory() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createAllocateAMDGPUSharedMemory() {
  return impl::createAllocateAMDGPUSharedMemory();
}
#undef GEN_PASS_DEF_ALLOCATEAMDGPUSHAREDMEMORY
#endif // GEN_PASS_DEF_ALLOCATEAMDGPUSHAREDMEMORY

//===----------------------------------------------------------------------===//
// ConvertBuiltinFuncToLLVM
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTBUILTINFUNCTOLLVM
struct ConvertBuiltinFuncToLLVMOptions {
  bool ftz = true;
};
#undef GEN_PASS_DECL_CONVERTBUILTINFUNCTOLLVM
#endif // GEN_PASS_DECL_CONVERTBUILTINFUNCTOLLVM
#ifdef GEN_PASS_DEF_CONVERTBUILTINFUNCTOLLVM
namespace impl {

template <typename DerivedT>
class ConvertBuiltinFuncToLLVMBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertBuiltinFuncToLLVMBase;

  ConvertBuiltinFuncToLLVMBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertBuiltinFuncToLLVMBase(const ConvertBuiltinFuncToLLVMBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertBuiltinFuncToLLVMBase& operator=(const ConvertBuiltinFuncToLLVMBase &) = delete;
  ConvertBuiltinFuncToLLVMBase(ConvertBuiltinFuncToLLVMBase &&) = delete;
  ConvertBuiltinFuncToLLVMBase& operator=(ConvertBuiltinFuncToLLVMBase &&) = delete;
  ~ConvertBuiltinFuncToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-builtin-func-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-builtin-func-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert Builtin Func to LLVM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertBuiltinFuncToLLVM");
  }
  ::llvm::StringRef getName() const override { return "ConvertBuiltinFuncToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertBuiltinFuncToLLVMBase<DerivedT>)

  ConvertBuiltinFuncToLLVMBase(ConvertBuiltinFuncToLLVMOptions options) : ConvertBuiltinFuncToLLVMBase() {
    ftz = std::move(options.ftz);
  }
protected:
  ::mlir::Pass::Option<bool> ftz{*this, "ftz", ::llvm::cl::desc(R"PO(flush denorms for math functions)PO"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTBUILTINFUNCTOLLVM
#endif // GEN_PASS_DEF_CONVERTBUILTINFUNCTOLLVM

//===----------------------------------------------------------------------===//
// ConvertTritonAMDGPUToLLVM
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTTRITONAMDGPUTOLLVM
struct ConvertTritonAMDGPUToLLVMOptions {
  std::string arch = "";
  bool ftz = true;
};
#undef GEN_PASS_DECL_CONVERTTRITONAMDGPUTOLLVM
#endif // GEN_PASS_DECL_CONVERTTRITONAMDGPUTOLLVM
#ifdef GEN_PASS_DEF_CONVERTTRITONAMDGPUTOLLVM
namespace impl {

template <typename DerivedT>
class ConvertTritonAMDGPUToLLVMBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertTritonAMDGPUToLLVMBase;

  ConvertTritonAMDGPUToLLVMBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertTritonAMDGPUToLLVMBase(const ConvertTritonAMDGPUToLLVMBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertTritonAMDGPUToLLVMBase& operator=(const ConvertTritonAMDGPUToLLVMBase &) = delete;
  ConvertTritonAMDGPUToLLVMBase(ConvertTritonAMDGPUToLLVMBase &&) = delete;
  ConvertTritonAMDGPUToLLVMBase& operator=(ConvertTritonAMDGPUToLLVMBase &&) = delete;
  ~ConvertTritonAMDGPUToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-triton-amdgpu-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "convert-triton-amdgpu-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert TritonGPU to LLVM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertTritonAMDGPUToLLVM");
  }
  ::llvm::StringRef getName() const override { return "ConvertTritonAMDGPUToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::triton::TritonDialect>();
    registry.insert<mlir::triton::gpu::TritonGPUDialect>();
    registry.insert<mlir::ROCDL::ROCDLDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertTritonAMDGPUToLLVMBase<DerivedT>)

  ConvertTritonAMDGPUToLLVMBase(ConvertTritonAMDGPUToLLVMOptions options) : ConvertTritonAMDGPUToLLVMBase() {
    arch = std::move(options.arch);
    ftz = std::move(options.ftz);
  }
protected:
  ::mlir::Pass::Option<std::string> arch{*this, "arch", ::llvm::cl::desc(R"PO(gfx target device architecture, e.g., gfx942)PO"), ::llvm::cl::init("")};
  ::mlir::Pass::Option<bool> ftz{*this, "ftz", ::llvm::cl::desc(R"PO(flush denorms for math functions)PO"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTTRITONAMDGPUTOLLVM
#endif // GEN_PASS_DEF_CONVERTTRITONAMDGPUTOLLVM

//===----------------------------------------------------------------------===//
// ConvertWarpPipeline
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTWARPPIPELINE
#undef GEN_PASS_DECL_CONVERTWARPPIPELINE
#endif // GEN_PASS_DECL_CONVERTWARPPIPELINE
#ifdef GEN_PASS_DEF_CONVERTWARPPIPELINE
namespace impl {

template <typename DerivedT>
class ConvertWarpPipelineBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertWarpPipelineBase;

  ConvertWarpPipelineBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertWarpPipelineBase(const ConvertWarpPipelineBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertWarpPipelineBase& operator=(const ConvertWarpPipelineBase &) = delete;
  ConvertWarpPipelineBase(ConvertWarpPipelineBase &&) = delete;
  ConvertWarpPipelineBase& operator=(ConvertWarpPipelineBase &&) = delete;
  ~ConvertWarpPipelineBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-warp-pipeline");
  }
  ::llvm::StringRef getArgument() const override { return "convert-warp-pipeline"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Emit conditional barrier and inlines scf.execute_region for warp-pipeline)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertWarpPipeline");
  }
  ::llvm::StringRef getName() const override { return "ConvertWarpPipeline"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::ROCDL::ROCDLDialect>();
    registry.insert<mlir::triton::amdgpu::TritonAMDGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertWarpPipelineBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTWARPPIPELINE
#endif // GEN_PASS_DEF_CONVERTWARPPIPELINE

//===----------------------------------------------------------------------===//
// TritonAMDGPUConvertWarpSpecializeToLLVM
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM
struct TritonAMDGPUConvertWarpSpecializeToLLVMOptions {
  std::string arch = "";
};
#undef GEN_PASS_DECL_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM
#endif // GEN_PASS_DECL_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM
#ifdef GEN_PASS_DEF_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM
namespace impl {

template <typename DerivedT>
class TritonAMDGPUConvertWarpSpecializeToLLVMBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonAMDGPUConvertWarpSpecializeToLLVMBase;

  TritonAMDGPUConvertWarpSpecializeToLLVMBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonAMDGPUConvertWarpSpecializeToLLVMBase(const TritonAMDGPUConvertWarpSpecializeToLLVMBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonAMDGPUConvertWarpSpecializeToLLVMBase& operator=(const TritonAMDGPUConvertWarpSpecializeToLLVMBase &) = delete;
  TritonAMDGPUConvertWarpSpecializeToLLVMBase(TritonAMDGPUConvertWarpSpecializeToLLVMBase &&) = delete;
  TritonAMDGPUConvertWarpSpecializeToLLVMBase& operator=(TritonAMDGPUConvertWarpSpecializeToLLVMBase &&) = delete;
  ~TritonAMDGPUConvertWarpSpecializeToLLVMBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-amdgpu-convert-warp-specialize-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "triton-amdgpu-convert-warp-specialize-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return R"PD(lower `ttg.warp_specialize` to LLVM)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonAMDGPUConvertWarpSpecializeToLLVM");
  }
  ::llvm::StringRef getName() const override { return "TritonAMDGPUConvertWarpSpecializeToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::ROCDL::ROCDLDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonAMDGPUConvertWarpSpecializeToLLVMBase<DerivedT>)

  TritonAMDGPUConvertWarpSpecializeToLLVMBase(TritonAMDGPUConvertWarpSpecializeToLLVMOptions options) : TritonAMDGPUConvertWarpSpecializeToLLVMBase() {
    arch = std::move(options.arch);
  }
protected:
  ::mlir::Pass::Option<std::string> arch{*this, "arch", ::llvm::cl::desc(R"PO(target device architecture, e.g., gfx1250)PO"), ::llvm::cl::init("")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM
#endif // GEN_PASS_DEF_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM

//===----------------------------------------------------------------------===//
// TritonAMDGPUInsertInstructionSchedHints
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
struct TritonAMDGPUInsertInstructionSchedHintsOptions {
  std::string variant = "none";
};
#undef GEN_PASS_DECL_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_DECL_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#ifdef GEN_PASS_DEF_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
namespace impl {

template <typename DerivedT>
class TritonAMDGPUInsertInstructionSchedHintsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonAMDGPUInsertInstructionSchedHintsBase;

  TritonAMDGPUInsertInstructionSchedHintsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonAMDGPUInsertInstructionSchedHintsBase(const TritonAMDGPUInsertInstructionSchedHintsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonAMDGPUInsertInstructionSchedHintsBase& operator=(const TritonAMDGPUInsertInstructionSchedHintsBase &) = delete;
  TritonAMDGPUInsertInstructionSchedHintsBase(TritonAMDGPUInsertInstructionSchedHintsBase &&) = delete;
  TritonAMDGPUInsertInstructionSchedHintsBase& operator=(TritonAMDGPUInsertInstructionSchedHintsBase &&) = delete;
  ~TritonAMDGPUInsertInstructionSchedHintsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-amdgpu-insert-instruction-sched-hints");
  }
  ::llvm::StringRef getArgument() const override { return "triton-amdgpu-insert-instruction-sched-hints"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Insert instruction scheduling hints after the dot ops in the main loop)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonAMDGPUInsertInstructionSchedHints");
  }
  ::llvm::StringRef getName() const override { return "TritonAMDGPUInsertInstructionSchedHints"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::triton::amdgpu::TritonAMDGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonAMDGPUInsertInstructionSchedHintsBase<DerivedT>)

  TritonAMDGPUInsertInstructionSchedHintsBase(TritonAMDGPUInsertInstructionSchedHintsOptions options) : TritonAMDGPUInsertInstructionSchedHintsBase() {
    variant = std::move(options.variant);
  }
protected:
  ::mlir::Pass::Option<std::string> variant{*this, "variant", ::llvm::cl::desc(R"PO(instruction scheduling variant)PO"), ::llvm::cl::init("none")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_DEF_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS

//===----------------------------------------------------------------------===//
// TritonAMDGPULowerInstructionSchedHints
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
struct TritonAMDGPULowerInstructionSchedHintsOptions {
  std::string arch = "";
  int32_t numStages = 2;
};
#undef GEN_PASS_DECL_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_DECL_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#ifdef GEN_PASS_DEF_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
namespace impl {

template <typename DerivedT>
class TritonAMDGPULowerInstructionSchedHintsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonAMDGPULowerInstructionSchedHintsBase;

  TritonAMDGPULowerInstructionSchedHintsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonAMDGPULowerInstructionSchedHintsBase(const TritonAMDGPULowerInstructionSchedHintsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonAMDGPULowerInstructionSchedHintsBase& operator=(const TritonAMDGPULowerInstructionSchedHintsBase &) = delete;
  TritonAMDGPULowerInstructionSchedHintsBase(TritonAMDGPULowerInstructionSchedHintsBase &&) = delete;
  TritonAMDGPULowerInstructionSchedHintsBase& operator=(TritonAMDGPULowerInstructionSchedHintsBase &&) = delete;
  ~TritonAMDGPULowerInstructionSchedHintsBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-amdgpu-lower-insert-instruction-sched-hints");
  }
  ::llvm::StringRef getArgument() const override { return "triton-amdgpu-lower-insert-instruction-sched-hints"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower instruction scheduling hints to LLVM intrinsics)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonAMDGPULowerInstructionSchedHints");
  }
  ::llvm::StringRef getName() const override { return "TritonAMDGPULowerInstructionSchedHints"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::ROCDL::ROCDLDialect>();
    registry.insert<mlir::triton::amdgpu::TritonAMDGPUDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonAMDGPULowerInstructionSchedHintsBase<DerivedT>)

  TritonAMDGPULowerInstructionSchedHintsBase(TritonAMDGPULowerInstructionSchedHintsOptions options) : TritonAMDGPULowerInstructionSchedHintsBase() {
    arch = std::move(options.arch);
    numStages = std::move(options.numStages);
  }
protected:
  ::mlir::Pass::Option<std::string> arch{*this, "arch", ::llvm::cl::desc(R"PO(gfx target device architecture, e.g., gfx942)PO"), ::llvm::cl::init("")};
  ::mlir::Pass::Option<int32_t> numStages{*this, "num_stages", ::llvm::cl::desc(R"PO(number of pipeline stages)PO"), ::llvm::cl::init(2)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_DEF_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#ifdef GEN_PASS_REGISTRATION
// Generate registrations for all passes.
#define GEN_PASS_REGISTRATION_ALLOCATEAMDGPUSHAREDMEMORY
#define GEN_PASS_REGISTRATION_CONVERTBUILTINFUNCTOLLVM
#define GEN_PASS_REGISTRATION_CONVERTTRITONAMDGPUTOLLVM
#define GEN_PASS_REGISTRATION_CONVERTWARPPIPELINE
#define GEN_PASS_REGISTRATION_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM
#define GEN_PASS_REGISTRATION_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#define GEN_PASS_REGISTRATION_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AllocateAMDGPUSharedMemory Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_ALLOCATEAMDGPUSHAREDMEMORY

inline void registerAllocateAMDGPUSharedMemory() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAllocateAMDGPUSharedMemory();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAllocateAMDGPUSharedMemoryPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAllocateAMDGPUSharedMemory();
  });
}

#undef GEN_PASS_REGISTRATION_ALLOCATEAMDGPUSHAREDMEMORY
#endif // GEN_PASS_REGISTRATION_ALLOCATEAMDGPUSHAREDMEMORY

//===----------------------------------------------------------------------===//
// ConvertBuiltinFuncToLLVM Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_CONVERTBUILTINFUNCTOLLVM

inline void registerConvertBuiltinFuncToLLVM() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createConvertBuiltinFuncToLLVMPass(/*ftz=*/true);
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertBuiltinFuncToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createConvertBuiltinFuncToLLVMPass(/*ftz=*/true);
  });
}

#undef GEN_PASS_REGISTRATION_CONVERTBUILTINFUNCTOLLVM
#endif // GEN_PASS_REGISTRATION_CONVERTBUILTINFUNCTOLLVM

//===----------------------------------------------------------------------===//
// ConvertTritonAMDGPUToLLVM Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_CONVERTTRITONAMDGPUTOLLVM

inline void registerConvertTritonAMDGPUToLLVM() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createConvertTritonAMDGPUToLLVMPass("", /*ftz=*/true);
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertTritonAMDGPUToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createConvertTritonAMDGPUToLLVMPass("", /*ftz=*/true);
  });
}

#undef GEN_PASS_REGISTRATION_CONVERTTRITONAMDGPUTOLLVM
#endif // GEN_PASS_REGISTRATION_CONVERTTRITONAMDGPUTOLLVM

//===----------------------------------------------------------------------===//
// ConvertWarpPipeline Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_CONVERTWARPPIPELINE

inline void registerConvertWarpPipeline() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::AMD::createConvertWarpPipelinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertWarpPipelinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::AMD::createConvertWarpPipelinePass();
  });
}

#undef GEN_PASS_REGISTRATION_CONVERTWARPPIPELINE
#endif // GEN_PASS_REGISTRATION_CONVERTWARPPIPELINE

//===----------------------------------------------------------------------===//
// TritonAMDGPUConvertWarpSpecializeToLLVM Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM

inline void registerTritonAMDGPUConvertWarpSpecializeToLLVM() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::AMD::createTritonAMDGPUConvertWarpSpecializeToLLVMPass("");
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonAMDGPUConvertWarpSpecializeToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::AMD::createTritonAMDGPUConvertWarpSpecializeToLLVMPass("");
  });
}

#undef GEN_PASS_REGISTRATION_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM
#endif // GEN_PASS_REGISTRATION_TRITONAMDGPUCONVERTWARPSPECIALIZETOLLVM

//===----------------------------------------------------------------------===//
// TritonAMDGPUInsertInstructionSchedHints Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS

inline void registerTritonAMDGPUInsertInstructionSchedHints() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createTritonAMDGPUInsertInstructionSchedHintsPass(/*variant=*/"");
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonAMDGPUInsertInstructionSchedHintsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createTritonAMDGPUInsertInstructionSchedHintsPass(/*variant=*/"");
  });
}

#undef GEN_PASS_REGISTRATION_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_REGISTRATION_TRITONAMDGPUINSERTINSTRUCTIONSCHEDHINTS

//===----------------------------------------------------------------------===//
// TritonAMDGPULowerInstructionSchedHints Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS

inline void registerTritonAMDGPULowerInstructionSchedHints() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createTritonAMDGPULowerInstructionSchedHintsPass(/*arch=*/"",/*numStages=*/2);
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonAMDGPULowerInstructionSchedHintsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::triton::createTritonAMDGPULowerInstructionSchedHintsPass(/*arch=*/"",/*numStages=*/2);
  });
}

#undef GEN_PASS_REGISTRATION_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#endif // GEN_PASS_REGISTRATION_TRITONAMDGPULOWERINSTRUCTIONSCHEDHINTS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// TritonAMDGPUToLLVM Registration
//===----------------------------------------------------------------------===//

inline void registerTritonAMDGPUToLLVMPasses() {
  registerAllocateAMDGPUSharedMemory();
  registerConvertBuiltinFuncToLLVM();
  registerConvertTritonAMDGPUToLLVM();
  registerConvertWarpPipeline();
  registerTritonAMDGPUConvertWarpSpecializeToLLVM();
  registerTritonAMDGPUInsertInstructionSchedHints();
  registerTritonAMDGPULowerInstructionSchedHints();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
#ifdef GEN_PASS_CLASSES
#error "GEN_PASS_CLASSES is deprecated; use per-pass macros"
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
