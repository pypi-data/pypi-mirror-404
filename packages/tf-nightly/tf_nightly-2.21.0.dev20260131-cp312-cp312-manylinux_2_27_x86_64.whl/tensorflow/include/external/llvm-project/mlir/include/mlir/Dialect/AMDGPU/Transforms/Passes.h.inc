/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_AMDGPUEMULATEATOMICSPASS
#define GEN_PASS_DECL_AMDGPUFOLDMEMREFOPSPASS
#define GEN_PASS_DECL_AMDGPUMASKEDLOADTOLOADPASS
#define GEN_PASS_DECL_AMDGPURESOLVESTRIDEDMETADATAPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AmdgpuEmulateAtomicsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_AMDGPUEMULATEATOMICSPASS
struct AmdgpuEmulateAtomicsPassOptions {
  std::string chipset = "gfx000";
};
std::unique_ptr<::mlir::Pass> createAmdgpuEmulateAtomicsPass();
std::unique_ptr<::mlir::Pass> createAmdgpuEmulateAtomicsPass(AmdgpuEmulateAtomicsPassOptions options);
#undef GEN_PASS_DECL_AMDGPUEMULATEATOMICSPASS
#endif // GEN_PASS_DECL_AMDGPUEMULATEATOMICSPASS
#ifdef GEN_PASS_DEF_AMDGPUEMULATEATOMICSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createAmdgpuEmulateAtomicsPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createAmdgpuEmulateAtomicsPass(AmdgpuEmulateAtomicsPassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class AmdgpuEmulateAtomicsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AmdgpuEmulateAtomicsPassBase;

  AmdgpuEmulateAtomicsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AmdgpuEmulateAtomicsPassBase(const AmdgpuEmulateAtomicsPassBase &other) : ::mlir::OperationPass<>(other) {}
  AmdgpuEmulateAtomicsPassBase& operator=(const AmdgpuEmulateAtomicsPassBase &) = delete;
  AmdgpuEmulateAtomicsPassBase(AmdgpuEmulateAtomicsPassBase &&) = delete;
  AmdgpuEmulateAtomicsPassBase& operator=(AmdgpuEmulateAtomicsPassBase &&) = delete;
  ~AmdgpuEmulateAtomicsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("amdgpu-emulate-atomics");
  }
  ::llvm::StringRef getArgument() const override { return "amdgpu-emulate-atomics"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Emulate atomic operations on chipsets that do not support them)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AmdgpuEmulateAtomicsPass");
  }
  ::llvm::StringRef getName() const override { return "AmdgpuEmulateAtomicsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<cf::ControlFlowDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AmdgpuEmulateAtomicsPassBase<DerivedT>)

  AmdgpuEmulateAtomicsPassBase(AmdgpuEmulateAtomicsPassOptions options) : AmdgpuEmulateAtomicsPassBase() {
    chipset = std::move(options.chipset);
  }
protected:
  ::mlir::Pass::Option<std::string> chipset{*this, "chipset", ::llvm::cl::desc(R"PO(Chipset that these operations will run on)PO"), ::llvm::cl::init("gfx000")};
private:

  friend std::unique_ptr<::mlir::Pass> createAmdgpuEmulateAtomicsPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createAmdgpuEmulateAtomicsPass(AmdgpuEmulateAtomicsPassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createAmdgpuEmulateAtomicsPass() {
  return impl::createAmdgpuEmulateAtomicsPass();
}

std::unique_ptr<::mlir::Pass> createAmdgpuEmulateAtomicsPass(AmdgpuEmulateAtomicsPassOptions options) {
  return impl::createAmdgpuEmulateAtomicsPass(std::move(options));
}
#undef GEN_PASS_DEF_AMDGPUEMULATEATOMICSPASS
#endif // GEN_PASS_DEF_AMDGPUEMULATEATOMICSPASS

//===----------------------------------------------------------------------===//
// AmdgpuFoldMemRefOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_AMDGPUFOLDMEMREFOPSPASS
std::unique_ptr<::mlir::Pass> createAmdgpuFoldMemRefOpsPass();
#undef GEN_PASS_DECL_AMDGPUFOLDMEMREFOPSPASS
#endif // GEN_PASS_DECL_AMDGPUFOLDMEMREFOPSPASS
#ifdef GEN_PASS_DEF_AMDGPUFOLDMEMREFOPSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createAmdgpuFoldMemRefOpsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class AmdgpuFoldMemRefOpsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AmdgpuFoldMemRefOpsPassBase;

  AmdgpuFoldMemRefOpsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AmdgpuFoldMemRefOpsPassBase(const AmdgpuFoldMemRefOpsPassBase &other) : ::mlir::OperationPass<>(other) {}
  AmdgpuFoldMemRefOpsPassBase& operator=(const AmdgpuFoldMemRefOpsPassBase &) = delete;
  AmdgpuFoldMemRefOpsPassBase(AmdgpuFoldMemRefOpsPassBase &&) = delete;
  AmdgpuFoldMemRefOpsPassBase& operator=(AmdgpuFoldMemRefOpsPassBase &&) = delete;
  ~AmdgpuFoldMemRefOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("amdgpu-fold-memrefs-ops");
  }
  ::llvm::StringRef getArgument() const override { return "amdgpu-fold-memrefs-ops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Fold memref operations into their parent operations)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AmdgpuFoldMemRefOpsPass");
  }
  ::llvm::StringRef getName() const override { return "AmdgpuFoldMemRefOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AmdgpuFoldMemRefOpsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createAmdgpuFoldMemRefOpsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createAmdgpuFoldMemRefOpsPass() {
  return impl::createAmdgpuFoldMemRefOpsPass();
}
#undef GEN_PASS_DEF_AMDGPUFOLDMEMREFOPSPASS
#endif // GEN_PASS_DEF_AMDGPUFOLDMEMREFOPSPASS

//===----------------------------------------------------------------------===//
// AmdgpuMaskedloadToLoadPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_AMDGPUMASKEDLOADTOLOADPASS
std::unique_ptr<::mlir::Pass> createAmdgpuMaskedloadToLoadPass();
#undef GEN_PASS_DECL_AMDGPUMASKEDLOADTOLOADPASS
#endif // GEN_PASS_DECL_AMDGPUMASKEDLOADTOLOADPASS
#ifdef GEN_PASS_DEF_AMDGPUMASKEDLOADTOLOADPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createAmdgpuMaskedloadToLoadPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class AmdgpuMaskedloadToLoadPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AmdgpuMaskedloadToLoadPassBase;

  AmdgpuMaskedloadToLoadPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AmdgpuMaskedloadToLoadPassBase(const AmdgpuMaskedloadToLoadPassBase &other) : ::mlir::OperationPass<>(other) {}
  AmdgpuMaskedloadToLoadPassBase& operator=(const AmdgpuMaskedloadToLoadPassBase &) = delete;
  AmdgpuMaskedloadToLoadPassBase(AmdgpuMaskedloadToLoadPassBase &&) = delete;
  AmdgpuMaskedloadToLoadPassBase& operator=(AmdgpuMaskedloadToLoadPassBase &&) = delete;
  ~AmdgpuMaskedloadToLoadPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("amdgpu-maskedload-to-load");
  }
  ::llvm::StringRef getArgument() const override { return "amdgpu-maskedload-to-load"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower the operations from the vector maskedload to vector load)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AmdgpuMaskedloadToLoadPass");
  }
  ::llvm::StringRef getName() const override { return "AmdgpuMaskedloadToLoadPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<scf::SCFDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AmdgpuMaskedloadToLoadPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createAmdgpuMaskedloadToLoadPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createAmdgpuMaskedloadToLoadPass() {
  return impl::createAmdgpuMaskedloadToLoadPass();
}
#undef GEN_PASS_DEF_AMDGPUMASKEDLOADTOLOADPASS
#endif // GEN_PASS_DEF_AMDGPUMASKEDLOADTOLOADPASS

//===----------------------------------------------------------------------===//
// AmdgpuResolveStridedMetadataPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_AMDGPURESOLVESTRIDEDMETADATAPASS
std::unique_ptr<::mlir::Pass> createAmdgpuResolveStridedMetadataPass();
#undef GEN_PASS_DECL_AMDGPURESOLVESTRIDEDMETADATAPASS
#endif // GEN_PASS_DECL_AMDGPURESOLVESTRIDEDMETADATAPASS
#ifdef GEN_PASS_DEF_AMDGPURESOLVESTRIDEDMETADATAPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createAmdgpuResolveStridedMetadataPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class AmdgpuResolveStridedMetadataPassBase : public ::mlir::OperationPass<> {
public:
  using Base = AmdgpuResolveStridedMetadataPassBase;

  AmdgpuResolveStridedMetadataPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AmdgpuResolveStridedMetadataPassBase(const AmdgpuResolveStridedMetadataPassBase &other) : ::mlir::OperationPass<>(other) {}
  AmdgpuResolveStridedMetadataPassBase& operator=(const AmdgpuResolveStridedMetadataPassBase &) = delete;
  AmdgpuResolveStridedMetadataPassBase(AmdgpuResolveStridedMetadataPassBase &&) = delete;
  AmdgpuResolveStridedMetadataPassBase& operator=(AmdgpuResolveStridedMetadataPassBase &&) = delete;
  ~AmdgpuResolveStridedMetadataPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("amdgpu-resolve-strided-metadata");
  }
  ::llvm::StringRef getArgument() const override { return "amdgpu-resolve-strided-metadata"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Resolve memref.extract_strided_metadata on AMDGPU ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AmdgpuResolveStridedMetadataPass");
  }
  ::llvm::StringRef getName() const override { return "AmdgpuResolveStridedMetadataPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AmdgpuResolveStridedMetadataPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createAmdgpuResolveStridedMetadataPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createAmdgpuResolveStridedMetadataPass() {
  return impl::createAmdgpuResolveStridedMetadataPass();
}
#undef GEN_PASS_DEF_AMDGPURESOLVESTRIDEDMETADATAPASS
#endif // GEN_PASS_DEF_AMDGPURESOLVESTRIDEDMETADATAPASS
#ifdef GEN_PASS_REGISTRATION
// Generate registrations for all passes.
#define GEN_PASS_REGISTRATION_AMDGPUEMULATEATOMICSPASS
#define GEN_PASS_REGISTRATION_AMDGPUFOLDMEMREFOPSPASS
#define GEN_PASS_REGISTRATION_AMDGPUMASKEDLOADTOLOADPASS
#define GEN_PASS_REGISTRATION_AMDGPURESOLVESTRIDEDMETADATAPASS
#endif // GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AmdgpuEmulateAtomicsPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_AMDGPUEMULATEATOMICSPASS

inline void registerAmdgpuEmulateAtomicsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAmdgpuEmulateAtomicsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAmdgpuEmulateAtomicsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAmdgpuEmulateAtomicsPass();
  });
}

#undef GEN_PASS_REGISTRATION_AMDGPUEMULATEATOMICSPASS
#endif // GEN_PASS_REGISTRATION_AMDGPUEMULATEATOMICSPASS

//===----------------------------------------------------------------------===//
// AmdgpuFoldMemRefOpsPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_AMDGPUFOLDMEMREFOPSPASS

inline void registerAmdgpuFoldMemRefOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAmdgpuFoldMemRefOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAmdgpuFoldMemRefOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAmdgpuFoldMemRefOpsPass();
  });
}

#undef GEN_PASS_REGISTRATION_AMDGPUFOLDMEMREFOPSPASS
#endif // GEN_PASS_REGISTRATION_AMDGPUFOLDMEMREFOPSPASS

//===----------------------------------------------------------------------===//
// AmdgpuMaskedloadToLoadPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_AMDGPUMASKEDLOADTOLOADPASS

inline void registerAmdgpuMaskedloadToLoadPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAmdgpuMaskedloadToLoadPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAmdgpuMaskedloadToLoadPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAmdgpuMaskedloadToLoadPass();
  });
}

#undef GEN_PASS_REGISTRATION_AMDGPUMASKEDLOADTOLOADPASS
#endif // GEN_PASS_REGISTRATION_AMDGPUMASKEDLOADTOLOADPASS

//===----------------------------------------------------------------------===//
// AmdgpuResolveStridedMetadataPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_AMDGPURESOLVESTRIDEDMETADATAPASS

inline void registerAmdgpuResolveStridedMetadataPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAmdgpuResolveStridedMetadataPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAmdgpuResolveStridedMetadataPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createAmdgpuResolveStridedMetadataPass();
  });
}

#undef GEN_PASS_REGISTRATION_AMDGPURESOLVESTRIDEDMETADATAPASS
#endif // GEN_PASS_REGISTRATION_AMDGPURESOLVESTRIDEDMETADATAPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AMDGPU Registration
//===----------------------------------------------------------------------===//

inline void registerAMDGPUPasses() {
  registerAmdgpuEmulateAtomicsPass();
  registerAmdgpuFoldMemRefOpsPass();
  registerAmdgpuMaskedloadToLoadPass();
  registerAmdgpuResolveStridedMetadataPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
#ifdef GEN_PASS_CLASSES
#error "GEN_PASS_CLASSES is deprecated; use per-pass macros"
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
