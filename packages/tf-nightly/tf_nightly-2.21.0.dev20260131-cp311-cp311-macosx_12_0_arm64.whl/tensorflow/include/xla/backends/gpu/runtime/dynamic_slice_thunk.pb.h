// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: xla/backends/gpu/runtime/dynamic_slice_thunk.proto
// Protobuf C++ Version: 6.31.1

#ifndef xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto_2epb_2eh
#define xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "xla/service/buffer_assignment.pb.h"
#include "xla/xla.pb.h"
#include "xla/xla_data.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto PROTOBUF_EXPORT

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct PROTOBUF_EXPORT TableStruct_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
PROTOBUF_EXPORT extern const ::google::protobuf::internal::DescriptorTable descriptor_table_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto;
}  // extern "C"
namespace xla {
namespace gpu {
class OffsetAsFunctionOfIndvarModulesMetadataProto;
struct OffsetAsFunctionOfIndvarModulesMetadataProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OffsetAsFunctionOfIndvarModulesMetadataProtoDefaultTypeInternal _OffsetAsFunctionOfIndvarModulesMetadataProto_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OffsetAsFunctionOfIndvarModulesMetadataProto_class_data_;
class OptionalBufferAllocationSliceProto;
struct OptionalBufferAllocationSliceProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OptionalBufferAllocationSliceProtoDefaultTypeInternal _OptionalBufferAllocationSliceProto_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalBufferAllocationSliceProto_class_data_;
class OptionalDynamicSliceOffsetsProto;
struct OptionalDynamicSliceOffsetsProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OptionalDynamicSliceOffsetsProtoDefaultTypeInternal _OptionalDynamicSliceOffsetsProto_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalDynamicSliceOffsetsProto_class_data_;
class OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto;
struct OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProtoDefaultTypeInternal _OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto_class_data_;
class OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto;
struct OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProtoDefaultTypeInternal _OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto_class_data_;
class OptionalPrimitiveType;
struct OptionalPrimitiveTypeDefaultTypeInternal;
PROTOBUF_EXPORT extern OptionalPrimitiveTypeDefaultTypeInternal _OptionalPrimitiveType_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalPrimitiveType_class_data_;
class OptionalShapeProto;
struct OptionalShapeProtoDefaultTypeInternal;
PROTOBUF_EXPORT extern OptionalShapeProtoDefaultTypeInternal _OptionalShapeProto_default_instance_;
PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalShapeProto_class_data_;
}  // namespace gpu
}  // namespace xla
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace xla {
namespace gpu {

// ===================================================================


// -------------------------------------------------------------------

class PROTOBUF_EXPORT OptionalPrimitiveType final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.gpu.OptionalPrimitiveType) */ {
 public:
  inline OptionalPrimitiveType() : OptionalPrimitiveType(nullptr) {}
  ~OptionalPrimitiveType() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OptionalPrimitiveType* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OptionalPrimitiveType));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptionalPrimitiveType(::google::protobuf::internal::ConstantInitialized);

  inline OptionalPrimitiveType(const OptionalPrimitiveType& from) : OptionalPrimitiveType(nullptr, from) {}
  inline OptionalPrimitiveType(OptionalPrimitiveType&& from) noexcept
      : OptionalPrimitiveType(nullptr, ::std::move(from)) {}
  inline OptionalPrimitiveType& operator=(const OptionalPrimitiveType& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalPrimitiveType& operator=(OptionalPrimitiveType&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalPrimitiveType& default_instance() {
    return *reinterpret_cast<const OptionalPrimitiveType*>(
        &_OptionalPrimitiveType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(OptionalPrimitiveType& a, OptionalPrimitiveType& b) { a.Swap(&b); }
  inline void Swap(OptionalPrimitiveType* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalPrimitiveType* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalPrimitiveType* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OptionalPrimitiveType>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptionalPrimitiveType& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptionalPrimitiveType& from) { OptionalPrimitiveType::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OptionalPrimitiveType* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.gpu.OptionalPrimitiveType"; }

 protected:
  explicit OptionalPrimitiveType(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OptionalPrimitiveType(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OptionalPrimitiveType& from);
  OptionalPrimitiveType(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OptionalPrimitiveType&& from) noexcept
      : OptionalPrimitiveType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // optional .xla.PrimitiveType value = 1;
  bool has_value() const;
  void clear_value() ;
  ::xla::PrimitiveType value() const;
  void set_value(::xla::PrimitiveType value);

  private:
  ::xla::PrimitiveType _internal_value() const;
  void _internal_set_value(::xla::PrimitiveType value);

  public:
  // @@protoc_insertion_point(class_scope:xla.gpu.OptionalPrimitiveType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OptionalPrimitiveType& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalPrimitiveType_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto) */ {
 public:
  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto() : OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(nullptr) {}
  ~OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(::google::protobuf::internal::ConstantInitialized);

  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& from) : OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(nullptr, from) {}
  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto&& from) noexcept
      : OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(nullptr, ::std::move(from)) {}
  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& operator=(const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& operator=(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& default_instance() {
    return *reinterpret_cast<const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto*>(
        &_OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto_default_instance_);
  }
  enum OffsetCase {
    kConstOffset = 1,
    kSliceOffset = 2,
    kHloModuleOffsetIdx = 3,
    OFFSET_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& a, OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& b) { a.Swap(&b); }
  inline void Swap(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& from) { OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto"; }

 protected:
  explicit OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& from);
  OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto&& from) noexcept
      : OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConstOffsetFieldNumber = 1,
    kSliceOffsetFieldNumber = 2,
    kHloModuleOffsetIdxFieldNumber = 3,
  };
  // int64 const_offset = 1;
  bool has_const_offset() const;
  void clear_const_offset() ;
  ::int64_t const_offset() const;
  void set_const_offset(::int64_t value);

  private:
  ::int64_t _internal_const_offset() const;
  void _internal_set_const_offset(::int64_t value);

  public:
  // .xla.buffer_assignment.BufferAllocationSliceProto slice_offset = 2;
  bool has_slice_offset() const;
  private:
  bool _internal_has_slice_offset() const;

  public:
  void clear_slice_offset() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& slice_offset() const;
  [[nodiscard]] ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE release_slice_offset();
  ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NONNULL mutable_slice_offset();
  void set_allocated_slice_offset(::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_slice_offset(::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE unsafe_arena_release_slice_offset();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_slice_offset() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NONNULL _internal_mutable_slice_offset();

  public:
  // int64 hlo_module_offset_idx = 3;
  bool has_hlo_module_offset_idx() const;
  void clear_hlo_module_offset_idx() ;
  ::int64_t hlo_module_offset_idx() const;
  void set_hlo_module_offset_idx(::int64_t value);

  private:
  ::int64_t _internal_hlo_module_offset_idx() const;
  void _internal_set_hlo_module_offset_idx(::int64_t value);

  public:
  void clear_offset();
  OffsetCase offset_case() const;
  // @@protoc_insertion_point(class_scope:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto)
 private:
  class _Internal;
  void set_has_const_offset();
  void set_has_slice_offset();
  void set_has_hlo_module_offset_idx();
  inline bool has_offset() const;
  inline void clear_has_offset();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 3,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& from_msg);
    union OffsetUnion {
      constexpr OffsetUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t const_offset_;
      ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE slice_offset_;
      ::int64_t hlo_module_offset_idx_;
    } offset_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OptionalBufferAllocationSliceProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.gpu.OptionalBufferAllocationSliceProto) */ {
 public:
  inline OptionalBufferAllocationSliceProto() : OptionalBufferAllocationSliceProto(nullptr) {}
  ~OptionalBufferAllocationSliceProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OptionalBufferAllocationSliceProto* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OptionalBufferAllocationSliceProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptionalBufferAllocationSliceProto(::google::protobuf::internal::ConstantInitialized);

  inline OptionalBufferAllocationSliceProto(const OptionalBufferAllocationSliceProto& from) : OptionalBufferAllocationSliceProto(nullptr, from) {}
  inline OptionalBufferAllocationSliceProto(OptionalBufferAllocationSliceProto&& from) noexcept
      : OptionalBufferAllocationSliceProto(nullptr, ::std::move(from)) {}
  inline OptionalBufferAllocationSliceProto& operator=(const OptionalBufferAllocationSliceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalBufferAllocationSliceProto& operator=(OptionalBufferAllocationSliceProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalBufferAllocationSliceProto& default_instance() {
    return *reinterpret_cast<const OptionalBufferAllocationSliceProto*>(
        &_OptionalBufferAllocationSliceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(OptionalBufferAllocationSliceProto& a, OptionalBufferAllocationSliceProto& b) { a.Swap(&b); }
  inline void Swap(OptionalBufferAllocationSliceProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalBufferAllocationSliceProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalBufferAllocationSliceProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OptionalBufferAllocationSliceProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptionalBufferAllocationSliceProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptionalBufferAllocationSliceProto& from) { OptionalBufferAllocationSliceProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OptionalBufferAllocationSliceProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.gpu.OptionalBufferAllocationSliceProto"; }

 protected:
  explicit OptionalBufferAllocationSliceProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OptionalBufferAllocationSliceProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OptionalBufferAllocationSliceProto& from);
  OptionalBufferAllocationSliceProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OptionalBufferAllocationSliceProto&& from) noexcept
      : OptionalBufferAllocationSliceProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSliceFieldNumber = 1,
  };
  // optional .xla.buffer_assignment.BufferAllocationSliceProto slice = 1;
  bool has_slice() const;
  void clear_slice() ;
  const ::xla::buffer_assignment::BufferAllocationSliceProto& slice() const;
  [[nodiscard]] ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE release_slice();
  ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NONNULL mutable_slice();
  void set_allocated_slice(::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_slice(::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE value);
  ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE unsafe_arena_release_slice();

  private:
  const ::xla::buffer_assignment::BufferAllocationSliceProto& _internal_slice() const;
  ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NONNULL _internal_mutable_slice();

  public:
  // @@protoc_insertion_point(class_scope:xla.gpu.OptionalBufferAllocationSliceProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OptionalBufferAllocationSliceProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE slice_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalBufferAllocationSliceProto_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OptionalShapeProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.gpu.OptionalShapeProto) */ {
 public:
  inline OptionalShapeProto() : OptionalShapeProto(nullptr) {}
  ~OptionalShapeProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OptionalShapeProto* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OptionalShapeProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptionalShapeProto(::google::protobuf::internal::ConstantInitialized);

  inline OptionalShapeProto(const OptionalShapeProto& from) : OptionalShapeProto(nullptr, from) {}
  inline OptionalShapeProto(OptionalShapeProto&& from) noexcept
      : OptionalShapeProto(nullptr, ::std::move(from)) {}
  inline OptionalShapeProto& operator=(const OptionalShapeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalShapeProto& operator=(OptionalShapeProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalShapeProto& default_instance() {
    return *reinterpret_cast<const OptionalShapeProto*>(
        &_OptionalShapeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(OptionalShapeProto& a, OptionalShapeProto& b) { a.Swap(&b); }
  inline void Swap(OptionalShapeProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalShapeProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalShapeProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OptionalShapeProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptionalShapeProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptionalShapeProto& from) { OptionalShapeProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OptionalShapeProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.gpu.OptionalShapeProto"; }

 protected:
  explicit OptionalShapeProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OptionalShapeProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OptionalShapeProto& from);
  OptionalShapeProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OptionalShapeProto&& from) noexcept
      : OptionalShapeProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShapeFieldNumber = 1,
  };
  // optional .xla.ShapeProto shape = 1;
  bool has_shape() const;
  void clear_shape() ;
  const ::xla::ShapeProto& shape() const;
  [[nodiscard]] ::xla::ShapeProto* PROTOBUF_NULLABLE release_shape();
  ::xla::ShapeProto* PROTOBUF_NONNULL mutable_shape();
  void set_allocated_shape(::xla::ShapeProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_shape(::xla::ShapeProto* PROTOBUF_NULLABLE value);
  ::xla::ShapeProto* PROTOBUF_NULLABLE unsafe_arena_release_shape();

  private:
  const ::xla::ShapeProto& _internal_shape() const;
  ::xla::ShapeProto* PROTOBUF_NONNULL _internal_mutable_shape();

  public:
  // @@protoc_insertion_point(class_scope:xla.gpu.OptionalShapeProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OptionalShapeProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::ShapeProto* PROTOBUF_NULLABLE shape_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalShapeProto_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto) */ {
 public:
  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto() : OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(nullptr) {}
  ~OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(::google::protobuf::internal::ConstantInitialized);

  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& from) : OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(nullptr, from) {}
  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto&& from) noexcept
      : OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(nullptr, ::std::move(from)) {}
  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& operator=(const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& operator=(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& default_instance() {
    return *reinterpret_cast<const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto*>(
        &_OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& a, OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& b) { a.Swap(&b); }
  inline void Swap(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& from) { OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto"; }

 protected:
  explicit OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& from);
  OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto&& from) noexcept
      : OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetsFieldNumber = 1,
  };
  // repeated .xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto offsets = 1;
  int offsets_size() const;
  private:
  int _internal_offsets_size() const;

  public:
  void clear_offsets() ;
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL mutable_offsets(int index);
  ::google::protobuf::RepeatedPtrField<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>* PROTOBUF_NONNULL mutable_offsets();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>& _internal_offsets() const;
  ::google::protobuf::RepeatedPtrField<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>* PROTOBUF_NONNULL _internal_mutable_offsets();
  public:
  const ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& offsets(int index) const;
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL add_offsets();
  const ::google::protobuf::RepeatedPtrField<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>& offsets() const;
  // @@protoc_insertion_point(class_scope:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& from_msg);
    ::google::protobuf::RepeatedPtrField< ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto > offsets_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OptionalDynamicSliceOffsetsProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.gpu.OptionalDynamicSliceOffsetsProto) */ {
 public:
  inline OptionalDynamicSliceOffsetsProto() : OptionalDynamicSliceOffsetsProto(nullptr) {}
  ~OptionalDynamicSliceOffsetsProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OptionalDynamicSliceOffsetsProto* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OptionalDynamicSliceOffsetsProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OptionalDynamicSliceOffsetsProto(::google::protobuf::internal::ConstantInitialized);

  inline OptionalDynamicSliceOffsetsProto(const OptionalDynamicSliceOffsetsProto& from) : OptionalDynamicSliceOffsetsProto(nullptr, from) {}
  inline OptionalDynamicSliceOffsetsProto(OptionalDynamicSliceOffsetsProto&& from) noexcept
      : OptionalDynamicSliceOffsetsProto(nullptr, ::std::move(from)) {}
  inline OptionalDynamicSliceOffsetsProto& operator=(const OptionalDynamicSliceOffsetsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalDynamicSliceOffsetsProto& operator=(OptionalDynamicSliceOffsetsProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalDynamicSliceOffsetsProto& default_instance() {
    return *reinterpret_cast<const OptionalDynamicSliceOffsetsProto*>(
        &_OptionalDynamicSliceOffsetsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(OptionalDynamicSliceOffsetsProto& a, OptionalDynamicSliceOffsetsProto& b) { a.Swap(&b); }
  inline void Swap(OptionalDynamicSliceOffsetsProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalDynamicSliceOffsetsProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OptionalDynamicSliceOffsetsProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OptionalDynamicSliceOffsetsProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OptionalDynamicSliceOffsetsProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OptionalDynamicSliceOffsetsProto& from) { OptionalDynamicSliceOffsetsProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OptionalDynamicSliceOffsetsProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.gpu.OptionalDynamicSliceOffsetsProto"; }

 protected:
  explicit OptionalDynamicSliceOffsetsProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OptionalDynamicSliceOffsetsProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OptionalDynamicSliceOffsetsProto& from);
  OptionalDynamicSliceOffsetsProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OptionalDynamicSliceOffsetsProto&& from) noexcept
      : OptionalDynamicSliceOffsetsProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using DynamicSliceOffsetProto = OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto;
  using DynamicSliceOffsetsProto = OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto;

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetsFieldNumber = 1,
  };
  // optional .xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto offsets = 1;
  bool has_offsets() const;
  void clear_offsets() ;
  const ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& offsets() const;
  [[nodiscard]] ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE release_offsets();
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL mutable_offsets();
  void set_allocated_offsets(::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_offsets(::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE value);
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE unsafe_arena_release_offsets();

  private:
  const ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& _internal_offsets() const;
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL _internal_mutable_offsets();

  public:
  // @@protoc_insertion_point(class_scope:xla.gpu.OptionalDynamicSliceOffsetsProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OptionalDynamicSliceOffsetsProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE offsets_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OptionalDynamicSliceOffsetsProto_class_data_;
// -------------------------------------------------------------------

class PROTOBUF_EXPORT OffsetAsFunctionOfIndvarModulesMetadataProto final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto) */ {
 public:
  inline OffsetAsFunctionOfIndvarModulesMetadataProto() : OffsetAsFunctionOfIndvarModulesMetadataProto(nullptr) {}
  ~OffsetAsFunctionOfIndvarModulesMetadataProto() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OffsetAsFunctionOfIndvarModulesMetadataProto* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OffsetAsFunctionOfIndvarModulesMetadataProto));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OffsetAsFunctionOfIndvarModulesMetadataProto(::google::protobuf::internal::ConstantInitialized);

  inline OffsetAsFunctionOfIndvarModulesMetadataProto(const OffsetAsFunctionOfIndvarModulesMetadataProto& from) : OffsetAsFunctionOfIndvarModulesMetadataProto(nullptr, from) {}
  inline OffsetAsFunctionOfIndvarModulesMetadataProto(OffsetAsFunctionOfIndvarModulesMetadataProto&& from) noexcept
      : OffsetAsFunctionOfIndvarModulesMetadataProto(nullptr, ::std::move(from)) {}
  inline OffsetAsFunctionOfIndvarModulesMetadataProto& operator=(const OffsetAsFunctionOfIndvarModulesMetadataProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OffsetAsFunctionOfIndvarModulesMetadataProto& operator=(OffsetAsFunctionOfIndvarModulesMetadataProto&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OffsetAsFunctionOfIndvarModulesMetadataProto& default_instance() {
    return *reinterpret_cast<const OffsetAsFunctionOfIndvarModulesMetadataProto*>(
        &_OffsetAsFunctionOfIndvarModulesMetadataProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(OffsetAsFunctionOfIndvarModulesMetadataProto& a, OffsetAsFunctionOfIndvarModulesMetadataProto& b) { a.Swap(&b); }
  inline void Swap(OffsetAsFunctionOfIndvarModulesMetadataProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OffsetAsFunctionOfIndvarModulesMetadataProto* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OffsetAsFunctionOfIndvarModulesMetadataProto* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OffsetAsFunctionOfIndvarModulesMetadataProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OffsetAsFunctionOfIndvarModulesMetadataProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OffsetAsFunctionOfIndvarModulesMetadataProto& from) { OffsetAsFunctionOfIndvarModulesMetadataProto::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OffsetAsFunctionOfIndvarModulesMetadataProto* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto"; }

 protected:
  explicit OffsetAsFunctionOfIndvarModulesMetadataProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  OffsetAsFunctionOfIndvarModulesMetadataProto(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const OffsetAsFunctionOfIndvarModulesMetadataProto& from);
  OffsetAsFunctionOfIndvarModulesMetadataProto(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, OffsetAsFunctionOfIndvarModulesMetadataProto&& from) noexcept
      : OffsetAsFunctionOfIndvarModulesMetadataProto(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExtractedOffsetModulesFieldNumber = 3,
    kIndvarInitFieldNumber = 1,
    kIndvarUpdateFieldNumber = 2,
  };
  // repeated .xla.HloModuleProtoWithConfig extracted_offset_modules = 3;
  int extracted_offset_modules_size() const;
  private:
  int _internal_extracted_offset_modules_size() const;

  public:
  void clear_extracted_offset_modules() ;
  ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL mutable_extracted_offset_modules(int index);
  ::google::protobuf::RepeatedPtrField<::xla::HloModuleProtoWithConfig>* PROTOBUF_NONNULL mutable_extracted_offset_modules();

  private:
  const ::google::protobuf::RepeatedPtrField<::xla::HloModuleProtoWithConfig>& _internal_extracted_offset_modules() const;
  ::google::protobuf::RepeatedPtrField<::xla::HloModuleProtoWithConfig>* PROTOBUF_NONNULL _internal_mutable_extracted_offset_modules();
  public:
  const ::xla::HloModuleProtoWithConfig& extracted_offset_modules(int index) const;
  ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL add_extracted_offset_modules();
  const ::google::protobuf::RepeatedPtrField<::xla::HloModuleProtoWithConfig>& extracted_offset_modules() const;
  // .xla.HloModuleProtoWithConfig indvar_init = 1;
  bool has_indvar_init() const;
  void clear_indvar_init() ;
  const ::xla::HloModuleProtoWithConfig& indvar_init() const;
  [[nodiscard]] ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE release_indvar_init();
  ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL mutable_indvar_init();
  void set_allocated_indvar_init(::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_indvar_init(::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE value);
  ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE unsafe_arena_release_indvar_init();

  private:
  const ::xla::HloModuleProtoWithConfig& _internal_indvar_init() const;
  ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL _internal_mutable_indvar_init();

  public:
  // .xla.HloModuleProtoWithConfig indvar_update = 2;
  bool has_indvar_update() const;
  void clear_indvar_update() ;
  const ::xla::HloModuleProtoWithConfig& indvar_update() const;
  [[nodiscard]] ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE release_indvar_update();
  ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL mutable_indvar_update();
  void set_allocated_indvar_update(::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_indvar_update(::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE value);
  ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE unsafe_arena_release_indvar_update();

  private:
  const ::xla::HloModuleProtoWithConfig& _internal_indvar_update() const;
  ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL _internal_mutable_indvar_update();

  public:
  // @@protoc_insertion_point(class_scope:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   3, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const OffsetAsFunctionOfIndvarModulesMetadataProto& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::xla::HloModuleProtoWithConfig > extracted_offset_modules_;
    ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE indvar_init_;
    ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE indvar_update_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto;
};

PROTOBUF_EXPORT extern const ::google::protobuf::internal::ClassDataFull OffsetAsFunctionOfIndvarModulesMetadataProto_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// OptionalBufferAllocationSliceProto

// optional .xla.buffer_assignment.BufferAllocationSliceProto slice = 1;
inline bool OptionalBufferAllocationSliceProto::has_slice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.slice_ != nullptr);
  return value;
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& OptionalBufferAllocationSliceProto::_internal_slice() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::buffer_assignment::BufferAllocationSliceProto* p = _impl_.slice_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& OptionalBufferAllocationSliceProto::slice() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.gpu.OptionalBufferAllocationSliceProto.slice)
  return _internal_slice();
}
inline void OptionalBufferAllocationSliceProto::unsafe_arena_set_allocated_slice(
    ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.slice_);
  }
  _impl_.slice_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.gpu.OptionalBufferAllocationSliceProto.slice)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE OptionalBufferAllocationSliceProto::release_slice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* released = _impl_.slice_;
  _impl_.slice_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE OptionalBufferAllocationSliceProto::unsafe_arena_release_slice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.gpu.OptionalBufferAllocationSliceProto.slice)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* temp = _impl_.slice_;
  _impl_.slice_ = nullptr;
  return temp;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NONNULL OptionalBufferAllocationSliceProto::_internal_mutable_slice() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.slice_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
    _impl_.slice_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(p);
  }
  return _impl_.slice_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NONNULL OptionalBufferAllocationSliceProto::mutable_slice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_slice();
  // @@protoc_insertion_point(field_mutable:xla.gpu.OptionalBufferAllocationSliceProto.slice)
  return _msg;
}
inline void OptionalBufferAllocationSliceProto::set_allocated_slice(::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.slice_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.slice_ = reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.gpu.OptionalBufferAllocationSliceProto.slice)
}

// -------------------------------------------------------------------

// OptionalShapeProto

// optional .xla.ShapeProto shape = 1;
inline bool OptionalShapeProto::has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline const ::xla::ShapeProto& OptionalShapeProto::_internal_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::ShapeProto* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::ShapeProto&>(::xla::_ShapeProto_default_instance_);
}
inline const ::xla::ShapeProto& OptionalShapeProto::shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.gpu.OptionalShapeProto.shape)
  return _internal_shape();
}
inline void OptionalShapeProto::unsafe_arena_set_allocated_shape(
    ::xla::ShapeProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = reinterpret_cast<::xla::ShapeProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.gpu.OptionalShapeProto.shape)
}
inline ::xla::ShapeProto* PROTOBUF_NULLABLE OptionalShapeProto::release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::ShapeProto* released = _impl_.shape_;
  _impl_.shape_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::xla::ShapeProto* PROTOBUF_NULLABLE OptionalShapeProto::unsafe_arena_release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.gpu.OptionalShapeProto.shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::ShapeProto* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::xla::ShapeProto* PROTOBUF_NONNULL OptionalShapeProto::_internal_mutable_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::ShapeProto>(GetArena());
    _impl_.shape_ = reinterpret_cast<::xla::ShapeProto*>(p);
  }
  return _impl_.shape_;
}
inline ::xla::ShapeProto* PROTOBUF_NONNULL OptionalShapeProto::mutable_shape()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::ShapeProto* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:xla.gpu.OptionalShapeProto.shape)
  return _msg;
}
inline void OptionalShapeProto::set_allocated_shape(::xla::ShapeProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shape_ = reinterpret_cast<::xla::ShapeProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.gpu.OptionalShapeProto.shape)
}

// -------------------------------------------------------------------

// OptionalPrimitiveType

// optional .xla.PrimitiveType value = 1;
inline bool OptionalPrimitiveType::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OptionalPrimitiveType::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::xla::PrimitiveType OptionalPrimitiveType::value() const {
  // @@protoc_insertion_point(field_get:xla.gpu.OptionalPrimitiveType.value)
  return _internal_value();
}
inline void OptionalPrimitiveType::set_value(::xla::PrimitiveType value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:xla.gpu.OptionalPrimitiveType.value)
}
inline ::xla::PrimitiveType OptionalPrimitiveType::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::xla::PrimitiveType>(_impl_.value_);
}
inline void OptionalPrimitiveType::_internal_set_value(::xla::PrimitiveType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto

// int64 const_offset = 1;
inline bool OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::has_const_offset() const {
  return offset_case() == kConstOffset;
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::set_has_const_offset() {
  _impl_._oneof_case_[0] = kConstOffset;
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::clear_const_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (offset_case() == kConstOffset) {
    _impl_.offset_.const_offset_ = ::int64_t{0};
    clear_has_offset();
  }
}
inline ::int64_t OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::const_offset() const {
  // @@protoc_insertion_point(field_get:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.const_offset)
  return _internal_const_offset();
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::set_const_offset(::int64_t value) {
  if (offset_case() != kConstOffset) {
    clear_offset();
    set_has_const_offset();
  }
  _impl_.offset_.const_offset_ = value;
  // @@protoc_insertion_point(field_set:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.const_offset)
}
inline ::int64_t OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::_internal_const_offset() const {
  if (offset_case() == kConstOffset) {
    return _impl_.offset_.const_offset_;
  }
  return ::int64_t{0};
}

// .xla.buffer_assignment.BufferAllocationSliceProto slice_offset = 2;
inline bool OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::has_slice_offset() const {
  return offset_case() == kSliceOffset;
}
inline bool OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::_internal_has_slice_offset() const {
  return offset_case() == kSliceOffset;
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::set_has_slice_offset() {
  _impl_._oneof_case_[0] = kSliceOffset;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::release_slice_offset() {
  // @@protoc_insertion_point(field_release:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.slice_offset)
  if (offset_case() == kSliceOffset) {
    clear_has_offset();
    auto* temp = _impl_.offset_.slice_offset_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.offset_.slice_offset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::_internal_slice_offset() const {
  return offset_case() == kSliceOffset ? *_impl_.offset_.slice_offset_ : reinterpret_cast<::xla::buffer_assignment::BufferAllocationSliceProto&>(::xla::buffer_assignment::_BufferAllocationSliceProto_default_instance_);
}
inline const ::xla::buffer_assignment::BufferAllocationSliceProto& OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::slice_offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.slice_offset)
  return _internal_slice_offset();
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::unsafe_arena_release_slice_offset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.slice_offset)
  if (offset_case() == kSliceOffset) {
    clear_has_offset();
    auto* temp = _impl_.offset_.slice_offset_;
    _impl_.offset_.slice_offset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::unsafe_arena_set_allocated_slice_offset(
    ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_offset();
  if (value) {
    set_has_slice_offset();
    _impl_.offset_.slice_offset_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.slice_offset)
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NONNULL OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::_internal_mutable_slice_offset() {
  if (offset_case() != kSliceOffset) {
    clear_offset();
    set_has_slice_offset();
    _impl_.offset_.slice_offset_ = 
        ::google::protobuf::Message::DefaultConstruct<::xla::buffer_assignment::BufferAllocationSliceProto>(GetArena());
  }
  return _impl_.offset_.slice_offset_;
}
inline ::xla::buffer_assignment::BufferAllocationSliceProto* PROTOBUF_NONNULL OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::mutable_slice_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::xla::buffer_assignment::BufferAllocationSliceProto* _msg = _internal_mutable_slice_offset();
  // @@protoc_insertion_point(field_mutable:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.slice_offset)
  return _msg;
}

// int64 hlo_module_offset_idx = 3;
inline bool OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::has_hlo_module_offset_idx() const {
  return offset_case() == kHloModuleOffsetIdx;
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::set_has_hlo_module_offset_idx() {
  _impl_._oneof_case_[0] = kHloModuleOffsetIdx;
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::clear_hlo_module_offset_idx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (offset_case() == kHloModuleOffsetIdx) {
    _impl_.offset_.hlo_module_offset_idx_ = ::int64_t{0};
    clear_has_offset();
  }
}
inline ::int64_t OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::hlo_module_offset_idx() const {
  // @@protoc_insertion_point(field_get:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.hlo_module_offset_idx)
  return _internal_hlo_module_offset_idx();
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::set_hlo_module_offset_idx(::int64_t value) {
  if (offset_case() != kHloModuleOffsetIdx) {
    clear_offset();
    set_has_hlo_module_offset_idx();
  }
  _impl_.offset_.hlo_module_offset_idx_ = value;
  // @@protoc_insertion_point(field_set:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto.hlo_module_offset_idx)
}
inline ::int64_t OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::_internal_hlo_module_offset_idx() const {
  if (offset_case() == kHloModuleOffsetIdx) {
    return _impl_.offset_.hlo_module_offset_idx_;
  }
  return ::int64_t{0};
}

inline bool OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::has_offset() const {
  return offset_case() != OFFSET_NOT_SET;
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::clear_has_offset() {
  _impl_._oneof_case_[0] = OFFSET_NOT_SET;
}
inline OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::OffsetCase OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::offset_case() const {
  return OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto::OffsetCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto

// repeated .xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetProto offsets = 1;
inline int OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::_internal_offsets_size() const {
  return _internal_offsets().size();
}
inline int OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::offsets_size() const {
  return _internal_offsets_size();
}
inline void OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::clear_offsets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offsets_.Clear();
}
inline ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::mutable_offsets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto.offsets)
  return _internal_mutable_offsets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>* PROTOBUF_NONNULL OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::mutable_offsets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto.offsets)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_offsets();
}
inline const ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto& OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::offsets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto.offsets)
  return _internal_offsets().Get(index);
}
inline ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* PROTOBUF_NONNULL OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::add_offsets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto* _add = _internal_mutable_offsets()->Add();
  // @@protoc_insertion_point(field_add:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto.offsets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>& OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::offsets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto.offsets)
  return _internal_offsets();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>&
OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::_internal_offsets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offsets_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetProto>* PROTOBUF_NONNULL
OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto::_internal_mutable_offsets() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.offsets_;
}

// -------------------------------------------------------------------

// OptionalDynamicSliceOffsetsProto

// optional .xla.gpu.OptionalDynamicSliceOffsetsProto.DynamicSliceOffsetsProto offsets = 1;
inline bool OptionalDynamicSliceOffsetsProto::has_offsets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offsets_ != nullptr);
  return value;
}
inline void OptionalDynamicSliceOffsetsProto::clear_offsets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offsets_ != nullptr) _impl_.offsets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& OptionalDynamicSliceOffsetsProto::_internal_offsets() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* p = _impl_.offsets_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto&>(::xla::gpu::_OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto_default_instance_);
}
inline const ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto& OptionalDynamicSliceOffsetsProto::offsets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.gpu.OptionalDynamicSliceOffsetsProto.offsets)
  return _internal_offsets();
}
inline void OptionalDynamicSliceOffsetsProto::unsafe_arena_set_allocated_offsets(
    ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offsets_);
  }
  _impl_.offsets_ = reinterpret_cast<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.gpu.OptionalDynamicSliceOffsetsProto.offsets)
}
inline ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE OptionalDynamicSliceOffsetsProto::release_offsets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* released = _impl_.offsets_;
  _impl_.offsets_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE OptionalDynamicSliceOffsetsProto::unsafe_arena_release_offsets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.gpu.OptionalDynamicSliceOffsetsProto.offsets)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* temp = _impl_.offsets_;
  _impl_.offsets_ = nullptr;
  return temp;
}
inline ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL OptionalDynamicSliceOffsetsProto::_internal_mutable_offsets() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.offsets_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto>(GetArena());
    _impl_.offsets_ = reinterpret_cast<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto*>(p);
  }
  return _impl_.offsets_;
}
inline ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NONNULL OptionalDynamicSliceOffsetsProto::mutable_offsets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* _msg = _internal_mutable_offsets();
  // @@protoc_insertion_point(field_mutable:xla.gpu.OptionalDynamicSliceOffsetsProto.offsets)
  return _msg;
}
inline void OptionalDynamicSliceOffsetsProto::set_allocated_offsets(::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offsets_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.offsets_ = reinterpret_cast<::xla::gpu::OptionalDynamicSliceOffsetsProto_DynamicSliceOffsetsProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.gpu.OptionalDynamicSliceOffsetsProto.offsets)
}

// -------------------------------------------------------------------

// OffsetAsFunctionOfIndvarModulesMetadataProto

// .xla.HloModuleProtoWithConfig indvar_init = 1;
inline bool OffsetAsFunctionOfIndvarModulesMetadataProto::has_indvar_init() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.indvar_init_ != nullptr);
  return value;
}
inline const ::xla::HloModuleProtoWithConfig& OffsetAsFunctionOfIndvarModulesMetadataProto::_internal_indvar_init() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::HloModuleProtoWithConfig* p = _impl_.indvar_init_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::HloModuleProtoWithConfig&>(::xla::_HloModuleProtoWithConfig_default_instance_);
}
inline const ::xla::HloModuleProtoWithConfig& OffsetAsFunctionOfIndvarModulesMetadataProto::indvar_init() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_init)
  return _internal_indvar_init();
}
inline void OffsetAsFunctionOfIndvarModulesMetadataProto::unsafe_arena_set_allocated_indvar_init(
    ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indvar_init_);
  }
  _impl_.indvar_init_ = reinterpret_cast<::xla::HloModuleProtoWithConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_init)
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE OffsetAsFunctionOfIndvarModulesMetadataProto::release_indvar_init() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::HloModuleProtoWithConfig* released = _impl_.indvar_init_;
  _impl_.indvar_init_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE OffsetAsFunctionOfIndvarModulesMetadataProto::unsafe_arena_release_indvar_init() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_init)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::xla::HloModuleProtoWithConfig* temp = _impl_.indvar_init_;
  _impl_.indvar_init_ = nullptr;
  return temp;
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL OffsetAsFunctionOfIndvarModulesMetadataProto::_internal_mutable_indvar_init() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indvar_init_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::HloModuleProtoWithConfig>(GetArena());
    _impl_.indvar_init_ = reinterpret_cast<::xla::HloModuleProtoWithConfig*>(p);
  }
  return _impl_.indvar_init_;
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL OffsetAsFunctionOfIndvarModulesMetadataProto::mutable_indvar_init()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::xla::HloModuleProtoWithConfig* _msg = _internal_mutable_indvar_init();
  // @@protoc_insertion_point(field_mutable:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_init)
  return _msg;
}
inline void OffsetAsFunctionOfIndvarModulesMetadataProto::set_allocated_indvar_init(::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indvar_init_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.indvar_init_ = reinterpret_cast<::xla::HloModuleProtoWithConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_init)
}

// .xla.HloModuleProtoWithConfig indvar_update = 2;
inline bool OffsetAsFunctionOfIndvarModulesMetadataProto::has_indvar_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.indvar_update_ != nullptr);
  return value;
}
inline const ::xla::HloModuleProtoWithConfig& OffsetAsFunctionOfIndvarModulesMetadataProto::_internal_indvar_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::xla::HloModuleProtoWithConfig* p = _impl_.indvar_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::xla::HloModuleProtoWithConfig&>(::xla::_HloModuleProtoWithConfig_default_instance_);
}
inline const ::xla::HloModuleProtoWithConfig& OffsetAsFunctionOfIndvarModulesMetadataProto::indvar_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_update)
  return _internal_indvar_update();
}
inline void OffsetAsFunctionOfIndvarModulesMetadataProto::unsafe_arena_set_allocated_indvar_update(
    ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indvar_update_);
  }
  _impl_.indvar_update_ = reinterpret_cast<::xla::HloModuleProtoWithConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_update)
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE OffsetAsFunctionOfIndvarModulesMetadataProto::release_indvar_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::HloModuleProtoWithConfig* released = _impl_.indvar_update_;
  _impl_.indvar_update_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE OffsetAsFunctionOfIndvarModulesMetadataProto::unsafe_arena_release_indvar_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_update)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::xla::HloModuleProtoWithConfig* temp = _impl_.indvar_update_;
  _impl_.indvar_update_ = nullptr;
  return temp;
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL OffsetAsFunctionOfIndvarModulesMetadataProto::_internal_mutable_indvar_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.indvar_update_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::xla::HloModuleProtoWithConfig>(GetArena());
    _impl_.indvar_update_ = reinterpret_cast<::xla::HloModuleProtoWithConfig*>(p);
  }
  return _impl_.indvar_update_;
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL OffsetAsFunctionOfIndvarModulesMetadataProto::mutable_indvar_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::xla::HloModuleProtoWithConfig* _msg = _internal_mutable_indvar_update();
  // @@protoc_insertion_point(field_mutable:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_update)
  return _msg;
}
inline void OffsetAsFunctionOfIndvarModulesMetadataProto::set_allocated_indvar_update(::xla::HloModuleProtoWithConfig* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.indvar_update_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.indvar_update_ = reinterpret_cast<::xla::HloModuleProtoWithConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.indvar_update)
}

// repeated .xla.HloModuleProtoWithConfig extracted_offset_modules = 3;
inline int OffsetAsFunctionOfIndvarModulesMetadataProto::_internal_extracted_offset_modules_size() const {
  return _internal_extracted_offset_modules().size();
}
inline int OffsetAsFunctionOfIndvarModulesMetadataProto::extracted_offset_modules_size() const {
  return _internal_extracted_offset_modules_size();
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL OffsetAsFunctionOfIndvarModulesMetadataProto::mutable_extracted_offset_modules(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.extracted_offset_modules)
  return _internal_mutable_extracted_offset_modules()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::xla::HloModuleProtoWithConfig>* PROTOBUF_NONNULL OffsetAsFunctionOfIndvarModulesMetadataProto::mutable_extracted_offset_modules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.extracted_offset_modules)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_extracted_offset_modules();
}
inline const ::xla::HloModuleProtoWithConfig& OffsetAsFunctionOfIndvarModulesMetadataProto::extracted_offset_modules(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.extracted_offset_modules)
  return _internal_extracted_offset_modules().Get(index);
}
inline ::xla::HloModuleProtoWithConfig* PROTOBUF_NONNULL OffsetAsFunctionOfIndvarModulesMetadataProto::add_extracted_offset_modules()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::xla::HloModuleProtoWithConfig* _add = _internal_mutable_extracted_offset_modules()->Add();
  // @@protoc_insertion_point(field_add:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.extracted_offset_modules)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::xla::HloModuleProtoWithConfig>& OffsetAsFunctionOfIndvarModulesMetadataProto::extracted_offset_modules() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:xla.gpu.OffsetAsFunctionOfIndvarModulesMetadataProto.extracted_offset_modules)
  return _internal_extracted_offset_modules();
}
inline const ::google::protobuf::RepeatedPtrField<::xla::HloModuleProtoWithConfig>&
OffsetAsFunctionOfIndvarModulesMetadataProto::_internal_extracted_offset_modules() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extracted_offset_modules_;
}
inline ::google::protobuf::RepeatedPtrField<::xla::HloModuleProtoWithConfig>* PROTOBUF_NONNULL
OffsetAsFunctionOfIndvarModulesMetadataProto::_internal_mutable_extracted_offset_modules() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.extracted_offset_modules_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace gpu
}  // namespace xla


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // xla_2fbackends_2fgpu_2fruntime_2fdynamic_5fslice_5fthunk_2eproto_2epb_2eh
