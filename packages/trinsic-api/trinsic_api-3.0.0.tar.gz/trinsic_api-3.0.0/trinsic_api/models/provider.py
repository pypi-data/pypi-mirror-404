# coding: utf-8

"""
    Trinsic API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from trinsic_api.models.contract_attachment import ContractAttachment
from trinsic_api.models.contract_attribute import ContractAttribute
from trinsic_api.models.integration_launch_method import IntegrationLaunchMethod
from trinsic_api.models.provider_health import ProviderHealth
from trinsic_api.models.result_collection_method import ResultCollectionMethod
from trinsic_api.models.sub_provider_metadata import SubProviderMetadata
from typing import Optional, Set
from typing_extensions import Self

class Provider(BaseModel):
    """
    Provider
    """ # noqa: E501
    id: StrictStr = Field(description="The unique identifier of the provider")
    name: StrictStr = Field(description="The display name of the provider")
    logo_url: StrictStr = Field(description="The URL of the provider's logo", alias="logoUrl")
    subtext: StrictStr = Field(description="The Provider's subtext recommended to be shown next to the name.              This is flavor text, not a full, human-readable description of the provider.")
    description: StrictStr = Field(description="A description of the provider's capabilities")
    geography: List[StrictStr] = Field(description="Geographic regions where this provider operates")
    regions: List[StrictStr] = Field(description="Specific regions supported by this provider")
    countries: List[StrictStr] = Field(description="The countries where this Provider is available (as alpha-2 ISO codes).")
    subdivisions: List[StrictStr] = Field(description="The subdivisions (states, provinces, etc.) where this Provider is available (as alpha-2 ISO codes).")
    licensed: StrictBool = Field(description="Whether this provider is licensed for use by your organization")
    launch_method: IntegrationLaunchMethod = Field(description="Relevant only to Direct Provider Sessions.              The `LaunchMethod` which must be supported to launch the Provider Session in Direct Provider Sessions.", alias="launchMethod")
    collection_method: ResultCollectionMethod = Field(description="Relevant only to Direct Provider Sessions.              The `CollectionMethod` which must be supported to launch the Provider Session in Direct Provider Sessions.", alias="collectionMethod")
    results_may_be_delayed_after_redirect: StrictBool = Field(description="If `true`, then the results for this Provider may not be available immediately after the user is redirected back to your application. In this case, the `GetSessionResults` API must be called until results are available.              This is an uncommon scenario, and only applies to Providers which cannot guarantee the availability of results immediately after the user is redirected back to your application.", alias="resultsMayBeDelayedAfterRedirect")
    has_refreshable_content: StrictBool = Field(description="Relevant only to Direct Provider Sessions.              Whether the Provider requires the `RefreshStepContent` capability.              For example, Samsung Wallet's deep links expire every 30 seconds, and must be refreshed periodically for a resilient user flow.", alias="hasRefreshableContent")
    requires_input: StrictBool = Field(description="Relevant to Hosted Provider Sessions and Direct Provider Sessions.              If `true`, this Provider requires provider-specific input on Session creation. If this input is not provided, Trinsic's Hosted UI will be invoked to collect the input from the user.", alias="requiresInput")
    has_trinsic_interface: StrictBool = Field(description="Whether there exists a Trinsic-hosted UI for this Provider.              This is `true` for any Provider which is not a simple, OIDC-like redirect flow.", alias="hasTrinsicInterface")
    supports_direct_provider_sessions: StrictBool = Field(description="Whether this Provider can be fully whitelabeled/OEMed through the Direct Provider Sessions API.              If `false`, the Provider may still be launched through Direct Provider Sessions; however, it will necessarily require a Trinsic-hosted UI to function.", alias="supportsDirectProviderSessions")
    available_attributes: Optional[List[ContractAttribute]] = Field(default=None, description="Information about the user attributes that this Provider will return in verification results.", alias="availableAttributes")
    available_attachments: Optional[List[ContractAttachment]] = Field(default=None, description="Information about the attachments that this Provider will return in verification results.", alias="availableAttachments")
    sub_providers: Optional[List[SubProviderMetadata]] = Field(default=None, description="Metadata about the sub-providers which are available for this Provider in the current Environment.              For example, Italy's SPID is a Provider which aggregates access to multiple sub-providers.", alias="subProviders")
    live_health: ProviderHealth = Field(description="The health for a provider in the live environment", alias="liveHealth")
    test_health: ProviderHealth = Field(description="The health for a provider in the test environment", alias="testHealth")
    __properties: ClassVar[List[str]] = ["id", "name", "logoUrl", "subtext", "description", "geography", "regions", "countries", "subdivisions", "licensed", "launchMethod", "collectionMethod", "resultsMayBeDelayedAfterRedirect", "hasRefreshableContent", "requiresInput", "hasTrinsicInterface", "supportsDirectProviderSessions", "availableAttributes", "availableAttachments", "subProviders", "liveHealth", "testHealth"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Provider from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "description",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in available_attributes (list)
        _items = []
        if self.available_attributes:
            for _item_available_attributes in self.available_attributes:
                if _item_available_attributes:
                    _items.append(_item_available_attributes.to_dict())
            _dict['availableAttributes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in available_attachments (list)
        _items = []
        if self.available_attachments:
            for _item_available_attachments in self.available_attachments:
                if _item_available_attachments:
                    _items.append(_item_available_attachments.to_dict())
            _dict['availableAttachments'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in sub_providers (list)
        _items = []
        if self.sub_providers:
            for _item_sub_providers in self.sub_providers:
                if _item_sub_providers:
                    _items.append(_item_sub_providers.to_dict())
            _dict['subProviders'] = _items
        # set to None if available_attributes (nullable) is None
        # and model_fields_set contains the field
        if self.available_attributes is None and "available_attributes" in self.model_fields_set:
            _dict['availableAttributes'] = None

        # set to None if available_attachments (nullable) is None
        # and model_fields_set contains the field
        if self.available_attachments is None and "available_attachments" in self.model_fields_set:
            _dict['availableAttachments'] = None

        # set to None if sub_providers (nullable) is None
        # and model_fields_set contains the field
        if self.sub_providers is None and "sub_providers" in self.model_fields_set:
            _dict['subProviders'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Provider from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "logoUrl": obj.get("logoUrl"),
            "subtext": obj.get("subtext"),
            "description": obj.get("description"),
            "geography": obj.get("geography"),
            "regions": obj.get("regions"),
            "countries": obj.get("countries"),
            "subdivisions": obj.get("subdivisions"),
            "licensed": obj.get("licensed"),
            "launchMethod": obj.get("launchMethod"),
            "collectionMethod": obj.get("collectionMethod"),
            "resultsMayBeDelayedAfterRedirect": obj.get("resultsMayBeDelayedAfterRedirect"),
            "hasRefreshableContent": obj.get("hasRefreshableContent"),
            "requiresInput": obj.get("requiresInput"),
            "hasTrinsicInterface": obj.get("hasTrinsicInterface"),
            "supportsDirectProviderSessions": obj.get("supportsDirectProviderSessions"),
            "availableAttributes": [ContractAttribute.from_dict(_item) for _item in obj["availableAttributes"]] if obj.get("availableAttributes") is not None else None,
            "availableAttachments": [ContractAttachment.from_dict(_item) for _item in obj["availableAttachments"]] if obj.get("availableAttachments") is not None else None,
            "subProviders": [SubProviderMetadata.from_dict(_item) for _item in obj["subProviders"]] if obj.get("subProviders") is not None else None,
            "liveHealth": obj.get("liveHealth"),
            "testHealth": obj.get("testHealth")
        })
        return _obj


