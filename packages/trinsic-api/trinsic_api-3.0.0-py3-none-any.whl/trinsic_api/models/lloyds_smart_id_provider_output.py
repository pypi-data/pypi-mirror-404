# coding: utf-8

"""
    Trinsic API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from trinsic_api.models.yoti_document_details import YotiDocumentDetails
from trinsic_api.models.yoti_structured_postal_address import YotiStructuredPostalAddress
from typing import Optional, Set
from typing_extensions import Self

class LloydsSmartIdProviderOutput(BaseModel):
    """
    Exposed properties for the `lloyds-smart-id` Provider which do not directly map to the normalized IdentityData model.
    """ # noqa: E501
    remember_me_id: Optional[StrictStr] = Field(default=None, description="The unique id for your service of the individual. This is not shared between different services so if the user logs into a different service, the user will have a new id for the other service.", alias="rememberMeId")
    email: Optional[StrictStr] = Field(default=None, description="The email address of the individual")
    given_name: Optional[StrictStr] = Field(default=None, description="The given name of the individual. This can correspond to first and middle names in English.", alias="givenName")
    family_name: Optional[StrictStr] = Field(default=None, description="The family name of the individual", alias="familyName")
    full_name: Optional[StrictStr] = Field(default=None, description="Full name of the individual which is composed of the given and family name. Unverified full name may be safe to use. For example, Aadhaar card provides full name, but due to certain limitations of verifying Aadhaar, Yoti is unable to verify this property so it is listed as \"unverified\".", alias="fullName")
    date_of_birth: Optional[date] = Field(default=None, description="The date of birth of the individual. Unverified date of birth may be safe to use. For example, Aadhaar card provides date of birth, but due to certain limitations of verifying Aadhaar, Yoti is unable to verify this property so it is listed as \"unverified\".", alias="dateOfBirth")
    gender: Optional[StrictStr] = Field(default=None, description="The gender of the individual. Depending on the source or country, gender may not be verified. This is a setting that can be configured while setting up scopes.              Unverified gender may be safe to use. For example, Aadhaar card provides gender, but due to certain limitations of verifying Aadhaar, Yoti is unable to verify this property so it is listed as \"unverified\". In some countries Possible values: - \"MALE\" - \"FEMALE\" - \"TRANSGENDER\" - \"OTHER\"")
    nationality: Optional[StrictStr] = Field(default=None, description="The nationality of the individual as a ISO alpha-3 code")
    mobile_number: Optional[StrictStr] = Field(default=None, description="The mobile phone number of the individual. This number was verified with a one time password (OTP) during the user's registration with Yoti. In some cases, Yoti may do additional checks against its sources to confirm the user's identity.", alias="mobileNumber")
    structured_postal_address: Optional[YotiStructuredPostalAddress] = Field(default=None, description="A structured postal address for the individual that comes from the underlying document or can be manually added. In the case of being manually added, the address is considered \"unverified\". Unverified addresses may be safe to use. For example, Aadhaar card provides an address, but due to certain limitations of verifying Aadhaar, Yoti is unable to verify this property so it is listed as \"unverified\".", alias="structuredPostalAddress")
    postal_address: Optional[StrictStr] = Field(default=None, description="The whole address for the individual that comes from the underlying document or can be manually added. In the case of being manually added, the address is considered \"unverified\". The format of this will be different for each country. Refer to `StructuredPostalAddress` for a detailed version of the address.", alias="postalAddress")
    document_details: Optional[YotiDocumentDetails] = Field(default=None, description="The details of the underlying document used to help create the Yoti credential", alias="documentDetails")
    __properties: ClassVar[List[str]] = ["rememberMeId", "email", "givenName", "familyName", "fullName", "dateOfBirth", "gender", "nationality", "mobileNumber", "structuredPostalAddress", "postalAddress", "documentDetails"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of LloydsSmartIdProviderOutput from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of structured_postal_address
        if self.structured_postal_address:
            _dict['structuredPostalAddress'] = self.structured_postal_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of document_details
        if self.document_details:
            _dict['documentDetails'] = self.document_details.to_dict()
        # set to None if remember_me_id (nullable) is None
        # and model_fields_set contains the field
        if self.remember_me_id is None and "remember_me_id" in self.model_fields_set:
            _dict['rememberMeId'] = None

        # set to None if email (nullable) is None
        # and model_fields_set contains the field
        if self.email is None and "email" in self.model_fields_set:
            _dict['email'] = None

        # set to None if given_name (nullable) is None
        # and model_fields_set contains the field
        if self.given_name is None and "given_name" in self.model_fields_set:
            _dict['givenName'] = None

        # set to None if family_name (nullable) is None
        # and model_fields_set contains the field
        if self.family_name is None and "family_name" in self.model_fields_set:
            _dict['familyName'] = None

        # set to None if full_name (nullable) is None
        # and model_fields_set contains the field
        if self.full_name is None and "full_name" in self.model_fields_set:
            _dict['fullName'] = None

        # set to None if date_of_birth (nullable) is None
        # and model_fields_set contains the field
        if self.date_of_birth is None and "date_of_birth" in self.model_fields_set:
            _dict['dateOfBirth'] = None

        # set to None if gender (nullable) is None
        # and model_fields_set contains the field
        if self.gender is None and "gender" in self.model_fields_set:
            _dict['gender'] = None

        # set to None if nationality (nullable) is None
        # and model_fields_set contains the field
        if self.nationality is None and "nationality" in self.model_fields_set:
            _dict['nationality'] = None

        # set to None if mobile_number (nullable) is None
        # and model_fields_set contains the field
        if self.mobile_number is None and "mobile_number" in self.model_fields_set:
            _dict['mobileNumber'] = None

        # set to None if structured_postal_address (nullable) is None
        # and model_fields_set contains the field
        if self.structured_postal_address is None and "structured_postal_address" in self.model_fields_set:
            _dict['structuredPostalAddress'] = None

        # set to None if postal_address (nullable) is None
        # and model_fields_set contains the field
        if self.postal_address is None and "postal_address" in self.model_fields_set:
            _dict['postalAddress'] = None

        # set to None if document_details (nullable) is None
        # and model_fields_set contains the field
        if self.document_details is None and "document_details" in self.model_fields_set:
            _dict['documentDetails'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of LloydsSmartIdProviderOutput from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "rememberMeId": obj.get("rememberMeId"),
            "email": obj.get("email"),
            "givenName": obj.get("givenName"),
            "familyName": obj.get("familyName"),
            "fullName": obj.get("fullName"),
            "dateOfBirth": obj.get("dateOfBirth"),
            "gender": obj.get("gender"),
            "nationality": obj.get("nationality"),
            "mobileNumber": obj.get("mobileNumber"),
            "structuredPostalAddress": YotiStructuredPostalAddress.from_dict(obj["structuredPostalAddress"]) if obj.get("structuredPostalAddress") is not None else None,
            "postalAddress": obj.get("postalAddress"),
            "documentDetails": YotiDocumentDetails.from_dict(obj["documentDetails"]) if obj.get("documentDetails") is not None else None
        })
        return _obj


