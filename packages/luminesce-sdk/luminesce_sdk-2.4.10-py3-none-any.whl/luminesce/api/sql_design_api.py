# coding: utf-8

"""
    FINBOURNE Luminesce Web API

    FINBOURNE Technology  # noqa: E501

    Contact: info@finbourne.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic.v1 import validate_arguments, ValidationError
from typing import overload, Optional, Union, Awaitable

from pydantic.v1 import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import List, Optional, Union
from typing_extensions import Annotated
from luminesce.models.case_statement_design import CaseStatementDesign
from luminesce.models.convert_to_view_data import ConvertToViewData
from luminesce.models.error_highlight_request import ErrorHighlightRequest
from luminesce.models.error_highlight_response import ErrorHighlightResponse
from luminesce.models.file_reader_builder_def import FileReaderBuilderDef
from luminesce.models.file_reader_builder_response import FileReaderBuilderResponse
from luminesce.models.inlined_property_design import InlinedPropertyDesign
from luminesce.models.intellisense_request import IntellisenseRequest
from luminesce.models.intellisense_response import IntellisenseResponse
from luminesce.models.lusid_grid_data import LusidGridData
from luminesce.models.query_design import QueryDesign
from luminesce.models.query_designer_version import QueryDesignerVersion
from luminesce.models.scalar_parameter import ScalarParameter
from luminesce.models.writer_design import WriterDesign

from luminesce.api_client import ApiClient
from luminesce.api_response import ApiResponse
from luminesce.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)
from luminesce.extensions.configuration_options import ConfigurationOptions

# ensure templated type usages are imported
from pydantic.v1 import Field, StrictStr
from typing import Optional
from typing_extensions import Annotated

class SqlDesignApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @overload
    async def get_provider_template_for_export(self, provider : Annotated[StrictStr, Field(..., description="Name of the provider for which this template is for")], content_type : Annotated[StrictStr, Field(..., description="File content type for the Template. csv or excel")], **kwargs) -> bytearray:  # noqa: E501
        ...

    @overload
    def get_provider_template_for_export(self, provider : Annotated[StrictStr, Field(..., description="Name of the provider for which this template is for")], content_type : Annotated[StrictStr, Field(..., description="File content type for the Template. csv or excel")], async_req: Optional[bool]=True, **kwargs) -> bytearray:  # noqa: E501
        ...

    @validate_arguments
    def get_provider_template_for_export(self, provider : Annotated[StrictStr, Field(..., description="Name of the provider for which this template is for")], content_type : Annotated[StrictStr, Field(..., description="File content type for the Template. csv or excel")], async_req: Optional[bool]=None, **kwargs) -> Union[bytearray, Awaitable[bytearray]]:  # noqa: E501
        """GetProviderTemplateForExport: Makes a fields template for file importing via a writer  # noqa: E501

        Generates a template file for all the writable fields for a given provider returned in CSV or Excel (xlsx) format (as a file to be downloaded)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_provider_template_for_export(provider, content_type, async_req=True)
        >>> result = thread.get()

        :param provider: Name of the provider for which this template is for (required)
        :type provider: str
        :param content_type: File content type for the Template. csv or excel (required)
        :type content_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_provider_template_for_export_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.get_provider_template_for_export_with_http_info(provider, content_type, **kwargs)  # noqa: E501

    @validate_arguments
    def get_provider_template_for_export_with_http_info(self, provider : Annotated[StrictStr, Field(..., description="Name of the provider for which this template is for")], content_type : Annotated[StrictStr, Field(..., description="File content type for the Template. csv or excel")], **kwargs) -> ApiResponse:  # noqa: E501
        """GetProviderTemplateForExport: Makes a fields template for file importing via a writer  # noqa: E501

        Generates a template file for all the writable fields for a given provider returned in CSV or Excel (xlsx) format (as a file to be downloaded)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_provider_template_for_export_with_http_info(provider, content_type, async_req=True)
        >>> result = thread.get()

        :param provider: Name of the provider for which this template is for (required)
        :type provider: str
        :param content_type: File content type for the Template. csv or excel (required)
        :type content_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'provider',
            'content_type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_provider_template_for_export" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('provider') is not None:  # noqa: E501
            _query_params.append(('provider', _params['provider']))

        if _params.get('content_type') is not None:  # noqa: E501
            _query_params.append(('contentType', _params['content_type']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/providertemplateforexport', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_case_statement_design_sql_to_design(self, body : Annotated[Optional[StrictStr], Field( description="SQL to attempt to create an case statement Design object from")] = None, **kwargs) -> CaseStatementDesign:  # noqa: E501
        ...

    @overload
    def put_case_statement_design_sql_to_design(self, body : Annotated[Optional[StrictStr], Field( description="SQL to attempt to create an case statement Design object from")] = None, async_req: Optional[bool]=True, **kwargs) -> CaseStatementDesign:  # noqa: E501
        ...

    @validate_arguments
    def put_case_statement_design_sql_to_design(self, body : Annotated[Optional[StrictStr], Field( description="SQL to attempt to create an case statement Design object from")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[CaseStatementDesign, Awaitable[CaseStatementDesign]]:  # noqa: E501
        """PutCaseStatementDesignSqlToDesign: Convert SQL to a case statement design object  # noqa: E501

        Converts a SQL query to a CaseStatementDesign object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_case_statement_design_sql_to_design(body, async_req=True)
        >>> result = thread.get()

        :param body: SQL to attempt to create an case statement Design object from
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CaseStatementDesign
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_case_statement_design_sql_to_design_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_case_statement_design_sql_to_design_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def put_case_statement_design_sql_to_design_with_http_info(self, body : Annotated[Optional[StrictStr], Field( description="SQL to attempt to create an case statement Design object from")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PutCaseStatementDesignSqlToDesign: Convert SQL to a case statement design object  # noqa: E501

        Converts a SQL query to a CaseStatementDesign object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_case_statement_design_sql_to_design_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: SQL to attempt to create an case statement Design object from
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CaseStatementDesign, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_case_statement_design_sql_to_design" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "CaseStatementDesign",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/tocasestatementdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_case_statement_design_to_sql(self, case_statement_design : Annotated[CaseStatementDesign, Field(description="CaseStatementDesign object to try and create a SQL query from")], **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def put_case_statement_design_to_sql(self, case_statement_design : Annotated[CaseStatementDesign, Field(description="CaseStatementDesign object to try and create a SQL query from")], async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def put_case_statement_design_to_sql(self, case_statement_design : Annotated[CaseStatementDesign, Field(description="CaseStatementDesign object to try and create a SQL query from")], async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """PutCaseStatementDesignToSql: Convert a case statement design object to SQL  # noqa: E501

        Generates a SQL case statement query from a structured CaseStatementDesign object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_case_statement_design_to_sql(case_statement_design, async_req=True)
        >>> result = thread.get()

        :param case_statement_design: CaseStatementDesign object to try and create a SQL query from (required)
        :type case_statement_design: CaseStatementDesign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_case_statement_design_to_sql_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_case_statement_design_to_sql_with_http_info(case_statement_design, **kwargs)  # noqa: E501

    @validate_arguments
    def put_case_statement_design_to_sql_with_http_info(self, case_statement_design : Annotated[CaseStatementDesign, Field(description="CaseStatementDesign object to try and create a SQL query from")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutCaseStatementDesignToSql: Convert a case statement design object to SQL  # noqa: E501

        Generates a SQL case statement query from a structured CaseStatementDesign object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_case_statement_design_to_sql_with_http_info(case_statement_design, async_req=True)
        >>> result = thread.get()

        :param case_statement_design: CaseStatementDesign object to try and create a SQL query from (required)
        :type case_statement_design: CaseStatementDesign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'case_statement_design'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_case_statement_design_to_sql" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['case_statement_design'] is not None:
            _body_params = _params['case_statement_design']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/fromcasestatementdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_file_read_design_to_sql(self, file_reader_builder_def : Annotated[FileReaderBuilderDef, Field(description="Structured file read design object to generate SQL from")], execute_query : Annotated[Optional[StrictBool], Field(description="Should the generated query be executed to build preview data or determine errors.>")] = None, **kwargs) -> FileReaderBuilderResponse:  # noqa: E501
        ...

    @overload
    def put_file_read_design_to_sql(self, file_reader_builder_def : Annotated[FileReaderBuilderDef, Field(description="Structured file read design object to generate SQL from")], execute_query : Annotated[Optional[StrictBool], Field(description="Should the generated query be executed to build preview data or determine errors.>")] = None, async_req: Optional[bool]=True, **kwargs) -> FileReaderBuilderResponse:  # noqa: E501
        ...

    @validate_arguments
    def put_file_read_design_to_sql(self, file_reader_builder_def : Annotated[FileReaderBuilderDef, Field(description="Structured file read design object to generate SQL from")], execute_query : Annotated[Optional[StrictBool], Field(description="Should the generated query be executed to build preview data or determine errors.>")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[FileReaderBuilderResponse, Awaitable[FileReaderBuilderResponse]]:  # noqa: E501
        """PutFileReadDesignToSql: Make file read SQL from a design object  # noqa: E501

        Generates SQL from a FileReaderBuilderDef object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_file_read_design_to_sql(file_reader_builder_def, execute_query, async_req=True)
        >>> result = thread.get()

        :param file_reader_builder_def: Structured file read design object to generate SQL from (required)
        :type file_reader_builder_def: FileReaderBuilderDef
        :param execute_query: Should the generated query be executed to build preview data or determine errors.>
        :type execute_query: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileReaderBuilderResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_file_read_design_to_sql_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_file_read_design_to_sql_with_http_info(file_reader_builder_def, execute_query, **kwargs)  # noqa: E501

    @validate_arguments
    def put_file_read_design_to_sql_with_http_info(self, file_reader_builder_def : Annotated[FileReaderBuilderDef, Field(description="Structured file read design object to generate SQL from")], execute_query : Annotated[Optional[StrictBool], Field(description="Should the generated query be executed to build preview data or determine errors.>")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PutFileReadDesignToSql: Make file read SQL from a design object  # noqa: E501

        Generates SQL from a FileReaderBuilderDef object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_file_read_design_to_sql_with_http_info(file_reader_builder_def, execute_query, async_req=True)
        >>> result = thread.get()

        :param file_reader_builder_def: Structured file read design object to generate SQL from (required)
        :type file_reader_builder_def: FileReaderBuilderDef
        :param execute_query: Should the generated query be executed to build preview data or determine errors.>
        :type execute_query: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileReaderBuilderResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'file_reader_builder_def',
            'execute_query'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_file_read_design_to_sql" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('execute_query') is not None:  # noqa: E501
            _query_params.append(('executeQuery', _params['execute_query']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['file_reader_builder_def'] is not None:
            _body_params = _params['file_reader_builder_def']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "FileReaderBuilderResponse",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/fromfilereaddesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_inlined_properties_design_sql_to_design(self, body : Annotated[Optional[StrictStr], Field( description="SQL query to attempt to generate the inlined properties design object from")] = None, **kwargs) -> InlinedPropertyDesign:  # noqa: E501
        ...

    @overload
    def put_inlined_properties_design_sql_to_design(self, body : Annotated[Optional[StrictStr], Field( description="SQL query to attempt to generate the inlined properties design object from")] = None, async_req: Optional[bool]=True, **kwargs) -> InlinedPropertyDesign:  # noqa: E501
        ...

    @validate_arguments
    def put_inlined_properties_design_sql_to_design(self, body : Annotated[Optional[StrictStr], Field( description="SQL query to attempt to generate the inlined properties design object from")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[InlinedPropertyDesign, Awaitable[InlinedPropertyDesign]]:  # noqa: E501
        """PutInlinedPropertiesDesignSqlToDesign: Make an inlined properties design from SQL  # noqa: E501

        Generates a SQL-inlined-properties-design object from SQL string, if possible.  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_inlined_properties_design_sql_to_design(body, async_req=True)
        >>> result = thread.get()

        :param body: SQL query to attempt to generate the inlined properties design object from
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InlinedPropertyDesign
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_inlined_properties_design_sql_to_design_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_inlined_properties_design_sql_to_design_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def put_inlined_properties_design_sql_to_design_with_http_info(self, body : Annotated[Optional[StrictStr], Field( description="SQL query to attempt to generate the inlined properties design object from")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PutInlinedPropertiesDesignSqlToDesign: Make an inlined properties design from SQL  # noqa: E501

        Generates a SQL-inlined-properties-design object from SQL string, if possible.  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_inlined_properties_design_sql_to_design_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: SQL query to attempt to generate the inlined properties design object from
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InlinedPropertyDesign, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_inlined_properties_design_sql_to_design" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "InlinedPropertyDesign",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/toinlinedpropertiesdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_inlined_properties_design_to_sql(self, inlined_property_design : Annotated[InlinedPropertyDesign, Field(description="Inlined properties Designer specification to generate SQL from")], **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def put_inlined_properties_design_to_sql(self, inlined_property_design : Annotated[InlinedPropertyDesign, Field(description="Inlined properties Designer specification to generate SQL from")], async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def put_inlined_properties_design_to_sql(self, inlined_property_design : Annotated[InlinedPropertyDesign, Field(description="Inlined properties Designer specification to generate SQL from")], async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """PutInlinedPropertiesDesignToSql: Make inlined properties SQL from a design object  # noqa: E501

        Generates inlined properties SQL from a structured design  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_inlined_properties_design_to_sql(inlined_property_design, async_req=True)
        >>> result = thread.get()

        :param inlined_property_design: Inlined properties Designer specification to generate SQL from (required)
        :type inlined_property_design: InlinedPropertyDesign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_inlined_properties_design_to_sql_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_inlined_properties_design_to_sql_with_http_info(inlined_property_design, **kwargs)  # noqa: E501

    @validate_arguments
    def put_inlined_properties_design_to_sql_with_http_info(self, inlined_property_design : Annotated[InlinedPropertyDesign, Field(description="Inlined properties Designer specification to generate SQL from")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutInlinedPropertiesDesignToSql: Make inlined properties SQL from a design object  # noqa: E501

        Generates inlined properties SQL from a structured design  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_inlined_properties_design_to_sql_with_http_info(inlined_property_design, async_req=True)
        >>> result = thread.get()

        :param inlined_property_design: Inlined properties Designer specification to generate SQL from (required)
        :type inlined_property_design: InlinedPropertyDesign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'inlined_property_design'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_inlined_properties_design_to_sql" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['inlined_property_design'] is not None:
            _body_params = _params['inlined_property_design']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/frominlinedpropertiesdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_intellisense(self, intellisense_request : Annotated[IntellisenseRequest, Field(description="SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from.")], **kwargs) -> IntellisenseResponse:  # noqa: E501
        ...

    @overload
    def put_intellisense(self, intellisense_request : Annotated[IntellisenseRequest, Field(description="SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from.")], async_req: Optional[bool]=True, **kwargs) -> IntellisenseResponse:  # noqa: E501
        ...

    @validate_arguments
    def put_intellisense(self, intellisense_request : Annotated[IntellisenseRequest, Field(description="SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from.")], async_req: Optional[bool]=None, **kwargs) -> Union[IntellisenseResponse, Awaitable[IntellisenseResponse]]:  # noqa: E501
        """PutIntellisense: Make intellisense prompts given an SQL snip-it  # noqa: E501

        Generate a set of possible intellisense prompts given a SQL snip-it (in need not yet be valid SQL) and cursor location  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_intellisense(intellisense_request, async_req=True)
        >>> result = thread.get()

        :param intellisense_request: SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from. (required)
        :type intellisense_request: IntellisenseRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IntellisenseResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_intellisense_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_intellisense_with_http_info(intellisense_request, **kwargs)  # noqa: E501

    @validate_arguments
    def put_intellisense_with_http_info(self, intellisense_request : Annotated[IntellisenseRequest, Field(description="SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutIntellisense: Make intellisense prompts given an SQL snip-it  # noqa: E501

        Generate a set of possible intellisense prompts given a SQL snip-it (in need not yet be valid SQL) and cursor location  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_intellisense_with_http_info(intellisense_request, async_req=True)
        >>> result = thread.get()

        :param intellisense_request: SQL and a row/colum position within it from which to determine intellisense options for the user to potentially choose from. (required)
        :type intellisense_request: IntellisenseRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IntellisenseResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'intellisense_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_intellisense" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['intellisense_request'] is not None:
            _body_params = _params['intellisense_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "IntellisenseResponse",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/intellisense', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_intellisense_error(self, error_highlight_request : Annotated[ErrorHighlightRequest, Field(description="SQL (by line) to syntax check and return error ranges from within, if any.")], **kwargs) -> ErrorHighlightResponse:  # noqa: E501
        ...

    @overload
    def put_intellisense_error(self, error_highlight_request : Annotated[ErrorHighlightRequest, Field(description="SQL (by line) to syntax check and return error ranges from within, if any.")], async_req: Optional[bool]=True, **kwargs) -> ErrorHighlightResponse:  # noqa: E501
        ...

    @validate_arguments
    def put_intellisense_error(self, error_highlight_request : Annotated[ErrorHighlightRequest, Field(description="SQL (by line) to syntax check and return error ranges from within, if any.")], async_req: Optional[bool]=None, **kwargs) -> Union[ErrorHighlightResponse, Awaitable[ErrorHighlightResponse]]:  # noqa: E501
        """PutIntellisenseError: Get error ranges from SQL  # noqa: E501

        Generate a set of error ranges, if any, in the given SQL (expressed as Lines)  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_intellisense_error(error_highlight_request, async_req=True)
        >>> result = thread.get()

        :param error_highlight_request: SQL (by line) to syntax check and return error ranges from within, if any. (required)
        :type error_highlight_request: ErrorHighlightRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ErrorHighlightResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_intellisense_error_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_intellisense_error_with_http_info(error_highlight_request, **kwargs)  # noqa: E501

    @validate_arguments
    def put_intellisense_error_with_http_info(self, error_highlight_request : Annotated[ErrorHighlightRequest, Field(description="SQL (by line) to syntax check and return error ranges from within, if any.")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutIntellisenseError: Get error ranges from SQL  # noqa: E501

        Generate a set of error ranges, if any, in the given SQL (expressed as Lines)  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_intellisense_error_with_http_info(error_highlight_request, async_req=True)
        >>> result = thread.get()

        :param error_highlight_request: SQL (by line) to syntax check and return error ranges from within, if any. (required)
        :type error_highlight_request: ErrorHighlightRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ErrorHighlightResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'error_highlight_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_intellisense_error" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['error_highlight_request'] is not None:
            _body_params = _params['error_highlight_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "ErrorHighlightResponse",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/intellisenseError', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_lusid_grid_to_query(self, lusid_grid_data : LusidGridData, **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def put_lusid_grid_to_query(self, lusid_grid_data : LusidGridData, async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def put_lusid_grid_to_query(self, lusid_grid_data : LusidGridData, async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """[EXPERIMENTAL] PutLusidGridToQuery: Generates SQL from a dashboard view  # noqa: E501

        Used to convert dashboard views in LUSID to SQL that can be run in Lumi  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_lusid_grid_to_query(lusid_grid_data, async_req=True)
        >>> result = thread.get()

        :param lusid_grid_data: (required)
        :type lusid_grid_data: LusidGridData
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_lusid_grid_to_query_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_lusid_grid_to_query_with_http_info(lusid_grid_data, **kwargs)  # noqa: E501

    @validate_arguments
    def put_lusid_grid_to_query_with_http_info(self, lusid_grid_data : LusidGridData, **kwargs) -> ApiResponse:  # noqa: E501
        """[EXPERIMENTAL] PutLusidGridToQuery: Generates SQL from a dashboard view  # noqa: E501

        Used to convert dashboard views in LUSID to SQL that can be run in Lumi  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_lusid_grid_to_query_with_http_info(lusid_grid_data, async_req=True)
        >>> result = thread.get()

        :param lusid_grid_data: (required)
        :type lusid_grid_data: LusidGridData
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'lusid_grid_data'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_lusid_grid_to_query" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['lusid_grid_data'] is not None:
            _body_params = _params['lusid_grid_data']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/fromlusidgrid', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_query_design_to_sql(self, query_design : Annotated[QueryDesign, Field(description="Structured Query design object to generate SQL from")], **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def put_query_design_to_sql(self, query_design : Annotated[QueryDesign, Field(description="Structured Query design object to generate SQL from")], async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def put_query_design_to_sql(self, query_design : Annotated[QueryDesign, Field(description="Structured Query design object to generate SQL from")], async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """PutQueryDesignToSql: Make SQL from a structured query design  # noqa: E501

        Generates SQL from a QueryDesign object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_query_design_to_sql(query_design, async_req=True)
        >>> result = thread.get()

        :param query_design: Structured Query design object to generate SQL from (required)
        :type query_design: QueryDesign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_query_design_to_sql_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_query_design_to_sql_with_http_info(query_design, **kwargs)  # noqa: E501

    @validate_arguments
    def put_query_design_to_sql_with_http_info(self, query_design : Annotated[QueryDesign, Field(description="Structured Query design object to generate SQL from")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutQueryDesignToSql: Make SQL from a structured query design  # noqa: E501

        Generates SQL from a QueryDesign object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_query_design_to_sql_with_http_info(query_design, async_req=True)
        >>> result = thread.get()

        :param query_design: Structured Query design object to generate SQL from (required)
        :type query_design: QueryDesign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'query_design'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_query_design_to_sql" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['query_design'] is not None:
            _body_params = _params['query_design']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/fromdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_query_to_format(self, body : Annotated[StrictStr, Field(..., description="LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it")], trailing_commas : Annotated[Optional[StrictBool], Field(description="Should commas be after an expression (as opposed to before)")] = None, uppercase_keywords : Annotated[Optional[StrictBool], Field(description="Should key words be capitalized")] = None, break_join_on_sections : Annotated[Optional[StrictBool], Field(description="Should clauses on joins be given line breaks?")] = None, space_after_expanded_comma : Annotated[Optional[StrictBool], Field(description="Should comma-lists have spaces after the commas?")] = None, keyword_standardization : Annotated[Optional[StrictBool], Field(description="Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)")] = None, expand_comma_lists : Annotated[Optional[StrictBool], Field(description="Should comma-lists (e.g. select a,b,c) have line breaks added?")] = None, expand_in_lists : Annotated[Optional[StrictBool], Field(description="Should IN-lists have line breaks added?")] = None, expand_boolean_expressions : Annotated[Optional[StrictBool], Field(description="Should boolean expressions have line breaks added?")] = None, expand_between_conditions : Annotated[Optional[StrictBool], Field(description="Should between conditions have line breaks added?")] = None, expand_case_statements : Annotated[Optional[StrictBool], Field(description="Should case-statements have line breaks added?")] = None, max_line_width : Annotated[Optional[StrictInt], Field(description="Maximum number of characters to allow on one line (if possible)")] = None, space_before_trailing_single_line_comments : Annotated[Optional[StrictBool], Field(description="Should the be a space before trailing single line comments?")] = None, multiline_comment_extra_line_break : Annotated[Optional[StrictBool], Field(description="Should an additional line break be added after multi-line comments?")] = None, **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def put_query_to_format(self, body : Annotated[StrictStr, Field(..., description="LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it")], trailing_commas : Annotated[Optional[StrictBool], Field(description="Should commas be after an expression (as opposed to before)")] = None, uppercase_keywords : Annotated[Optional[StrictBool], Field(description="Should key words be capitalized")] = None, break_join_on_sections : Annotated[Optional[StrictBool], Field(description="Should clauses on joins be given line breaks?")] = None, space_after_expanded_comma : Annotated[Optional[StrictBool], Field(description="Should comma-lists have spaces after the commas?")] = None, keyword_standardization : Annotated[Optional[StrictBool], Field(description="Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)")] = None, expand_comma_lists : Annotated[Optional[StrictBool], Field(description="Should comma-lists (e.g. select a,b,c) have line breaks added?")] = None, expand_in_lists : Annotated[Optional[StrictBool], Field(description="Should IN-lists have line breaks added?")] = None, expand_boolean_expressions : Annotated[Optional[StrictBool], Field(description="Should boolean expressions have line breaks added?")] = None, expand_between_conditions : Annotated[Optional[StrictBool], Field(description="Should between conditions have line breaks added?")] = None, expand_case_statements : Annotated[Optional[StrictBool], Field(description="Should case-statements have line breaks added?")] = None, max_line_width : Annotated[Optional[StrictInt], Field(description="Maximum number of characters to allow on one line (if possible)")] = None, space_before_trailing_single_line_comments : Annotated[Optional[StrictBool], Field(description="Should the be a space before trailing single line comments?")] = None, multiline_comment_extra_line_break : Annotated[Optional[StrictBool], Field(description="Should an additional line break be added after multi-line comments?")] = None, async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def put_query_to_format(self, body : Annotated[StrictStr, Field(..., description="LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it")], trailing_commas : Annotated[Optional[StrictBool], Field(description="Should commas be after an expression (as opposed to before)")] = None, uppercase_keywords : Annotated[Optional[StrictBool], Field(description="Should key words be capitalized")] = None, break_join_on_sections : Annotated[Optional[StrictBool], Field(description="Should clauses on joins be given line breaks?")] = None, space_after_expanded_comma : Annotated[Optional[StrictBool], Field(description="Should comma-lists have spaces after the commas?")] = None, keyword_standardization : Annotated[Optional[StrictBool], Field(description="Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)")] = None, expand_comma_lists : Annotated[Optional[StrictBool], Field(description="Should comma-lists (e.g. select a,b,c) have line breaks added?")] = None, expand_in_lists : Annotated[Optional[StrictBool], Field(description="Should IN-lists have line breaks added?")] = None, expand_boolean_expressions : Annotated[Optional[StrictBool], Field(description="Should boolean expressions have line breaks added?")] = None, expand_between_conditions : Annotated[Optional[StrictBool], Field(description="Should between conditions have line breaks added?")] = None, expand_case_statements : Annotated[Optional[StrictBool], Field(description="Should case-statements have line breaks added?")] = None, max_line_width : Annotated[Optional[StrictInt], Field(description="Maximum number of characters to allow on one line (if possible)")] = None, space_before_trailing_single_line_comments : Annotated[Optional[StrictBool], Field(description="Should the be a space before trailing single line comments?")] = None, multiline_comment_extra_line_break : Annotated[Optional[StrictBool], Field(description="Should an additional line break be added after multi-line comments?")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """PutQueryToFormat: Format SQL into a more readable form  # noqa: E501

         This formats SQL (given a set of options as to how to do so), a.k.a. Pretty-Print the SQL. It takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly) and returns the reformatted version. e.g. ```sql select x,y,z from a inner join b on a.x=b.x where x>y or y!=z ``` becomes ```sql select x, y, z from a inner join b    on a.x = b.x where x > y    or y != z ```   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_query_to_format(body, trailing_commas, uppercase_keywords, break_join_on_sections, space_after_expanded_comma, keyword_standardization, expand_comma_lists, expand_in_lists, expand_boolean_expressions, expand_between_conditions, expand_case_statements, max_line_width, space_before_trailing_single_line_comments, multiline_comment_extra_line_break, async_req=True)
        >>> result = thread.get()

        :param body: LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it (required)
        :type body: str
        :param trailing_commas: Should commas be after an expression (as opposed to before)
        :type trailing_commas: bool
        :param uppercase_keywords: Should key words be capitalized
        :type uppercase_keywords: bool
        :param break_join_on_sections: Should clauses on joins be given line breaks?
        :type break_join_on_sections: bool
        :param space_after_expanded_comma: Should comma-lists have spaces after the commas?
        :type space_after_expanded_comma: bool
        :param keyword_standardization: Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)
        :type keyword_standardization: bool
        :param expand_comma_lists: Should comma-lists (e.g. select a,b,c) have line breaks added?
        :type expand_comma_lists: bool
        :param expand_in_lists: Should IN-lists have line breaks added?
        :type expand_in_lists: bool
        :param expand_boolean_expressions: Should boolean expressions have line breaks added?
        :type expand_boolean_expressions: bool
        :param expand_between_conditions: Should between conditions have line breaks added?
        :type expand_between_conditions: bool
        :param expand_case_statements: Should case-statements have line breaks added?
        :type expand_case_statements: bool
        :param max_line_width: Maximum number of characters to allow on one line (if possible)
        :type max_line_width: int
        :param space_before_trailing_single_line_comments: Should the be a space before trailing single line comments?
        :type space_before_trailing_single_line_comments: bool
        :param multiline_comment_extra_line_break: Should an additional line break be added after multi-line comments?
        :type multiline_comment_extra_line_break: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_query_to_format_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_query_to_format_with_http_info(body, trailing_commas, uppercase_keywords, break_join_on_sections, space_after_expanded_comma, keyword_standardization, expand_comma_lists, expand_in_lists, expand_boolean_expressions, expand_between_conditions, expand_case_statements, max_line_width, space_before_trailing_single_line_comments, multiline_comment_extra_line_break, **kwargs)  # noqa: E501

    @validate_arguments
    def put_query_to_format_with_http_info(self, body : Annotated[StrictStr, Field(..., description="LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it")], trailing_commas : Annotated[Optional[StrictBool], Field(description="Should commas be after an expression (as opposed to before)")] = None, uppercase_keywords : Annotated[Optional[StrictBool], Field(description="Should key words be capitalized")] = None, break_join_on_sections : Annotated[Optional[StrictBool], Field(description="Should clauses on joins be given line breaks?")] = None, space_after_expanded_comma : Annotated[Optional[StrictBool], Field(description="Should comma-lists have spaces after the commas?")] = None, keyword_standardization : Annotated[Optional[StrictBool], Field(description="Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)")] = None, expand_comma_lists : Annotated[Optional[StrictBool], Field(description="Should comma-lists (e.g. select a,b,c) have line breaks added?")] = None, expand_in_lists : Annotated[Optional[StrictBool], Field(description="Should IN-lists have line breaks added?")] = None, expand_boolean_expressions : Annotated[Optional[StrictBool], Field(description="Should boolean expressions have line breaks added?")] = None, expand_between_conditions : Annotated[Optional[StrictBool], Field(description="Should between conditions have line breaks added?")] = None, expand_case_statements : Annotated[Optional[StrictBool], Field(description="Should case-statements have line breaks added?")] = None, max_line_width : Annotated[Optional[StrictInt], Field(description="Maximum number of characters to allow on one line (if possible)")] = None, space_before_trailing_single_line_comments : Annotated[Optional[StrictBool], Field(description="Should the be a space before trailing single line comments?")] = None, multiline_comment_extra_line_break : Annotated[Optional[StrictBool], Field(description="Should an additional line break be added after multi-line comments?")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PutQueryToFormat: Format SQL into a more readable form  # noqa: E501

         This formats SQL (given a set of options as to how to do so), a.k.a. Pretty-Print the SQL. It takes some SQL (or a fragment thereof, it need not fully parse as yet and certainly need not execute correctly) and returns the reformatted version. e.g. ```sql select x,y,z from a inner join b on a.x=b.x where x>y or y!=z ``` becomes ```sql select x, y, z from a inner join b    on a.x = b.x where x > y    or y != z ```   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_query_to_format_with_http_info(body, trailing_commas, uppercase_keywords, break_join_on_sections, space_after_expanded_comma, keyword_standardization, expand_comma_lists, expand_in_lists, expand_boolean_expressions, expand_between_conditions, expand_case_statements, max_line_width, space_before_trailing_single_line_comments, multiline_comment_extra_line_break, async_req=True)
        >>> result = thread.get()

        :param body: LuminesceSql to Pretty-Print. Even if it doesn't parse an attempt will be made to format it (required)
        :type body: str
        :param trailing_commas: Should commas be after an expression (as opposed to before)
        :type trailing_commas: bool
        :param uppercase_keywords: Should key words be capitalized
        :type uppercase_keywords: bool
        :param break_join_on_sections: Should clauses on joins be given line breaks?
        :type break_join_on_sections: bool
        :param space_after_expanded_comma: Should comma-lists have spaces after the commas?
        :type space_after_expanded_comma: bool
        :param keyword_standardization: Should the \"nicest\" key words be used? (e.g. JOIN -> INNER JOIN)
        :type keyword_standardization: bool
        :param expand_comma_lists: Should comma-lists (e.g. select a,b,c) have line breaks added?
        :type expand_comma_lists: bool
        :param expand_in_lists: Should IN-lists have line breaks added?
        :type expand_in_lists: bool
        :param expand_boolean_expressions: Should boolean expressions have line breaks added?
        :type expand_boolean_expressions: bool
        :param expand_between_conditions: Should between conditions have line breaks added?
        :type expand_between_conditions: bool
        :param expand_case_statements: Should case-statements have line breaks added?
        :type expand_case_statements: bool
        :param max_line_width: Maximum number of characters to allow on one line (if possible)
        :type max_line_width: int
        :param space_before_trailing_single_line_comments: Should the be a space before trailing single line comments?
        :type space_before_trailing_single_line_comments: bool
        :param multiline_comment_extra_line_break: Should an additional line break be added after multi-line comments?
        :type multiline_comment_extra_line_break: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body',
            'trailing_commas',
            'uppercase_keywords',
            'break_join_on_sections',
            'space_after_expanded_comma',
            'keyword_standardization',
            'expand_comma_lists',
            'expand_in_lists',
            'expand_boolean_expressions',
            'expand_between_conditions',
            'expand_case_statements',
            'max_line_width',
            'space_before_trailing_single_line_comments',
            'multiline_comment_extra_line_break'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_query_to_format" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('trailing_commas') is not None:  # noqa: E501
            _query_params.append(('trailingCommas', _params['trailing_commas']))

        if _params.get('uppercase_keywords') is not None:  # noqa: E501
            _query_params.append(('uppercaseKeywords', _params['uppercase_keywords']))

        if _params.get('break_join_on_sections') is not None:  # noqa: E501
            _query_params.append(('breakJoinOnSections', _params['break_join_on_sections']))

        if _params.get('space_after_expanded_comma') is not None:  # noqa: E501
            _query_params.append(('spaceAfterExpandedComma', _params['space_after_expanded_comma']))

        if _params.get('keyword_standardization') is not None:  # noqa: E501
            _query_params.append(('keywordStandardization', _params['keyword_standardization']))

        if _params.get('expand_comma_lists') is not None:  # noqa: E501
            _query_params.append(('expandCommaLists', _params['expand_comma_lists']))

        if _params.get('expand_in_lists') is not None:  # noqa: E501
            _query_params.append(('expandInLists', _params['expand_in_lists']))

        if _params.get('expand_boolean_expressions') is not None:  # noqa: E501
            _query_params.append(('expandBooleanExpressions', _params['expand_boolean_expressions']))

        if _params.get('expand_between_conditions') is not None:  # noqa: E501
            _query_params.append(('expandBetweenConditions', _params['expand_between_conditions']))

        if _params.get('expand_case_statements') is not None:  # noqa: E501
            _query_params.append(('expandCaseStatements', _params['expand_case_statements']))

        if _params.get('max_line_width') is not None:  # noqa: E501
            _query_params.append(('maxLineWidth', _params['max_line_width']))

        if _params.get('space_before_trailing_single_line_comments') is not None:  # noqa: E501
            _query_params.append(('spaceBeforeTrailingSingleLineComments', _params['space_before_trailing_single_line_comments']))

        if _params.get('multiline_comment_extra_line_break') is not None:  # noqa: E501
            _query_params.append(('multilineCommentExtraLineBreak', _params['multiline_comment_extra_line_break']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/pretty', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_sql_to_extract_scalar_parameters(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the design object from")], **kwargs) -> List[ScalarParameter]:  # noqa: E501
        ...

    @overload
    def put_sql_to_extract_scalar_parameters(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the design object from")], async_req: Optional[bool]=True, **kwargs) -> List[ScalarParameter]:  # noqa: E501
        ...

    @validate_arguments
    def put_sql_to_extract_scalar_parameters(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the design object from")], async_req: Optional[bool]=None, **kwargs) -> Union[List[ScalarParameter], Awaitable[List[ScalarParameter]]]:  # noqa: E501
        """PutSqlToExtractScalarParameters: Extract scalar parameter information from SQL  # noqa: E501

        Extracts information about all the scalar parameters defined in the given SQL statement  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_extract_scalar_parameters(body, async_req=True)
        >>> result = thread.get()

        :param body: SQL query to generate the design object from (required)
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[ScalarParameter]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_sql_to_extract_scalar_parameters_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_sql_to_extract_scalar_parameters_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def put_sql_to_extract_scalar_parameters_with_http_info(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the design object from")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutSqlToExtractScalarParameters: Extract scalar parameter information from SQL  # noqa: E501

        Extracts information about all the scalar parameters defined in the given SQL statement  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_extract_scalar_parameters_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: SQL query to generate the design object from (required)
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[ScalarParameter], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_sql_to_extract_scalar_parameters" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "List[ScalarParameter]",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/extractscalarparameters', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_sql_to_file_read_design(self, determine_available_sources : Annotated[Optional[StrictBool], Field(description="Should the available sources be determined from `Sys.Registration`")] = None, body : Annotated[Optional[StrictStr], Field( description="SQL query to generate the file read design object from")] = None, **kwargs) -> FileReaderBuilderDef:  # noqa: E501
        ...

    @overload
    def put_sql_to_file_read_design(self, determine_available_sources : Annotated[Optional[StrictBool], Field(description="Should the available sources be determined from `Sys.Registration`")] = None, body : Annotated[Optional[StrictStr], Field( description="SQL query to generate the file read design object from")] = None, async_req: Optional[bool]=True, **kwargs) -> FileReaderBuilderDef:  # noqa: E501
        ...

    @validate_arguments
    def put_sql_to_file_read_design(self, determine_available_sources : Annotated[Optional[StrictBool], Field(description="Should the available sources be determined from `Sys.Registration`")] = None, body : Annotated[Optional[StrictStr], Field( description="SQL query to generate the file read design object from")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[FileReaderBuilderDef, Awaitable[FileReaderBuilderDef]]:  # noqa: E501
        """PutSqlToFileReadDesign: Make a design object from file-read SQL  # noqa: E501

        Generates a SQL-file-read-design object from SQL string, if possible.  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_file_read_design(determine_available_sources, body, async_req=True)
        >>> result = thread.get()

        :param determine_available_sources: Should the available sources be determined from `Sys.Registration`
        :type determine_available_sources: bool
        :param body: SQL query to generate the file read design object from
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: FileReaderBuilderDef
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_sql_to_file_read_design_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_sql_to_file_read_design_with_http_info(determine_available_sources, body, **kwargs)  # noqa: E501

    @validate_arguments
    def put_sql_to_file_read_design_with_http_info(self, determine_available_sources : Annotated[Optional[StrictBool], Field(description="Should the available sources be determined from `Sys.Registration`")] = None, body : Annotated[Optional[StrictStr], Field( description="SQL query to generate the file read design object from")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PutSqlToFileReadDesign: Make a design object from file-read SQL  # noqa: E501

        Generates a SQL-file-read-design object from SQL string, if possible.  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_file_read_design_with_http_info(determine_available_sources, body, async_req=True)
        >>> result = thread.get()

        :param determine_available_sources: Should the available sources be determined from `Sys.Registration`
        :type determine_available_sources: bool
        :param body: SQL query to generate the file read design object from
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(FileReaderBuilderDef, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'determine_available_sources',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_sql_to_file_read_design" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('determine_available_sources') is not None:  # noqa: E501
            _query_params.append(('determineAvailableSources', _params['determine_available_sources']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "FileReaderBuilderDef",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/tofilereaddesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_sql_to_query_design(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the design object from")], validate_with_metadata : Annotated[Optional[StrictBool], Field(description="Should the table be validated against the users' view of Sys.Field to fill in DataTypes, etc.?")] = None, version : Annotated[Optional[str], Field( description="Designer version number used to support multiple web user interface versions. Only some values will be allowed and this will change over time (as mentioned this whole method is largely internal to the Finbourne web user interfaces and evolves over time).")] = None, **kwargs) -> QueryDesign:  # noqa: E501
        ...

    @overload
    def put_sql_to_query_design(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the design object from")], validate_with_metadata : Annotated[Optional[StrictBool], Field(description="Should the table be validated against the users' view of Sys.Field to fill in DataTypes, etc.?")] = None, version : Annotated[Optional[str], Field( description="Designer version number used to support multiple web user interface versions. Only some values will be allowed and this will change over time (as mentioned this whole method is largely internal to the Finbourne web user interfaces and evolves over time).")] = None, async_req: Optional[bool]=True, **kwargs) -> QueryDesign:  # noqa: E501
        ...

    @validate_arguments
    def put_sql_to_query_design(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the design object from")], validate_with_metadata : Annotated[Optional[StrictBool], Field(description="Should the table be validated against the users' view of Sys.Field to fill in DataTypes, etc.?")] = None, version : Annotated[Optional[str], Field( description="Designer version number used to support multiple web user interface versions. Only some values will be allowed and this will change over time (as mentioned this whole method is largely internal to the Finbourne web user interfaces and evolves over time).")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[QueryDesign, Awaitable[QueryDesign]]:  # noqa: E501
        """PutSqlToQueryDesign: Make a SQL-design object from SQL if possible  # noqa: E501

        Generates a QueryDesign object from simple SQL if possible  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_query_design(body, validate_with_metadata, version, async_req=True)
        >>> result = thread.get()

        :param body: SQL query to generate the design object from (required)
        :type body: str
        :param validate_with_metadata: Should the table be validated against the users' view of Sys.Field to fill in DataTypes, etc.?
        :type validate_with_metadata: bool
        :param version: Designer version number used to support multiple web user interface versions. Only some values will be allowed and this will change over time (as mentioned this whole method is largely internal to the Finbourne web user interfaces and evolves over time).
        :type version: QueryDesignerVersion
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: QueryDesign
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_sql_to_query_design_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_sql_to_query_design_with_http_info(body, validate_with_metadata, version, **kwargs)  # noqa: E501

    @validate_arguments
    def put_sql_to_query_design_with_http_info(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the design object from")], validate_with_metadata : Annotated[Optional[StrictBool], Field(description="Should the table be validated against the users' view of Sys.Field to fill in DataTypes, etc.?")] = None, version : Annotated[Optional[str], Field( description="Designer version number used to support multiple web user interface versions. Only some values will be allowed and this will change over time (as mentioned this whole method is largely internal to the Finbourne web user interfaces and evolves over time).")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PutSqlToQueryDesign: Make a SQL-design object from SQL if possible  # noqa: E501

        Generates a QueryDesign object from simple SQL if possible  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_query_design_with_http_info(body, validate_with_metadata, version, async_req=True)
        >>> result = thread.get()

        :param body: SQL query to generate the design object from (required)
        :type body: str
        :param validate_with_metadata: Should the table be validated against the users' view of Sys.Field to fill in DataTypes, etc.?
        :type validate_with_metadata: bool
        :param version: Designer version number used to support multiple web user interface versions. Only some values will be allowed and this will change over time (as mentioned this whole method is largely internal to the Finbourne web user interfaces and evolves over time).
        :type version: QueryDesignerVersion
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(QueryDesign, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body',
            'validate_with_metadata',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_sql_to_query_design" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('validate_with_metadata') is not None:  # noqa: E501
            _query_params.append(('validateWithMetadata', _params['validate_with_metadata']))

        if _params.get('version') is not None:  # noqa: E501
            _query_params.append(('version', _params['version']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "QueryDesign",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/todesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_sql_to_view_design(self, body : Annotated[StrictStr, Field(..., description="SQL Query to generate the ConvertToViewData object from")], **kwargs) -> ConvertToViewData:  # noqa: E501
        ...

    @overload
    def put_sql_to_view_design(self, body : Annotated[StrictStr, Field(..., description="SQL Query to generate the ConvertToViewData object from")], async_req: Optional[bool]=True, **kwargs) -> ConvertToViewData:  # noqa: E501
        ...

    @validate_arguments
    def put_sql_to_view_design(self, body : Annotated[StrictStr, Field(..., description="SQL Query to generate the ConvertToViewData object from")], async_req: Optional[bool]=None, **kwargs) -> Union[ConvertToViewData, Awaitable[ConvertToViewData]]:  # noqa: E501
        """PutSqlToViewDesign: Make a view-design from view creation SQL  # noqa: E501

        Converts SQL which creates a view into a structured ConvertToViewData object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_view_design(body, async_req=True)
        >>> result = thread.get()

        :param body: SQL Query to generate the ConvertToViewData object from (required)
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ConvertToViewData
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_sql_to_view_design_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_sql_to_view_design_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def put_sql_to_view_design_with_http_info(self, body : Annotated[StrictStr, Field(..., description="SQL Query to generate the ConvertToViewData object from")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutSqlToViewDesign: Make a view-design from view creation SQL  # noqa: E501

        Converts SQL which creates a view into a structured ConvertToViewData object  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_view_design_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body: SQL Query to generate the ConvertToViewData object from (required)
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ConvertToViewData, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_sql_to_view_design" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "ConvertToViewData",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/toviewdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_sql_to_writer_design(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the writer design object from")], merge_additional_mapping_fields : Annotated[Optional[StrictBool], Field(description="Should `Sys.Field` be used to find additional potential fields to map from? (not always possible)")] = None, **kwargs) -> WriterDesign:  # noqa: E501
        ...

    @overload
    def put_sql_to_writer_design(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the writer design object from")], merge_additional_mapping_fields : Annotated[Optional[StrictBool], Field(description="Should `Sys.Field` be used to find additional potential fields to map from? (not always possible)")] = None, async_req: Optional[bool]=True, **kwargs) -> WriterDesign:  # noqa: E501
        ...

    @validate_arguments
    def put_sql_to_writer_design(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the writer design object from")], merge_additional_mapping_fields : Annotated[Optional[StrictBool], Field(description="Should `Sys.Field` be used to find additional potential fields to map from? (not always possible)")] = None, async_req: Optional[bool]=None, **kwargs) -> Union[WriterDesign, Awaitable[WriterDesign]]:  # noqa: E501
        """PutSqlToWriterDesign: Make a SQL-writer-design object from SQL  # noqa: E501

        Generates a SQL-writer-design object (WriterDesign) from a SQL query, if possible  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_writer_design(body, merge_additional_mapping_fields, async_req=True)
        >>> result = thread.get()

        :param body: SQL query to generate the writer design object from (required)
        :type body: str
        :param merge_additional_mapping_fields: Should `Sys.Field` be used to find additional potential fields to map from? (not always possible)
        :type merge_additional_mapping_fields: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WriterDesign
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_sql_to_writer_design_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_sql_to_writer_design_with_http_info(body, merge_additional_mapping_fields, **kwargs)  # noqa: E501

    @validate_arguments
    def put_sql_to_writer_design_with_http_info(self, body : Annotated[StrictStr, Field(..., description="SQL query to generate the writer design object from")], merge_additional_mapping_fields : Annotated[Optional[StrictBool], Field(description="Should `Sys.Field` be used to find additional potential fields to map from? (not always possible)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """PutSqlToWriterDesign: Make a SQL-writer-design object from SQL  # noqa: E501

        Generates a SQL-writer-design object (WriterDesign) from a SQL query, if possible  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_sql_to_writer_design_with_http_info(body, merge_additional_mapping_fields, async_req=True)
        >>> result = thread.get()

        :param body: SQL query to generate the writer design object from (required)
        :type body: str
        :param merge_additional_mapping_fields: Should `Sys.Field` be used to find additional potential fields to map from? (not always possible)
        :type merge_additional_mapping_fields: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WriterDesign, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'body',
            'merge_additional_mapping_fields'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_sql_to_writer_design" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('merge_additional_mapping_fields') is not None:  # noqa: E501
            _query_params.append(('mergeAdditionalMappingFields', _params['merge_additional_mapping_fields']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body'] is not None:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['text/plain']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "WriterDesign",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/towriterdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_view_design_to_sql(self, convert_to_view_data : Annotated[ConvertToViewData, Field(description="Structured Query design object to generate SQL from")], **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def put_view_design_to_sql(self, convert_to_view_data : Annotated[ConvertToViewData, Field(description="Structured Query design object to generate SQL from")], async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def put_view_design_to_sql(self, convert_to_view_data : Annotated[ConvertToViewData, Field(description="Structured Query design object to generate SQL from")], async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """PutViewDesignToSql: Make view creation sql from a view-design  # noqa: E501

        Converts a ConvertToView specification into SQL that creates a view  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_view_design_to_sql(convert_to_view_data, async_req=True)
        >>> result = thread.get()

        :param convert_to_view_data: Structured Query design object to generate SQL from (required)
        :type convert_to_view_data: ConvertToViewData
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_view_design_to_sql_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_view_design_to_sql_with_http_info(convert_to_view_data, **kwargs)  # noqa: E501

    @validate_arguments
    def put_view_design_to_sql_with_http_info(self, convert_to_view_data : Annotated[ConvertToViewData, Field(description="Structured Query design object to generate SQL from")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutViewDesignToSql: Make view creation sql from a view-design  # noqa: E501

        Converts a ConvertToView specification into SQL that creates a view  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_view_design_to_sql_with_http_info(convert_to_view_data, async_req=True)
        >>> result = thread.get()

        :param convert_to_view_data: Structured Query design object to generate SQL from (required)
        :type convert_to_view_data: ConvertToViewData
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'convert_to_view_data'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_view_design_to_sql" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['convert_to_view_data'] is not None:
            _body_params = _params['convert_to_view_data']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/fromviewdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))


    @overload
    async def put_writer_design_to_sql(self, writer_design : Annotated[WriterDesign, Field(description="Structured Writer Design design object to generate Writer SQL from")], **kwargs) -> str:  # noqa: E501
        ...

    @overload
    def put_writer_design_to_sql(self, writer_design : Annotated[WriterDesign, Field(description="Structured Writer Design design object to generate Writer SQL from")], async_req: Optional[bool]=True, **kwargs) -> str:  # noqa: E501
        ...

    @validate_arguments
    def put_writer_design_to_sql(self, writer_design : Annotated[WriterDesign, Field(description="Structured Writer Design design object to generate Writer SQL from")], async_req: Optional[bool]=None, **kwargs) -> Union[str, Awaitable[str]]:  # noqa: E501
        """PutWriterDesignToSql: Make writer SQL from a writer-design object  # noqa: E501

        Generates writer SQL from a valid WriterDesign structure  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_writer_design_to_sql(writer_design, async_req=True)
        >>> result = thread.get()

        :param writer_design: Structured Writer Design design object to generate Writer SQL from (required)
        :type writer_design: WriterDesign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the put_writer_design_to_sql_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        if async_req is not None:
            kwargs['async_req'] = async_req
        return self.put_writer_design_to_sql_with_http_info(writer_design, **kwargs)  # noqa: E501

    @validate_arguments
    def put_writer_design_to_sql_with_http_info(self, writer_design : Annotated[WriterDesign, Field(description="Structured Writer Design design object to generate Writer SQL from")], **kwargs) -> ApiResponse:  # noqa: E501
        """PutWriterDesignToSql: Make writer SQL from a writer-design object  # noqa: E501

        Generates writer SQL from a valid WriterDesign structure  > This method is generally only intended for IDE generation purposes.  > It is largely internal to the Finbourne web user interfaces and subject to change without notice.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_writer_design_to_sql_with_http_info(writer_design, async_req=True)
        >>> result = thread.get()

        :param writer_design: Structured Writer Design design object to generate Writer SQL from (required)
        :type writer_design: WriterDesign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: Timeout setting. Do not use - use the opts parameter instead
        :param opts: Configuration options for this request
        :type opts: ConfigurationOptions, optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'writer_design'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers',
                'opts'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_writer_design_to_sql" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['writer_design'] is not None:
            _body_params = _params['writer_design']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json', 'text/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['oauth2']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "LusidProblemDetails",
            '403': "LusidProblemDetails",
        }

        return self.api_client.call_api(
            '/api/Sql/fromwriterdesign', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            opts=_params.get('opts'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
