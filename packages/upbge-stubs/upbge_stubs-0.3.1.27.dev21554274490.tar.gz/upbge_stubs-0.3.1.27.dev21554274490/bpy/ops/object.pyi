"""


Object Operators
****************

:func:`add`

:func:`add_modifier_menu`

:func:`add_named`

:func:`align`

:func:`anim_transforms_to_deltas`

:func:`armature_add`

:func:`assign_property_defaults`

:func:`bake`

:func:`bake_image`

:func:`camera_add`

:func:`camera_custom_update`

:func:`clear_override_library`

:func:`collection_add`

:func:`collection_external_asset_drop`

:func:`collection_instance_add`

:func:`collection_link`

:func:`collection_objects_select`

:func:`collection_remove`

:func:`collection_unlink`

:func:`constraint_add`

:func:`constraint_add_with_targets`

:func:`constraints_clear`

:func:`constraints_copy`

:func:`convert`

:func:`copy_global_transform`

:func:`copy_relative_transform`

:func:`correctivesmooth_bind`

:func:`curves_empty_hair_add`

:func:`curves_random_add`

:func:`data_instance_add`

:func:`data_transfer`

:func:`datalayout_transfer`

:func:`delete`

:func:`delete_fix_to_camera_keys`

:func:`drop_geometry_nodes`

:func:`drop_named_material`

:func:`duplicate`

:func:`duplicate_move`

:func:`duplicate_move_linked`

:func:`duplicates_make_real`

:func:`editmode_toggle`

:func:`effector_add`

:func:`empty_add`

:func:`empty_image_add`

:func:`explode_refresh`

:func:`fix_to_camera`

:func:`forcefield_toggle`

:func:`game_physics_copy`

:func:`game_property_clear`

:func:`game_property_copy`

:func:`game_property_move`

:func:`game_property_new`

:func:`game_property_remove`

:func:`geometry_node_bake_delete_single`

:func:`geometry_node_bake_pack_single`

:func:`geometry_node_bake_single`

:func:`geometry_node_bake_unpack_single`

:func:`geometry_node_tree_copy_assign`

:func:`geometry_nodes_input_attribute_toggle`

:func:`geometry_nodes_move_to_nodes`

:func:`grease_pencil_add`

:func:`grease_pencil_dash_modifier_segment_add`

:func:`grease_pencil_dash_modifier_segment_move`

:func:`grease_pencil_dash_modifier_segment_remove`

:func:`grease_pencil_time_modifier_segment_add`

:func:`grease_pencil_time_modifier_segment_move`

:func:`grease_pencil_time_modifier_segment_remove`

:func:`hide_collection`

:func:`hide_render_clear_all`

:func:`hide_view_clear`

:func:`hide_view_set`

:func:`hook_add_newob`

:func:`hook_add_selob`

:func:`hook_assign`

:func:`hook_recenter`

:func:`hook_remove`

:func:`hook_reset`

:func:`hook_select`

:func:`instance_offset_from_cursor`

:func:`instance_offset_from_object`

:func:`instance_offset_to_cursor`

:func:`isolate_type_render`

:func:`join`

:func:`join_shapes`

:func:`join_uvs`

:func:`laplaciandeform_bind`

:func:`lattice_add_to_selected`

:func:`light_add`

:func:`light_linking_blocker_collection_new`

:func:`light_linking_blockers_link`

:func:`light_linking_blockers_select`

:func:`light_linking_receiver_collection_new`

:func:`light_linking_receivers_link`

:func:`light_linking_receivers_select`

:func:`light_linking_unlink_from_collection`

:func:`lightprobe_add`

:func:`lightprobe_cache_bake`

:func:`lightprobe_cache_free`

:func:`lineart_bake_strokes`

:func:`lineart_clear`

:func:`link_to_collection`

:func:`location_clear`

:func:`lod_add`

:func:`lod_by_name`

:func:`lod_clear_all`

:func:`lod_generate`

:func:`lod_remove`

:func:`logic_bricks_copy`

:func:`make_dupli_face`

:func:`make_links_data`

:func:`make_links_scene`

:func:`make_local`

:func:`make_override_library`

:func:`make_single_user`

:func:`material_slot_add`

:func:`material_slot_assign`

:func:`material_slot_copy`

:func:`material_slot_deselect`

:func:`material_slot_move`

:func:`material_slot_remove`

:func:`material_slot_remove_all`

:func:`material_slot_remove_unused`

:func:`material_slot_select`

:func:`meshdeform_bind`

:func:`metaball_add`

:func:`mode_set`

:func:`mode_set_with_submode`

:func:`modifier_add`

:func:`modifier_add_node_group`

:func:`modifier_apply`

:func:`modifier_apply_as_shapekey`

:func:`modifier_convert`

:func:`modifier_copy`

:func:`modifier_copy_to_selected`

:func:`modifier_move_down`

:func:`modifier_move_to_index`

:func:`modifier_move_up`

:func:`modifier_remove`

:func:`modifier_set_active`

:func:`modifiers_clear`

:func:`modifiers_copy_to_selected`

:func:`move_to_collection`

:func:`multires_base_apply`

:func:`multires_external_pack`

:func:`multires_external_save`

:func:`multires_higher_levels_delete`

:func:`multires_rebuild_subdiv`

:func:`multires_reshape`

:func:`multires_subdivide`

:func:`multires_unsubdivide`

:func:`ocean_bake`

:func:`origin_clear`

:func:`origin_set`

:func:`parent_clear`

:func:`parent_inverse_apply`

:func:`parent_no_inverse_set`

:func:`parent_set`

:func:`particle_system_add`

:func:`particle_system_remove`

:func:`paste_transform`

:func:`paths_calculate`

:func:`paths_clear`

:func:`paths_update`

:func:`paths_update_visible`

:func:`pointcloud_random_add`

:func:`posemode_toggle`

:func:`quadriflow_remesh`

:func:`quick_explode`

:func:`quick_fur`

:func:`quick_liquid`

:func:`quick_smoke`

:func:`randomize_transform`

:func:`reset_override_library`

:func:`rotation_clear`

:func:`scale_clear`

:func:`select_all`

:func:`select_by_type`

:func:`select_camera`

:func:`select_grouped`

:func:`select_hierarchy`

:func:`select_less`

:func:`select_linked`

:func:`select_mirror`

:func:`select_more`

:func:`select_pattern`

:func:`select_random`

:func:`select_same_collection`

:func:`shade_auto_smooth`

:func:`shade_flat`

:func:`shade_smooth`

:func:`shade_smooth_by_angle`

:func:`shaderfx_add`

:func:`shaderfx_copy`

:func:`shaderfx_move_down`

:func:`shaderfx_move_to_index`

:func:`shaderfx_move_up`

:func:`shaderfx_remove`

:func:`shape_key_add`

:func:`shape_key_clear`

:func:`shape_key_copy`

:func:`shape_key_lock`

:func:`shape_key_make_basis`

:func:`shape_key_mirror`

:func:`shape_key_move`

:func:`shape_key_remove`

:func:`shape_key_retime`

:func:`shape_key_transfer`

:func:`simulation_nodes_cache_bake`

:func:`simulation_nodes_cache_calculate_to_frame`

:func:`simulation_nodes_cache_delete`

:func:`skin_armature_create`

:func:`skin_loose_mark_clear`

:func:`skin_radii_equalize`

:func:`skin_root_mark`

:func:`speaker_add`

:func:`subdivision_set`

:func:`surfacedeform_bind`

:func:`text_add`

:func:`track_clear`

:func:`track_set`

:func:`transfer_mode`

:func:`transform_apply`

:func:`transform_axis_target`

:func:`transform_to_mouse`

:func:`transforms_to_deltas`

:func:`unlink_data`

:func:`update_shapes`

:func:`vertex_group_add`

:func:`vertex_group_assign`

:func:`vertex_group_assign_new`

:func:`vertex_group_clean`

:func:`vertex_group_copy`

:func:`vertex_group_copy_to_selected`

:func:`vertex_group_deselect`

:func:`vertex_group_invert`

:func:`vertex_group_levels`

:func:`vertex_group_limit_total`

:func:`vertex_group_lock`

:func:`vertex_group_mirror`

:func:`vertex_group_move`

:func:`vertex_group_normalize`

:func:`vertex_group_normalize_all`

:func:`vertex_group_quantize`

:func:`vertex_group_remove`

:func:`vertex_group_remove_from`

:func:`vertex_group_select`

:func:`vertex_group_set_active`

:func:`vertex_group_smooth`

:func:`vertex_group_sort`

:func:`vertex_parent_set`

:func:`vertex_weight_copy`

:func:`vertex_weight_delete`

:func:`vertex_weight_normalize_active_vertex`

:func:`vertex_weight_paste`

:func:`vertex_weight_set_active`

:func:`visual_geometry_to_objects`

:func:`visual_transform_apply`

:func:`volume_add`

:func:`volume_import`

:func:`voxel_remesh`

:func:`voxel_size_edit`

"""

import typing

import mathutils

def add(*args, radius: float = 1.0, type: str = 'EMPTY', enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add an object to the scene

  """

  ...

def add_modifier_menu() -> None:

  """

  Undocumented, consider `contributing <https://developer.blender.org/>`_.

  """

  ...

def add_named(*args, linked: bool = False, name: str = '', session_uid: int = 0, matrix: mathutils.Matrix = ((0.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0, 0.0)), drop_x: int = 0, drop_y: int = 0) -> None:

  """

  Add named object

  """

  ...

def align(*args, bb_quality: bool = True, align_mode: str = 'OPT_2', relative_to: str = 'OPT_4', align_axis: typing.Set[str] = {}) -> None:

  """

  Align objects

  """

  ...

def anim_transforms_to_deltas() -> None:

  """

  Convert object animation for normal transforms to delta transforms

  """

  ...

def armature_add(*args, radius: float = 1.0, enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add an armature object to the scene

  """

  ...

def assign_property_defaults(*args, process_data: bool = True, process_bones: bool = True) -> None:

  """

  Assign the current values of custom properties as their defaults, for use as part of the rest pose state in NLA track mixing

  """

  ...

def bake(*args, type: str = 'COMBINED', pass_filter: typing.Set[str] = {}, filepath: str = '', width: int = 512, height: int = 512, margin: int = 16, margin_type: str = 'EXTEND', use_selected_to_active: bool = False, max_ray_distance: float = 0.0, cage_extrusion: float = 0.0, cage_object: str = '', normal_space: str = 'TANGENT', normal_r: str = 'POS_X', normal_g: str = 'POS_Y', normal_b: str = 'POS_Z', target: str = 'IMAGE_TEXTURES', save_mode: str = 'INTERNAL', use_clear: bool = False, use_cage: bool = False, use_split_materials: bool = False, use_automatic_name: bool = False, uv_layer: str = '') -> None:

  """

  Bake image textures of selected objects

  """

  ...

def bake_image() -> None:

  """

  Bake image textures of selected objects

  """

  ...

def camera_add(*args, enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a camera object to the scene

  """

  ...

def camera_custom_update() -> None:

  """

  Update custom camera with new parameters from the shader

  """

  ...

def clear_override_library() -> None:

  """

  Delete the selected local overrides and relink their usages to the linked data-blocks if possible, else reset them and mark them as non editable

  """

  ...

def collection_add() -> None:

  """

  Add an object to a new collection

  """

  ...

def collection_external_asset_drop(*args, session_uid: int = 0, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0), use_instance: bool = True, drop_x: int = 0, drop_y: int = 0, collection: str = '') -> None:

  """

  Add the dragged collection to the scene

  """

  ...

def collection_instance_add(*args, name: str = 'Collection', collection: str = '', align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0), session_uid: int = 0, drop_x: int = 0, drop_y: int = 0) -> None:

  """

  Add a collection instance

  """

  ...

def collection_link(*args, collection: str = '') -> None:

  """

  Add an object to an existing collection

  """

  ...

def collection_objects_select() -> None:

  """

  Select all objects in collection

  """

  ...

def collection_remove() -> None:

  """

  Remove the active object from this collection

  """

  ...

def collection_unlink() -> None:

  """

  Unlink the collection from all objects

  """

  ...

def constraint_add(*args, type: str = '') -> None:

  """

  Add a constraint to the active object

  """

  ...

def constraint_add_with_targets(*args, type: str = '') -> None:

  """

  Add a constraint to the active object, with target (where applicable) set to the selected objects/bones

  """

  ...

def constraints_clear() -> None:

  """

  Clear all constraints from the selected objects

  """

  ...

def constraints_copy() -> None:

  """

  Copy constraints to other selected objects

  """

  ...

def convert(*args, target: str = 'MESH', keep_original: bool = False, merge_customdata: bool = True, thickness: int = 5, faces: bool = True, offset: float = 0.01) -> None:

  """

  Convert selected objects to another type

  """

  ...

def copy_global_transform() -> None:

  """

  Copies the matrix of the currently active object or pose bone to the clipboard. Uses world-space matrices

  """

  ...

def copy_relative_transform() -> None:

  """

  Copies the matrix of the currently active object or pose bone to the clipboard. Uses matrices relative to a specific object or the active scene camera

  """

  ...

def correctivesmooth_bind(*args, modifier: str = '') -> None:

  """

  Bind base pose in Corrective Smooth modifier

  """

  ...

def curves_empty_hair_add(*args, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add an empty curve object to the scene with the selected mesh as surface

  """

  ...

def curves_random_add(*args, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a curves object with random curves to the scene

  """

  ...

def data_instance_add(*args, name: str = '', session_uid: int = 0, type: str = 'ACTION', align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0), drop_x: int = 0, drop_y: int = 0) -> None:

  """

  Add an object data instance

  """

  ...

def data_transfer(*args, use_reverse_transfer: bool = False, use_freeze: bool = False, data_type: str = 'VGROUP_WEIGHTS', use_create: bool = True, vert_mapping: str = 'NEAREST', edge_mapping: str = 'NEAREST', loop_mapping: str = 'NEAREST_POLYNOR', poly_mapping: str = 'NEAREST', use_auto_transform: bool = False, use_object_transform: bool = True, use_max_distance: bool = False, max_distance: float = 1.0, ray_radius: float = 0.0, islands_precision: float = 0.1, layers_select_src: str = 'ACTIVE', layers_select_dst: str = 'ACTIVE', mix_mode: str = 'REPLACE', mix_factor: float = 1.0) -> None:

  """

  Transfer data layer(s) (weights, edge sharp, etc.) from active to selected meshes

  """

  ...

def datalayout_transfer(*args, modifier: str = '', data_type: str = '', use_delete: bool = False, layers_select_src: str = 'ACTIVE', layers_select_dst: str = 'ACTIVE') -> None:

  """

  Transfer layout of data layer(s) from active to selected meshes

  """

  ...

def delete(*args, use_global: bool = False, confirm: bool = True) -> None:

  """

  Delete selected objects

  """

  ...

def delete_fix_to_camera_keys() -> None:

  """

  Delete all keys that were generated by the 'Fix to Scene Camera' operator

  """

  ...

def drop_geometry_nodes(*args, session_uid: int = 0, show_datablock_in_modifier: bool = True) -> None:

  """

  Undocumented, consider `contributing <https://developer.blender.org/>`_.

  """

  ...

def drop_named_material(*args, name: str = '', session_uid: int = 0) -> None:

  """

  Undocumented, consider `contributing <https://developer.blender.org/>`_.

  """

  ...

def duplicate(*args, linked: bool = False, mode: str = 'TRANSLATION') -> None:

  """

  Duplicate selected objects

  """

  ...

def duplicate_move(*args, OBJECT_OT_duplicate: OBJECT_OT_duplicate = None, TRANSFORM_OT_translate: TRANSFORM_OT_translate = None) -> None:

  """

  Duplicate the selected objects and move them

  """

  ...

def duplicate_move_linked(*args, OBJECT_OT_duplicate: OBJECT_OT_duplicate = None, TRANSFORM_OT_translate: TRANSFORM_OT_translate = None) -> None:

  """

  Duplicate the selected objects, but not their object data, and move them

  """

  ...

def duplicates_make_real(*args, use_base_parent: bool = False, use_hierarchy: bool = False) -> None:

  """

  Make instanced objects attached to this object real

  """

  ...

def editmode_toggle() -> None:

  """

  Toggle object's edit mode

  """

  ...

def effector_add(*args, type: str = 'FORCE', radius: float = 1.0, enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add an empty object with a physics effector to the scene

  """

  ...

def empty_add(*args, type: str = 'PLAIN_AXES', radius: float = 1.0, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add an empty object to the scene

  """

  ...

def empty_image_add(*args, filepath: str = '', hide_props_region: bool = True, check_existing: bool = False, filter_blender: bool = False, filter_backup: bool = False, filter_image: bool = True, filter_movie: bool = True, filter_python: bool = False, filter_font: bool = False, filter_sound: bool = False, filter_text: bool = False, filter_archive: bool = False, filter_btx: bool = False, filter_alembic: bool = False, filter_usd: bool = False, filter_obj: bool = False, filter_volume: bool = False, filter_folder: bool = True, filter_blenlib: bool = False, filemode: int = 9, relative_path: bool = True, show_multiview: bool = False, use_multiview: bool = False, display_type: str = 'DEFAULT', sort_method: str = '', name: str = '', session_uid: int = 0, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0), background: bool = False) -> None:

  """

  Add an empty image type to scene with data

  """

  ...

def explode_refresh(*args, modifier: str = '') -> None:

  """

  Refresh data in the Explode modifier

  """

  ...

def fix_to_camera(*args, use_location: bool = True, use_rotation: bool = True, use_scale: bool = True) -> None:

  """

  Generate new keys to fix the selected object/bone to the camera on unkeyed frames

  """

  ...

def forcefield_toggle() -> None:

  """

  Toggle object's force field

  """

  ...

def game_physics_copy() -> None:

  """

  Copy game physics properties to other selected objects

  """

  ...

def game_property_clear() -> None:

  """

  Remove all game properties from all selected objects

  """

  ...

def game_property_copy(*args, operation: str = 'COPY', property: str = '') -> None:

  """

  Copy/merge/replace a game property from active object to all selected objects

  """

  ...

def game_property_move(*args, index: int = 0, direction: str = 'UP') -> None:

  """

  Move game property

  """

  ...

def game_property_new(*args, type: str = 'FLOAT', name: str = '') -> None:

  """

  Create a new property available to the game engine

  """

  ...

def game_property_remove(*args, index: int = 0) -> None:

  """

  Remove game property

  """

  ...

def geometry_node_bake_delete_single(*args, session_uid: int = 0, modifier_name: str = '', bake_id: int = 0) -> None:

  """

  Delete baked data of a single bake node or simulation

  """

  ...

def geometry_node_bake_pack_single(*args, session_uid: int = 0, modifier_name: str = '', bake_id: int = 0) -> None:

  """

  Pack baked data from disk into the .blend file

  """

  ...

def geometry_node_bake_single(*args, session_uid: int = 0, modifier_name: str = '', bake_id: int = 0) -> None:

  """

  Bake a single bake node or simulation

  """

  ...

def geometry_node_bake_unpack_single(*args, session_uid: int = 0, modifier_name: str = '', bake_id: int = 0, method: str = 'USE_LOCAL') -> None:

  """

  Unpack baked data from the .blend file to disk

  """

  ...

def geometry_node_tree_copy_assign() -> None:

  """

  Duplicate the active geometry node group and assign it to the active modifier

  """

  ...

def geometry_nodes_input_attribute_toggle(*args, input_name: str = '', modifier_name: str = '') -> None:

  """

  Switch between an attribute and a single value to define the data for every element

  """

  ...

def geometry_nodes_move_to_nodes(*args, use_selected_objects: bool = False) -> None:

  """

  Move inputs and outputs from in the modifier to a new node group

  """

  ...

def grease_pencil_add(*args, type: str = 'EMPTY', use_in_front: bool = True, stroke_depth_offset: float = 0.05, use_lights: bool = True, stroke_depth_order: str = '3D', radius: float = 1.0, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a Grease Pencil object to the scene

  """

  ...

def grease_pencil_dash_modifier_segment_add(*args, modifier: str = '') -> None:

  """

  Add a segment to the dash modifier

  """

  ...

def grease_pencil_dash_modifier_segment_move(*args, modifier: str = '', type: str = 'UP') -> None:

  """

  Move the active dash segment up or down

  """

  ...

def grease_pencil_dash_modifier_segment_remove(*args, modifier: str = '', index: int = 0) -> None:

  """

  Remove the active segment from the dash modifier

  """

  ...

def grease_pencil_time_modifier_segment_add(*args, modifier: str = '') -> None:

  """

  Add a segment to the time modifier

  """

  ...

def grease_pencil_time_modifier_segment_move(*args, modifier: str = '', type: str = 'UP') -> None:

  """

  Move the active time segment up or down

  """

  ...

def grease_pencil_time_modifier_segment_remove(*args, modifier: str = '', index: int = 0) -> None:

  """

  Remove the active segment from the time modifier

  """

  ...

def hide_collection(*args, collection_index: int = -1, toggle: bool = False, extend: bool = False) -> None:

  """

  Show only objects in collection (Shift to extend)

  """

  ...

def hide_render_clear_all() -> None:

  """

  Reveal all render objects by setting the hide render flag

  """

  ...

def hide_view_clear(*args, select: bool = True) -> None:

  """

  Reveal temporarily hidden objects

  """

  ...

def hide_view_set(*args, unselected: bool = False) -> None:

  """

  Temporarily hide objects from the viewport

  """

  ...

def hook_add_newob() -> None:

  """

  Hook selected vertices to a newly created object

  """

  ...

def hook_add_selob(*args, use_bone: bool = False) -> None:

  """

  Hook selected vertices to the first selected object

  """

  ...

def hook_assign(*args, modifier: str = '') -> None:

  """

  Assign the selected vertices to a hook

  """

  ...

def hook_recenter(*args, modifier: str = '') -> None:

  """

  Set hook center to cursor position

  """

  ...

def hook_remove(*args, modifier: str = '') -> None:

  """

  Remove a hook from the active object

  """

  ...

def hook_reset(*args, modifier: str = '') -> None:

  """

  Recalculate and clear offset transformation

  """

  ...

def hook_select(*args, modifier: str = '') -> None:

  """

  Select affected vertices on mesh

  """

  ...

def instance_offset_from_cursor() -> None:

  """

  Set offset used for collection instances based on cursor position

  """

  ...

def instance_offset_from_object() -> None:

  """

  Set offset used for collection instances based on the active object position

  """

  ...

def instance_offset_to_cursor() -> None:

  """

  Set cursor position to the offset used for collection instances

  """

  ...

def isolate_type_render() -> None:

  """

  Hide unselected render objects of same type as active by setting the hide render flag

  """

  ...

def join() -> None:

  """

  Join selected objects into active object

  """

  ...

def join_shapes(*args, use_mirror: bool = False) -> None:

  """

  Add the vertex positions of selected objects as shape keys or update existing shape keys with matching names

  """

  ...

def join_uvs() -> None:

  """

  Transfer UV Maps from active to selected objects (needs matching geometry)

  """

  ...

def laplaciandeform_bind(*args, modifier: str = '') -> None:

  """

  Bind mesh to system in laplacian deform modifier

  """

  ...

def lattice_add_to_selected(*args, fit_to_selected: bool = True, radius: float = 1.0, margin: float = 0.0, add_modifiers: bool = True, resolution_u: int = 2, resolution_v: int = 2, resolution_w: int = 2, enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a lattice and use it to deform selected objects

  """

  ...

def light_add(*args, type: str = 'POINT', radius: float = 1.0, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a light object to the scene

  """

  ...

def light_linking_blocker_collection_new() -> None:

  """

  Create new light linking collection used by the active emitter

  """

  ...

def light_linking_blockers_link(*args, link_state: str = 'INCLUDE') -> None:

  """

  Light link selected blockers to the active emitter object

  """

  ...

def light_linking_blockers_select() -> None:

  """

  Select all objects which block light from this emitter

  """

  ...

def light_linking_receiver_collection_new() -> None:

  """

  Create new light linking collection used by the active emitter

  """

  ...

def light_linking_receivers_link(*args, link_state: str = 'INCLUDE') -> None:

  """

  Light link selected receivers to the active emitter object

  """

  ...

def light_linking_receivers_select() -> None:

  """

  Select all objects which receive light from this emitter

  """

  ...

def light_linking_unlink_from_collection() -> None:

  """

  Remove this object or collection from the light linking collection

  """

  ...

def lightprobe_add(*args, type: str = 'SPHERE', radius: float = 1.0, enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a light probe object

  """

  ...

def lightprobe_cache_bake(*args, subset: str = 'ALL') -> None:

  """

  Bake irradiance volume light cache

  """

  ...

def lightprobe_cache_free(*args, subset: str = 'SELECTED') -> None:

  """

  Delete cached indirect lighting

  """

  ...

def lineart_bake_strokes(*args, bake_all: bool = False) -> None:

  """

  Bake Line Art for current Grease Pencil object

  """

  ...

def lineart_clear(*args, clear_all: bool = False) -> None:

  """

  Clear all strokes in current Grease Pencil object

  """

  ...

def link_to_collection(*args, collection_uid: int = -1, is_new: bool = False, new_collection_name: str = '') -> None:

  """

  Link objects to a collection

  """

  ...

def location_clear(*args, clear_delta: bool = False) -> None:

  """

  Clear the object's location

  """

  ...

def lod_add() -> None:

  """

  Add a level of detail to this object

  """

  ...

def lod_by_name() -> None:

  """

  Add levels of detail to this object based on object names

  """

  ...

def lod_clear_all() -> None:

  """

  Remove all levels of detail from this object

  """

  ...

def lod_generate(*args, count: int = 3, target: float = 0.1, package: bool = False) -> None:

  """

  Generate levels of detail using the decimate modifier

  """

  ...

def lod_remove(*args, index: int = 1) -> None:

  """

  Remove a level of detail from this object

  """

  ...

def logic_bricks_copy() -> None:

  """

  Copy logic bricks to other selected objects

  """

  ...

def make_dupli_face() -> None:

  """

  Convert objects into instanced faces

  """

  ...

def make_links_data(*args, type: str = 'OBDATA') -> None:

  """

  Transfer data from active object to selected objects

  """

  ...

def make_links_scene(*args, scene: str = '') -> None:

  """

  Link selection to another scene

  """

  ...

def make_local(*args, type: str = 'SELECT_OBJECT') -> None:

  """

  Make library linked data-blocks local to this file

  """

  ...

def make_override_library(*args, collection: int = 0) -> None:

  """

  Create a local override of the selected linked objects, and their hierarchy of dependencies

  """

  ...

def make_single_user(*args, type: str = 'SELECTED_OBJECTS', object: bool = False, obdata: bool = False, material: bool = False, animation: bool = False, obdata_animation: bool = False) -> None:

  """

  Make linked data local to each object

  """

  ...

def material_slot_add() -> None:

  """

  Add a new material slot

  """

  ...

def material_slot_assign() -> None:

  """

  Assign active material slot to selection

  """

  ...

def material_slot_copy() -> None:

  """

  Copy material to selected objects

  """

  ...

def material_slot_deselect() -> None:

  """

  Deselect by active material slot

  """

  ...

def material_slot_move(*args, direction: str = 'UP') -> None:

  """

  Move the active material up/down in the list

  """

  ...

def material_slot_remove() -> None:

  """

  Remove the selected material slot

  """

  ...

def material_slot_remove_all() -> None:

  """

  Remove all materials

  """

  ...

def material_slot_remove_unused() -> None:

  """

  Remove unused material slots

  """

  ...

def material_slot_select() -> None:

  """

  Select by active material slot

  """

  ...

def meshdeform_bind(*args, modifier: str = '') -> None:

  """

  Bind mesh to cage in mesh deform modifier

  """

  ...

def metaball_add(*args, type: str = 'BALL', radius: float = 2.0, enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add an metaball object to the scene

  """

  ...

def mode_set(*args, mode: str = 'OBJECT', toggle: bool = False) -> None:

  """

  Sets the object interaction mode

  """

  ...

def mode_set_with_submode(*args, mode: str = 'OBJECT', toggle: bool = False, mesh_select_mode: typing.Set[str] = {}) -> None:

  """

  Sets the object interaction mode

  """

  ...

def modifier_add(*args, type: str = 'SUBSURF', use_selected_objects: bool = False) -> None:

  """

  Add a procedural operation/effect to the active object

  """

  ...

def modifier_add_node_group(*args, asset_library_type: str = 'LOCAL', asset_library_identifier: str = '', relative_asset_identifier: str = '', session_uid: int = 0, use_selected_objects: bool = False) -> None:

  """

  Add a procedural operation/effect to the active object

  """

  ...

def modifier_apply(*args, modifier: str = '', report: bool = False, merge_customdata: bool = True, single_user: bool = False, all_keyframes: bool = False, use_selected_objects: bool = False) -> None:

  """

  Apply modifier and remove from the stack

  """

  ...

def modifier_apply_as_shapekey(*args, keep_modifier: bool = False, modifier: str = '', report: bool = False, use_selected_objects: bool = False) -> None:

  """

  Apply modifier as a new shape key and remove from the stack

  """

  ...

def modifier_convert(*args, modifier: str = '') -> None:

  """

  Convert particles to a mesh object

  """

  ...

def modifier_copy(*args, modifier: str = '', use_selected_objects: bool = False) -> None:

  """

  Duplicate modifier at the same position in the stack

  """

  ...

def modifier_copy_to_selected(*args, modifier: str = '') -> None:

  """

  Copy the modifier from the active object to all selected objects

  """

  ...

def modifier_move_down(*args, modifier: str = '') -> None:

  """

  Move modifier down in the stack

  """

  ...

def modifier_move_to_index(*args, modifier: str = '', index: int = 0, use_selected_objects: bool = False) -> None:

  """

  Change the modifier's index in the stack so it evaluates after the set number of others

  """

  ...

def modifier_move_up(*args, modifier: str = '') -> None:

  """

  Move modifier up in the stack

  """

  ...

def modifier_remove(*args, modifier: str = '', report: bool = False, use_selected_objects: bool = False) -> None:

  """

  Remove a modifier from the active object

  """

  ...

def modifier_set_active(*args, modifier: str = '') -> None:

  """

  Activate the modifier to use as the context

  """

  ...

def modifiers_clear() -> None:

  """

  Clear all modifiers from the selected objects

  """

  ...

def modifiers_copy_to_selected() -> None:

  """

  Copy modifiers to other selected objects

  """

  ...

def move_to_collection(*args, collection_uid: int = -1, is_new: bool = False, new_collection_name: str = '') -> None:

  """

  Move objects to a collection

  """

  ...

def multires_base_apply(*args, modifier: str = '', apply_heuristic: bool = True) -> None:

  """

  Modify the base mesh to conform to the displaced mesh

  """

  ...

def multires_external_pack() -> None:

  """

  Pack displacements from an external file

  """

  ...

def multires_external_save(*args, filepath: str = '', hide_props_region: bool = True, check_existing: bool = True, filter_blender: bool = False, filter_backup: bool = False, filter_image: bool = False, filter_movie: bool = False, filter_python: bool = False, filter_font: bool = False, filter_sound: bool = False, filter_text: bool = False, filter_archive: bool = False, filter_btx: bool = True, filter_alembic: bool = False, filter_usd: bool = False, filter_obj: bool = False, filter_volume: bool = False, filter_folder: bool = True, filter_blenlib: bool = False, filemode: int = 9, relative_path: bool = True, display_type: str = 'DEFAULT', sort_method: str = '', modifier: str = '') -> None:

  """

  Save displacements to an external file

  """

  ...

def multires_higher_levels_delete(*args, modifier: str = '') -> None:

  """

  Deletes the higher resolution mesh, potential loss of detail

  """

  ...

def multires_rebuild_subdiv(*args, modifier: str = '') -> None:

  """

  Rebuilds all possible subdivisions levels to generate a lower resolution base mesh

  """

  ...

def multires_reshape(*args, modifier: str = '') -> None:

  """

  Copy vertex coordinates from other object

  """

  ...

def multires_subdivide(*args, modifier: str = '', mode: str = 'CATMULL_CLARK') -> None:

  """

  Add a new level of subdivision

  """

  ...

def multires_unsubdivide(*args, modifier: str = '') -> None:

  """

  Rebuild a lower subdivision level of the current base mesh

  """

  ...

def ocean_bake(*args, modifier: str = '', free: bool = False) -> None:

  """

  Bake an image sequence of ocean data

  """

  ...

def origin_clear() -> None:

  """

  Clear the object's origin

  """

  ...

def origin_set(*args, type: str = 'GEOMETRY_ORIGIN', center: str = 'MEDIAN') -> None:

  """

  Set the object's origin, by either moving the data, or set to center of data, or use 3D cursor

  """

  ...

def parent_clear(*args, type: str = 'CLEAR') -> None:

  """

  Clear the object's parenting

  """

  ...

def parent_inverse_apply() -> None:

  """

  Apply the object's parent inverse to its data

  """

  ...

def parent_no_inverse_set(*args, keep_transform: bool = False) -> None:

  """

  Set the object's parenting without setting the inverse parent correction

  """

  ...

def parent_set(*args, type: str = 'OBJECT', xmirror: bool = False, keep_transform: bool = False) -> None:

  """

  Set the object's parenting

  """

  ...

def particle_system_add() -> None:

  """

  Add a particle system

  """

  ...

def particle_system_remove() -> None:

  """

  Remove the selected particle system

  """

  ...

def paste_transform(*args, method: str = 'CURRENT', bake_step: int = 0, use_mirror: bool = False, mirror_axis_loc: str = 'x', mirror_axis_rot: str = 'z', use_relative: bool = False) -> None:

  """

  Pastes the matrix from the clipboard to the currently active pose bone or object. Uses world-space matrices

  """

  ...

def paths_calculate(*args, display_type: str = 'RANGE', range: str = 'SCENE') -> None:

  """

  Generate motion paths for the selected objects

  """

  ...

def paths_clear(*args, only_selected: bool = False) -> None:

  """

  Undocumented, consider `contributing <https://developer.blender.org/>`_.

  """

  ...

def paths_update() -> None:

  """

  Recalculate motion paths for selected objects

  """

  ...

def paths_update_visible() -> None:

  """

  Recalculate all visible motion paths for objects and poses

  """

  ...

def pointcloud_random_add(*args, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a point cloud object to the scene

  """

  ...

def posemode_toggle() -> None:

  """

  Enable or disable posing/selecting bones

  """

  ...

def quadriflow_remesh(*args, use_mesh_symmetry: bool = True, use_preserve_sharp: bool = False, use_preserve_boundary: bool = False, preserve_attributes: bool = False, smooth_normals: bool = False, mode: str = 'FACES', target_ratio: float = 1.0, target_edge_length: float = 0.1, target_faces: int = 4000, mesh_area: float = -1.0, seed: int = 0) -> None:

  """

  Create a new quad based mesh using the surface data of the current mesh. All data layers will be lost

  """

  ...

def quick_explode(*args, style: str = 'EXPLODE', amount: int = 100, frame_duration: int = 50, frame_start: int = 1, frame_end: int = 10, velocity: float = 1.0, fade: bool = True) -> None:

  """

  Make selected objects explode

  """

  ...

def quick_fur(*args, density: str = 'MEDIUM', length: float = 0.1, radius: float = 0.001, view_percentage: float = 1.0, apply_hair_guides: bool = True, use_noise: bool = True, use_frizz: bool = True) -> None:

  """

  Add a fur setup to the selected objects

  """

  ...

def quick_liquid(*args, show_flows: bool = False) -> None:

  """

  Make selected objects liquid

  """

  ...

def quick_smoke(*args, style: str = 'SMOKE', show_flows: bool = False) -> None:

  """

  Use selected objects as smoke emitters

  """

  ...

def randomize_transform(*args, random_seed: int = 0, use_delta: bool = False, use_loc: bool = True, loc: mathutils.Vector = (0.0, 0.0, 0.0), use_rot: bool = True, rot: mathutils.Euler = (0.0, 0.0, 0.0), use_scale: bool = True, scale_even: bool = False, scale: typing.Tuple[float, float, float] = (1.0, 1.0, 1.0)) -> None:

  """

  Randomize objects location, rotation, and scale

  """

  ...

def reset_override_library() -> None:

  """

  Reset the selected local overrides to their linked references values

  """

  ...

def rotation_clear(*args, clear_delta: bool = False) -> None:

  """

  Clear the object's rotation

  """

  ...

def scale_clear(*args, clear_delta: bool = False) -> None:

  """

  Clear the object's scale

  """

  ...

def select_all(*args, action: str = 'TOGGLE') -> None:

  """

  Change selection of all visible objects in scene

  """

  ...

def select_by_type(*args, extend: bool = False, type: str = 'MESH') -> None:

  """

  Select all visible objects that are of a type

  """

  ...

def select_camera(*args, extend: bool = False) -> None:

  """

  Select the active camera

  """

  ...

def select_grouped(*args, extend: bool = False, type: str = 'CHILDREN_RECURSIVE') -> None:

  """

  Select all visible objects grouped by various properties

  """

  ...

def select_hierarchy(*args, direction: str = 'PARENT', extend: bool = False) -> None:

  """

  Select object relative to the active object's position in the hierarchy

  """

  ...

def select_less() -> None:

  """

  Deselect objects at the boundaries of parent/child relationships

  """

  ...

def select_linked(*args, extend: bool = False, type: str = 'OBDATA') -> None:

  """

  Select all visible objects that are linked

  """

  ...

def select_mirror(*args, extend: bool = False) -> None:

  """

  Select the mirror objects of the selected object e.g. "L.sword" and "R.sword"

  """

  ...

def select_more() -> None:

  """

  Select connected parent/child objects

  """

  ...

def select_pattern(*args, pattern: str = '*args', case_sensitive: bool = False, extend: bool = True) -> None:

  """

  Select objects matching a naming pattern

  """

  ...

def select_random(*args, ratio: float = 0.5, seed: int = 0, action: str = 'SELECT') -> None:

  """

  Select or deselect random visible objects

  """

  ...

def select_same_collection(*args, collection: str = '') -> None:

  """

  Select object in the same collection

  """

  ...

def shade_auto_smooth(*args, use_auto_smooth: bool = True, angle: float = 0.523599) -> None:

  """

  Add modifier to automatically set the sharpness of mesh edges based on the angle between the neighboring faces

  """

  ...

def shade_flat(*args, keep_sharp_edges: bool = True) -> None:

  """

  Render and display faces uniform, using face normals

  """

  ...

def shade_smooth(*args, keep_sharp_edges: bool = True) -> None:

  """

  Render and display faces smooth, using interpolated vertex normals

  """

  ...

def shade_smooth_by_angle(*args, angle: float = 0.523599, keep_sharp_edges: bool = True) -> None:

  """

  Set the sharpness of mesh edges based on the angle between the neighboring faces

  """

  ...

def shaderfx_add(*args, type: str = 'FX_BLUR') -> None:

  """

  Add a visual effect to the active object

  """

  ...

def shaderfx_copy(*args, shaderfx: str = '') -> None:

  """

  Duplicate effect at the same position in the stack

  """

  ...

def shaderfx_move_down(*args, shaderfx: str = '') -> None:

  """

  Move effect down in the stack

  """

  ...

def shaderfx_move_to_index(*args, shaderfx: str = '', index: int = 0) -> None:

  """

  Change the effect's position in the list so it evaluates after the set number of others

  """

  ...

def shaderfx_move_up(*args, shaderfx: str = '') -> None:

  """

  Move effect up in the stack

  """

  ...

def shaderfx_remove(*args, shaderfx: str = '', report: bool = False) -> None:

  """

  Remove a effect from the active Grease Pencil object

  """

  ...

def shape_key_add(*args, from_mix: bool = True) -> None:

  """

  Add shape key to the object

  """

  ...

def shape_key_clear() -> None:

  """

  Reset the weights of all shape keys to 0 or to the closest value respecting the limits

  """

  ...

def shape_key_copy() -> None:

  """

  Duplicate the active shape key

  """

  ...

def shape_key_lock(*args, action: str = 'LOCK') -> None:

  """

  Change the lock state of all shape keys of active object

  """

  ...

def shape_key_make_basis() -> None:

  """

  Make this shape key the new basis key, effectively applying it to the mesh. Note that this applies the shape key at its 100% value

  """

  ...

def shape_key_mirror(*args, use_topology: bool = False) -> None:

  """

  Mirror the current shape key along the local X axis

  """

  ...

def shape_key_move(*args, type: str = 'TOP') -> None:

  """

  Move selected shape keys up/down in the list

  """

  ...

def shape_key_remove(*args, all: bool = False, apply_mix: bool = False) -> None:

  """

  Remove shape key from the object

  """

  ...

def shape_key_retime() -> None:

  """

  Resets the timing for absolute shape keys

  """

  ...

def shape_key_transfer(*args, mode: str = 'OFFSET', use_clamp: bool = False) -> None:

  """

  Copy the active shape key of another selected object to this one

  """

  ...

def simulation_nodes_cache_bake(*args, selected: bool = False) -> None:

  """

  Bake simulations in geometry nodes modifiers

  """

  ...

def simulation_nodes_cache_calculate_to_frame(*args, selected: bool = False) -> None:

  """

  Calculate simulations in geometry nodes modifiers from the start to current frame

  """

  ...

def simulation_nodes_cache_delete(*args, selected: bool = False) -> None:

  """

  Delete cached/baked simulations in geometry nodes modifiers

  """

  ...

def skin_armature_create(*args, modifier: str = '') -> None:

  """

  Create an armature that parallels the skin layout

  """

  ...

def skin_loose_mark_clear(*args, action: str = 'MARK') -> None:

  """

  Mark/clear selected vertices as loose

  """

  ...

def skin_radii_equalize() -> None:

  """

  Make skin radii of selected vertices equal on each axis

  """

  ...

def skin_root_mark() -> None:

  """

  Mark selected vertices as roots

  """

  ...

def speaker_add(*args, enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a speaker object to the scene

  """

  ...

def subdivision_set(*args, level: int = 1, relative: bool = False, ensure_modifier: bool = True) -> None:

  """

  Sets a Subdivision Surface level (1 to 5)

  """

  ...

def surfacedeform_bind(*args, modifier: str = '') -> None:

  """

  Bind mesh to target in surface deform modifier

  """

  ...

def text_add(*args, radius: float = 1.0, enter_editmode: bool = False, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a text object to the scene

  """

  ...

def track_clear(*args, type: str = 'CLEAR') -> None:

  """

  Clear tracking constraint or flag from object

  """

  ...

def track_set(*args, type: str = 'DAMPTRACK') -> None:

  """

  Make the object track another object, using various methods/constraints

  """

  ...

def transfer_mode(*args, use_flash_on_transfer: bool = True) -> None:

  """

  Switches the active object and assigns the same mode to a new one under the mouse cursor, leaving the active mode in the current one

  """

  ...

def transform_apply(*args, location: bool = True, rotation: bool = True, scale: bool = True, properties: bool = True, corrective_flip_normals: bool = True, isolate_users: bool = False) -> None:

  """

  Apply the object's transformation to its data

  """

  ...

def transform_axis_target() -> None:

  """

  Interactively point cameras and lights to a location (Ctrl translates)

  """

  ...

def transform_to_mouse(*args, name: str = '', session_uid: int = 0, matrix: mathutils.Matrix = ((0.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0, 0.0)), drop_x: int = 0, drop_y: int = 0) -> None:

  """

  Snap selected item(s) to the mouse location

  """

  ...

def transforms_to_deltas(*args, mode: str = 'ALL', reset_values: bool = True) -> None:

  """

  Convert normal object transforms to delta transforms, any existing delta transforms will be included as well

  """

  ...

def unlink_data() -> None:

  """

  Undocumented, consider `contributing <https://developer.blender.org/>`_.

  """

  ...

def update_shapes(*args, use_mirror: bool = False) -> None:

  """

  Update existing shape keys with the vertex positions of selected objects with matching names

  """

  ...

def vertex_group_add() -> None:

  """

  Add a new vertex group to the active object

  """

  ...

def vertex_group_assign() -> None:

  """

  Assign the selected vertices to the active vertex group

  """

  ...

def vertex_group_assign_new() -> None:

  """

  Assign the selected vertices to a new vertex group

  """

  ...

def vertex_group_clean(*args, group_select_mode: str = '', limit: float = 0.0, keep_single: bool = False) -> None:

  """

  Remove vertex group assignments which are not required

  """

  ...

def vertex_group_copy() -> None:

  """

  Make a copy of the active vertex group

  """

  ...

def vertex_group_copy_to_selected() -> None:

  """

  Replace vertex groups of selected objects by vertex groups of active object

  """

  ...

def vertex_group_deselect() -> None:

  """

  Deselect all selected vertices assigned to the active vertex group

  """

  ...

def vertex_group_invert(*args, group_select_mode: str = '', auto_assign: bool = True, auto_remove: bool = True) -> None:

  """

  Invert active vertex group's weights

  """

  ...

def vertex_group_levels(*args, group_select_mode: str = '', offset: float = 0.0, gain: float = 1.0) -> None:

  """

  Add some offset and multiply with some gain the weights of the active vertex group

  """

  ...

def vertex_group_limit_total(*args, group_select_mode: str = '', limit: int = 4) -> None:

  """

  Limit deform weights associated with a vertex to a specified number by removing lowest weights

  """

  ...

def vertex_group_lock(*args, action: str = 'TOGGLE', mask: str = 'ALL') -> None:

  """

  Change the lock state of all or some vertex groups of active object

  """

  ...

def vertex_group_mirror(*args, mirror_weights: bool = True, flip_group_names: bool = True, all_groups: bool = False, use_topology: bool = False) -> None:

  """

  Mirror vertex group, flip weights and/or names, editing only selected vertices, flipping when both sides are selected otherwise copy from unselected

  """

  ...

def vertex_group_move(*args, direction: str = 'UP') -> None:

  """

  Move the active vertex group up/down in the list

  """

  ...

def vertex_group_normalize() -> None:

  """

  Normalize weights of the active vertex group, so that the highest ones are now 1.0

  """

  ...

def vertex_group_normalize_all(*args, group_select_mode: str = '', lock_active: bool = True) -> None:

  """

  Normalize all weights of all vertex groups, so that for each vertex, the sum of all weights is 1.0

  """

  ...

def vertex_group_quantize(*args, group_select_mode: str = '', steps: int = 4) -> None:

  """

  Set weights to a fixed number of steps

  """

  ...

def vertex_group_remove(*args, all: bool = False, all_unlocked: bool = False) -> None:

  """

  Delete the active or all vertex groups from the active object

  """

  ...

def vertex_group_remove_from(*args, use_all_groups: bool = False, use_all_verts: bool = False) -> None:

  """

  Remove the selected vertices from active or all vertex group(s)

  """

  ...

def vertex_group_select() -> None:

  """

  Select all the vertices assigned to the active vertex group

  """

  ...

def vertex_group_set_active(*args, group: str = '') -> None:

  """

  Set the active vertex group

  """

  ...

def vertex_group_smooth(*args, group_select_mode: str = '', factor: float = 0.5, repeat: int = 1, expand: float = 0.0) -> None:

  """

  Smooth weights for selected vertices

  """

  ...

def vertex_group_sort(*args, sort_type: str = 'NAME') -> None:

  """

  Sort vertex groups

  """

  ...

def vertex_parent_set() -> None:

  """

  Parent selected objects to the selected vertices

  """

  ...

def vertex_weight_copy() -> None:

  """

  Copy weights from active to selected

  """

  ...

def vertex_weight_delete(*args, weight_group: int = -1) -> None:

  """

  Delete this weight from the vertex (disabled if vertex group is locked)

  """

  ...

def vertex_weight_normalize_active_vertex() -> None:

  """

  Normalize active vertex's weights

  """

  ...

def vertex_weight_paste(*args, weight_group: int = -1) -> None:

  """

  Copy this group's weight to other selected vertices (disabled if vertex group is locked)

  """

  ...

def vertex_weight_set_active(*args, weight_group: int = -1) -> None:

  """

  Set as active vertex group

  """

  ...

def visual_geometry_to_objects() -> None:

  """

  Convert geometry and instances into editable objects and collections

  """

  ...

def visual_transform_apply() -> None:

  """

  Apply the object's visual transformation to its data

  """

  ...

def volume_add(*args, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Add a volume object to the scene

  """

  ...

def volume_import(*args, filepath: str = '', directory: str = '', files: typing.Union[typing.Sequence[OperatorFileListElement], typing.Mapping[str, OperatorFileListElement], bpy.types.bpy_prop_collection] = None, hide_props_region: bool = True, check_existing: bool = False, filter_blender: bool = False, filter_backup: bool = False, filter_image: bool = False, filter_movie: bool = False, filter_python: bool = False, filter_font: bool = False, filter_sound: bool = False, filter_text: bool = False, filter_archive: bool = False, filter_btx: bool = False, filter_alembic: bool = False, filter_usd: bool = False, filter_obj: bool = False, filter_volume: bool = True, filter_folder: bool = True, filter_blenlib: bool = False, filemode: int = 9, relative_path: bool = True, display_type: str = 'DEFAULT', sort_method: str = '', use_sequence_detection: bool = True, align: str = 'WORLD', location: mathutils.Vector = (0.0, 0.0, 0.0), rotation: mathutils.Euler = (0.0, 0.0, 0.0), scale: mathutils.Vector = (0.0, 0.0, 0.0)) -> None:

  """

  Import OpenVDB volume file

  """

  ...

def voxel_remesh() -> None:

  """

  Calculates a new manifold mesh based on the volume of the current mesh. All data layers will be lost

  """

  ...

def voxel_size_edit() -> None:

  """

  Modify the mesh voxel size interactively used in the voxel remesher

  """

  ...
