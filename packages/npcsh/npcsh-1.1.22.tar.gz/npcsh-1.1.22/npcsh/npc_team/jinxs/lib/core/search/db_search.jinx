jinx_name: db_search
description: Search conversation history database with interactive TUI
interactive: true
inputs:
- query: ""
- path: ""
- limit: "100"
- text: "false"

steps:
  - name: search_db
    engine: python
    code: |
      import os
      import sys
      import tty
      import termios
      from datetime import datetime
      from sqlalchemy import create_engine, text

      query = context.get('query', '').strip()
      text_mode = context.get('text', '').lower() in ('true', '1', 'yes')

      if not query:
          lines = [
              "Usage: /db_search <query>",
              "",
              "Searches conversation history for matching content.",
              "",
              "Options:",
              "  path  - Filter by directory path",
              "  limit - Max results (default 100)",
              "  text  - Text-only output, no TUI (true/false)",
              "",
              "TUI Controls:",
              "  j/k or arrows - Navigate",
              "  1/2/3         - Sort by time/role/npc",
              "  p             - Preview full message",
              "  r             - Reattach to conversation",
              "  f             - Filter by role (user/assistant/all)",
              "  q/ESC         - Quit",
              "",
              "Examples:",
              "  /db_search python debugging",
              "  /db_search api errors path=/home/user/project",
              "  /db_search errors text=true",
          ]
          context['output'] = "\n".join(lines)
      else:
          db_path = os.getenv("NPCSH_DB_PATH", os.path.expanduser("~/npcsh_history.db"))
          limit = int(context.get('limit') or 100)
          filter_path = context.get('path', '').strip()

          engine = create_engine(f'sqlite:///{db_path}')

          try:
              with engine.connect() as conn:
                  if filter_path:
                      result = conn.execute(text("""
                          SELECT conversation_id, timestamp, role, content, npc, directory_path
                          FROM conversation_history
                          WHERE LOWER(content) LIKE LOWER(:query)
                            AND (directory_path = :path OR directory_path LIKE :path_pattern)
                          ORDER BY timestamp DESC
                          LIMIT :limit
                      """), {
                          "query": f"%{query}%",
                          "path": filter_path,
                          "path_pattern": filter_path + "/%",
                          "limit": limit
                      })
                  else:
                      result = conn.execute(text("""
                          SELECT conversation_id, timestamp, role, content, npc, directory_path
                          FROM conversation_history
                          WHERE LOWER(content) LIKE LOWER(:query)
                          ORDER BY timestamp DESC
                          LIMIT :limit
                      """), {"query": f"%{query}%", "limit": limit})

                  rows = [dict(row._mapping) for row in result.fetchall()]

              if not rows:
                  context['output'] = f"No results found for '{query}'"
              elif text_mode:
                  # Text-only output
                  lines = [f"Found {len(rows)} results for '{query}':", ""]
                  for row in rows:
                      cid = row['conversation_id'][:8] if row['conversation_id'] else '?'
                      ts = str(row['timestamp'])[:16] if row['timestamp'] else '?'
                      role = row['role'] or '?'
                      content = (row['content'] or '')[:100].replace('\n', ' ')
                      npc_name = row['npc'] or 'default'
                      path = row['directory_path'] or ''

                      lines.append(f"[{cid}] {ts} ({role}/{npc_name})")
                      lines.append(f"  {content}")
                      if path:
                          lines.append(f"  @ {path}")
                      lines.append("")
                  context['output'] = "\n".join(lines)
              else:
                  # Interactive TUI mode
                  def get_terminal_size():
                      try:
                          size = os.get_terminal_size()
                          return size.columns, size.lines
                      except:
                          return 80, 24

                  def format_ts(ts):
                      if not ts:
                          return 'unknown'
                      try:
                          if 'T' in str(ts):
                              dt = datetime.fromisoformat(str(ts).replace('Z', '+00:00'))
                          else:
                              dt = datetime.strptime(str(ts)[:19], '%Y-%m-%d %H:%M:%S')
                          now = datetime.now()
                          diff = now - dt.replace(tzinfo=None)
                          if diff.days == 0:
                              return f"Today {dt.strftime('%H:%M')}"
                          elif diff.days == 1:
                              return f"Yesterday {dt.strftime('%H:%M')}"
                          elif diff.days < 7:
                              return dt.strftime('%a %H:%M')
                          else:
                              return dt.strftime('%b %d %H:%M')
                      except:
                          return str(ts)[:16]

                  width, height = get_terminal_size()
                  selected = 0
                  scroll = 0
                  list_height = height - 5
                  mode = 'list'
                  preview_scroll = 0
                  sort_mode = 'time'  # time, role, npc
                  role_filter = 'all'  # all, user, assistant

                  def sort_rows(rows, sort_mode):
                      if sort_mode == 'time':
                          return sorted(rows, key=lambda x: x.get('timestamp') or '', reverse=True)
                      elif sort_mode == 'role':
                          return sorted(rows, key=lambda x: (x.get('role') or '', x.get('timestamp') or ''), reverse=True)
                      elif sort_mode == 'npc':
                          return sorted(rows, key=lambda x: (x.get('npc') or '', x.get('timestamp') or ''), reverse=True)
                      return rows

                  def filter_rows(rows, role_filter):
                      if role_filter == 'all':
                          return rows
                      return [r for r in rows if r.get('role') == role_filter]

                  display_rows = filter_rows(sort_rows(rows, sort_mode), role_filter)

                  fd = sys.stdin.fileno()
                  old_settings = termios.tcgetattr(fd)

                  try:
                      tty.setcbreak(fd)
                      sys.stdout.write('\033[?25l')
                      sys.stdout.write('\033[2J\033[H')

                      while True:
                          width, height = get_terminal_size()
                          list_height = height - 5

                          if mode == 'list':
                              if selected < scroll:
                                  scroll = selected
                              elif selected >= scroll + list_height:
                                  scroll = selected - list_height + 1

                          sys.stdout.write('\033[H')

                          # Header
                          if mode == 'list':
                              sort_ind = {'time': '1', 'role': '2', 'npc': '3'}[sort_mode]
                              header = f" DB SEARCH ({len(display_rows)} results): '{query}' [sort:{sort_mode}({sort_ind}) filter:{role_filter}] "
                          else:
                              header = f" PREVIEW: {display_rows[selected]['conversation_id'][:16]} "
                          sys.stdout.write(f'\033[7;1m{header.ljust(width)}\033[0m\n')

                          # Column headers
                          if mode == 'list':
                              col_header = f' {"TIMESTAMP":<16} {"ROLE":<10} {"NPC":<12} {"CONTENT":<40}'
                              sys.stdout.write(f'\033[90m{col_header[:width]}\033[0m\n')
                          else:
                              sys.stdout.write(f'\033[90m{"─" * width}\033[0m\n')

                          if mode == 'list':
                              for i in range(list_height):
                                  idx = scroll + i
                                  sys.stdout.write(f'\033[{3+i};1H\033[K')
                                  if idx >= len(display_rows):
                                      continue

                                  r = display_rows[idx]
                                  ts = format_ts(r.get('timestamp'))
                                  role = (r.get('role') or '?')[:10]
                                  npc_name = (r.get('npc') or 'default')[:12]
                                  content = (r.get('content') or '')[:60].replace('\n', ' ')

                                  # Color by role
                                  if r.get('role') == 'user':
                                      role_color = '\033[32m'  # green
                                  elif r.get('role') == 'assistant':
                                      role_color = '\033[34m'  # blue
                                  else:
                                      role_color = '\033[90m'  # gray

                                  line = f" {ts:<16} {role_color}{role:<10}\033[0m {npc_name:<12} {content}"
                                  line = line[:width+20]  # allow for color codes

                                  if idx == selected:
                                      sys.stdout.write(f'\033[7;1m>{line}\033[0m')
                                  else:
                                      sys.stdout.write(f' {line}')

                              # Status bar
                              sys.stdout.write(f'\033[{height-2};1H\033[K\033[90m{"─" * width}\033[0m')
                              sel = display_rows[selected] if display_rows else {}
                              cid = sel.get('conversation_id', '')[:20]
                              path = sel.get('directory_path', '')
                              if len(path) > 40:
                                  path = '...' + path[-37:]
                              sys.stdout.write(f'\033[{height-1};1H\033[K {cid}  @ {path}'.ljust(width))
                              sys.stdout.write(f'\033[{height};1H\033[K\033[7m j/k:Nav 1/2/3:Sort f:Filter p:Preview r:Reattach q:Quit [{selected+1}/{len(display_rows)}] \033[0m')

                          else:  # preview mode
                              sel = display_rows[selected]
                              content = sel.get('content') or ''
                              lines = content.split('\n')

                              for i in range(list_height):
                                  idx = preview_scroll + i
                                  sys.stdout.write(f'\033[{3+i};1H\033[K')
                                  if idx < len(lines):
                                      sys.stdout.write(lines[idx][:width-1])

                              sys.stdout.write(f'\033[{height-2};1H\033[K\033[90m{"─" * width}\033[0m')
                              role = sel.get('role') or '?'
                              npc_name = sel.get('npc') or 'default'
                              ts = format_ts(sel.get('timestamp'))
                              sys.stdout.write(f'\033[{height-1};1H\033[K {role}/{npc_name} - {ts}  [{preview_scroll+1}/{len(lines)} lines]')
                              sys.stdout.write(f'\033[{height};1H\033[K\033[7m j/k:Scroll b:Back r:Reattach q:Quit \033[0m')

                          sys.stdout.flush()

                          c = os.read(fd, 1).decode('latin-1')

                          if c == '\x1b':
                              import select as _sel
                              if _sel.select([fd], [], [], 0.05)[0]:
                                  c2 = os.read(fd, 1).decode('latin-1')
                              else:
                                  if mode == 'preview':
                                      mode = 'list'
                                      sys.stdout.write('\033[2J\033[H')
                                  else:
                                      context['output'] = "Cancelled."
                                      break
                                  continue
                              if c2 == '[':
                                  c3 = os.read(fd, 1).decode('latin-1')
                                  if c3 == 'A':  # Up
                                      if mode == 'list' and selected > 0:
                                          selected -= 1
                                      elif mode == 'preview' and preview_scroll > 0:
                                          preview_scroll -= 1
                                  elif c3 == 'B':  # Down
                                      if mode == 'list' and selected < len(display_rows) - 1:
                                          selected += 1
                                      elif mode == 'preview':
                                          sel = display_rows[selected]
                                          lines = (sel.get('content') or '').split('\n')
                                          if preview_scroll < max(0, len(lines) - list_height):
                                              preview_scroll += 1
                              else:
                                  if mode == 'preview':
                                      mode = 'list'
                                      sys.stdout.write('\033[2J\033[H')
                                  else:
                                      context['output'] = "Cancelled."
                                      break
                              continue

                          if c == 'q' or c == '\x03':
                              context['output'] = "Cancelled."
                              break
                          elif c == 'k':
                              if mode == 'list' and selected > 0:
                                  selected -= 1
                              elif mode == 'preview' and preview_scroll > 0:
                                  preview_scroll -= 1
                          elif c == 'j':
                              if mode == 'list' and selected < len(display_rows) - 1:
                                  selected += 1
                              elif mode == 'preview':
                                  sel = display_rows[selected]
                                  lines = (sel.get('content') or '').split('\n')
                                  if preview_scroll < max(0, len(lines) - list_height):
                                      preview_scroll += 1
                          elif c == '1':
                              sort_mode = 'time'
                              display_rows = filter_rows(sort_rows(rows, sort_mode), role_filter)
                              selected = 0
                              scroll = 0
                          elif c == '2':
                              sort_mode = 'role'
                              display_rows = filter_rows(sort_rows(rows, sort_mode), role_filter)
                              selected = 0
                              scroll = 0
                          elif c == '3':
                              sort_mode = 'npc'
                              display_rows = filter_rows(sort_rows(rows, sort_mode), role_filter)
                              selected = 0
                              scroll = 0
                          elif c == 'f' and mode == 'list':
                              # Cycle through filters
                              if role_filter == 'all':
                                  role_filter = 'user'
                              elif role_filter == 'user':
                                  role_filter = 'assistant'
                              else:
                                  role_filter = 'all'
                              display_rows = filter_rows(sort_rows(rows, sort_mode), role_filter)
                              selected = 0
                              scroll = 0
                          elif c == 'p' and mode == 'list' and display_rows:
                              mode = 'preview'
                              preview_scroll = 0
                              sys.stdout.write('\033[2J\033[H')
                          elif c == 'b' and mode == 'preview':
                              mode = 'list'
                              sys.stdout.write('\033[2J\033[H')
                          elif c == 'r' and display_rows:
                              cid = display_rows[selected]['conversation_id']
                              if 'state' in dir() and state is not None:
                                  state.conversation_id = cid
                                  context['output'] = f"Reattached to: {cid}"
                              else:
                                  context['output'] = f"Selected: {cid}\n\nRun: /set conversation_id={cid}"
                              break
                          elif c in ('\r', '\n') and display_rows:
                              cid = display_rows[selected]['conversation_id']
                              context['output'] = f"Selected: {cid}\n\nRun: /set conversation_id={cid}"
                              break

                  finally:
                      termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
                      sys.stdout.write('\033[?25h')
                      sys.stdout.write('\033[2J\033[H')
                      sys.stdout.flush()

          except Exception as e:
              import traceback
              context['output'] = f"Search error: {e}\n{traceback.format_exc()}"
