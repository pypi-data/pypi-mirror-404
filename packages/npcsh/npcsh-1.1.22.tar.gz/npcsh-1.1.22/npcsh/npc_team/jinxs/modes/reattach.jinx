jinx_name: reattach
description: Interactive viewer to browse and reattach to previous conversations
inputs:
- path: ""
- all: "false"

steps:
  - name: launch_viewer
    engine: python
    code: |
      import os
      import sys
      import tty
      import termios
      from datetime import datetime
      from sqlalchemy import create_engine, text

      def get_terminal_size():
          try:
              size = os.get_terminal_size()
              return size.columns, size.lines
          except:
              return 80, 24

      def format_ts(ts):
          if not ts:
              return 'unknown'
          try:
              if 'T' in str(ts):
                  dt = datetime.fromisoformat(str(ts).replace('Z', '+00:00'))
              else:
                  dt = datetime.strptime(str(ts)[:19], '%Y-%m-%d %H:%M:%S')
              now = datetime.now()
              diff = now - dt.replace(tzinfo=None)
              if diff.days == 0:
                  return f"Today {dt.strftime('%H:%M')}"
              elif diff.days == 1:
                  return f"Yesterday {dt.strftime('%H:%M')}"
              elif diff.days < 7:
                  return dt.strftime('%a %H:%M')
              else:
                  return dt.strftime('%b %d')
          except:
              return str(ts)[:16]

      filter_path = context.get('path', '').strip()
      show_all = context.get('all', '').lower() in ('true', '1', 'yes')
      db_path = os.getenv("NPCSH_DB_PATH", os.path.expanduser("~/npcsh_history.db"))

      if not filter_path:
          filter_path = os.getcwd()
      filter_path = os.path.abspath(os.path.expanduser(filter_path))

      engine = create_engine(f'sqlite:///{db_path}')

      with engine.connect() as conn:
          if show_all:
              result = conn.execute(text("""
                  SELECT conversation_id, directory_path,
                         MIN(timestamp) as started,
                         MAX(timestamp) as last_msg,
                         COUNT(*) as msg_count,
                         GROUP_CONCAT(DISTINCT npc) as npcs,
                         GROUP_CONCAT(DISTINCT model) as models,
                         GROUP_CONCAT(DISTINCT provider) as providers,
                         COALESCE(SUM(input_tokens), 0) as total_input_tokens,
                         COALESCE(SUM(output_tokens), 0) as total_output_tokens,
                         COALESCE(SUM(CAST(cost AS REAL)), 0) as total_cost
                  FROM conversation_history
                  GROUP BY conversation_id
                  ORDER BY last_msg DESC
              """))
              target_path = "ALL PATHS"
          else:
              result = conn.execute(text("""
                  SELECT conversation_id, directory_path,
                         MIN(timestamp) as started,
                         MAX(timestamp) as last_msg,
                         COUNT(*) as msg_count,
                         GROUP_CONCAT(DISTINCT npc) as npcs,
                         GROUP_CONCAT(DISTINCT model) as models,
                         GROUP_CONCAT(DISTINCT provider) as providers,
                         COALESCE(SUM(input_tokens), 0) as total_input_tokens,
                         COALESCE(SUM(output_tokens), 0) as total_output_tokens,
                         COALESCE(SUM(CAST(cost AS REAL)), 0) as total_cost
                  FROM conversation_history
                  WHERE directory_path = :path OR directory_path = :path_slash
                  GROUP BY conversation_id
                  ORDER BY last_msg DESC
              """), {"path": filter_path, "path_slash": filter_path + "/"})
              target_path = filter_path

          convos = [dict(row._mapping) for row in result.fetchall()]

      if not convos:
          context['output'] = f"No conversations for: {target_path}"
      else:
          width, height = get_terminal_size()
          selected = 0
          scroll = 0
          list_height = height - 5
          mode = 'list'
          preview_msgs = []
          preview_scroll = 0

          fd = sys.stdin.fileno()
          old_settings = termios.tcgetattr(fd)

          try:
              tty.setcbreak(fd)
              sys.stdout.write('\033[?25l')
              sys.stdout.write('\033[2J\033[H')

              while True:
                  if mode == 'list':
                      if selected < scroll:
                          scroll = selected
                      elif selected >= scroll + list_height:
                          scroll = selected - list_height + 1

                  sys.stdout.write('\033[H')
                  if mode == 'list':
                      header = f" REATTACH ({len(convos)} convos): {target_path[:width-30]} "
                  else:
                      header = f" PREVIEW: {convos[selected]['conversation_id'][:width-12]} "
                  sys.stdout.write(f'\033[7;1m{header.ljust(width)}\033[0m\n')
                  sys.stdout.write(f'\033[90m{"─" * width}\033[0m\n')

                  if mode == 'list':
                      for i in range(list_height):
                          idx = scroll + i
                          sys.stdout.write(f'\033[{3+i};1H\033[K')
                          if idx >= len(convos):
                              continue

                          c = convos[idx]
                          cid = c['conversation_id'][:12]
                          msgs = c['msg_count']
                          ts = format_ts(c['last_msg'])
                          npcs = (c['npcs'] or 'default')[:10]
                          models = (c.get('models') or '')
                          # Shorten model names
                          if models:
                              short_models = []
                              for m in models.split(',')[:2]:
                                  m = m.strip()
                                  if 'gpt-4' in m: short_models.append('gpt4')
                                  elif 'gpt-3' in m: short_models.append('gpt3')
                                  elif 'claude-3-5-sonnet' in m: short_models.append('sonnet')
                                  elif 'claude-3-5-haiku' in m: short_models.append('haiku')
                                  elif 'claude-3-opus' in m: short_models.append('opus')
                                  elif 'claude' in m: short_models.append('claude')
                                  elif 'gemini' in m: short_models.append('gemini')
                                  elif m: short_models.append(m[:8])
                              models = ','.join(short_models)[:12]
                          else:
                              models = '-'

                          line = f" {cid:<14} {msgs:>3} msgs  {ts:<12} {npcs:<10} {models:<12}"
                          line = line[:width-2].ljust(width-1)

                          if idx == selected:
                              sys.stdout.write(f'\033[7;1m>{line}\033[0m')
                          else:
                              sys.stdout.write(f' {line}')

                      sys.stdout.write(f'\033[{height-2};1H\033[K\033[90m{"─" * width}\033[0m')
                      sel = convos[selected]
                      sel_model = (sel.get('models') or '-')[:20]
                      in_tok = sel.get('total_input_tokens', 0)
                      out_tok = sel.get('total_output_tokens', 0)
                      cost = sel.get('total_cost', 0)
                      cost_str = f"${cost:.4f}" if cost else "-"
                      tok_str = f"{in_tok}in/{out_tok}out" if (in_tok or out_tok) else "-"
                      sys.stdout.write(f'\033[{height-1};1H\033[K {sel["conversation_id"][:16]}  {sel_model}  tokens:{tok_str}  cost:{cost_str}'.ljust(width))
                      sys.stdout.write(f'\033[{height};1H\033[K\033[7m j/k:Nav  Enter:Select  p:Preview  q:Quit  [{selected+1}/{len(convos)}] \033[0m')
                  else:
                      for i in range(list_height):
                          idx = preview_scroll + i
                          sys.stdout.write(f'\033[{3+i};1H\033[K')
                          if idx >= len(preview_msgs):
                              continue

                          m = preview_msgs[idx]
                          role = m.get('role', '?')
                          content = (m.get('content') or '')[:200].replace('\n', ' ')
                          model = m.get('model') or ''
                          in_tok = m.get('input_tokens')
                          out_tok = m.get('output_tokens')

                          if role == 'user':
                              prefix = '\033[32;1mYou:\033[0m '
                          elif role == 'assistant':
                              # Shorten model name for display
                              short_model = ''
                              if model:
                                  if 'gpt-4' in model: short_model = 'gpt4'
                                  elif 'gpt-3' in model: short_model = 'gpt3'
                                  elif 'claude-3-5-sonnet' in model: short_model = 'sonnet'
                                  elif 'claude-3-5-haiku' in model: short_model = 'haiku'
                                  elif 'claude-3-opus' in model: short_model = 'opus'
                                  elif 'claude' in model: short_model = 'claude'
                                  elif 'gemini' in model: short_model = 'gemini'
                                  else: short_model = model[:10]
                              tok_info = ''
                              if in_tok or out_tok:
                                  tok_info = f' [{in_tok or 0}/{out_tok or 0}]'
                              if short_model:
                                  prefix = f'\033[34;1mAI({short_model}{tok_info}):\033[0m '
                              else:
                                  prefix = f'\033[34;1mAI{tok_info}:\033[0m '
                          else:
                              prefix = f'\033[90m{role}:\033[0m '

                          sys.stdout.write(f'{prefix}{content[:width-len(prefix)+8]}')

                      sys.stdout.write(f'\033[{height-2};1H\033[K\033[90m{"─" * width}\033[0m')
                      sys.stdout.write(f'\033[{height-1};1H\033[K {len(preview_msgs)} messages')
                      sys.stdout.write(f'\033[{height};1H\033[K\033[7m j/k:Scroll  b:Back  Enter:Select  q:Quit \033[0m')

                  sys.stdout.flush()

                  c = sys.stdin.read(1)

                  if c == '\x1b':
                      c2 = sys.stdin.read(1)
                      if c2 == '[':
                          c3 = sys.stdin.read(1)
                          if c3 == 'A':  # Up
                              if mode == 'list' and selected > 0:
                                  selected -= 1
                              elif mode == 'preview' and preview_scroll > 0:
                                  preview_scroll -= 1
                          elif c3 == 'B':  # Down
                              if mode == 'list' and selected < len(convos) - 1:
                                  selected += 1
                              elif mode == 'preview' and preview_scroll < max(0, len(preview_msgs) - list_height):
                                  preview_scroll += 1
                      else:
                          if mode == 'preview':
                              mode = 'list'
                              sys.stdout.write('\033[2J\033[H')
                          else:
                              context['output'] = "Cancelled."
                              break
                      continue

                  if c == 'q' or c == '\x03':
                      context['output'] = "Cancelled."
                      break
                  elif c == 'k':
                      if mode == 'list' and selected > 0:
                          selected -= 1
                      elif mode == 'preview' and preview_scroll > 0:
                          preview_scroll -= 1
                  elif c == 'j':
                      if mode == 'list' and selected < len(convos) - 1:
                          selected += 1
                      elif mode == 'preview' and preview_scroll < max(0, len(preview_msgs) - list_height):
                          preview_scroll += 1
                  elif c == 'p' and mode == 'list':
                      cid = convos[selected]['conversation_id']
                      with engine.connect() as conn:
                          result = conn.execute(text("""
                              SELECT role, content, timestamp, npc, model, provider,
                                     input_tokens, output_tokens, cost
                              FROM conversation_history
                              WHERE conversation_id = :cid
                              ORDER BY timestamp ASC
                          """), {"cid": cid})
                          preview_msgs = [dict(row._mapping) for row in result.fetchall()]
                      preview_scroll = 0
                      mode = 'preview'
                      sys.stdout.write('\033[2J\033[H')
                  elif c == 'b' and mode == 'preview':
                      mode = 'list'
                      sys.stdout.write('\033[2J\033[H')
                  elif c in ('\r', '\n'):
                      cid = convos[selected]['conversation_id']
                      if 'state' in dir() and state is not None:
                          state.conversation_id = cid
                          context['output'] = f"Reattached to: {cid}"
                      else:
                          context['output'] = f"Selected: {cid}\n\nRun: /set conversation_id={cid}"
                      break

          finally:
              termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
              sys.stdout.write('\033[?25h')
              sys.stdout.write('\033[2J\033[H')
              sys.stdout.flush()
