jinx_name: spool
description: Interactive chat mode - simple conversational interface with an NPC
inputs:
  - model: null
  - provider: null
  - attachments: null
  - stream: true

steps:
  - name: spool_repl
    engine: python
    code: |
      import os
      import sys
      import tty
      import termios
      from termcolor import colored

      from npcpy.llm_funcs import get_llm_response
      from npcpy.npc_sysenv import get_system_message, render_markdown
      from npcpy.data.load import load_file_contents
      from npcpy.data.text import rag_search

      npc = context.get('npc')
      team = context.get('team')
      messages = context.get('messages', [])
      stream = context.get('stream', True)
      attachments = context.get('attachments')

      # Resolve npc if it's a string (npc name) rather than NPC object
      if isinstance(npc, str) and team:
          npc = team.get(npc) if hasattr(team, 'get') else None
      elif isinstance(npc, str):
          npc = None

      # Use NPC's model/provider or fallback
      model = context.get('model') or (npc.model if npc and hasattr(npc, 'model') else None)
      provider = context.get('provider') or (npc.provider if npc and hasattr(npc, 'provider') else None)

      # ========== TUI Helper Functions ==========
      def get_terminal_size():
          try:
              size = os.get_terminal_size()
              return size.columns, size.lines
          except:
              return 80, 24

      def history_tui_browser(messages):
          """Interactive TUI browser for conversation history"""
          # Filter out system messages for display
          history = [m for m in messages if m.get('role') != 'system']

          if not history:
              print(colored("No conversation history yet.", "yellow"))
              return

          width, height = get_terminal_size()
          selected = len(history) - 1  # Start at most recent
          scroll = max(0, selected - (height - 6))
          list_height = height - 5
          mode = 'list'
          preview_scroll = 0
          preview_lines = []

          fd = sys.stdin.fileno()
          old_settings = termios.tcgetattr(fd)

          try:
              tty.setcbreak(fd)
              sys.stdout.write('\033[?25l')
              sys.stdout.write('\033[2J\033[H')

              while True:
                  width, height = get_terminal_size()
                  list_height = height - 5

                  if mode == 'list':
                      if selected < scroll:
                          scroll = selected
                      elif selected >= scroll + list_height:
                          scroll = selected - list_height + 1

                  sys.stdout.write('\033[H')

                  # Header
                  if mode == 'list':
                      header = f" CONVERSATION HISTORY ({len(history)} messages) "
                  else:
                      header = f" MESSAGE {selected + 1} "
                  sys.stdout.write(f'\033[7;1m{header.ljust(width)}\033[0m\n')

                  if mode == 'list':
                      col_header = f' {"#":<4} {"ROLE":<12} {"PREVIEW":<60}'
                      sys.stdout.write(f'\033[90m{col_header[:width]}\033[0m\n')
                  else:
                      sys.stdout.write(f'\033[90m{"─" * width}\033[0m\n')

                  if mode == 'list':
                      for i in range(list_height):
                          idx = scroll + i
                          sys.stdout.write(f'\033[{3+i};1H\033[K')
                          if idx >= len(history):
                              continue

                          msg = history[idx]
                          role = msg.get('role', '?')[:12]
                          content = msg.get('content', '')[:60].replace('\n', ' ')

                          line = f" {idx+1:<4} {role:<12} {content}"
                          line = line[:width-1]

                          # Color by role
                          if msg.get('role') == 'user':
                              color = '\033[32m'  # green
                          elif msg.get('role') == 'assistant':
                              color = '\033[34m'  # blue
                          else:
                              color = ''

                          if idx == selected:
                              sys.stdout.write(f'\033[7;1m>{line.ljust(width-2)}\033[0m')
                          elif color:
                              sys.stdout.write(f'{color}{line}\033[0m')
                          else:
                              sys.stdout.write(f' {line}')

                      # Status bar
                      sys.stdout.write(f'\033[{height-2};1H\033[K\033[90m{"─" * width}\033[0m')
                      user_msgs = len([m for m in history if m.get('role') == 'user'])
                      asst_msgs = len([m for m in history if m.get('role') == 'assistant'])
                      sys.stdout.write(f'\033[{height-1};1H\033[K User: {user_msgs} | Assistant: {asst_msgs}'.ljust(width)[:width])
                      sys.stdout.write(f'\033[{height};1H\033[K\033[7m j/k:Nav p:Preview c:Copy q:Quit [{selected+1}/{len(history)}] \033[0m')

                  else:  # preview mode
                      for i in range(list_height):
                          idx = preview_scroll + i
                          sys.stdout.write(f'\033[{3+i};1H\033[K')
                          if idx < len(preview_lines):
                              sys.stdout.write(preview_lines[idx][:width-1])

                      sys.stdout.write(f'\033[{height-2};1H\033[K\033[90m{"─" * width}\033[0m')
                      sys.stdout.write(f'\033[{height-1};1H\033[K [{preview_scroll+1}/{len(preview_lines)} lines]')
                      sys.stdout.write(f'\033[{height};1H\033[K\033[7m j/k:Scroll b:Back c:Copy q:Quit \033[0m')

                  sys.stdout.flush()

                  c = sys.stdin.read(1)

                  if c == '\x1b':
                      c2 = sys.stdin.read(1)
                      if c2 == '[':
                          c3 = sys.stdin.read(1)
                          if c3 == 'A':  # Up
                              if mode == 'list' and selected > 0:
                                  selected -= 1
                              elif mode == 'preview' and preview_scroll > 0:
                                  preview_scroll -= 1
                          elif c3 == 'B':  # Down
                              if mode == 'list' and selected < len(history) - 1:
                                  selected += 1
                              elif mode == 'preview' and preview_scroll < max(0, len(preview_lines) - list_height):
                                  preview_scroll += 1
                      else:
                          if mode == 'preview':
                              mode = 'list'
                              sys.stdout.write('\033[2J\033[H')
                          else:
                              return
                      continue

                  if c == 'q' or c == '\x03':
                      return
                  elif c == 'k':
                      if mode == 'list' and selected > 0:
                          selected -= 1
                      elif mode == 'preview' and preview_scroll > 0:
                          preview_scroll -= 1
                  elif c == 'j':
                      if mode == 'list' and selected < len(history) - 1:
                          selected += 1
                      elif mode == 'preview' and preview_scroll < max(0, len(preview_lines) - list_height):
                          preview_scroll += 1
                  elif c == 'p' and mode == 'list':
                      # Preview message
                      msg = history[selected]
                      preview_str = f"Role: {msg.get('role', '?')}\n"
                      preview_str += f"{'=' * 40}\n\n"
                      preview_str += msg.get('content', '')
                      preview_lines = preview_str.split('\n')
                      mode = 'preview'
                      preview_scroll = 0
                      sys.stdout.write('\033[2J\033[H')
                  elif c == 'b' and mode == 'preview':
                      mode = 'list'
                      sys.stdout.write('\033[2J\033[H')
                  elif c == 'c':
                      # Copy to clipboard
                      msg = history[selected]
                      content = msg.get('content', '')
                      try:
                          import subprocess
                          subprocess.run(['xclip', '-selection', 'clipboard'], input=content.encode(), check=True)
                      except:
                          try:
                              subprocess.run(['xsel', '--clipboard', '--input'], input=content.encode(), check=True)
                          except:
                              pass

          finally:
              termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
              sys.stdout.write('\033[?25h')
              sys.stdout.write('\033[2J\033[H')
              sys.stdout.flush()

      # ASCII art
      print("""
       _____ ____   ____   ____  _
      / ___/|  _ \ / __ \ / __ \| |
      \___ \| |_) | |  | | |  | | |
       ___) |  __/| |  | | |  | | |___
      |____/|_|    \____/ \____/|_____|
      """)

      npc_name = npc.name if npc else "chat"
      print(f"Entering spool mode (NPC: {npc_name}). Type '/sq' to exit.")
      print("  - /history: Browse conversation history")

      # Load attachments if provided
      loaded_chunks = {}
      if attachments:
          if isinstance(attachments, str):
              attachments = [f.strip() for f in attachments.split(',')]
          for file_path in attachments:
              file_path = os.path.expanduser(file_path)
              if os.path.exists(file_path):
                  try:
                      chunks = load_file_contents(file_path)
                      loaded_chunks[file_path] = chunks
                      print(colored(f"Loaded {len(chunks)} chunks from: {file_path}", "green"))
                  except Exception as e:
                      print(colored(f"Error loading {file_path}: {e}", "red"))

      # Ensure system message
      if not messages or messages[0].get("role") != "system":
          sys_msg = get_system_message(npc) if npc else "You are a helpful assistant."
          messages.insert(0, {"role": "system", "content": sys_msg})

      # REPL loop
      while True:
          try:
              prompt_str = f"{npc_name}> "
              user_input = input(prompt_str).strip()

              if not user_input:
                  continue

              if user_input.lower() == "/sq":
                  print("Exiting spool mode.")
                  break

              # Handle /history for conversation browser
              if user_input.lower() == "/history":
                  history_tui_browser(messages)
                  continue

              # Handle /ots for screenshots inline
              if user_input.startswith("/ots"):
                  from npcpy.data.image import capture_screenshot
                  parts = user_input.split()
                  image_paths = []
                  if len(parts) > 1:
                      for p in parts[1:]:
                          fp = os.path.expanduser(p)
                          if os.path.exists(fp):
                              image_paths.append(fp)
                  else:
                      ss = capture_screenshot()
                      if ss and "file_path" in ss:
                          image_paths.append(ss["file_path"])
                          print(colored(f"Screenshot: {ss['filename']}", "green"))

                  if image_paths:
                      vision_prompt = input("Prompt for image(s): ").strip() or "Describe these images."
                      resp = get_llm_response(
                          vision_prompt,
                          model=npc.vision_model if hasattr(npc, 'vision_model') else model,
                          provider=npc.vision_provider if hasattr(npc, 'vision_provider') else provider,
                          messages=messages,
                          images=image_paths,
                          stream=stream,
                          npc=npc
                      )
                      messages = resp.get('messages', messages)
                      render_markdown(str(resp.get('response', '')))
                  continue

              # Add RAG context if files loaded
              current_prompt = user_input
              if loaded_chunks:
                  context_content = ""
                  for filename, chunks in loaded_chunks.items():
                      full_text = "\n".join(chunks)
                      retrieved = rag_search(user_input, full_text, similarity_threshold=0.3)
                      if retrieved:
                          context_content += f"\n\nContext from {filename}:\n{retrieved}\n"
                  if context_content:
                      current_prompt += f"\n\n--- Relevant context ---{context_content}"

              # Get response
              resp = get_llm_response(
                  current_prompt,
                  model=model,
                  provider=provider,
                  messages=messages,
                  stream=stream,
                  npc=npc
              )

              messages = resp.get('messages', messages)
              response_text = resp.get('response', '')

              # Handle streaming vs non-streaming
              if hasattr(response_text, '__iter__') and not isinstance(response_text, str):
                  full_response = ""
                  for chunk in response_text:
                      if hasattr(chunk, 'choices') and chunk.choices:
                          delta = chunk.choices[0].delta
                          if hasattr(delta, 'content') and delta.content:
                              print(delta.content, end='', flush=True)
                              full_response += delta.content
                  print()
              else:
                  render_markdown(str(response_text))

              # Track usage if available
              if 'usage' in resp and npc and hasattr(npc, 'shared_context'):
                  usage = resp['usage']
                  npc.shared_context['session_input_tokens'] += usage.get('input_tokens', 0)
                  npc.shared_context['session_output_tokens'] += usage.get('output_tokens', 0)
                  npc.shared_context['turn_count'] += 1

          except KeyboardInterrupt:
              print("\nUse '/sq' to exit or continue.")
              continue
          except EOFError:
              print("\nExiting spool mode.")
              break

      context['output'] = "Exited spool mode."
      context['messages'] = messages
