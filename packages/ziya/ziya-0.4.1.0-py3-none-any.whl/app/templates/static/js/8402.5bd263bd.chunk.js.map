{"version":3,"file":"static/js/8402.5bd263bd.chunk.js","mappings":"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","sources":["plugins/d3/d2Plugin.ts"],"sourcesContent":["import { D3RenderPlugin } from '../../types/d3';\nimport { isDiagramDefinitionComplete } from '../../utils/diagramUtils';\nimport { extractDefinitionFromYAML } from '../../utils/diagramUtils';\n\nexport interface D2Spec {\n    type: 'd2';\n    isStreaming?: boolean;\n    forceRender?: boolean;\n    definition: string;\n    layout?: 'elk' | 'dagre' | 'tala';\n}\n\nconst isD2Spec = (spec: any): spec is D2Spec => {\n    return (\n        typeof spec === 'object' &&\n        spec !== null &&\n        spec.type === 'd2' &&\n        typeof spec.definition === 'string' &&\n        spec.definition.trim().length > 0\n    );\n};\n\n// Enhanced D2 parser with better syntax support\n// D2 parser and renderer\nclass D2Parser {\n    private nodes: Map<string, any> = new Map();\n    private edges: any[] = [];\n    private containers: Map<string, any> = new Map();\n    private currentContainer: string | null = null;\n    private containerStack: string[] = [];\n\n    constructor() {\n        this.reset();\n    }\n\n    private reset() {\n        this.nodes.clear();\n        this.edges = [];\n        this.containers.clear();\n        this.containerStack = [];\n        this.currentContainer = null;\n    }\n\n    parse(definition: string) {\n        this.reset();\n        \n        const lines = definition.split('\\n')\n            .map(line => line.trim())\n            .filter(line => line && !line.startsWith('#'));\n        \n        for (const line of lines) {\n            this.parseLine(line);\n        }\n\n        return {\n            nodes: Array.from(this.nodes.values()),\n            edges: this.edges,\n            containers: Array.from(this.containers.values())\n        };\n    }\n\n    private parseLine(line: string) {\n        // Handle container start/end\n        if (line.endsWith('{')) {\n            // Handle nested containers\n            const containerName = line.replace('{', '').trim();\n            if (this.currentContainer) {\n                this.containerStack.push(this.currentContainer);\n            }\n            this.currentContainer = containerName;\n            this.containers.set(containerName, {\n                id: containerName,\n                label: containerName,\n                type: 'container',\n                children: [],\n                parent: this.containerStack.length > 0 ? this.containerStack[this.containerStack.length - 1] : null\n            });\n            return;\n        }\n        \n        if (line === '}') {\n            // Pop from container stack for nested containers\n            this.currentContainer = this.containerStack.pop() || null;\n            return;\n        }\n\n        // Handle connections (edges)\n        if (line.includes('->') || line.includes('<->') || line.includes('<-')) {\n            this.parseConnection(line);\n        }\n        // Handle node definitions with properties\n        else if (line.includes(':') && (line.includes('{') || line.includes('}'))) {\n            this.parseNodeWithProperties(line);\n        }\n        // Handle simple node definitions\n        else if (line.includes(':')) {\n            this.parseSimpleNode(line);\n        }\n        // Handle style definitions\n        else if (line.includes('.') && line.includes(':')) {\n            this.parseStyleDefinition(line);\n        }\n    }\n\n    private parseConnection(line: string) {\n        const connectionRegex = /([^-<>]+)(\\s*<?-+>?\\s*)([^-<>]+)(?:\\s*:\\s*(.+))?/;\n        const match = line.match(connectionRegex);\n        \n        if (match) {\n            let source = match[1].trim();\n            const connector = match[2].trim();\n            let target = match[3].trim();\n            const label = match[4]?.trim();\n\n            // Handle dotted paths (e.g., container.node)\n            source = this.resolvePath(source);\n            target = this.resolvePath(target);\n\n            // Ensure nodes exist\n            this.ensureNode(source);\n            this.ensureNode(target);\n\n            const edge = {\n                source: this.normalizeNodeId(source),\n                target: this.normalizeNodeId(target),\n                label: label || '',\n                bidirectional: connector.includes('<->'),\n                reversed: connector.startsWith('<-') && !connector.includes('<->')\n            };\n\n            this.edges.push(edge);\n        }\n    }\n\n    private parseSimpleNode(line: string) {\n        const parts = line.split(':');\n        if (parts.length >= 2) {\n            const nodeId = parts[0].trim();\n            const label = parts.slice(1).join(':').trim();\n\n            this.nodes.set(nodeId, {\n                id: this.normalizeNodeId(nodeId),\n                label: label || nodeId,\n                originalId: nodeId,\n                container: this.currentContainer\n            });\n\n            // Add to current container if we're inside one\n            if (this.currentContainer && this.containers.has(this.currentContainer)) {\n                this.containers.get(this.currentContainer).children.push(nodeId);\n            }\n        }\n    }\n\n    private parseNodeWithProperties(line: string) {\n        // Handle node properties like: node: { shape: circle; fill: blue }\n        const match = line.match(/([^:]+):\\s*\\{([^}]+)\\}/);\n        if (match) {\n            const nodeId = match[1].trim();\n            const properties = match[2].trim();\n\n            const node = this.nodes.get(nodeId) || {\n                id: this.normalizeNodeId(nodeId),\n                label: nodeId,\n                originalId: nodeId,\n                container: this.currentContainer\n            };\n\n            // Parse properties\n            const props = this.parseProperties(properties);\n            Object.assign(node, props);\n\n            this.nodes.set(nodeId, node);\n\n            // Add to current container if we're inside one\n            if (this.currentContainer && this.containers.has(this.currentContainer)) {\n                this.containers.get(this.currentContainer).children.push(nodeId);\n            }\n        }\n    }\n\n    private parseStyleDefinition(line: string) {\n        // Handle style definitions like: *.shape: circle\n        const match = line.match(/([^:]+):\\s*(.+)/);\n        if (match) {\n            const selector = match[1].trim();\n            const value = match[2].trim();\n            \n            // Apply styles to matching nodes\n            if (selector.startsWith('*.')) {\n                const property = selector.substring(2);\n                // Apply to all nodes - this is a simplified implementation\n                // In a full implementation, you'd store these styles and apply them during rendering\n            }\n        }\n    }\n\n    private parseProperties(propString: string): any {\n        const props: any = {};\n        const pairs = propString.split(';');\n\n        for (const pair of pairs) {\n            const [key, value] = pair.split(':').map(s => s.trim());\n            if (key && value) {\n                props[key] = value;\n            }\n        }\n\n        return props;\n    }\n\n    private resolvePath(path: string): string {\n        // Handle dotted paths like container.node\n        if (path.includes('.')) {\n            const parts = path.split('.');\n            // For now, just use the last part as the node ID\n            // In a full implementation, you'd handle the hierarchy properly\n            return parts[parts.length - 1];\n        }\n        return path;\n    }\n\n    private ensureNode(nodeId: string) {\n        if (!this.nodes.has(nodeId)) {\n            this.nodes.set(nodeId, {\n                id: this.normalizeNodeId(nodeId),\n                label: nodeId,\n                originalId: nodeId,\n                container: this.currentContainer\n            });\n        }\n    }\n\n    private normalizeNodeId(id: string): string {\n        return id.replace(/[^a-zA-Z0-9]/g, '_');\n    }\n}\n\n// Full ELK layout engine integration\nclass ELKLayoutEngine {\n    private elk: any | null = null;\n\n    async initialize() {\n        if (!this.elk) {\n            const ELK = (await import('elkjs')).default;\n            this.elk = new ELK();\n        }\n    }\n\n    async layout(nodes: any[], edges: any[], options: any = {}) {\n        if (nodes.length === 0) {\n            return { nodes: [], edges: [] };\n        }\n\n        await this.initialize();\n        \n        // Create ELK graph structure\n        const elkGraph = {\n            id: 'root',\n            layoutOptions: {\n                'elk.algorithm': options.algorithm || 'layered',\n                'elk.direction': options.direction || 'DOWN',\n                'elk.spacing.nodeNode': options.nodeSpacing || '50',\n                'elk.layered.spacing.nodeNodeBetweenLayers': options.layerSpacing || '50',\n                'elk.spacing.edgeNode': '30',\n                'elk.spacing.edgeEdge': '15',\n                'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',\n                'elk.layered.nodePlacement.strategy': 'BRANDES_KOEPF',\n                'elk.layered.cycleBreaking.strategy': 'GREEDY',\n                'elk.insideSelfLoops.activate': 'true',\n                ...options\n            },\n            children: nodes.map(node => ({\n                id: node.id,\n                width: this.calculateNodeWidth(node.label || node.id),\n                height: this.calculateNodeHeight(node.label || node.id),\n                labels: node.label ? [{\n                    text: node.label,\n                    layoutOptions: {\n                        'elk.labelManager': 'none'\n                    }\n                }] : [],\n                layoutOptions: {\n                    'elk.nodeSize.constraints': 'NODE_LABELS',\n                    'elk.nodeSize.options': 'DEFAULT_MINIMUM_SIZE COMPUTE_PADDING',\n                    'elk.padding': '[top=10,left=15,bottom=10,right=15]'\n                }\n            })),\n            edges: edges.map(edge => ({\n                id: `${edge.source}_${edge.target}`,\n                sources: [edge.source],\n                targets: [edge.target],\n                labels: edge.label ? [{\n                    text: edge.label,\n                    layoutOptions: {\n                        'elk.edgeLabels.placement': 'CENTER'\n                    }\n                }] : [],\n                layoutOptions: {\n                    'elk.edge.type': edge.bidirectional ? 'UNDIRECTED' : 'DIRECTED'\n                }\n            }))\n        };\n\n        try {\n            // Use ELK to compute the layout\n            const layoutedGraph = await this.elk.layout(elkGraph);\n\n            // Transform ELK result back to our format\n            const layoutedNodes = layoutedGraph.children?.map((elkNode: any) => {\n                const originalNode = nodes.find(n => n.id === elkNode.id);\n                return {\n                    ...originalNode,\n                    x: elkNode.x || 0,\n                    y: elkNode.y || 0,\n                    width: elkNode.width || 100,\n                    height: elkNode.height || 50\n                };\n            }) || [];\n\n            return { nodes: layoutedNodes, edges };\n        } catch (error) {\n            console.warn('ELK layout failed, falling back to simple layout:', error);\n            return this.simpleGridLayout(nodes, edges);\n        }\n    }\n\n    private calculateNodeWidth(text: string): number {\n        // Estimate width based on text length with minimum and maximum bounds\n        const baseWidth = 80;\n        const charWidth = 8;\n        const padding = 30;\n        return Math.max(baseWidth, Math.min(text.length * charWidth + padding, 200));\n    }\n\n    private calculateNodeHeight(text: string): number {\n        // Calculate height based on text wrapping\n        const baseHeight = 40;\n        const lineHeight = 16;\n        const maxWidth = 180;\n        const estimatedLines = Math.ceil((text.length * 8) / maxWidth);\n        return Math.max(baseHeight, baseHeight + (estimatedLines - 1) * lineHeight);\n    }\n\n    private simpleGridLayout(nodes: any[], edges: any[]) {\n        // Fallback layout when ELK fails\n        const cols = Math.ceil(Math.sqrt(nodes.length));\n        const nodeSpacing = 150;\n\n        nodes.forEach((node, index) => {\n            const row = Math.floor(index / cols);\n            const col = index % cols;\n            node.x = col * nodeSpacing + 100;\n            node.y = row * nodeSpacing + 100;\n            node.width = this.calculateNodeWidth(node.label || node.id);\n            node.height = this.calculateNodeHeight(node.label || node.id);\n        });\n\n        return { nodes, edges };\n    }\n}\n\nexport const d2Plugin: D3RenderPlugin = {\n    name: 'd2-renderer',\n    priority: 6,\n    sizingConfig: {\n        sizingStrategy: 'auto-expand',\n        needsDynamicHeight: true,\n        needsOverflowVisible: true,\n        observeResize: true,\n        containerStyles: {\n            width: '100%',\n            height: 'auto',\n            overflow: 'visible'\n        }\n    },\n    canHandle: isD2Spec,\n\n    isDefinitionComplete: (definition: string): boolean => {\n        if (!definition || definition.trim().length === 0) return false;\n\n        // Check for basic D2 syntax patterns\n        const lines = definition.trim().split('\\n').filter(line => line.trim());\n        if (lines.length === 0) return false;\n\n        // Look for connections or node definitions\n        const hasConnections = lines.some(line =>\n            line.includes('->') || line.includes('<->') || line.includes('<-')\n        );\n        const hasNodes = lines.some(line => line.includes(':'));\n\n        return hasConnections || hasNodes;\n    },\n\n    render: async (container: HTMLElement, d3: any, spec: D2Spec, isDarkMode: boolean) => {\n        try {\n            // Check if streaming and incomplete\n            if (spec.isStreaming && !spec.forceRender) {\n                const isComplete = d2Plugin.isDefinitionComplete!(spec.definition);\n                if (!isComplete) {\n                    container.innerHTML = `\n                        <div style=\"text-align: center; padding: 20px; background-color: ${isDarkMode ? '#1f1f1f' : '#f6f8fa'}; border: 1px dashed #ccc; border-radius: 4px;\">\n                            <p>Waiting for complete D2 definition...</p>\n                        </div>\n                    `;\n                    return;\n                }\n            }\n\n            // Parse D2 definition\n            const extractedDefinition = extractDefinitionFromYAML(spec.definition, 'd2');\n            const parser = new D2Parser();\n            const { nodes, edges, containers } = parser.parse(extractedDefinition);\n\n            if (nodes.length === 0) {\n                container.innerHTML = `\n                    <div style=\"text-align: center; padding: 20px; color: ${isDarkMode ? '#ff6b6b' : '#d63031'};\">\n                        <p>No nodes found in D2 definition</p>\n                    </div>\n                `;\n                return;\n            }\n\n            // Apply layout\n            const layoutEngine = new ELKLayoutEngine();\n            // Configure layout options based on diagram complexity\n            const layoutOptions = {\n                algorithm: spec.layout || 'layered',\n                direction: containers.length > 0 ? 'DOWN' : 'RIGHT',\n                nodeSpacing: '60',\n                layerSpacing: '80'\n            };\n\n            const layoutResult = await layoutEngine.layout(nodes, edges, layoutOptions);\n\n            // Render with D3\n            container.innerHTML = '';\n        const svg = d3.select(container)\n            .append('svg')\n            .attr('width', '100%')\n            .attr('height', () => {\n                // Calculate height based on layout\n                const maxY = Math.max(...layoutResult.nodes.map(n => n.y + n.height));\n                return Math.max(400, maxY + 100) + 'px';\n            })\n            .attr('viewBox', () => {\n                const maxX = Math.max(...layoutResult.nodes.map(n => n.x + n.width));\n                const maxY = Math.max(...layoutResult.nodes.map(n => n.y + n.height));\n                return `0 0 ${Math.max(800, maxX + 100)} ${Math.max(400, maxY + 100)}`;\n            });\n\n            // Theme colors\n    const colors = {\n        node: isDarkMode ? '#4361ee' : '#e3f2fd',\n        nodeStroke: isDarkMode ? '#4cc9f0' : '#1976d2',\n        edge: isDarkMode ? '#f72585' : '#666666',\n        text: isDarkMode ? '#ffffff' : '#000000'\n    };\n\n            // Render containers first (as background rectangles)\n    if (containers.length > 0) {\n        svg.selectAll('.container')\n            .data(containers)\n            .enter()\n            .append('rect')\n            .attr('class', 'container')\n            .attr('x', d => Math.min(...d.children.map(childId => {\n                    const node = layoutResult.nodes.find(n => n.originalId === childId);\n                return node ? node.x - 20 : 0;\n            })))\n            .attr('y', d => Math.min(...d.children.map(childId => {\n                    const node = layoutResult.nodes.find(n => n.originalId === childId);\n                return node ? node.y - 20 : 0;\n            })))\n            .attr('width', d => Math.max(...d.children.map(childId => {\n                    const node = layoutResult.nodes.find(n => n.originalId === childId);\n                return node ? node.x + node.width + 40 : 100;\n            })) - Math.min(...d.children.map(childId => {\n                    const node = layoutResult.nodes.find(n => n.originalId === childId);\n                return node ? node.x - 20 : 0;\n            })))\n            .attr('height', d => Math.max(...d.children.map(childId => {\n                    const node = layoutResult.nodes.find(n => n.originalId === childId);\n                return node ? node.y + node.height + 40 : 50;\n            })) - Math.min(...d.children.map(childId => {\n                    const node = layoutResult.nodes.find(n => n.originalId === childId);\n                return node ? node.y - 20 : 0;\n            })))\n            .attr('fill', 'none')\n            .attr('stroke', isDarkMode ? '#4cc9f0' : '#1976d2')\n            .attr('stroke-width', 2)\n            .attr('stroke-dasharray', '5,5')\n            .attr('rx', 10);\n    }\n\n            // Add arrowhead marker\n            svg.append('defs')\n                .append('marker')\n                .attr('id', 'arrowhead')\n                .attr('viewBox', '0 -5 10 10')\n                .attr('refX', 8)\n                .attr('refY', 0)\n                .attr('markerWidth', 6)\n                .attr('markerHeight', 6)\n                .attr('orient', 'auto')\n                .append('path')\n                .attr('d', 'M0,-5L10,0L0,5')\n                .attr('fill', colors.edge);\n\n            // Render edges\n            svg.selectAll('.edge')\n    .data(layoutResult.edges)\n    .enter()\n    .append('line')\n    .attr('class', 'edge')\n    .attr('x1', d => {\n        const sourceNode = layoutResult.nodes.find(n => n.id === d.source);\n        return sourceNode ? sourceNode.x + sourceNode.width / 2 : 0;\n    })\n    .attr('y1', d => {\n        const sourceNode = layoutResult.nodes.find(n => n.id === d.source);\n        return sourceNode ? sourceNode.y + sourceNode.height / 2 : 0;\n    })\n    .attr('x2', d => {\n        const targetNode = layoutResult.nodes.find(n => n.id === d.target);\n        return targetNode ? targetNode.x + targetNode.width / 2 : 0;\n    })\n    .attr('y2', d => {\n        const targetNode = layoutResult.nodes.find(n => n.id === d.target);\n        return targetNode ? targetNode.y + targetNode.height / 2 : 0;\n    })\n    .attr('stroke', colors.edge)\n    .attr('stroke-width', 2)\n    .attr('marker-end', 'url(#arrowhead)');\n\n            // Render nodes\nconst nodeGroups = svg.selectAll('.node')\n    .data(layoutResult.nodes)\n    .enter()\n    .append('g')\n    .attr('class', 'node')\n    .attr('transform', d => `translate(${d.x}, ${d.y})`);\n\nnodeGroups.append('rect')\n    .attr('width', d => d.width)\n    .attr('height', d => d.height)\n    .attr('fill', colors.node)\n    .attr('stroke', colors.nodeStroke)\n    .attr('stroke-width', 2)\n    .attr('rx', 5);\n\nnodeGroups.append('text')\n    .attr('x', d => d.width / 2)\n    .attr('y', d => d.height / 2)\n    .attr('text-anchor', 'middle')\n    .attr('dominant-baseline', 'middle')\n    .attr('fill', colors.text)\n    .attr('font-family', 'Arial, sans-serif')\n    .attr('font-size', '12px')\n    .text(d => d.label);\n\n            // Add edge labels if they exist\n            svg.selectAll('.edge-label')\n                .data(layoutResult.edges.filter(d => d.label))\n                .enter()\n                .append('text')\n                .attr('class', 'edge-label')\n                .attr('x', d => {\n                    const sourceNode = layoutResult.nodes.find(n => n.id === d.source);\n                    const targetNode = layoutResult.nodes.find(n => n.id === d.target);\n                    if (sourceNode && targetNode) {\n                        return (sourceNode.x + sourceNode.width / 2 + targetNode.x + targetNode.width / 2) / 2;\n                    }\n                    return 0;\n                })\n                .attr('y', d => {\n                    const sourceNode = layoutResult.nodes.find(n => n.id === d.source);\n                    const targetNode = layoutResult.nodes.find(n => n.id === d.target);\n                    if (sourceNode && targetNode) {\n                        return (sourceNode.y + sourceNode.height / 2 + targetNode.y + targetNode.height / 2) / 2;\n                    }\n                    return 0;\n                })\n                .attr('text-anchor', 'middle')\n                .attr('dominant-baseline', 'middle')\n                .attr('fill', colors.text)\n                .attr('font-family', 'Arial, sans-serif')\n                .attr('font-size', '10px')\n                .attr('background', isDarkMode ? '#1f1f1f' : '#ffffff')\n                .text(d => d.label);\n\n        } catch (error) {\n            console.error('D2 rendering error:', error);\n            container.innerHTML = `\n                <div style=\"\n                    padding: 20px;\n                    background-color: ${isDarkMode ? '#2a1f1f' : '#fff2f0'};\n                    border: 1px solid ${isDarkMode ? '#a61d24' : '#ffa39e'};\n                    border-radius: 6px;\n                    color: ${isDarkMode ? '#ff7875' : '#cf1322'};\n                \">\n                    <strong>D2 Rendering Error:</strong>\n                    <pre style=\"margin: 10px 0; white-space: pre-wrap;\">${error instanceof Error ? error.message : 'Unknown error'}</pre>\n                    <details style=\"margin-top: 10px;\">\n                        <summary style=\"cursor: pointer; font-weight: bold;\">Show D2 Definition</summary>\n                        <pre style=\"\n                            margin: 10px 0;\n                            padding: 10px;\n                            background-color: ${isDarkMode ? '#1f1f1f' : '#f6f8fa'};\n                            border-radius: 4px;\n                            overflow-x: auto;\n                            white-space: pre-wrap;\n                        \"><code>${spec.definition}</code></pre>\n                    </details>\n                </div>\n            `;\n        }\n    }\n};"],"names":["D2Parser","constructor","nodes","Map","edges","containers","currentContainer","containerStack","this","reset","clear","parse","definition","lines","split","map","line","trim","filter","startsWith","parseLine","Array","from","values","endsWith","containerName","replace","push","set","id","label","type","children","parent","length","includes","parseConnection","parseNodeWithProperties","parseSimpleNode","parseStyleDefinition","pop","match","_match$","source","connector","target","resolvePath","ensureNode","edge","normalizeNodeId","bidirectional","reversed","parts","nodeId","slice","join","originalId","container","has","get","properties","node","props","parseProperties","Object","assign","selector","substring","propString","pairs","pair","key","value","s","path","ELKLayoutEngine","elk","initialize","ELK","default","layout","options","arguments","undefined","elkGraph","layoutOptions","_objectSpread","algorithm","direction","nodeSpacing","layerSpacing","width","calculateNodeWidth","height","calculateNodeHeight","labels","text","concat","sources","targets","_layoutedGraph$childr","layoutedGraph","elkNode","originalNode","find","n","x","y","error","console","warn","simpleGridLayout","Math","max","min","estimatedLines","ceil","cols","sqrt","forEach","index","row","floor","col","d2Plugin","name","priority","sizingConfig","sizingStrategy","needsDynamicHeight","needsOverflowVisible","observeResize","containerStyles","overflow","canHandle","spec","isDefinitionComplete","hasConnections","some","hasNodes","render","async","d3","isDarkMode","isStreaming","forceRender","innerHTML","extractedDefinition","extractDefinitionFromYAML","parser","layoutEngine","layoutResult","svg","select","append","attr","maxY","maxX","colors","nodeStroke","selectAll","data","enter","d","childId","sourceNode","targetNode","nodeGroups","Error","message"],"ignoreList":[],"sourceRoot":""}