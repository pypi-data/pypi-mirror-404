"""
${Entity} model (SQLAlchemy ORM).

Auto-generated by fin-infra scaffold. Customize as needed.
"""
from datetime import datetime, timezone
from decimal import Decimal
from typing import Any, Dict, Optional
from uuid import uuid4

from sqlalchemy import CheckConstraint, DateTime, Index, Numeric, String, text
from sqlalchemy.dialects.postgresql import JSON
from sqlalchemy.ext.mutable import MutableDict
from sqlalchemy.orm import Mapped, mapped_column

from svc_infra.db.sql.base import ModelBase
from svc_infra.db.sql.types import GUID
from svc_infra.db.sql.uniq import make_unique_sql_indexes


class ${Entity}(ModelBase):
    """Net worth snapshot model for point-in-time financial tracking.
    
    Captures a complete picture of user's financial state at a specific date.
    Immutable snapshots enable time-series analysis and trend visualization.
    
    Attributes:
        id: Unique snapshot identifier (UUID)
        user_id: User who owns this snapshot
        snapshot_date: Date when snapshot was taken (timezone-aware)
        total_assets: Sum of all asset values (cash, investments, real estate, etc.)
        total_liabilities: Sum of all liabilities (loans, credit cards, mortgage, etc.)
        net_worth: Calculated net worth (total_assets - total_liabilities)
        liquid_net_worth: Liquid assets only (excluding real estate, retirement accounts)
        accounts_data: Raw account balances at snapshot time (JSON)
        asset_breakdown: Categorized asset values (JSON) - e.g., {"cash": 10000, "stocks": 50000}
        liability_breakdown: Categorized liability values (JSON) - e.g., {"credit_cards": 2000, "mortgage": 300000}
        extra: Additional snapshot metadata (JSON)
        created_at: When snapshot record was created${tenant_doc}${soft_delete_field}
        
    Note: Snapshots are immutable. To correct errors, delete and recreate.
    """
    __tablename__ = "${table_name}"

    # Primary key
    id: Mapped[str] = mapped_column(
        GUID(),
        primary_key=True,
        default=uuid4,
        doc="Unique snapshot identifier"
    )

    # Core fields (user_id nullable for simple testing, set to False in production)
    user_id: Mapped[Optional[str]] = mapped_column(
        String(64),
        nullable=True,
        index=True,
        doc="User who owns this snapshot"
    )
    
    snapshot_date: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        index=True,
        doc="Date when snapshot was taken (timezone-aware)"
    )
    
    # Financial amounts
    total_assets: Mapped[Decimal] = mapped_column(
        Numeric(15, 2),
        nullable=False,
        default=Decimal("0.00"),
        server_default=text("0.00"),
        doc="Sum of all asset values"
    )
    
    total_liabilities: Mapped[Decimal] = mapped_column(
        Numeric(15, 2),
        nullable=False,
        default=Decimal("0.00"),
        server_default=text("0.00"),
        doc="Sum of all liabilities"
    )
    
    net_worth: Mapped[Decimal] = mapped_column(
        Numeric(15, 2),
        nullable=False,
        doc="Calculated net worth (total_assets - total_liabilities)"
    )
    
    liquid_net_worth: Mapped[Optional[Decimal]] = mapped_column(
        Numeric(15, 2),
        nullable=True,
        doc="Liquid assets only (excluding real estate, retirement accounts)"
    )
    
    # JSON fields for detailed breakdown
    accounts_data: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSON,
        nullable=True,
        doc="Raw account balances at snapshot time (JSON)"
    )
    
    asset_breakdown: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSON,
        nullable=True,
        doc="Categorized asset values (JSON) - e.g., {'cash': 10000, 'stocks': 50000}"
    )
    
    liability_breakdown: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSON,
        nullable=True,
        doc="Categorized liability values (JSON) - e.g., {'credit_cards': 2000, 'mortgage': 300000}"
    )
    
    extra: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        MutableDict.as_mutable(JSON),
        nullable=True,
        doc="Additional snapshot metadata (JSON)"
    )
${tenant_field}
    # Timestamp (created_at only - snapshots are immutable, no updated_at)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        nullable=False
    )

    def __repr__(self) -> str:
        return f"<${Entity} id={self.id} user_id={self.user_id!r} date={self.snapshot_date.date()} net_worth={self.net_worth}>"

    __table_args__ = (
        # Ensure net_worth calculation is correct (PostgreSQL only)
        CheckConstraint(
            "net_worth = total_assets - total_liabilities",
            name="ck_${table_name}_net_worth_calc"
        ),
    )


# --- Uniqueness policy --------------------------------------------------------
# One snapshot per user per day: (user_id, snapshot_date) or (tenant_id, user_id, snapshot_date)
for _ix in make_unique_sql_indexes(
    ${Entity},
    unique_cs=["user_id", "snapshot_date"]${tenant_arg_unique_index}
):
    pass

# ----------------------- Service factory ---------------------------------------

def make_net_worth_service(session):
    """Create a net worth snapshot service instance.
    
    Usage:
        from sqlalchemy.ext.asyncio import AsyncSession
        from datetime import datetime, timezone
        
        async with AsyncSession(engine) as session:
            service = make_net_worth_service(session)
            snapshot = await service.create_snapshot(
                user_id="u123",
                snapshot_date=datetime.now(timezone.utc),
                total_assets=100000,
                total_liabilities=50000
            )
    """
    from .${entity}_repository import ${Entity}Repository
    return ${Entity}Repository(session)
