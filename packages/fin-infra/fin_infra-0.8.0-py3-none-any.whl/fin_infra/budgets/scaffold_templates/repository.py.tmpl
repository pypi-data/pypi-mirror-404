from __future__ import annotations
"""Repository pattern for budget data access.

This module provides an async repository for budget CRUD operations,
following best practices for SQLAlchemy 2.0 async patterns.

Generated by: fin-infra scaffold budgets
"""
from typing import Optional, List, Dict, Any
from datetime import datetime
from uuid import UUID

from sqlalchemy import select, and_, or_, func
from sqlalchemy.ext.asyncio import AsyncSession

from .${table_name} import ${Entity} as ${Entity}Model


class ${Entity}Repository:
    """Async repository for budget data access.
    
    Provides CRUD operations and budget-specific queries with proper
    filtering, error handling, and type safety.
    
    Attributes:
        session: SQLAlchemy async session for database operations
    
    Example:
        >>> from sqlalchemy.ext.asyncio import AsyncSession
        >>> 
        >>> async def get_user_budgets(session: AsyncSession, user_id: str):
        ...     repo = ${Entity}Repository(session)
        ...     return await repo.list(user_id=user_id)
    """
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with async session.
        
        Args:
            session: SQLAlchemy AsyncSession for database operations
        """
        self.session = session
    
    async def create(self, budget_data: Dict[str, Any]) -> ${Entity}Model:
        """Create a new budget.
        
        Args:
            budget_data: Budget fields (user_id, name, type, period, categories, etc.)
        
        Returns:
            Created budget model instance
        
        Raises:
            IntegrityError: If unique constraint violated (duplicate user_id + name)
        
        Example:
            >>> budget = await repo.create({
            ...     "user_id": "user123",
            ...     "name": "November 2025",
            ...     "type": "personal",
            ...     "period": "monthly",
            ...     "categories": {"Groceries": 600.00},
            ...     "start_date": datetime(2025, 11, 1),
            ...     "end_date": datetime(2025, 11, 30),
            ... })
        """
        budget = ${Entity}Model(**budget_data)
        self.session.add(budget)
        await self.session.flush()
        await self.session.refresh(budget)
        return budget
    
    async def get(self, budget_id: UUID${tenant_arg_type}) -> Optional[${Entity}Model]:
        """Get budget by ID.
        
        Args:
            budget_id: Budget UUID
${tenant_doc}        
        Returns:
            Budget model or None if not found
        
        Example:
            >>> budget = await repo.get(UUID("123e4567-e89b-12d3-a456-426614174000"))
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == budget_id)
${tenant_filter}${soft_delete_filter}        
        result = await self.session.execute(stmt)
        return result.scalar_one_or_none()
    
    async def list(
        self,
        user_id: str,
        type: Optional[str] = None,
        period: Optional[str] = None,
        active_only: bool = True${tenant_arg_type_comma}
    ) -> List[${Entity}Model]:
        """List budgets for a user with optional filters.
        
        Args:
            user_id: User identifier
            type: Filter by budget type (personal, household, etc.)
            period: Filter by budget period (monthly, weekly, etc.)
            active_only: If True, only return budgets overlapping current date
${tenant_doc}        
        Returns:
            List of budget models
        
        Example:
            >>> # Get all monthly budgets
            >>> budgets = await repo.list(
            ...     user_id="user123",
            ...     type="personal",
            ...     period="monthly",
            ... )
            >>> 
            >>> # Get active budgets only
            >>> active = await repo.list(user_id="user123", active_only=True)
        """
        stmt = select(${Entity}Model).where(${Entity}Model.user_id == user_id)
        
        # Optional filters
        if type:
            stmt = stmt.where(${Entity}Model.type == type)
        if period:
            stmt = stmt.where(${Entity}Model.period == period)
        if active_only:
            now = datetime.utcnow()
            stmt = stmt.where(
                and_(
                    ${Entity}Model.start_date <= now,
                    ${Entity}Model.end_date >= now,
                )
            )
${tenant_filter}${soft_delete_filter}        
        # Order by most recent first
        stmt = stmt.order_by(${Entity}Model.start_date.desc())
        
        result = await self.session.execute(stmt)
        return list(result.scalars().all())
    
    async def get_by_period(
        self,
        user_id: str,
        start_date: datetime,
        end_date: datetime${tenant_arg_type_comma}
    ) -> List[${Entity}Model]:
        """Get budgets overlapping a date range.
        
        Args:
            user_id: User identifier
            start_date: Period start date
            end_date: Period end date
${tenant_doc}        
        Returns:
            List of budgets overlapping the date range
        
        Example:
            >>> # Get all budgets for November 2025
            >>> budgets = await repo.get_by_period(
            ...     user_id="user123",
            ...     start_date=datetime(2025, 11, 1),
            ...     end_date=datetime(2025, 11, 30),
            ... )
        """
        stmt = select(${Entity}Model).where(
            and_(
                ${Entity}Model.user_id == user_id,
                # Budget overlaps if: budget.start <= period.end AND budget.end >= period.start
                ${Entity}Model.start_date <= end_date,
                ${Entity}Model.end_date >= start_date,
            )
        )
${tenant_filter}${soft_delete_filter}        stmt = stmt.order_by(${Entity}Model.start_date.desc())
        
        result = await self.session.execute(stmt)
        return list(result.scalars().all())
    
    async def get_active(self, user_id: str${tenant_arg_type_comma}) -> List[${Entity}Model]:
        """Get budgets active right now.
        
        Args:
            user_id: User identifier
${tenant_doc}        
        Returns:
            List of budgets where current date is within [start_date, end_date]
        
        Example:
            >>> active_budgets = await repo.get_active("user123")
        """
        now = datetime.utcnow()
        return await self.get_by_period(user_id, now, now${tenant_arg_val})
    
    async def update(self, budget_id: UUID, updates: Dict[str, Any]${tenant_arg_type_comma}) -> ${Entity}Model:
        """Update budget fields.
        
        Args:
            budget_id: Budget UUID
            updates: Fields to update (partial updates supported)
${tenant_doc}        
        Returns:
            Updated budget model
        
        Raises:
            ValueError: If budget not found
        
        Example:
            >>> budget = await repo.update(
            ...     budget_id=UUID("123..."),
            ...     updates={"name": "December 2025", "rollover_enabled": True},
            ... )
        """
        budget = await self.get(budget_id${tenant_arg_val})
        if not budget:
            raise ValueError(f"Budget {budget_id} not found")
        
        for key, value in updates.items():
            if hasattr(budget, key):
                setattr(budget, key, value)
        
        await self.session.flush()
        await self.session.refresh(budget)
        return budget
    
    async def delete(self, budget_id: UUID${tenant_arg_type_comma}, soft: bool = ${soft_delete_default}) -> None:
        """Delete budget (soft or hard delete).
        
        Args:
            budget_id: Budget UUID
${tenant_doc}            soft: If True, set deleted_at timestamp; if False, permanently remove
        
        Raises:
            ValueError: If budget not found
        
        Example:
            >>> # Soft delete (if soft_delete enabled)
            >>> await repo.delete(budget_id=UUID("123..."), soft=True)
            >>> 
            >>> # Hard delete
            >>> await repo.delete(budget_id=UUID("123..."), soft=False)
        """
        budget = await self.get(budget_id${tenant_arg_val})
        if not budget:
            raise ValueError(f"Budget {budget_id} not found")
        
        if soft:
${soft_delete_logic}        else:
            await self.session.delete(budget)
        
        await self.session.flush()
    
    async def count(self, user_id: str${tenant_arg_type_comma}) -> int:
        """Count budgets for a user.
        
        Args:
            user_id: User identifier
${tenant_doc}        
        Returns:
            Number of budgets
        
        Example:
            >>> count = await repo.count("user123")
        """
        stmt = select(func.count()).select_from(${Entity}Model).where(${Entity}Model.user_id == user_id)
${tenant_filter}${soft_delete_filter}        
        result = await self.session.execute(stmt)
        return result.scalar_one()
    
    def _to_pydantic(self, db_budget: ${Entity}Model):
        """Convert SQLAlchemy model to Pydantic schema.
        
        Helper for converting database models to API response schemas.
        
        Args:
            db_budget: SQLAlchemy ${Entity}Model instance
        
        Returns:
            Pydantic ${Entity}Read instance (import from schemas)
        
        Example:
            >>> from .${table_name}_schemas import ${Entity}Read
            >>> budget_model = await repo.get(budget_id)
            >>> budget_schema = repo._to_pydantic(budget_model)
            >>> # Or use Pydantic directly:
            >>> budget_schema = ${Entity}Read.model_validate(budget_model)
        """
        # Import here to avoid circular dependency
        from .${table_name}_schemas import ${Entity}Read
        return ${Entity}Read.model_validate(db_budget)
