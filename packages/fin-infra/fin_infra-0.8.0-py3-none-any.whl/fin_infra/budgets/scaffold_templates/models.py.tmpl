# models/${table_name}.py
"""SQLAlchemy models for budget persistence.

This module defines the database model for budgets. It follows svc-infra's
ModelBase pattern for Alembic migration discovery.

Generated by: fin-infra scaffold budgets
"""
from __future__ import annotations

from typing import Any, Callable, Dict, Iterable, Optional, Sequence, Tuple, Union, TYPE_CHECKING
import uuid
from datetime import datetime

from sqlalchemy import String, Boolean, DateTime, JSON, Text, text
from svc_infra.db.sql.types import GUID
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy.ext.mutable import MutableDict

from svc_infra.db.sql.base import ModelBase
from svc_infra.db.sql.uniq import make_unique_sql_indexes
from svc_infra.db.sql.uniq_hooks import dedupe_sql_service

if TYPE_CHECKING:
    from svc_infra.db.sql.repository import SqlRepository

# ------------------------------ Model ------------------------------

class ${Entity}(ModelBase):
    """SQLAlchemy model for ${entity} persistence.
    
    Attributes:
        id: Primary key (UUID)
        user_id: User identifier (indexed)
        name: Budget name (e.g., "November 2025", "Q4 Marketing")
        type: Budget type (personal, household, business, project, custom)
        period: Budget period (weekly, biweekly, monthly, quarterly, yearly)
        categories: JSON mapping category names to budgeted amounts
        start_date: Budget period start date (timezone-aware)
        end_date: Budget period end date (timezone-aware)
        rollover_enabled: Whether unused budget carries over to next period
        extra: JSON field for additional metadata (extensible)
        created_at: Creation timestamp (DB-managed)
        updated_at: Last update timestamp (DB-managed)
    """
    __tablename__ = "${table_name}"

    # identity
    id: Mapped[uuid.UUID] = mapped_column(GUID(), primary_key=True, default=uuid.uuid4)

    # ownership (nullable for simple testing, set to False in production with authentication)
    user_id: Mapped[Optional[str]] = mapped_column(String(64), nullable=True, index=True)

    # core budget fields
    name: Mapped[str] = mapped_column(String(128), nullable=False, index=True)
    type: Mapped[str] = mapped_column(String(32), nullable=False)
    period: Mapped[str] = mapped_column(String(32), nullable=False)
    
    # budget allocations (JSON: {"Groceries": 600.00, "Rent": 2000.00})
    categories: Mapped[dict] = mapped_column(MutableDict.as_mutable(JSON), default=dict, nullable=False)
    
    # date range
    start_date: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
    end_date: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False, index=True)
    
    # configuration
    rollover_enabled: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)

${tenant_field}${soft_delete_field}    # extensible metadata
    extra: Mapped[dict] = mapped_column(MutableDict.as_mutable(JSON), default=dict)

    # auditing (DB-side timestamps)
    created_at = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        nullable=False
    )
    updated_at = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=text("CURRENT_TIMESTAMP"),
        nullable=False
    )

    def __repr__(self) -> str:
        return f"<${Entity} id={self.id} name={self.name!r} user_id={self.user_id!r}>"

# --- Uniqueness policy --------------------------------------------------------
# Budgets are unique by (user_id, name) or (tenant_id, user_id, name) if multi-tenant
for _ix in make_unique_sql_indexes(
    ${Entity},
    unique_ci=["user_id", "name"]${tenant_arg_unique_index}
):
    pass

# ----------------------- Service factory ---------------------------------------

PreHook = Callable[[Dict[str, Any]], Dict[str, Any]]
ColumnSpec = Union[str, Sequence[str]]

def _map_budget_fields(data: Dict[str, Any]) -> Dict[str, Any]:
    """Normalize budget payload for persistence.
    
    Transformations:
    - metadata (schema alias) -> extra (column)
    - normalize name (trim whitespace)
    - validate categories (ensure dict)
    """
    d = dict(data)
    
    # Map Pydantic field name to SQLAlchemy column name
    if "metadata" in d:
        d["extra"] = d.pop("metadata")
    
    # Normalize name
    if "name" in d and isinstance(d["name"], str):
        d["name"] = d["name"].strip()
    
    # Ensure categories is dict
    if "categories" in d and not isinstance(d["categories"], dict):
        d["categories"] = {}
    
    return d

def _compose(*hooks: Optional[PreHook]) -> PreHook:
    """Chain multiple pre-hooks left-to-right, skipping Nones."""
    def _runner(payload: Dict[str, Any]) -> Dict[str, Any]:
        out = payload
        for h in hooks:
            if h:
                out = h(out)
        return out
    return _runner

def create_budget_service(
    repo: "SqlRepository",
    *,
    # Uniqueness: (user_id, name) by default
    unique_ci: Iterable[ColumnSpec] = (("user_id", "name"),),
    tenant_field: Optional[str] = ${tenant_default},
    # Allow projects to extend behavior
    extra_pre_create: Optional[PreHook] = None,
    extra_pre_update: Optional[PreHook] = None,
    # Override 409 messages
    messages: Optional[dict[Tuple[str, ...], str]] = None,
):
    """Build a budget Service with deduplication and normalization.
    
    Features:
    - Normalizes payload (metadataâ†’extra, trims name, validates categories)
    - Enforces uniqueness on (user_id, name) case-insensitive
    - Returns 409 on duplicate: "Budget with user_id='user123' name='November 2025' already exists."
    - Accepts extra pre-hooks for project-specific validation
    
    Args:
        repo: SqlRepository instance for database operations
        unique_ci: Columns for case-insensitive uniqueness (default: (user_id, name))
        tenant_field: Tenant column name if multi-tenant (default: None)
        extra_pre_create: Additional pre-create validation hook
        extra_pre_update: Additional pre-update validation hook
        messages: Custom 409 error messages per unique constraint
    
    Returns:
        Service instance with create/update/delete methods
    
    Example:
        >>> from svc_infra.db.sql.repository import SqlRepository
        >>> repo = SqlRepository(session, ${Entity})
        >>> service = create_budget_service(repo)
        >>> 
        >>> # Create budget (will dedupe on user_id + name)
        >>> budget = await service.create({
        ...     "user_id": "user123",
        ...     "name": "November 2025",
        ...     "type": "personal",
        ...     "period": "monthly",
        ...     "categories": {"Groceries": 600.00},
        ...     "start_date": datetime(2025, 11, 1),
        ...     "end_date": datetime(2025, 11, 30),
        ... })
        >>> 
        >>> # Duplicate creation returns 409
        >>> await service.create({...})  # raises HTTPException(409)
    """
    if messages is None:
        messages = {
            ("user_id", "name"): "${Entity} with user_id='{user_id}' name='{name}' already exists."
        }
    
    pre_create = _compose(_map_budget_fields, extra_pre_create)
    pre_update = _compose(_map_budget_fields, extra_pre_update)

    return dedupe_sql_service(
        repo,
        unique_ci=unique_ci,
        tenant_field=tenant_field,
        messages=messages,
        pre_create=pre_create,
        pre_update=pre_update,
    )
