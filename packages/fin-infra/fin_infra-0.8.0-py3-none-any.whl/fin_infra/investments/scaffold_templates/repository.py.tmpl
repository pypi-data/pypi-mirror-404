"""
${Entity} repository pattern for database operations.

Auto-generated by fin-infra scaffold. Customize as needed.
"""
from datetime import date, datetime, timedelta, timezone
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import uuid4

from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from .${entity} import ${Entity} as ${Entity}Model
from .${entity}_schemas import ${Entity}Create, ${Entity}Read, ${Entity}Update


class ${Entity}Repository:
    """Repository for holding snapshot database operations.
    
    Provides async CRUD operations and time-series queries for investment holdings.
    Snapshots are mostly immutable (only notes field can be updated).
    All methods handle multi-tenancy and soft deletes automatically.
    
    Usage:
        async with AsyncSession(engine) as session:
            repo = ${Entity}Repository(session)
            snapshot = await repo.create(${Entity}Create(
                user_id="u123",
                snapshot_date=datetime.now(timezone.utc),
                total_value=Decimal("100000.00"),
                holdings_count=25,
                holdings_data={...}
            ))
    """
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with database session.
        
        Args:
            session: SQLAlchemy async session for database operations
        """
        self.session = session
    
    async def create(
        self,
        snapshot: ${Entity}Create${tenant_arg_type_comma},
    ) -> ${Entity}Read:
        """Create a new holding snapshot.
        
        Args:
            snapshot: Snapshot data to create${tenant_doc}
        
        Returns:
            Created snapshot with id and created_at timestamp
            
        Raises:
            IntegrityError: If snapshot for same (user_id, snapshot_date) already exists
        """
        # Map Pydantic to SQLAlchemy
        data = _map_snapshot_fields(snapshot.model_dump(exclude_unset=True, by_alias=True))
        data["id"] = str(uuid4())${tenant_dict_assign}
        
        db_snapshot = ${Entity}Model(**data)
        self.session.add(db_snapshot)
        await self.session.flush()
        await self.session.refresh(db_snapshot)
        
        return _to_pydantic(db_snapshot)
    
    async def get(
        self,
        snapshot_id: str${tenant_arg_type_comma},
    ) -> Optional[${Entity}Read]:
        """Get a snapshot by ID.
        
        Args:
            snapshot_id: Snapshot unique identifier${tenant_doc}
        
        Returns:
            Snapshot if found, None otherwise
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == snapshot_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        db_snapshot = result.scalar_one_or_none()
        
        return _to_pydantic(db_snapshot) if db_snapshot else None
    
    async def list(
        self,
        user_id: str${tenant_arg_type_comma},
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
    ) -> List[${Entity}Read]:
        """List snapshots for a user with optional date range filter.
        
        Args:
            user_id: User identifier${tenant_doc}
            start_date: Optional start date (inclusive)
            end_date: Optional end date (inclusive)
        
        Returns:
            List of snapshots, ordered by snapshot_date (newest first)
        """
        stmt = select(${Entity}Model).where(${Entity}Model.user_id == user_id)${tenant_filter}${soft_delete_filter}
        
        if start_date:
            stmt = stmt.where(${Entity}Model.snapshot_date >= start_date)
        if end_date:
            stmt = stmt.where(${Entity}Model.snapshot_date <= end_date)
        
        # Order by snapshot_date descending (newest first)
        stmt = stmt.order_by(${Entity}Model.snapshot_date.desc())
        
        result = await self.session.execute(stmt)
        db_snapshots = result.scalars().all()
        
        return [_to_pydantic(s) for s in db_snapshots]
    
    async def update(
        self,
        snapshot_id: str,
        update_data: ${Entity}Update${tenant_arg_type_comma},
    ) -> ${Entity}Read:
        """Update a snapshot (only notes field can be modified).
        
        All other snapshot fields are immutable. To correct data errors,
        delete the snapshot and create a new one.
        
        Args:
            snapshot_id: Snapshot unique identifier
            update_data: Update schema (only notes field)${tenant_doc}
        
        Returns:
            Updated snapshot
            
        Raises:
            ValueError: If snapshot not found
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == snapshot_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        db_snapshot = result.scalar_one_or_none()
        
        if not db_snapshot:
            raise ValueError(f"${Entity} not found: {snapshot_id}")
        
        # Only notes can be updated
        if update_data.notes is not None:
            db_snapshot.notes = update_data.notes
        
        await self.session.flush()
        await self.session.refresh(db_snapshot)
        
        return _to_pydantic(db_snapshot)
    
    async def delete(
        self,
        snapshot_id: str${tenant_arg_type_comma},
        soft: bool = ${soft_delete_default},
    ) -> None:
        """Delete a snapshot (for corrections only).
        
        Snapshots are immutable. Delete only to fix errors, then recreate.
        
        Args:
            snapshot_id: Snapshot unique identifier${tenant_doc}
            soft: If True, soft delete (set deleted_at). If False, hard delete.
        
        Raises:
            ValueError: If snapshot not found
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == snapshot_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        snapshot = result.scalar_one_or_none()
        
        if not snapshot:
            raise ValueError(f"${Entity} not found: {snapshot_id}")
        
        ${soft_delete_logic}
        await self.session.flush()
    
    # -------------------- Holdings-specific methods ------------------------
    
    async def get_latest(
        self,
        user_id: str${tenant_arg_type_comma},
    ) -> Optional[${Entity}Read]:
        """Get the most recent holdings snapshot for a user.
        
        Args:
            user_id: User identifier${tenant_doc}
        
        Returns:
            Most recent snapshot, or None if no snapshots exist
        """
        stmt = (
            select(${Entity}Model)
            .where(${Entity}Model.user_id == user_id)${tenant_filter}${soft_delete_filter}
            .order_by(${Entity}Model.snapshot_date.desc())
            .limit(1)
        )
        
        result = await self.session.execute(stmt)
        db_snapshot = result.scalar_one_or_none()
        
        return _to_pydantic(db_snapshot) if db_snapshot else None
    
    async def get_by_date(
        self,
        user_id: str,
        snapshot_date: date${tenant_arg_type_comma},
    ) -> Optional[${Entity}Read]:
        """Get holdings snapshot for a specific date.
        
        Args:
            user_id: User identifier
            snapshot_date: Exact date to query (date object)${tenant_doc}
        
        Returns:
            Snapshot for that date, or None if not found
        """
        # Convert date to datetime range (start of day to end of day)
        start_dt = datetime.combine(snapshot_date, datetime.min.time()).replace(tzinfo=timezone.utc)
        end_dt = datetime.combine(snapshot_date, datetime.max.time()).replace(tzinfo=timezone.utc)
        
        stmt = (
            select(${Entity}Model)
            .where(
                ${Entity}Model.user_id == user_id,
                ${Entity}Model.snapshot_date >= start_dt,
                ${Entity}Model.snapshot_date <= end_dt
            )${tenant_filter}${soft_delete_filter}
            .limit(1)
        )
        
        result = await self.session.execute(stmt)
        db_snapshot = result.scalar_one_or_none()
        
        return _to_pydantic(db_snapshot) if db_snapshot else None
    
    async def get_by_date_range(
        self,
        user_id: str,
        start_date: date,
        end_date: date${tenant_arg_type_comma},
    ) -> List[${Entity}Read]:
        """Get holdings snapshots within a date range (time series data).
        
        Args:
            user_id: User identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)${tenant_doc}
        
        Returns:
            List of snapshots in date range, ordered by date (oldest to newest)
        """
        start_dt = datetime.combine(start_date, datetime.min.time()).replace(tzinfo=timezone.utc)
        end_dt = datetime.combine(end_date, datetime.max.time()).replace(tzinfo=timezone.utc)
        
        stmt = (
            select(${Entity}Model)
            .where(
                ${Entity}Model.user_id == user_id,
                ${Entity}Model.snapshot_date >= start_dt,
                ${Entity}Model.snapshot_date <= end_dt
            )${tenant_filter}${soft_delete_filter}
            .order_by(${Entity}Model.snapshot_date.asc())  # Oldest to newest for time series
        )
        
        result = await self.session.execute(stmt)
        db_snapshots = result.scalars().all()
        
        return [_to_pydantic(s) for s in db_snapshots]
    
    async def get_trend(
        self,
        user_id: str${tenant_arg_type_comma},
        months: int = 12,
    ) -> List[${Entity}Read]:
        """Get holdings snapshots for the last N months (trend analysis).
        
        Args:
            user_id: User identifier${tenant_doc}
            months: Number of months to look back (default: 12)
        
        Returns:
            List of snapshots from last N months, ordered by date (oldest to newest)
        """
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=months * 30)  # Approximate months
        
        stmt = (
            select(${Entity}Model)
            .where(
                ${Entity}Model.user_id == user_id,
                ${Entity}Model.snapshot_date >= start_date
            )${tenant_filter}${soft_delete_filter}
            .order_by(${Entity}Model.snapshot_date.asc())
        )
        
        result = await self.session.execute(stmt)
        db_snapshots = result.scalars().all()
        
        return [_to_pydantic(s) for s in db_snapshots]
    
    async def calculate_performance(
        self,
        user_id: str,
        start_date: date,
        end_date: date${tenant_arg_type_comma},
    ) -> Dict[str, Any]:
        """Calculate portfolio performance metrics between two dates.
        
        Args:
            user_id: User identifier
            start_date: Start date for comparison
            end_date: End date for comparison${tenant_doc}
        
        Returns:
            Dict with performance metrics: {
                "start_value": Decimal,
                "end_value": Decimal,
                "absolute_return": Decimal,
                "percent_return": Decimal,
                "start_date": date,
                "end_date": date,
                "days": int,
                "annualized_return": Decimal (if > 1 year)
            }
        
        Raises:
            ValueError: If snapshots not found for start or end date
        """
        start_snapshot = await self.get_by_date(user_id, start_date${tenant_arg_val})
        end_snapshot = await self.get_by_date(user_id, end_date${tenant_arg_val})
        
        if not start_snapshot:
            raise ValueError(f"No snapshot found for start date: {start_date}")
        if not end_snapshot:
            raise ValueError(f"No snapshot found for end date: {end_date}")
        
        absolute_return = end_snapshot.total_value - start_snapshot.total_value
        
        if start_snapshot.total_value == 0:
            percent_return = Decimal("0.00")
        else:
            percent_return = (absolute_return / start_snapshot.total_value * 100).quantize(Decimal("0.01"))
        
        days_diff = (end_date - start_date).days
        
        result = {
            "start_value": start_snapshot.total_value,
            "end_value": end_snapshot.total_value,
            "absolute_return": absolute_return,
            "percent_return": percent_return,
            "start_date": start_date,
            "end_date": end_date,
            "days": days_diff
        }
        
        # Calculate annualized return if > 1 year
        if days_diff >= 365:
            years = Decimal(days_diff) / Decimal("365.25")
            if start_snapshot.total_value > 0:
                annualized = ((Decimal("1") + (percent_return / Decimal("100"))) ** (Decimal("1") / years) - Decimal("1")) * Decimal("100")
                result["annualized_return"] = annualized.quantize(Decimal("0.01"))
        
        return result


# ----------------------- Helper functions ---------------------------------------

def _map_snapshot_fields(data: Dict[str, Any]) -> Dict[str, Any]:
    """Normalize snapshot payload for persistence.
    
    Transformations:
    - metadata (schema alias) -> extra (column)
    """
    d = dict(data)
    
    # Map Pydantic field name to SQLAlchemy column name
    if "metadata" in d:
        d["extra"] = d.pop("metadata")
    
    return d


def _to_pydantic(db_snapshot: ${Entity}Model) -> ${Entity}Read:
    """Convert SQLAlchemy model to Pydantic schema.
    
    Args:
        db_snapshot: SQLAlchemy snapshot model instance
    
    Returns:
        Pydantic ${Entity}Read schema
    """
    data = {
        "id": db_snapshot.id,
        "user_id": db_snapshot.user_id,
        "snapshot_date": db_snapshot.snapshot_date,
        "total_value": db_snapshot.total_value,
        "total_cost_basis": db_snapshot.total_cost_basis,
        "total_unrealized_gain_loss": db_snapshot.total_unrealized_gain_loss,
        "holdings_count": db_snapshot.holdings_count,
        "holdings_data": db_snapshot.holdings_data,
        "provider": db_snapshot.provider,
        "provider_metadata": db_snapshot.provider_metadata,
        "notes": db_snapshot.notes,
        "extra": db_snapshot.extra,
        "created_at": db_snapshot.created_at,
    }
    
    return ${Entity}Read(**data)
