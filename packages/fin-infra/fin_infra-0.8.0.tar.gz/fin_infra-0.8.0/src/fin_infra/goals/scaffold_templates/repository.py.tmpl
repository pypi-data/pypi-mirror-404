"""
${Entity} repository pattern for database operations.

Auto-generated by fin-infra scaffold. Customize as needed.
"""
from datetime import datetime
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import uuid4

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from .${entity} import ${Entity} as ${Entity}Model
from .${entity}_schemas import ${Entity}Create, ${Entity}Read, ${Entity}Update


class ${Entity}Repository:
    """Repository for ${entity} database operations.
    
    Provides async CRUD operations and goal-specific queries.
    All methods handle multi-tenancy and soft deletes automatically.
    
    Usage:
        async with AsyncSession(engine) as session:
            repo = ${Entity}Repository(session)
            goal = await repo.create(${Entity}Create(
                user_id="u123",
                name="Emergency Fund",
                target_amount=10000,
                target_date=datetime(2025, 12, 31)
            ))
    """
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with database session.
        
        Args:
            session: SQLAlchemy async session for database operations
        """
        self.session = session
    
    async def create(
        self,
        ${entity}: ${Entity}Create${tenant_arg_type_comma},
    ) -> ${Entity}Read:
        """Create a new ${entity}.
        
        Args:
            ${entity}: ${Entity} data to create${tenant_doc}
        
        Returns:
            Created ${entity} with id and timestamps
            
        Raises:
            IntegrityError: If ${entity} with same (user_id, name) already exists
        """
        # Map Pydantic to SQLAlchemy
        data = _map_${entity}_fields(${entity}.model_dump(exclude_unset=True, by_alias=True))
        data["id"] = str(uuid4())${tenant_dict_assign}
        
        db_${entity} = ${Entity}Model(**data)
        self.session.add(db_${entity})
        await self.session.flush()
        await self.session.refresh(db_${entity})
        
        return _to_pydantic(db_${entity})
    
    async def get(
        self,
        ${entity}_id: str${tenant_arg_type_comma},
    ) -> Optional[${Entity}Read]:
        """Get a ${entity} by ID.
        
        Args:
            ${entity}_id: ${Entity} unique identifier${tenant_doc}
        
        Returns:
            ${Entity} if found, None otherwise
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == ${entity}_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        db_${entity} = result.scalar_one_or_none()
        
        return _to_pydantic(db_${entity}) if db_${entity} else None
    
    async def list(
        self${tenant_arg_type_comma},
        category: Optional[str] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[${Entity}Read]:
        """List ${entity}s for a user with optional filters.
        
        Args:
            user_id: User identifier
            status: Optional status filter (active, achieved, abandoned, paused)
            category: Optional category filter (emergency_fund, retirement, etc.)${tenant_doc}
        
        Returns:
            List of ${entity}s matching criteria, ordered by priority (highest first)
        """
        stmt = select(${Entity}Model).where(${Entity}Model.user_id == user_id)${tenant_filter}${soft_delete_filter}
        
        if status:
            stmt = stmt.where(${Entity}Model.status == status)
        if category:
            stmt = stmt.where(${Entity}Model.category == category)
        
        # Order by priority (1=highest), then target_date
        stmt = stmt.order_by(${Entity}Model.priority, ${Entity}Model.target_date)
        
        result = await self.session.execute(stmt)
        db_${entity}s = result.scalars().all()
        
        return [_to_pydantic(g) for g in db_${entity}s]
    
    async def update(
        self,
        ${entity}_id: str,
        updates: ${Entity}Update${tenant_arg_type_comma},
    ) -> ${Entity}Read:
        """Update a ${entity}.
        
        Args:
            ${entity}_id: ${Entity} unique identifier
            updates: Fields to update${tenant_doc}
        
        Returns:
            Updated ${entity}
            
        Raises:
            ValueError: If ${entity} not found
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == ${entity}_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        db_${entity} = result.scalar_one_or_none()
        
        if not db_${entity}:
            raise ValueError(f"${Entity} not found: {${entity}_id}")
        
        # Apply updates
        update_data = _map_${entity}_fields(updates.model_dump(exclude_unset=True, by_alias=True))
        for key, value in update_data.items():
            setattr(db_${entity}, key, value)
        
        await self.session.flush()
        await self.session.refresh(db_${entity})
        
        return _to_pydantic(db_${entity})
    
    async def delete(
        self,
        ${entity}_id: str${tenant_arg_type_comma},
        soft: bool = ${soft_delete_default},
    ) -> None:
        """Delete a ${entity}.
        
        Args:
            ${entity}_id: ${Entity} unique identifier${tenant_doc}
            soft: If True, soft delete (set deleted_at). If False, hard delete.
        
        Raises:
            ValueError: If ${entity} not found
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == ${entity}_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        ${entity} = result.scalar_one_or_none()
        
        if not ${entity}:
            raise ValueError(f"${Entity} not found: {${entity}_id}")
        
        ${soft_delete_logic}
        await self.session.flush()
    
    # -------------------- Goal-specific methods ------------------------
    
    async def get_active(
        self,
        user_id: str${tenant_arg_type_comma},
    ) -> List[${Entity}Read]:
        """Get all active ${entity}s for a user.
        
        Args:
            user_id: User identifier${tenant_doc}
        
        Returns:
            List of active ${entity}s, ordered by priority
        """
        return await self.list(user_id, status="active"${tenant_arg_val})
    
    async def get_by_status(
        self,
        status: str${tenant_arg_type_comma},
    ) -> List[${Entity}Read]:
        """Get ${entity}s by status.
        
        Args:
            user_id: User identifier
            status: ${Entity} status (active, achieved, abandoned, paused)${tenant_doc}
        
        Returns:
            List of ${entity}s with matching status
        """
        return await self.list(user_id, status=status${tenant_arg_val})
    
    async def get_by_priority(
        self${tenant_arg_type_comma},
        min_priority: int = 1,
        max_priority: Optional[int] = None,
    ) -> List[${Entity}Read]:
        """Get ${entity}s with priority >= min_priority.
        
        Args:
            user_id: User identifier
            min_priority: Minimum priority level (1=highest)${tenant_doc}
        
        Returns:
            List of high-priority ${entity}s
        """
        stmt = select(${Entity}Model).where(
            ${Entity}Model.user_id == user_id,
            ${Entity}Model.priority <= min_priority  # Lower number = higher priority
        )${tenant_filter}${soft_delete_filter}
        
        stmt = stmt.order_by(${Entity}Model.priority, ${Entity}Model.target_date)
        
        result = await self.session.execute(stmt)
        db_${entity}s = result.scalars().all()
        
        return [_to_pydantic(g) for g in db_${entity}s]
    
    async def update_progress(
        self,
        ${entity}_id: str,
        new_amount: Decimal${tenant_arg_type_comma},
    ) -> ${Entity}Read:
        """Update goal progress (current_amount).
        
        Convenience method for updating progress without needing full ${Entity}Update schema.
        Automatically updates status to 'achieved' if target reached.
        
        Args:
            ${entity}_id: ${Entity} unique identifier
            new_amount: New current_amount value${tenant_doc}
        
        Returns:
            Updated ${entity}
            
        Raises:
            ValueError: If ${entity} not found or new_amount < 0
        """
        if new_amount < 0:
            raise ValueError("Progress amount cannot be negative")
        
        stmt = select(${Entity}Model).where(${Entity}Model.id == ${entity}_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        db_${entity} = result.scalar_one_or_none()
        
        if not db_${entity}:
            raise ValueError(f"${Entity} not found: {${entity}_id}")
        
        db_${entity}.current_amount = new_amount
        
        # Auto-update status if target reached
        if new_amount >= db_${entity}.target_amount and db_${entity}.status == "active":
            db_${entity}.status = "achieved"
        
        await self.session.flush()
        await self.session.refresh(db_${entity})
        
        return _to_pydantic(db_${entity})


# ----------------------- Helper functions ---------------------------------------

def _map_${entity}_fields(data: Dict[str, Any]) -> Dict[str, Any]:
    """Normalize ${entity} payload for persistence.
    
    Transformations:
    - metadata (schema alias) -> extra (column)
    - normalize name (trim whitespace)
    """
    d = dict(data)
    
    # Map Pydantic field name to SQLAlchemy column name
    if "metadata" in d:
        d["extra"] = d.pop("metadata")
    
    # Normalize name
    if "name" in d and isinstance(d["name"], str):
        d["name"] = d["name"].strip()
    
    return d


def _to_pydantic(db_${entity}: ${Entity}Model) -> ${Entity}Read:
    """Convert SQLAlchemy model to Pydantic schema.
    
    Args:
        db_${entity}: SQLAlchemy ${entity} model instance
    
    Returns:
        Pydantic ${Entity}Read schema with computed fields
    """
    # Convert to dict and add computed fields
    data = {
        "id": db_${entity}.id,
        "user_id": db_${entity}.user_id,
        "name": db_${entity}.name,
        "description": db_${entity}.description,
        "target_amount": db_${entity}.target_amount,
        "current_amount": db_${entity}.current_amount,
        "target_date": db_${entity}.target_date,
        "status": db_${entity}.status,
        "priority": db_${entity}.priority,
        "category": db_${entity}.category,
        "extra": db_${entity}.extra,
        "milestones": db_${entity}.milestones,
        "created_at": db_${entity}.created_at,
        "updated_at": db_${entity}.updated_at,
        "percent_complete": db_${entity}.percent_complete,
    }
    
    return ${Entity}Read(**data)
