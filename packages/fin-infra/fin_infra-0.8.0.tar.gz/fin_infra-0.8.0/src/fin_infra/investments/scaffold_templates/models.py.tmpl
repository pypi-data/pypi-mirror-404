"""
${Entity} model (SQLAlchemy ORM).

Auto-generated by fin-infra scaffold. Customize as needed.
"""
from datetime import datetime, timezone
from decimal import Decimal
from typing import Any, Dict, Optional
from uuid import uuid4

from sqlalchemy import DateTime, Index, Integer, Numeric, String, Text, text
from sqlalchemy.dialects.postgresql import JSON
from sqlalchemy.ext.mutable import MutableDict
from sqlalchemy.orm import Mapped, mapped_column

from svc_infra.db.sql.base import ModelBase
from svc_infra.db.sql.types import GUID
from svc_infra.db.sql.uniq import make_unique_sql_indexes


class ${Entity}(ModelBase):
    """Investment holdings snapshot model for historical tracking.
    
    Captures periodic snapshots of user's investment holdings from providers like Plaid or SnapTrade.
    Immutable snapshots enable performance analysis, trend tracking, and historical portfolio views.
    
    Real-time data: Use investment provider API endpoints (e.g., /v0/investments/holdings)
    Historical data: Query this table for snapshots over time
    
    Attributes:
        id: Unique snapshot identifier (UUID)
        user_id: User who owns this snapshot
        snapshot_date: Date/time when snapshot was taken (timezone-aware)
        total_value: Total portfolio value at snapshot time
        total_cost_basis: Total cost basis (if available from provider)
        total_unrealized_gain_loss: Total unrealized profit/loss
        holdings_count: Number of holdings in snapshot
        holdings_data: Complete holdings data from provider (JSON)
        provider: Provider source (plaid, snaptrade, etc.)
        provider_metadata: Provider-specific metadata (JSON)
        notes: Optional user notes about this snapshot
        created_at: When snapshot record was created${tenant_doc}
        
    Note: Snapshots are immutable. To correct errors, delete and recreate.
    """
    __tablename__ = "${table_name}"

    # Primary key
    id: Mapped[str] = mapped_column(
        GUID(),
        primary_key=True,
        default=uuid4,
        doc="Unique snapshot identifier"
    )

    # Core fields (user_id nullable for simple testing, set to False in production)
    user_id: Mapped[Optional[str]] = mapped_column(
        String(64),
        nullable=True,
        index=True,
        doc="User who owns this snapshot"
    )
    
    snapshot_date: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        index=True,
        default=lambda: datetime.now(timezone.utc),
        doc="Date/time when snapshot was taken (timezone-aware)"
    )
    
    # Aggregated metrics (for quick queries without parsing JSON)
    total_value: Mapped[Decimal] = mapped_column(
        Numeric(15, 2),
        nullable=False,
        doc="Total portfolio value at snapshot time"
    )
    
    total_cost_basis: Mapped[Optional[Decimal]] = mapped_column(
        Numeric(15, 2),
        nullable=True,
        doc="Total cost basis (if available from provider)"
    )
    
    total_unrealized_gain_loss: Mapped[Optional[Decimal]] = mapped_column(
        Numeric(15, 2),
        nullable=True,
        doc="Total unrealized profit/loss"
    )
    
    holdings_count: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        doc="Number of holdings in snapshot"
    )
    
    # Full holdings data (JSON from provider)
    holdings_data: Mapped[Dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        doc="Complete holdings data from investment provider API"
    )
    
    # Provider metadata
    provider: Mapped[str] = mapped_column(
        String(50),
        nullable=False,
        default="plaid",
        doc="Provider source (plaid, snaptrade, etc.)"
    )
    
    provider_metadata: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        JSON,
        nullable=True,
        doc="Provider-specific metadata (account IDs, sync status, etc.)"
    )
    
    # Notes (optional)
    notes: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True,
        doc="Optional user notes about this snapshot"
    )
    
    extra: Mapped[Optional[Dict[str, Any]]] = mapped_column(
        MutableDict.as_mutable(JSON),
        nullable=True,
        doc="Additional snapshot metadata (JSON)"
    )
${tenant_field}
    # Timestamp (created_at only - snapshots are immutable, no updated_at)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        nullable=False
    )

    def __repr__(self) -> str:
        return f"<${Entity} id={self.id} user_id={self.user_id!r} date={self.snapshot_date.date()} value={self.total_value}>"


# --- Uniqueness policy --------------------------------------------------------
# One snapshot per user per day: (user_id, snapshot_date) or (tenant_id, user_id, snapshot_date)
for _ix in make_unique_sql_indexes(
    ${Entity},
    unique_cs=["user_id", "snapshot_date"]${tenant_arg_unique_index}
):
    pass

# ----------------------- Service factory ---------------------------------------

def create_holding_snapshot_service(session):
    """Create a holding snapshot service instance.
    
    Usage:
        from sqlalchemy.ext.asyncio import AsyncSession
        from datetime import datetime, timezone
        
        async with AsyncSession(engine) as session:
            service = create_holding_snapshot_service(session)
            snapshot = await service.create_snapshot(
                user_id="u123",
                snapshot_date=datetime.now(timezone.utc),
                total_value=Decimal("100000.00"),
                holdings_count=25,
                holdings_data=[...]
            )
    """
    from .${entity}_repository import ${Entity}Repository
    return ${Entity}Repository(session)
