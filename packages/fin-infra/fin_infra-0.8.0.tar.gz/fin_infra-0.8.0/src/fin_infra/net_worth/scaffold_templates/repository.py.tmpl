"""
${Entity} repository pattern for database operations.

Auto-generated by fin-infra scaffold. Customize as needed.
"""
from datetime import date, datetime, timedelta, timezone
from decimal import Decimal
from typing import Any, Dict, List, Optional
from uuid import uuid4

from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from .${entity} import ${Entity} as ${Entity}Model
from .${entity}_schemas import ${Entity}Create, ${Entity}Read


class ${Entity}Repository:
    """Repository for net worth snapshot database operations.
    
    Provides async CRUD operations and time-series queries.
    Note: Snapshots are immutable - no update operation exists.
    All methods handle multi-tenancy and soft deletes automatically.
    
    Usage:
        async with AsyncSession(engine) as session:
            repo = ${Entity}Repository(session)
            snapshot = await repo.create(${Entity}Create(
                user_id="u123",
                snapshot_date=datetime.now(timezone.utc),
                total_assets=Decimal("100000.00"),
                total_liabilities=Decimal("50000.00"),
                net_worth=Decimal("50000.00")
            ))
    """
    
    def __init__(self, session: AsyncSession):
        """Initialize repository with database session.
        
        Args:
            session: SQLAlchemy async session for database operations
        """
        self.session = session
    
    async def create(
        self,
        snapshot: ${Entity}Create${tenant_arg_type_comma},
    ) -> ${Entity}Read:
        """Create a new net worth snapshot.
        
        Args:
            snapshot: Snapshot data to create${tenant_doc}
        
        Returns:
            Created snapshot with id and created_at timestamp
            
        Raises:
            IntegrityError: If snapshot for same (user_id, snapshot_date) already exists
        """
        # Map Pydantic to SQLAlchemy
        data = _map_snapshot_fields(snapshot.model_dump(exclude_unset=True, by_alias=True))
        data["id"] = str(uuid4())${tenant_dict_assign}
        
        db_snapshot = ${Entity}Model(**data)
        self.session.add(db_snapshot)
        await self.session.flush()
        await self.session.refresh(db_snapshot)
        
        return _to_pydantic(db_snapshot)
    
    async def get(
        self,
        snapshot_id: str${tenant_arg_type_comma},
    ) -> Optional[${Entity}Read]:
        """Get a snapshot by ID.
        
        Args:
            snapshot_id: Snapshot unique identifier${tenant_doc}
        
        Returns:
            Snapshot if found, None otherwise
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == snapshot_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        db_snapshot = result.scalar_one_or_none()
        
        return _to_pydantic(db_snapshot) if db_snapshot else None
    
    async def list(
        self,
        user_id: str${tenant_arg_type_comma},
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
    ) -> List[${Entity}Read]:
        """List snapshots for a user with optional date range filter.
        
        Args:
            user_id: User identifier${tenant_doc}
            start_date: Optional start date (inclusive)
            end_date: Optional end date (inclusive)
        
        Returns:
            List of snapshots, ordered by snapshot_date (newest first)
        """
        stmt = select(${Entity}Model).where(${Entity}Model.user_id == user_id)${tenant_filter}${soft_delete_filter}
        
        if start_date:
            stmt = stmt.where(${Entity}Model.snapshot_date >= start_date)
        if end_date:
            stmt = stmt.where(${Entity}Model.snapshot_date <= end_date)
        
        # Order by snapshot_date descending (newest first)
        stmt = stmt.order_by(${Entity}Model.snapshot_date.desc())
        
        result = await self.session.execute(stmt)
        db_snapshots = result.scalars().all()
        
        return [_to_pydantic(s) for s in db_snapshots]
    
    async def delete(
        self,
        snapshot_id: str${tenant_arg_type_comma},
        soft: bool = ${soft_delete_default},
    ) -> None:
        """Delete a snapshot (for corrections only).
        
        Snapshots are immutable. Delete only to fix errors, then recreate.
        
        Args:
            snapshot_id: Snapshot unique identifier${tenant_doc}
            soft: If True, soft delete (set deleted_at). If False, hard delete.
        
        Raises:
            ValueError: If snapshot not found
        """
        stmt = select(${Entity}Model).where(${Entity}Model.id == snapshot_id)${tenant_filter}${soft_delete_filter}
        
        result = await self.session.execute(stmt)
        snapshot = result.scalar_one_or_none()
        
        if not snapshot:
            raise ValueError(f"${Entity} not found: {snapshot_id}")
        
        ${soft_delete_logic}
        await self.session.flush()
    
    # -------------------- Net Worth-specific methods ------------------------
    
    async def get_latest(
        self,
        user_id: str${tenant_arg_type_comma},
    ) -> Optional[${Entity}Read]:
        """Get the most recent snapshot for a user.
        
        Args:
            user_id: User identifier${tenant_doc}
        
        Returns:
            Most recent snapshot, or None if no snapshots exist
        """
        stmt = (
            select(${Entity}Model)
            .where(${Entity}Model.user_id == user_id)${tenant_filter}${soft_delete_filter}
            .order_by(${Entity}Model.snapshot_date.desc())
            .limit(1)
        )
        
        result = await self.session.execute(stmt)
        db_snapshot = result.scalar_one_or_none()
        
        return _to_pydantic(db_snapshot) if db_snapshot else None
    
    async def get_by_date(
        self,
        user_id: str,
        snapshot_date: date${tenant_arg_type_comma},
    ) -> Optional[${Entity}Read]:
        """Get snapshot for a specific date.
        
        Args:
            user_id: User identifier
            snapshot_date: Exact date to query (date object)${tenant_doc}
        
        Returns:
            Snapshot for that date, or None if not found
        """
        # Convert date to datetime range (start of day to end of day)
        start_dt = datetime.combine(snapshot_date, datetime.min.time()).replace(tzinfo=timezone.utc)
        end_dt = datetime.combine(snapshot_date, datetime.max.time()).replace(tzinfo=timezone.utc)
        
        stmt = (
            select(${Entity}Model)
            .where(
                ${Entity}Model.user_id == user_id,
                ${Entity}Model.snapshot_date >= start_dt,
                ${Entity}Model.snapshot_date <= end_dt
            )${tenant_filter}${soft_delete_filter}
            .limit(1)
        )
        
        result = await self.session.execute(stmt)
        db_snapshot = result.scalar_one_or_none()
        
        return _to_pydantic(db_snapshot) if db_snapshot else None
    
    async def get_by_date_range(
        self,
        user_id: str,
        start_date: date,
        end_date: date${tenant_arg_type_comma},
    ) -> List[${Entity}Read]:
        """Get snapshots within a date range (time series data).
        
        Args:
            user_id: User identifier
            start_date: Start date (inclusive)
            end_date: End date (inclusive)${tenant_doc}
        
        Returns:
            List of snapshots in date range, ordered by date (oldest to newest)
        """
        start_dt = datetime.combine(start_date, datetime.min.time()).replace(tzinfo=timezone.utc)
        end_dt = datetime.combine(end_date, datetime.max.time()).replace(tzinfo=timezone.utc)
        
        stmt = (
            select(${Entity}Model)
            .where(
                ${Entity}Model.user_id == user_id,
                ${Entity}Model.snapshot_date >= start_dt,
                ${Entity}Model.snapshot_date <= end_dt
            )${tenant_filter}${soft_delete_filter}
            .order_by(${Entity}Model.snapshot_date.asc())  # Oldest to newest for time series
        )
        
        result = await self.session.execute(stmt)
        db_snapshots = result.scalars().all()
        
        return [_to_pydantic(s) for s in db_snapshots]
    
    async def get_trend(
        self,
        user_id: str${tenant_arg_type_comma},
        months: int = 12,
    ) -> List[${Entity}Read]:
        """Get snapshots for the last N months (trend analysis).
        
        Args:
            user_id: User identifier${tenant_doc}
            months: Number of months to look back (default: 12)
        
        Returns:
            List of snapshots from last N months, ordered by date (oldest to newest)
        """
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=months * 30)  # Approximate months
        
        stmt = (
            select(${Entity}Model)
            .where(
                ${Entity}Model.user_id == user_id,
                ${Entity}Model.snapshot_date >= start_date
            )${tenant_filter}${soft_delete_filter}
            .order_by(${Entity}Model.snapshot_date.asc())
        )
        
        result = await self.session.execute(stmt)
        db_snapshots = result.scalars().all()
        
        return [_to_pydantic(s) for s in db_snapshots]
    
    async def calculate_growth(
        self,
        user_id: str,
        start_date: date,
        end_date: date${tenant_arg_type_comma},
    ) -> Dict[str, Any]:
        """Calculate net worth growth metrics between two dates.
        
        Args:
            user_id: User identifier
            start_date: Start date for comparison
            end_date: End date for comparison${tenant_doc}
        
        Returns:
            Dict with growth metrics: {
                "start_net_worth": Decimal,
                "end_net_worth": Decimal,
                "absolute_growth": Decimal,
                "percent_growth": Decimal,
                "start_date": date,
                "end_date": date,
                "days": int
            }
        
        Raises:
            ValueError: If snapshots not found for start or end date
        """
        start_snapshot = await self.get_by_date(user_id, start_date${tenant_arg_val})
        end_snapshot = await self.get_by_date(user_id, end_date${tenant_arg_val})
        
        if not start_snapshot:
            raise ValueError(f"No snapshot found for start date: {start_date}")
        if not end_snapshot:
            raise ValueError(f"No snapshot found for end date: {end_date}")
        
        absolute_growth = end_snapshot.net_worth - start_snapshot.net_worth
        
        if start_snapshot.net_worth == 0:
            percent_growth = Decimal("0.00")
        else:
            percent_growth = (absolute_growth / start_snapshot.net_worth * 100).quantize(Decimal("0.01"))
        
        days_diff = (end_date - start_date).days
        
        return {
            "start_net_worth": start_snapshot.net_worth,
            "end_net_worth": end_snapshot.net_worth,
            "absolute_growth": absolute_growth,
            "percent_growth": percent_growth,
            "start_date": start_date,
            "end_date": end_date,
            "days": days_diff
        }


# ----------------------- Helper functions ---------------------------------------

def _map_snapshot_fields(data: Dict[str, Any]) -> Dict[str, Any]:
    """Normalize snapshot payload for persistence.
    
    Transformations:
    - metadata (schema alias) -> extra (column)
    """
    d = dict(data)
    
    # Map Pydantic field name to SQLAlchemy column name
    if "metadata" in d:
        d["extra"] = d.pop("metadata")
    
    return d


def _to_pydantic(db_snapshot: ${Entity}Model) -> ${Entity}Read:
    """Convert SQLAlchemy model to Pydantic schema.
    
    Args:
        db_snapshot: SQLAlchemy snapshot model instance
    
    Returns:
        Pydantic ${Entity}Read schema
    """
    data = {
        "id": db_snapshot.id,
        "user_id": db_snapshot.user_id,
        "snapshot_date": db_snapshot.snapshot_date,
        "total_assets": db_snapshot.total_assets,
        "total_liabilities": db_snapshot.total_liabilities,
        "net_worth": db_snapshot.net_worth,
        "liquid_net_worth": db_snapshot.liquid_net_worth,
        "accounts_data": db_snapshot.accounts_data,
        "asset_breakdown": db_snapshot.asset_breakdown,
        "liability_breakdown": db_snapshot.liability_breakdown,
        "extra": db_snapshot.extra,
        "created_at": db_snapshot.created_at,
    }
    
    return ${Entity}Read(**data)
