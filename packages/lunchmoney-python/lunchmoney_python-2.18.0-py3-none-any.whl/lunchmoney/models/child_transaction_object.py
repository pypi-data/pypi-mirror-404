# coding: utf-8

"""
    Lunch Money API - v2

    Welcome to the Lunch Money v2 API.  A working version of this API is now available through these docs, or directly at:  `https://api.lunchmoney.dev/v2`  <span class=\"red-text\"><strong>This is in alpha launch of a major API update. It is still subject to change during this alpha review period and bugs may still exist. Users are strongly encouraged to use the mock service or to create a test budget with example data as the first step to interacting with the v2 API.</strong></span> See the [Getting Started Guide](https://alpha.lunchmoney.dev/v2/getting-started) for more information on using a test budget.<br<br>  If you are new to the v2 API, you may wish to review the [v2 API Overview of Changes](https://alpha.lunchmoney.dev/v2/changelog).  ### Static Mock Server  You may also use these docs to explore the API using a static mock server endpoint.<p> This enables users to become familiar with the API without having to create an access token, and eliminates the possibility of modifying real data. <p> To access this endpoint select the second endpoint in the the \"Server\" dropdown to the right. When selected you should see \"Static Mock v2 Lunch Money API Server\".<br> When using this server, set your Bearer token to any string with 11 or more characters.  ### Migrating from V1  The v2 API is NOT backwards compatible with the v1 API. Developers are encouraged to review the [Migration Guide](https://alpha.lunchmoney.dev/v2/migration-guide) to understand the changes and plan their migration.  ### Acknowledgments  If you have been providing feedback on the API during our iterative design process, **THANK YOU**. We are happy to provide the opportunity to finally interact with the working API that was built based on your feedback.  ### Useful links: - [Getting Started](https://alpha.lunchmoney.dev/v2/getting-started) - [v2 API Changelog](https://alpha.lunchmoney.dev/v2/changelog) - [Migration Guide](https://alpha.lunchmoney.dev/v2/migration-guide) - [Rate Limits](https://alpha.lunchmoney.dev/v2/rate-limits) - [Current v1 Lunch Money API Documentation](https://lunchmoney.dev) - [Awesome Lunch Money Projects](https://github.com/lunch-money/awesome-lunchmoney?tab=readme-ov-file)

    The version of the OpenAPI document: 2.8.4
    Contact: devsupport@lunchmoney.app
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from lunchmoney.models.currency_enum import CurrencyEnum
from lunchmoney.models.transaction_attachment_object import TransactionAttachmentObject
from typing import Optional, Set
from typing_extensions import Self

class ChildTransactionObject(BaseModel):
    """
    ChildTransactionObject
    """ # noqa: E501
    id: StrictInt = Field(description="System created unique identifier for transaction")
    var_date: date = Field(description="Date of transaction in ISO 8601 format", alias="date")
    amount: StrictStr = Field(description="Amount of the transaction in numeric format to 4 decimal places. Positive values indicate a debit transaction, negative values indicate a credit transaction.")
    currency: CurrencyEnum = Field(description="Three-letter lowercase currency code of the transaction in ISO 4217 format")
    to_base: Union[StrictFloat, StrictInt] = Field(description="The amount converted to the user's primary currency. If the transaction currency is the same as the user's primary currency, to_base and amount will be the same. Positive values indicate a debit transaction, negative values indicate a credit transaction.")
    recurring_id: Optional[StrictInt] = Field(description="The unique identifier of the associated recurring item that this transaction matched.")
    payee: Annotated[str, Field(min_length=0, strict=True, max_length=140)] = Field(description="Name of payee set by the user, the financial institution, or by a matched recurring item. This will match the value displayed in payee field on the transactions page in the GUI. ")
    category_id: Optional[StrictInt] = Field(description="Unique identifier of associated category set by the user or by a matched recurring item.<br> Category details can be obtained by passing the value of this property to the [Get A Single Category](../operations/getCategoryById) API")
    notes: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=350)]] = Field(description="Any transaction notes set by the user or by a matched recurring item. This will match the value displayed in notes field on the transactions page in the GUI. ")
    status: StrictStr = Field(description="Status of the transaction.  Will be one of the following values: ")
    is_pending: StrictBool = Field(description="Denotes if the transaction is pending (not posted). Applies only to transactions in synced accounts and will always be false for transactions associated with manual accounts.")
    created_at: datetime = Field(description="The date and time of when the transaction was created (in the ISO 8601 extended format).")
    updated_at: datetime = Field(description="The date and time of when the transaction was last updated (in the ISO 8601 extended format).")
    is_split_parent: Optional[StrictBool] = Field(default=None, description="If true this transaction has been split into two or more other transactions. By default parent transactions are not returned in call to `GET /transactions` but they can be queried directly by their ID.")
    split_parent_id: Optional[StrictInt] = Field(description="A transaction ID if this is a split transaction. Denotes the transaction ID of the original, or parent, transaction. Is null if this is not a split transaction")
    is_group_parent: StrictBool = Field(description="True if this transaction represents a group of transactions. If so, amount and currency represent the totalled amount of transactions bearing this transaction's id as their group_parent_id. Amount is calculated based on the user's primary currency.")
    group_parent_id: Optional[StrictInt] = Field(description="Is set if this transaction is part of a group. Denotes the ID of the grouped transaction this is now included in. By default the transactions that were grouped are not returned in a call to `GET /transactions` but they can be queried directly by calling the `GET /transactions/group/{id}`, where the id passed is associated with a transaction where the `is_group_parent` attribute is true")
    manual_account_id: Optional[StrictInt] = Field(description="The unique identifier of the manual account associated with this transaction. This will always be null if this transaction is associated with a synced account or if this transaction has no associated account and appears as a \"Cash Transaction\" in the Lunch Money GUI.")
    plaid_account_id: Optional[StrictInt] = Field(description="The unique identifier of the plaid account associated with this transaction. This will always be null if this transaction is associated with a manual account or if this transaction has no associated account and appears as a \"Cash Transaction\" in the Lunch Money GUI.")
    tag_ids: List[StrictInt] = Field(description="A list of tag_ids for the tags associated with this transaction. If the transaction has no tags this will be an empty list.<br> Tag details can be obtained by passing the value of this attribute as the `ids` query parameter to the [List Tags](../operations/getTags) API")
    source: Optional[StrictStr] = Field(description="Source of the transaction: - `api`: Transaction was added by a call to the [POST /transactions](../operations/createTransaction) API - `csv`: Transaction was added via a CSV Import - `manual`: Transaction was created via the \"Add to Cash\" button on the Transactions page - `merge`: Transactions were originally in an account that was merged into another account - `plaid`: Transaction came from a Financial Institution synced via Plaid - `recurring`: Transaction was created from the Recurring page - `rule`: Transaction was created by a rule to split a transaction - `split`: This is a transaction created by splitting another transaction - `user`: This is a legacy value and is replaced by either csv or manual ")
    external_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=75)]] = Field(description="A user-defined external ID for any transaction that was added via csv import, `POST /transactions` API call, or manually added via the Lunch Money GUI. No external ID exists for transactions associated with synced accounts, and they cannot be added. For transactions associated with manual accounts, the external ID must be unique as attempts to add a subsequent transaction with the same external_id and manual_account_id will be flagged as duplicates and fail.")
    plaid_metadata: Optional[Dict[str, Any]] = Field(default=None, description="If requested, the transaction's plaid_metadata that came when this transaction was obtained. This will be a json object, but the schema is variable. This will only be present for transactions associated with a plaid account.")
    custom_metadata: Optional[Dict[str, Any]] = Field(default=None, description="If requested, the transaction's custom_metadata that was included when the transaction was inserted via the API. This will be a json object, but the schema is variable.")
    files: Optional[List[TransactionAttachmentObject]] = Field(default=None, description="A list of objects that describe any attachments to the transaction")
    __properties: ClassVar[List[str]] = ["id", "date", "amount", "currency", "to_base", "recurring_id", "payee", "category_id", "notes", "status", "is_pending", "created_at", "updated_at", "is_split_parent", "split_parent_id", "is_group_parent", "group_parent_id", "manual_account_id", "plaid_account_id", "tag_ids", "source", "external_id", "plaid_metadata", "custom_metadata", "files"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['reviewed', 'unreviewed', 'delete_pending']):
            raise ValueError("must be one of enum values ('reviewed', 'unreviewed', 'delete_pending')")
        return value

    @field_validator('source')
    def source_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['api', 'csv', 'manual', 'merge', 'plaid', 'recurring', 'rule', 'split', 'user']):
            raise ValueError("must be one of enum values ('api', 'csv', 'manual', 'merge', 'plaid', 'recurring', 'rule', 'split', 'user')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ChildTransactionObject from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in files (list)
        _items = []
        if self.files:
            for _item_files in self.files:
                if _item_files:
                    _items.append(_item_files.to_dict())
            _dict['files'] = _items
        # set to None if recurring_id (nullable) is None
        # and model_fields_set contains the field
        if self.recurring_id is None and "recurring_id" in self.model_fields_set:
            _dict['recurring_id'] = None

        # set to None if category_id (nullable) is None
        # and model_fields_set contains the field
        if self.category_id is None and "category_id" in self.model_fields_set:
            _dict['category_id'] = None

        # set to None if notes (nullable) is None
        # and model_fields_set contains the field
        if self.notes is None and "notes" in self.model_fields_set:
            _dict['notes'] = None

        # set to None if split_parent_id (nullable) is None
        # and model_fields_set contains the field
        if self.split_parent_id is None and "split_parent_id" in self.model_fields_set:
            _dict['split_parent_id'] = None

        # set to None if group_parent_id (nullable) is None
        # and model_fields_set contains the field
        if self.group_parent_id is None and "group_parent_id" in self.model_fields_set:
            _dict['group_parent_id'] = None

        # set to None if manual_account_id (nullable) is None
        # and model_fields_set contains the field
        if self.manual_account_id is None and "manual_account_id" in self.model_fields_set:
            _dict['manual_account_id'] = None

        # set to None if plaid_account_id (nullable) is None
        # and model_fields_set contains the field
        if self.plaid_account_id is None and "plaid_account_id" in self.model_fields_set:
            _dict['plaid_account_id'] = None

        # set to None if source (nullable) is None
        # and model_fields_set contains the field
        if self.source is None and "source" in self.model_fields_set:
            _dict['source'] = None

        # set to None if external_id (nullable) is None
        # and model_fields_set contains the field
        if self.external_id is None and "external_id" in self.model_fields_set:
            _dict['external_id'] = None

        # set to None if plaid_metadata (nullable) is None
        # and model_fields_set contains the field
        if self.plaid_metadata is None and "plaid_metadata" in self.model_fields_set:
            _dict['plaid_metadata'] = None

        # set to None if custom_metadata (nullable) is None
        # and model_fields_set contains the field
        if self.custom_metadata is None and "custom_metadata" in self.model_fields_set:
            _dict['custom_metadata'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ChildTransactionObject from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "date": obj.get("date"),
            "amount": obj.get("amount"),
            "currency": obj.get("currency"),
            "to_base": obj.get("to_base"),
            "recurring_id": obj.get("recurring_id"),
            "payee": obj.get("payee"),
            "category_id": obj.get("category_id"),
            "notes": obj.get("notes"),
            "status": obj.get("status"),
            "is_pending": obj.get("is_pending"),
            "created_at": obj.get("created_at"),
            "updated_at": obj.get("updated_at"),
            "is_split_parent": obj.get("is_split_parent"),
            "split_parent_id": obj.get("split_parent_id"),
            "is_group_parent": obj.get("is_group_parent"),
            "group_parent_id": obj.get("group_parent_id"),
            "manual_account_id": obj.get("manual_account_id"),
            "plaid_account_id": obj.get("plaid_account_id"),
            "tag_ids": obj.get("tag_ids"),
            "source": obj.get("source"),
            "external_id": obj.get("external_id"),
            "plaid_metadata": obj.get("plaid_metadata"),
            "custom_metadata": obj.get("custom_metadata"),
            "files": [TransactionAttachmentObject.from_dict(_item) for _item in obj["files"]] if obj.get("files") is not None else None
        })
        return _obj


