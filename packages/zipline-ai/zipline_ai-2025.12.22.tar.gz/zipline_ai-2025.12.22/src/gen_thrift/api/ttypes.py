#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys
import gen_thrift.common.ttypes
import gen_thrift.observability.ttypes

from thrift.transport import TTransport
all_structs = []


class Operation(object):
    MIN = 0
    MAX = 1
    FIRST = 2
    LAST = 3
    UNIQUE_COUNT = 4
    APPROX_UNIQUE_COUNT = 5
    COUNT = 6
    SUM = 7
    AVERAGE = 8
    VARIANCE = 9
    SKEW = 10
    KURTOSIS = 11
    APPROX_PERCENTILE = 12
    LAST_K = 13
    FIRST_K = 14
    TOP_K = 15
    BOTTOM_K = 16
    HISTOGRAM = 17
    APPROX_FREQUENT_K = 18
    APPROX_HEAVY_HITTERS_K = 19
    UNIQUE_TOP_K = 20

    _VALUES_TO_NAMES = {
        0: "MIN",
        1: "MAX",
        2: "FIRST",
        3: "LAST",
        4: "UNIQUE_COUNT",
        5: "APPROX_UNIQUE_COUNT",
        6: "COUNT",
        7: "SUM",
        8: "AVERAGE",
        9: "VARIANCE",
        10: "SKEW",
        11: "KURTOSIS",
        12: "APPROX_PERCENTILE",
        13: "LAST_K",
        14: "FIRST_K",
        15: "TOP_K",
        16: "BOTTOM_K",
        17: "HISTOGRAM",
        18: "APPROX_FREQUENT_K",
        19: "APPROX_HEAVY_HITTERS_K",
        20: "UNIQUE_TOP_K",
    }

    _NAMES_TO_VALUES = {
        "MIN": 0,
        "MAX": 1,
        "FIRST": 2,
        "LAST": 3,
        "UNIQUE_COUNT": 4,
        "APPROX_UNIQUE_COUNT": 5,
        "COUNT": 6,
        "SUM": 7,
        "AVERAGE": 8,
        "VARIANCE": 9,
        "SKEW": 10,
        "KURTOSIS": 11,
        "APPROX_PERCENTILE": 12,
        "LAST_K": 13,
        "FIRST_K": 14,
        "TOP_K": 15,
        "BOTTOM_K": 16,
        "HISTOGRAM": 17,
        "APPROX_FREQUENT_K": 18,
        "APPROX_HEAVY_HITTERS_K": 19,
        "UNIQUE_TOP_K": 20,
    }


class Accuracy(object):
    TEMPORAL = 0
    SNAPSHOT = 1

    _VALUES_TO_NAMES = {
        0: "TEMPORAL",
        1: "SNAPSHOT",
    }

    _NAMES_TO_VALUES = {
        "TEMPORAL": 0,
        "SNAPSHOT": 1,
    }


class EngineType(object):
    SPARK = 0
    BIGQUERY = 1
    SNOWFLAKE = 2

    _VALUES_TO_NAMES = {
        0: "SPARK",
        1: "BIGQUERY",
        2: "SNOWFLAKE",
    }

    _NAMES_TO_VALUES = {
        "SPARK": 0,
        "BIGQUERY": 1,
        "SNOWFLAKE": 2,
    }


class ConfType(object):
    GROUP_BY = 0
    JOIN = 1
    STAGING_QUERY = 2
    MODEL = 3
    MODEL_TRANSFORMS = 4

    _VALUES_TO_NAMES = {
        0: "GROUP_BY",
        1: "JOIN",
        2: "STAGING_QUERY",
        3: "MODEL",
        4: "MODEL_TRANSFORMS",
    }

    _NAMES_TO_VALUES = {
        "GROUP_BY": 0,
        "JOIN": 1,
        "STAGING_QUERY": 2,
        "MODEL": 3,
        "MODEL_TRANSFORMS": 4,
    }


class DataKind(object):
    BOOLEAN = 0
    BYTE = 1
    SHORT = 2
    INT = 3
    LONG = 4
    FLOAT = 5
    DOUBLE = 6
    STRING = 7
    BINARY = 8
    DATE = 9
    TIMESTAMP = 10
    MAP = 11
    LIST = 12
    STRUCT = 13

    _VALUES_TO_NAMES = {
        0: "BOOLEAN",
        1: "BYTE",
        2: "SHORT",
        3: "INT",
        4: "LONG",
        5: "FLOAT",
        6: "DOUBLE",
        7: "STRING",
        8: "BINARY",
        9: "DATE",
        10: "TIMESTAMP",
        11: "MAP",
        12: "LIST",
        13: "STRUCT",
    }

    _NAMES_TO_VALUES = {
        "BOOLEAN": 0,
        "BYTE": 1,
        "SHORT": 2,
        "INT": 3,
        "LONG": 4,
        "FLOAT": 5,
        "DOUBLE": 6,
        "STRING": 7,
        "BINARY": 8,
        "DATE": 9,
        "TIMESTAMP": 10,
        "MAP": 11,
        "LIST": 12,
        "STRUCT": 13,
    }


class DataModel(object):
    ENTITIES = 0
    EVENTS = 1

    _VALUES_TO_NAMES = {
        0: "ENTITIES",
        1: "EVENTS",
    }

    _NAMES_TO_VALUES = {
        "ENTITIES": 0,
        "EVENTS": 1,
    }


class ModelBackend(object):
    VertexAI = 0
    SageMaker = 1

    _VALUES_TO_NAMES = {
        0: "VertexAI",
        1: "SageMaker",
    }

    _NAMES_TO_VALUES = {
        "VertexAI": 0,
        "SageMaker": 1,
    }


class DeploymentStrategyType(object):
    BLUE_GREEN = 0
    ROLLING = 1
    IMMEDIATE = 2

    _VALUES_TO_NAMES = {
        0: "BLUE_GREEN",
        1: "ROLLING",
        2: "IMMEDIATE",
    }

    _NAMES_TO_VALUES = {
        "BLUE_GREEN": 0,
        "ROLLING": 1,
        "IMMEDIATE": 2,
    }


class Query(object):
    """
    Attributes:
     - selects
     - wheres
     - startPartition
     - endPartition
     - timeColumn
     - setups
     - mutationTimeColumn
     - reversalColumn
     - partitionColumn: Chronon expects all its batch input data to be date/time partitioned.
    We in-turn produce partitioned outputs.

     - partitionFormat: Partition format in the java DateFormatter spec:
    see: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html

     - partitionInterval: Indicates the timespan of a given interval of the source

     - partitionLag: Indicates how often this source is typically delayed by.
    Should be a multiple of partitionInterval

     - subPartitionsToWaitFor: Additional partitions to be used in sensing that the source data has landed.
    Should be a full partition string, such as `hr=23:00'

     - clustered: Indicates whether the source table uses clustering (e.g., Delta Lake) instead of
    traditional Hive-style partitioning. This affects sensor logic:
    - For partitioned tables: sensor checks max(partition_col) >= sensor_date
    - For clustered tables: sensor checks max(timestamp_col) >= next(sensor_date)
      to ensure all data for that date has landed.


    """
    thrift_spec = None


    def __init__(self, selects = None, wheres = None, startPartition = None, endPartition = None, timeColumn = None, setups = None, mutationTimeColumn = None, reversalColumn = None, partitionColumn = None, partitionFormat = None, partitionInterval = None, partitionLag = None, subPartitionsToWaitFor = None, clustered = None,):
        self.selects = selects
        self.wheres = wheres
        self.startPartition = startPartition
        self.endPartition = endPartition
        self.timeColumn = timeColumn
        self.setups = setups
        self.mutationTimeColumn = mutationTimeColumn
        self.reversalColumn = reversalColumn
        self.partitionColumn = partitionColumn
        self.partitionFormat = partitionFormat
        self.partitionInterval = partitionInterval
        self.partitionLag = partitionLag
        self.subPartitionsToWaitFor = subPartitionsToWaitFor
        self.clustered = clustered

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.selects = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.selects[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.wheres = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.wheres.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.timeColumn = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.setups = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.setups.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.mutationTimeColumn = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.reversalColumn = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRING:
                    self.partitionColumn = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRING:
                    self.partitionFormat = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRUCT:
                    self.partitionInterval = gen_thrift.common.ttypes.Window()
                    self.partitionInterval.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRUCT:
                    self.partitionLag = gen_thrift.common.ttypes.Window()
                    self.partitionLag.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.LIST:
                    self.subPartitionsToWaitFor = []
                    (_etype22, _size19) = iprot.readListBegin()
                    for _i23 in range(_size19):
                        _elem24 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.subPartitionsToWaitFor.append(_elem24)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.BOOL:
                    self.clustered = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Query')
        if self.selects is not None:
            oprot.writeFieldBegin('selects', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.selects))
            for kiter25, viter26 in self.selects.items():
                oprot.writeString(kiter25.encode('utf-8') if sys.version_info[0] == 2 else kiter25)
                oprot.writeString(viter26.encode('utf-8') if sys.version_info[0] == 2 else viter26)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.wheres is not None:
            oprot.writeFieldBegin('wheres', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.wheres))
            for iter27 in self.wheres:
                oprot.writeString(iter27.encode('utf-8') if sys.version_info[0] == 2 else iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 3)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.endPartition is not None:
            oprot.writeFieldBegin('endPartition', TType.STRING, 4)
            oprot.writeString(self.endPartition.encode('utf-8') if sys.version_info[0] == 2 else self.endPartition)
            oprot.writeFieldEnd()
        if self.timeColumn is not None:
            oprot.writeFieldBegin('timeColumn', TType.STRING, 5)
            oprot.writeString(self.timeColumn.encode('utf-8') if sys.version_info[0] == 2 else self.timeColumn)
            oprot.writeFieldEnd()
        if self.setups is not None:
            oprot.writeFieldBegin('setups', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.setups))
            for iter28 in self.setups:
                oprot.writeString(iter28.encode('utf-8') if sys.version_info[0] == 2 else iter28)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mutationTimeColumn is not None:
            oprot.writeFieldBegin('mutationTimeColumn', TType.STRING, 7)
            oprot.writeString(self.mutationTimeColumn.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTimeColumn)
            oprot.writeFieldEnd()
        if self.reversalColumn is not None:
            oprot.writeFieldBegin('reversalColumn', TType.STRING, 8)
            oprot.writeString(self.reversalColumn.encode('utf-8') if sys.version_info[0] == 2 else self.reversalColumn)
            oprot.writeFieldEnd()
        if self.partitionColumn is not None:
            oprot.writeFieldBegin('partitionColumn', TType.STRING, 20)
            oprot.writeString(self.partitionColumn.encode('utf-8') if sys.version_info[0] == 2 else self.partitionColumn)
            oprot.writeFieldEnd()
        if self.partitionFormat is not None:
            oprot.writeFieldBegin('partitionFormat', TType.STRING, 21)
            oprot.writeString(self.partitionFormat.encode('utf-8') if sys.version_info[0] == 2 else self.partitionFormat)
            oprot.writeFieldEnd()
        if self.partitionInterval is not None:
            oprot.writeFieldBegin('partitionInterval', TType.STRUCT, 22)
            self.partitionInterval.write(oprot)
            oprot.writeFieldEnd()
        if self.partitionLag is not None:
            oprot.writeFieldBegin('partitionLag', TType.STRUCT, 23)
            self.partitionLag.write(oprot)
            oprot.writeFieldEnd()
        if self.subPartitionsToWaitFor is not None:
            oprot.writeFieldBegin('subPartitionsToWaitFor', TType.LIST, 24)
            oprot.writeListBegin(TType.STRING, len(self.subPartitionsToWaitFor))
            for iter29 in self.subPartitionsToWaitFor:
                oprot.writeString(iter29.encode('utf-8') if sys.version_info[0] == 2 else iter29)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.clustered is not None:
            oprot.writeFieldBegin('clustered', TType.BOOL, 25)
            oprot.writeBool(self.clustered)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StagingQuery(object):
    """
    Staging Query encapsulates arbitrary spark computation. One key feature is that the computation follows a
    "fill-what's-missing" pattern. Basically instead of explicitly specifying dates you specify two macros.
    `{{ start_date }}` and `{{end_date}}`. Chronon will pass in earliest-missing-partition for `start_date` and
    execution-date / today for `end_date`. So the query will compute multiple partitions at once.

    Attributes:
     - metaData: Contains name, team, output_namespace, execution parameters etc. Things that don't change the semantics of the computation itself.

     - query: Arbitrary spark query that should be written with `{{ start_date }}`, `{{ end_date }}` and `{{ latest_date }}` templates
         - `{{ start_date }}` will be set to this user provided start date, future incremental runs will set it to the latest existing partition + 1 day.
         - `{{ start_date(offset=-10, lower_bound='2023-01-01', upper_bound='2024-01-01') }}` will shift the date back one day and bound it with lower and upper bounds.
         - `{{ end_date }}` is the end partition of the computing range. offsetting and bounding the end_date also works as described above.
         - `{{ latest_date }}` is the end partition independent of the computing range (meant for cumulative sources). offsetting and bounding the end_date also works as described above.
         - `{{ max_date(table=namespace.my_table) }}` is the max partition available for a given table.


     - startPartition: on the first run, `{{ start_date }}` will be set to this user provided start date, future incremental runs will set it to the latest existing partition + 1 day.

     - setups: Spark SQL setup statements. Used typically to register UDFs.

     - engineType: By default, spark is the compute engine. You can specify an override (eg. bigquery, etc.)

     - tableDependencies
     - recomputeDays

    """
    thrift_spec = None


    def __init__(self, metaData = None, query = None, startPartition = None, setups = None, engineType = None, tableDependencies = None, recomputeDays = None,):
        self.metaData = metaData
        self.query = query
        self.startPartition = startPartition
        self.setups = setups
        self.engineType = engineType
        self.tableDependencies = tableDependencies
        self.recomputeDays = recomputeDays

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startPartition = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.setups = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.setups.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.engineType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.tableDependencies = []
                    (_etype39, _size36) = iprot.readListBegin()
                    for _i40 in range(_size36):
                        _elem41 = gen_thrift.common.ttypes.TableDependency()
                        _elem41.read(iprot)
                        self.tableDependencies.append(_elem41)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I32:
                    self.recomputeDays = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StagingQuery')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 2)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        if self.startPartition is not None:
            oprot.writeFieldBegin('startPartition', TType.STRING, 3)
            oprot.writeString(self.startPartition.encode('utf-8') if sys.version_info[0] == 2 else self.startPartition)
            oprot.writeFieldEnd()
        if self.setups is not None:
            oprot.writeFieldBegin('setups', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.setups))
            for iter42 in self.setups:
                oprot.writeString(iter42.encode('utf-8') if sys.version_info[0] == 2 else iter42)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.engineType is not None:
            oprot.writeFieldBegin('engineType', TType.I32, 5)
            oprot.writeI32(self.engineType)
            oprot.writeFieldEnd()
        if self.tableDependencies is not None:
            oprot.writeFieldBegin('tableDependencies', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.tableDependencies))
            for iter43 in self.tableDependencies:
                iter43.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.recomputeDays is not None:
            oprot.writeFieldBegin('recomputeDays', TType.I32, 20)
            oprot.writeI32(self.recomputeDays)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EventSource(object):
    """
    Attributes:
     - table: Table currently needs to be a 'ds' (date string - yyyy-MM-dd) partitioned hive table. Table names can contain subpartition specs, example db.table/system=mobile/currency=USD

     - topic: Topic is a kafka table. The table contains all the events historically came through this topic.

     - query: The logic used to scan both the table and the topic. Contains row level transformations and filtering expressed as Spark SQL statements.

     - isCumulative: If each new hive partition contains not just the current day's events but the entire set of events since the begininng. The key property is that the events are not mutated across partitions.


    """
    thrift_spec = None


    def __init__(self, table = None, topic = None, query = None, isCumulative = None,):
        self.table = table
        self.topic = topic
        self.query = query
        self.isCumulative = isCumulative

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.topic = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isCumulative = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EventSource')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 1)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.topic is not None:
            oprot.writeFieldBegin('topic', TType.STRING, 2)
            oprot.writeString(self.topic.encode('utf-8') if sys.version_info[0] == 2 else self.topic)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 3)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        if self.isCumulative is not None:
            oprot.writeFieldBegin('isCumulative', TType.BOOL, 4)
            oprot.writeBool(self.isCumulative)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EntitySource(object):
    """
    Entity Sources represent data that gets mutated over-time - at row-level. This is a group of three data elements.
    snapshotTable, mutationTable and mutationTopic. mutationTable and mutationTopic are only necessary if we are trying
    to create realtime or point-in-time aggregations over these sources. Entity sources usually map 1:1 with a database
    tables in your OLTP store that typically serves live application traffic. When mutation data is absent they map 1:1
    to `dim` tables in star schema.

    Attributes:
     - snapshotTable: Snapshot table currently needs to be a 'ds' (date string - yyyy-MM-dd) partitioned hive table.
     - mutationTable: Topic is a kafka table. The table contains all the events that historically came through this topic.
     - mutationTopic: The logic used to scan both the table and the topic. Contains row level transformations and filtering expressed as Spark SQL statements.
     - query: If each new hive partition contains not just the current day's events but the entire set of events since the begininng. The key property is that the events are not mutated across partitions.

    """
    thrift_spec = None


    def __init__(self, snapshotTable = None, mutationTable = None, mutationTopic = None, query = None,):
        self.snapshotTable = snapshotTable
        self.mutationTable = mutationTable
        self.mutationTopic = mutationTopic
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapshotTable = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mutationTable = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mutationTopic = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EntitySource')
        if self.snapshotTable is not None:
            oprot.writeFieldBegin('snapshotTable', TType.STRING, 1)
            oprot.writeString(self.snapshotTable.encode('utf-8') if sys.version_info[0] == 2 else self.snapshotTable)
            oprot.writeFieldEnd()
        if self.mutationTable is not None:
            oprot.writeFieldBegin('mutationTable', TType.STRING, 2)
            oprot.writeString(self.mutationTable.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTable)
            oprot.writeFieldEnd()
        if self.mutationTopic is not None:
            oprot.writeFieldBegin('mutationTopic', TType.STRING, 3)
            oprot.writeString(self.mutationTopic.encode('utf-8') if sys.version_info[0] == 2 else self.mutationTopic)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 4)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExternalSource(object):
    """
    Attributes:
     - metadata
     - keySchema
     - valueSchema

    """
    thrift_spec = None


    def __init__(self, metadata = None, keySchema = None, valueSchema = None,):
        self.metadata = metadata
        self.keySchema = keySchema
        self.valueSchema = valueSchema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metadata = MetaData()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.keySchema = TDataType()
                    self.keySchema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.valueSchema = TDataType()
                    self.valueSchema.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExternalSource')
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 1)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.keySchema is not None:
            oprot.writeFieldBegin('keySchema', TType.STRUCT, 2)
            self.keySchema.write(oprot)
            oprot.writeFieldEnd()
        if self.valueSchema is not None:
            oprot.writeFieldBegin('valueSchema', TType.STRUCT, 3)
            self.valueSchema.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinSource(object):
    """
    Output of a Join can be used as input to downstream computations like GroupBy or a Join.
    Below is a short description of each of the cases we handle.
    Case #1: a join's source is another join [TODO]
      - while serving, we expect the keys for the upstream join to be passed in the request.
        we will query upstream first, and use the result to query downstream
      - while backfill, we will backfill the upstream first, and use the table as the left of the subsequent join
      - this is currently a "to do" because users can achieve this by themselves unlike case 2:
    Case #2: a join is the source of another GroupBy
      - We will support arbitrarily long transformation chains with this.
      - for batch (Accuracy.SNAPSHOT), we simply backfill the join first and compute groupBy as usual
        - will substitute the joinSource with the resulting table and continue computation
        - we will add a "resolve source" step prior to backfills that will compute the parent join and update the source
      - for realtime (Accuracy.TEMPORAL), we need to do "stream enrichment"
        - we will simply issue "fetchJoin" and create an enriched source. Note the join left should be of type "events".


    Attributes:
     - join
     - query

    """
    thrift_spec = None


    def __init__(self, join = None, query = None,):
        self.join = join
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.join = Join()
                    self.join.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinSource')
        if self.join is not None:
            oprot.writeFieldBegin('join', TType.STRUCT, 1)
            self.join.write(oprot)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 2)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Source(object):
    """
    Attributes:
     - events
     - entities
     - joinSource
     - modelTransforms

    """
    thrift_spec = None


    def __init__(self, events = None, entities = None, joinSource = None, modelTransforms = None,):
        self.events = events
        self.entities = entities
        self.joinSource = joinSource
        self.modelTransforms = modelTransforms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.events = EventSource()
                    self.events.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.entities = EntitySource()
                    self.entities.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.joinSource = JoinSource()
                    self.joinSource.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.modelTransforms = ModelTransforms()
                    self.modelTransforms.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Source')
        if self.events is not None:
            oprot.writeFieldBegin('events', TType.STRUCT, 1)
            self.events.write(oprot)
            oprot.writeFieldEnd()
        if self.entities is not None:
            oprot.writeFieldBegin('entities', TType.STRUCT, 2)
            self.entities.write(oprot)
            oprot.writeFieldEnd()
        if self.joinSource is not None:
            oprot.writeFieldBegin('joinSource', TType.STRUCT, 3)
            self.joinSource.write(oprot)
            oprot.writeFieldEnd()
        if self.modelTransforms is not None:
            oprot.writeFieldBegin('modelTransforms', TType.STRUCT, 4)
            self.modelTransforms.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Aggregation(object):
    """
    Chronon provides a powerful aggregations primitive - that takes the familiar aggregation operation, via groupBy in
    SQL and extends it with three things - windowing, bucketing and auto-explode.

    Attributes:
     - inputColumn: The column as specified in source.query.selects - on which we need to aggregate with.

     - operation: The type of aggregation that needs to be performed on the inputColumn.

     - argMap: Extra arguments that needs to be passed to some of the operations like LAST_K, APPROX_PERCENTILE.

     - windows: For TEMPORAL case windows are sawtooth. Meaning head slides ahead continuously in time, whereas, the tail only hops ahead, at discrete points in time. Hop is determined by the window size automatically. The maximum hop size is 1/12 of window size. You can specify multiple such windows at once.
      - Window > 12 days  -> Hop Size = 1 day
      - Window > 12 hours -> Hop Size = 1 hr
      - Window > 1hr      -> Hop Size = 5 minutes
     - buckets: This is an additional layer of aggregation. You can key a group_by by user, and bucket a “item_view” count by “item_category”. This will produce one row per user, with column containing map of “item_category” to “view_count”. You can specify multiple such buckets at once

    """
    thrift_spec = None


    def __init__(self, inputColumn = None, operation = None, argMap = None, windows = None, buckets = None,):
        self.inputColumn = inputColumn
        self.operation = operation
        self.argMap = argMap
        self.windows = windows
        self.buckets = buckets

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.inputColumn = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.argMap = {}
                    (_ktype45, _vtype46, _size44) = iprot.readMapBegin()
                    for _i48 in range(_size44):
                        _key49 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val50 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.argMap[_key49] = _val50
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.windows = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = gen_thrift.common.ttypes.Window()
                        _elem56.read(iprot)
                        self.windows.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.buckets = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.buckets.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Aggregation')
        if self.inputColumn is not None:
            oprot.writeFieldBegin('inputColumn', TType.STRING, 1)
            oprot.writeString(self.inputColumn.encode('utf-8') if sys.version_info[0] == 2 else self.inputColumn)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.I32, 2)
            oprot.writeI32(self.operation)
            oprot.writeFieldEnd()
        if self.argMap is not None:
            oprot.writeFieldBegin('argMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.argMap))
            for kiter63, viter64 in self.argMap.items():
                oprot.writeString(kiter63.encode('utf-8') if sys.version_info[0] == 2 else kiter63)
                oprot.writeString(viter64.encode('utf-8') if sys.version_info[0] == 2 else viter64)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.windows is not None:
            oprot.writeFieldBegin('windows', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.windows))
            for iter65 in self.windows:
                iter65.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.buckets is not None:
            oprot.writeFieldBegin('buckets', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.buckets))
            for iter66 in self.buckets:
                oprot.writeString(iter66.encode('utf-8') if sys.version_info[0] == 2 else iter66)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AggregationPart(object):
    """
    Attributes:
     - inputColumn
     - operation
     - argMap
     - window
     - bucket

    """
    thrift_spec = None


    def __init__(self, inputColumn = None, operation = None, argMap = None, window = None, bucket = None,):
        self.inputColumn = inputColumn
        self.operation = operation
        self.argMap = argMap
        self.window = window
        self.bucket = bucket

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.inputColumn = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.operation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.argMap = {}
                    (_ktype68, _vtype69, _size67) = iprot.readMapBegin()
                    for _i71 in range(_size67):
                        _key72 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val73 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.argMap[_key72] = _val73
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.window = gen_thrift.common.ttypes.Window()
                    self.window.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.bucket = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AggregationPart')
        if self.inputColumn is not None:
            oprot.writeFieldBegin('inputColumn', TType.STRING, 1)
            oprot.writeString(self.inputColumn.encode('utf-8') if sys.version_info[0] == 2 else self.inputColumn)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.I32, 2)
            oprot.writeI32(self.operation)
            oprot.writeFieldEnd()
        if self.argMap is not None:
            oprot.writeFieldBegin('argMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.argMap))
            for kiter74, viter75 in self.argMap.items():
                oprot.writeString(kiter74.encode('utf-8') if sys.version_info[0] == 2 else kiter74)
                oprot.writeString(viter75.encode('utf-8') if sys.version_info[0] == 2 else viter75)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.window is not None:
            oprot.writeFieldBegin('window', TType.STRUCT, 4)
            self.window.write(oprot)
            oprot.writeFieldEnd()
        if self.bucket is not None:
            oprot.writeFieldBegin('bucket', TType.STRING, 5)
            oprot.writeString(self.bucket.encode('utf-8') if sys.version_info[0] == 2 else self.bucket)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MetaData(object):
    """
    contains configs params that don't change the contents of the output.


    Attributes:
     - name
     - team
     - version
     - outputNamespace
     - additionalOutputPartitionColumns: By default we will just partition the output by the date column - set via "spark.chronon.partition.column"
    With this we will partition the output with the specified additional columns

     - tableProperties
     - tags
     - columnTags
     - columnHashes
     - online
     - production
     - sourceFile
     - customJson
     - consistencyCheck
     - samplePercent
     - consistencySamplePercent
     - driftSpec
     - executionInfo

    """
    thrift_spec = None


    def __init__(self, name = None, team = None, version = None, outputNamespace = None, additionalOutputPartitionColumns = None, tableProperties = None, tags = None, columnTags = None, columnHashes = None, online = None, production = None, sourceFile = None, customJson = None, consistencyCheck = None, samplePercent = None, consistencySamplePercent = None, driftSpec = None, executionInfo = None,):
        self.name = name
        self.team = team
        self.version = version
        self.outputNamespace = outputNamespace
        self.additionalOutputPartitionColumns = additionalOutputPartitionColumns
        self.tableProperties = tableProperties
        self.tags = tags
        self.columnTags = columnTags
        self.columnHashes = columnHashes
        self.online = online
        self.production = production
        self.sourceFile = sourceFile
        self.customJson = customJson
        self.consistencyCheck = consistencyCheck
        self.samplePercent = samplePercent
        self.consistencySamplePercent = consistencySamplePercent
        self.driftSpec = driftSpec
        self.executionInfo = executionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.team = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.outputNamespace = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.additionalOutputPartitionColumns = []
                    (_etype79, _size76) = iprot.readListBegin()
                    for _i80 in range(_size76):
                        _elem81 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.additionalOutputPartitionColumns.append(_elem81)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.tableProperties = {}
                    (_ktype83, _vtype84, _size82) = iprot.readMapBegin()
                    for _i86 in range(_size82):
                        _key87 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val88 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tableProperties[_key87] = _val88
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.MAP:
                    self.tags = {}
                    (_ktype90, _vtype91, _size89) = iprot.readMapBegin()
                    for _i93 in range(_size89):
                        _key94 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val95 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tags[_key94] = _val95
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.MAP:
                    self.columnTags = {}
                    (_ktype97, _vtype98, _size96) = iprot.readMapBegin()
                    for _i100 in range(_size96):
                        _key101 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val102 = {}
                        (_ktype104, _vtype105, _size103) = iprot.readMapBegin()
                        for _i107 in range(_size103):
                            _key108 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val109 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val102[_key108] = _val109
                        iprot.readMapEnd()
                        self.columnTags[_key101] = _val102
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.MAP:
                    self.columnHashes = {}
                    (_ktype111, _vtype112, _size110) = iprot.readMapBegin()
                    for _i114 in range(_size110):
                        _key115 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val116 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnHashes[_key115] = _val116
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.BOOL:
                    self.online = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.BOOL:
                    self.production = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 102:
                if ftype == TType.STRING:
                    self.sourceFile = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 103:
                if ftype == TType.STRING:
                    self.customJson = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.BOOL:
                    self.consistencyCheck = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 201:
                if ftype == TType.DOUBLE:
                    self.samplePercent = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 202:
                if ftype == TType.DOUBLE:
                    self.consistencySamplePercent = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 203:
                if ftype == TType.STRUCT:
                    self.driftSpec = gen_thrift.observability.ttypes.DriftSpec()
                    self.driftSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 204:
                if ftype == TType.STRUCT:
                    self.executionInfo = gen_thrift.common.ttypes.ExecutionInfo()
                    self.executionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MetaData')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.team is not None:
            oprot.writeFieldBegin('team', TType.STRING, 2)
            oprot.writeString(self.team.encode('utf-8') if sys.version_info[0] == 2 else self.team)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 3)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.outputNamespace is not None:
            oprot.writeFieldBegin('outputNamespace', TType.STRING, 4)
            oprot.writeString(self.outputNamespace.encode('utf-8') if sys.version_info[0] == 2 else self.outputNamespace)
            oprot.writeFieldEnd()
        if self.additionalOutputPartitionColumns is not None:
            oprot.writeFieldBegin('additionalOutputPartitionColumns', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.additionalOutputPartitionColumns))
            for iter117 in self.additionalOutputPartitionColumns:
                oprot.writeString(iter117.encode('utf-8') if sys.version_info[0] == 2 else iter117)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tableProperties is not None:
            oprot.writeFieldBegin('tableProperties', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tableProperties))
            for kiter118, viter119 in self.tableProperties.items():
                oprot.writeString(kiter118.encode('utf-8') if sys.version_info[0] == 2 else kiter118)
                oprot.writeString(viter119.encode('utf-8') if sys.version_info[0] == 2 else viter119)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.MAP, 20)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tags))
            for kiter120, viter121 in self.tags.items():
                oprot.writeString(kiter120.encode('utf-8') if sys.version_info[0] == 2 else kiter120)
                oprot.writeString(viter121.encode('utf-8') if sys.version_info[0] == 2 else viter121)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.columnTags is not None:
            oprot.writeFieldBegin('columnTags', TType.MAP, 21)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.columnTags))
            for kiter122, viter123 in self.columnTags.items():
                oprot.writeString(kiter122.encode('utf-8') if sys.version_info[0] == 2 else kiter122)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter123))
                for kiter124, viter125 in viter123.items():
                    oprot.writeString(kiter124.encode('utf-8') if sys.version_info[0] == 2 else kiter124)
                    oprot.writeString(viter125.encode('utf-8') if sys.version_info[0] == 2 else viter125)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.columnHashes is not None:
            oprot.writeFieldBegin('columnHashes', TType.MAP, 22)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.columnHashes))
            for kiter126, viter127 in self.columnHashes.items():
                oprot.writeString(kiter126.encode('utf-8') if sys.version_info[0] == 2 else kiter126)
                oprot.writeString(viter127.encode('utf-8') if sys.version_info[0] == 2 else viter127)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.online is not None:
            oprot.writeFieldBegin('online', TType.BOOL, 100)
            oprot.writeBool(self.online)
            oprot.writeFieldEnd()
        if self.production is not None:
            oprot.writeFieldBegin('production', TType.BOOL, 101)
            oprot.writeBool(self.production)
            oprot.writeFieldEnd()
        if self.sourceFile is not None:
            oprot.writeFieldBegin('sourceFile', TType.STRING, 102)
            oprot.writeString(self.sourceFile.encode('utf-8') if sys.version_info[0] == 2 else self.sourceFile)
            oprot.writeFieldEnd()
        if self.customJson is not None:
            oprot.writeFieldBegin('customJson', TType.STRING, 103)
            oprot.writeString(self.customJson.encode('utf-8') if sys.version_info[0] == 2 else self.customJson)
            oprot.writeFieldEnd()
        if self.consistencyCheck is not None:
            oprot.writeFieldBegin('consistencyCheck', TType.BOOL, 200)
            oprot.writeBool(self.consistencyCheck)
            oprot.writeFieldEnd()
        if self.samplePercent is not None:
            oprot.writeFieldBegin('samplePercent', TType.DOUBLE, 201)
            oprot.writeDouble(self.samplePercent)
            oprot.writeFieldEnd()
        if self.consistencySamplePercent is not None:
            oprot.writeFieldBegin('consistencySamplePercent', TType.DOUBLE, 202)
            oprot.writeDouble(self.consistencySamplePercent)
            oprot.writeFieldEnd()
        if self.driftSpec is not None:
            oprot.writeFieldBegin('driftSpec', TType.STRUCT, 203)
            self.driftSpec.write(oprot)
            oprot.writeFieldEnd()
        if self.executionInfo is not None:
            oprot.writeFieldBegin('executionInfo', TType.STRUCT, 204)
            self.executionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Conf(object):
    """
    Attributes:
     - name
     - hash
     - contents
     - confType

    """
    thrift_spec = None


    def __init__(self, name = None, hash = None, contents = None, confType = None,):
        self.name = name
        self.hash = hash
        self.contents = contents
        self.confType = confType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.contents = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.confType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Conf')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.hash is not None:
            oprot.writeFieldBegin('hash', TType.STRING, 2)
            oprot.writeString(self.hash.encode('utf-8') if sys.version_info[0] == 2 else self.hash)
            oprot.writeFieldEnd()
        if self.contents is not None:
            oprot.writeFieldBegin('contents', TType.STRING, 3)
            oprot.writeString(self.contents.encode('utf-8') if sys.version_info[0] == 2 else self.contents)
            oprot.writeFieldEnd()
        if self.confType is not None:
            oprot.writeFieldBegin('confType', TType.I32, 4)
            oprot.writeI32(self.confType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupBy(object):
    """
    Attributes:
     - metaData
     - sources
     - keyColumns
     - aggregations
     - accuracy
     - derivations

    """
    thrift_spec = None


    def __init__(self, metaData = None, sources = None, keyColumns = None, aggregations = None, accuracy = None, derivations = None,):
        self.metaData = metaData
        self.sources = sources
        self.keyColumns = keyColumns
        self.aggregations = aggregations
        self.accuracy = accuracy
        self.derivations = derivations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.sources = []
                    (_etype131, _size128) = iprot.readListBegin()
                    for _i132 in range(_size128):
                        _elem133 = Source()
                        _elem133.read(iprot)
                        self.sources.append(_elem133)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.keyColumns = []
                    (_etype137, _size134) = iprot.readListBegin()
                    for _i138 in range(_size134):
                        _elem139 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyColumns.append(_elem139)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aggregations = []
                    (_etype143, _size140) = iprot.readListBegin()
                    for _i144 in range(_size140):
                        _elem145 = Aggregation()
                        _elem145.read(iprot)
                        self.aggregations.append(_elem145)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.accuracy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.derivations = []
                    (_etype149, _size146) = iprot.readListBegin()
                    for _i150 in range(_size146):
                        _elem151 = Derivation()
                        _elem151.read(iprot)
                        self.derivations.append(_elem151)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupBy')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.sources is not None:
            oprot.writeFieldBegin('sources', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.sources))
            for iter152 in self.sources:
                iter152.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.keyColumns is not None:
            oprot.writeFieldBegin('keyColumns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.keyColumns))
            for iter153 in self.keyColumns:
                oprot.writeString(iter153.encode('utf-8') if sys.version_info[0] == 2 else iter153)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregations is not None:
            oprot.writeFieldBegin('aggregations', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.aggregations))
            for iter154 in self.aggregations:
                iter154.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.accuracy is not None:
            oprot.writeFieldBegin('accuracy', TType.I32, 5)
            oprot.writeI32(self.accuracy)
            oprot.writeFieldEnd()
        if self.derivations is not None:
            oprot.writeFieldBegin('derivations', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.derivations))
            for iter155 in self.derivations:
                iter155.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class JoinPart(object):
    """
    Attributes:
     - groupBy
     - keyMapping
     - prefix
     - useLongNames

    """
    thrift_spec = None


    def __init__(self, groupBy = None, keyMapping = None, prefix = None, useLongNames = None,):
        self.groupBy = groupBy
        self.keyMapping = keyMapping
        self.prefix = prefix
        self.useLongNames = useLongNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.groupBy = GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.keyMapping = {}
                    (_ktype157, _vtype158, _size156) = iprot.readMapBegin()
                    for _i160 in range(_size156):
                        _key161 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val162 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyMapping[_key161] = _val162
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.useLongNames = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('JoinPart')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.keyMapping is not None:
            oprot.writeFieldBegin('keyMapping', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyMapping))
            for kiter163, viter164 in self.keyMapping.items():
                oprot.writeString(kiter163.encode('utf-8') if sys.version_info[0] == 2 else kiter163)
                oprot.writeString(viter164.encode('utf-8') if sys.version_info[0] == 2 else viter164)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.prefix is not None:
            oprot.writeFieldBegin('prefix', TType.STRING, 3)
            oprot.writeString(self.prefix.encode('utf-8') if sys.version_info[0] == 2 else self.prefix)
            oprot.writeFieldEnd()
        if self.useLongNames is not None:
            oprot.writeFieldBegin('useLongNames', TType.BOOL, 10)
            oprot.writeBool(self.useLongNames)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExternalPart(object):
    """
    Attributes:
     - source
     - keyMapping
     - prefix

    """
    thrift_spec = None


    def __init__(self, source = None, keyMapping = None, prefix = None,):
        self.source = source
        self.keyMapping = keyMapping
        self.prefix = prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.source = ExternalSource()
                    self.source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.keyMapping = {}
                    (_ktype166, _vtype167, _size165) = iprot.readMapBegin()
                    for _i169 in range(_size165):
                        _key170 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val171 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyMapping[_key170] = _val171
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prefix = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExternalPart')
        if self.source is not None:
            oprot.writeFieldBegin('source', TType.STRUCT, 1)
            self.source.write(oprot)
            oprot.writeFieldEnd()
        if self.keyMapping is not None:
            oprot.writeFieldBegin('keyMapping', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.keyMapping))
            for kiter172, viter173 in self.keyMapping.items():
                oprot.writeString(kiter172.encode('utf-8') if sys.version_info[0] == 2 else kiter172)
                oprot.writeString(viter173.encode('utf-8') if sys.version_info[0] == 2 else viter173)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.prefix is not None:
            oprot.writeFieldBegin('prefix', TType.STRING, 3)
            oprot.writeString(self.prefix.encode('utf-8') if sys.version_info[0] == 2 else self.prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Derivation(object):
    """
    Attributes:
     - name
     - expression

    """
    thrift_spec = None


    def __init__(self, name = None, expression = None,):
        self.name = name
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Derivation')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 2)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Join(object):
    """
    Attributes:
     - metaData
     - left
     - joinParts
     - skewKeys
     - onlineExternalParts
     - bootstrapParts
     - rowIds
     - derivations: List of a derived column names to the expression based on joinPart / externalPart columns
    The expression can be any valid Spark SQL select clause without aggregation functions.

    joinPart column names are automatically constructed according to the below convention
     `{join_part_prefix}_{group_by_name}_{input_column_name}_{aggregation_operation}_{window}_{by_bucket}`
     prefix, window and bucket are optional. You can find the type information of columns using the analyzer tool.

    externalPart column names are automatically constructed according to the below convention
     `ext_{external_source_name}_{value_column}`
    Types are defined along with the schema by users for external sources.

    Including a column with key "*" and value "*", means that every raw column will be included along with the derived
    columns.

     - useLongNames

    """
    thrift_spec = None


    def __init__(self, metaData = None, left = None, joinParts = None, skewKeys = None, onlineExternalParts = None, bootstrapParts = None, rowIds = None, derivations = None, useLongNames = None,):
        self.metaData = metaData
        self.left = left
        self.joinParts = joinParts
        self.skewKeys = skewKeys
        self.onlineExternalParts = onlineExternalParts
        self.bootstrapParts = bootstrapParts
        self.rowIds = rowIds
        self.derivations = derivations
        self.useLongNames = useLongNames

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.left = Source()
                    self.left.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.joinParts = []
                    (_etype177, _size174) = iprot.readListBegin()
                    for _i178 in range(_size174):
                        _elem179 = JoinPart()
                        _elem179.read(iprot)
                        self.joinParts.append(_elem179)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.skewKeys = {}
                    (_ktype181, _vtype182, _size180) = iprot.readMapBegin()
                    for _i184 in range(_size180):
                        _key185 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val186 = []
                        (_etype190, _size187) = iprot.readListBegin()
                        for _i191 in range(_size187):
                            _elem192 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val186.append(_elem192)
                        iprot.readListEnd()
                        self.skewKeys[_key185] = _val186
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.onlineExternalParts = []
                    (_etype196, _size193) = iprot.readListBegin()
                    for _i197 in range(_size193):
                        _elem198 = ExternalPart()
                        _elem198.read(iprot)
                        self.onlineExternalParts.append(_elem198)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.bootstrapParts = []
                    (_etype202, _size199) = iprot.readListBegin()
                    for _i203 in range(_size199):
                        _elem204 = BootstrapPart()
                        _elem204.read(iprot)
                        self.bootstrapParts.append(_elem204)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.rowIds = []
                    (_etype208, _size205) = iprot.readListBegin()
                    for _i209 in range(_size205):
                        _elem210 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.rowIds.append(_elem210)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.derivations = []
                    (_etype214, _size211) = iprot.readListBegin()
                    for _i215 in range(_size211):
                        _elem216 = Derivation()
                        _elem216.read(iprot)
                        self.derivations.append(_elem216)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 50:
                if ftype == TType.BOOL:
                    self.useLongNames = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Join')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.STRUCT, 2)
            self.left.write(oprot)
            oprot.writeFieldEnd()
        if self.joinParts is not None:
            oprot.writeFieldBegin('joinParts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.joinParts))
            for iter217 in self.joinParts:
                iter217.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.skewKeys is not None:
            oprot.writeFieldBegin('skewKeys', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.skewKeys))
            for kiter218, viter219 in self.skewKeys.items():
                oprot.writeString(kiter218.encode('utf-8') if sys.version_info[0] == 2 else kiter218)
                oprot.writeListBegin(TType.STRING, len(viter219))
                for iter220 in viter219:
                    oprot.writeString(iter220.encode('utf-8') if sys.version_info[0] == 2 else iter220)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.onlineExternalParts is not None:
            oprot.writeFieldBegin('onlineExternalParts', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.onlineExternalParts))
            for iter221 in self.onlineExternalParts:
                iter221.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bootstrapParts is not None:
            oprot.writeFieldBegin('bootstrapParts', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.bootstrapParts))
            for iter222 in self.bootstrapParts:
                iter222.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rowIds is not None:
            oprot.writeFieldBegin('rowIds', TType.LIST, 8)
            oprot.writeListBegin(TType.STRING, len(self.rowIds))
            for iter223 in self.rowIds:
                oprot.writeString(iter223.encode('utf-8') if sys.version_info[0] == 2 else iter223)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.derivations is not None:
            oprot.writeFieldBegin('derivations', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.derivations))
            for iter224 in self.derivations:
                iter224.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.useLongNames is not None:
            oprot.writeFieldBegin('useLongNames', TType.BOOL, 50)
            oprot.writeBool(self.useLongNames)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BootstrapPart(object):
    """
    Attributes:
     - metaData
     - table
     - query
     - keyColumns

    """
    thrift_spec = None


    def __init__(self, metaData = None, table = None, query = None, keyColumns = None,):
        self.metaData = metaData
        self.table = table
        self.query = query
        self.keyColumns = keyColumns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query = Query()
                    self.query.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.keyColumns = []
                    (_etype228, _size225) = iprot.readListBegin()
                    for _i229 in range(_size225):
                        _elem230 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.keyColumns.append(_elem230)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BootstrapPart')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 2)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRUCT, 3)
            self.query.write(oprot)
            oprot.writeFieldEnd()
        if self.keyColumns is not None:
            oprot.writeFieldBegin('keyColumns', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.keyColumns))
            for iter231 in self.keyColumns:
                oprot.writeString(iter231.encode('utf-8') if sys.version_info[0] == 2 else iter231)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GroupByServingInfo(object):
    """
    Attributes:
     - groupBy
     - inputAvroSchema
     - selectedAvroSchema
     - keyAvroSchema
     - batchEndDate
     - dateFormat

    """
    thrift_spec = None


    def __init__(self, groupBy = None, inputAvroSchema = None, selectedAvroSchema = None, keyAvroSchema = None, batchEndDate = None, dateFormat = None,):
        self.groupBy = groupBy
        self.inputAvroSchema = inputAvroSchema
        self.selectedAvroSchema = selectedAvroSchema
        self.keyAvroSchema = keyAvroSchema
        self.batchEndDate = batchEndDate
        self.dateFormat = dateFormat

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.groupBy = GroupBy()
                    self.groupBy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.inputAvroSchema = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.selectedAvroSchema = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.keyAvroSchema = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.batchEndDate = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.dateFormat = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GroupByServingInfo')
        if self.groupBy is not None:
            oprot.writeFieldBegin('groupBy', TType.STRUCT, 1)
            self.groupBy.write(oprot)
            oprot.writeFieldEnd()
        if self.inputAvroSchema is not None:
            oprot.writeFieldBegin('inputAvroSchema', TType.STRING, 2)
            oprot.writeString(self.inputAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.inputAvroSchema)
            oprot.writeFieldEnd()
        if self.selectedAvroSchema is not None:
            oprot.writeFieldBegin('selectedAvroSchema', TType.STRING, 3)
            oprot.writeString(self.selectedAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.selectedAvroSchema)
            oprot.writeFieldEnd()
        if self.keyAvroSchema is not None:
            oprot.writeFieldBegin('keyAvroSchema', TType.STRING, 4)
            oprot.writeString(self.keyAvroSchema.encode('utf-8') if sys.version_info[0] == 2 else self.keyAvroSchema)
            oprot.writeFieldEnd()
        if self.batchEndDate is not None:
            oprot.writeFieldBegin('batchEndDate', TType.STRING, 5)
            oprot.writeString(self.batchEndDate.encode('utf-8') if sys.version_info[0] == 2 else self.batchEndDate)
            oprot.writeFieldEnd()
        if self.dateFormat is not None:
            oprot.writeFieldBegin('dateFormat', TType.STRING, 6)
            oprot.writeString(self.dateFormat.encode('utf-8') if sys.version_info[0] == 2 else self.dateFormat)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DataField(object):
    """
    Attributes:
     - name
     - dataType

    """
    thrift_spec = None


    def __init__(self, name = None, dataType = None,):
        self.name = name
        self.dataType = dataType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dataType = TDataType()
                    self.dataType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DataField')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.STRUCT, 2)
            self.dataType.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataType(object):
    """
    Attributes:
     - kind
     - params
     - name

    """
    thrift_spec = None


    def __init__(self, kind = None, params = None, name = None,):
        self.kind = kind
        self.params = params
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.kind = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.params = []
                    (_etype235, _size232) = iprot.readListBegin()
                    for _i236 in range(_size232):
                        _elem237 = DataField()
                        _elem237.read(iprot)
                        self.params.append(_elem237)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataType')
        if self.kind is not None:
            oprot.writeFieldBegin('kind', TType.I32, 1)
            oprot.writeI32(self.kind)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.params))
            for iter238 in self.params:
                iter238.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DataSpec(object):
    """
    Attributes:
     - schema
     - partitionColumns
     - retentionDays
     - props

    """
    thrift_spec = None


    def __init__(self, schema = None, partitionColumns = None, retentionDays = None, props = None,):
        self.schema = schema
        self.partitionColumns = partitionColumns
        self.retentionDays = retentionDays
        self.props = props

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.schema = TDataType()
                    self.schema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partitionColumns = []
                    (_etype242, _size239) = iprot.readListBegin()
                    for _i243 in range(_size239):
                        _elem244 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.partitionColumns.append(_elem244)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.retentionDays = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.props = {}
                    (_ktype246, _vtype247, _size245) = iprot.readMapBegin()
                    for _i249 in range(_size245):
                        _key250 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val251 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.props[_key250] = _val251
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DataSpec')
        if self.schema is not None:
            oprot.writeFieldBegin('schema', TType.STRUCT, 1)
            self.schema.write(oprot)
            oprot.writeFieldEnd()
        if self.partitionColumns is not None:
            oprot.writeFieldBegin('partitionColumns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.partitionColumns))
            for iter252 in self.partitionColumns:
                oprot.writeString(iter252.encode('utf-8') if sys.version_info[0] == 2 else iter252)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.retentionDays is not None:
            oprot.writeFieldBegin('retentionDays', TType.I32, 3)
            oprot.writeI32(self.retentionDays)
            oprot.writeFieldEnd()
        if self.props is not None:
            oprot.writeFieldBegin('props', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.props))
            for kiter253, viter254 in self.props.items():
                oprot.writeString(kiter253.encode('utf-8') if sys.version_info[0] == 2 else kiter253)
                oprot.writeString(viter254.encode('utf-8') if sys.version_info[0] == 2 else viter254)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Team(object):
    """
    Attributes:
     - name
     - description
     - email
     - outputNamespace
     - tableProperties
     - env
     - conf
     - clusterConf

    """
    thrift_spec = None


    def __init__(self, name = None, description = None, email = None, outputNamespace = None, tableProperties = None, env = None, conf = None, clusterConf = None,):
        self.name = name
        self.description = description
        self.email = email
        self.outputNamespace = outputNamespace
        self.tableProperties = tableProperties
        self.env = env
        self.conf = conf
        self.clusterConf = clusterConf

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.outputNamespace = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.MAP:
                    self.tableProperties = {}
                    (_ktype256, _vtype257, _size255) = iprot.readMapBegin()
                    for _i259 in range(_size255):
                        _key260 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val261 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tableProperties[_key260] = _val261
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.env = gen_thrift.common.ttypes.EnvironmentVariables()
                    self.env.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.conf = gen_thrift.common.ttypes.ConfigProperties()
                    self.conf.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRUCT:
                    self.clusterConf = gen_thrift.common.ttypes.ClusterConfigProperties()
                    self.clusterConf.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Team')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 2)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 3)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.outputNamespace is not None:
            oprot.writeFieldBegin('outputNamespace', TType.STRING, 10)
            oprot.writeString(self.outputNamespace.encode('utf-8') if sys.version_info[0] == 2 else self.outputNamespace)
            oprot.writeFieldEnd()
        if self.tableProperties is not None:
            oprot.writeFieldBegin('tableProperties', TType.MAP, 11)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tableProperties))
            for kiter262, viter263 in self.tableProperties.items():
                oprot.writeString(kiter262.encode('utf-8') if sys.version_info[0] == 2 else kiter262)
                oprot.writeString(viter263.encode('utf-8') if sys.version_info[0] == 2 else viter263)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.env is not None:
            oprot.writeFieldBegin('env', TType.STRUCT, 20)
            self.env.write(oprot)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.STRUCT, 21)
            self.conf.write(oprot)
            oprot.writeFieldEnd()
        if self.clusterConf is not None:
            oprot.writeFieldBegin('clusterConf', TType.STRUCT, 22)
            self.clusterConf.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Model(object):
    """
    A Model represents a single ML model and includes details to help with model inference (batch & online)
    as well as model training and deployment orchestration

    Attributes:
     - metaData
     - inferenceSpec
     - inputMapping
     - outputMapping
     - valueSchema
     - modelArtifactBaseUri
     - trainingConf
     - deploymentConf

    """
    thrift_spec = None


    def __init__(self, metaData = None, inferenceSpec = None, inputMapping = None, outputMapping = None, valueSchema = None, modelArtifactBaseUri = None, trainingConf = None, deploymentConf = None,):
        self.metaData = metaData
        self.inferenceSpec = inferenceSpec
        self.inputMapping = inputMapping
        self.outputMapping = outputMapping
        self.valueSchema = valueSchema
        self.modelArtifactBaseUri = modelArtifactBaseUri
        self.trainingConf = trainingConf
        self.deploymentConf = deploymentConf

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.inferenceSpec = InferenceSpec()
                    self.inferenceSpec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.inputMapping = {}
                    (_ktype265, _vtype266, _size264) = iprot.readMapBegin()
                    for _i268 in range(_size264):
                        _key269 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val270 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.inputMapping[_key269] = _val270
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.outputMapping = {}
                    (_ktype272, _vtype273, _size271) = iprot.readMapBegin()
                    for _i275 in range(_size271):
                        _key276 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val277 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.outputMapping[_key276] = _val277
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.valueSchema = TDataType()
                    self.valueSchema.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.modelArtifactBaseUri = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.trainingConf = TrainingSpec()
                    self.trainingConf.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.deploymentConf = DeploymentSpec()
                    self.deploymentConf.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Model')
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 1)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.inferenceSpec is not None:
            oprot.writeFieldBegin('inferenceSpec', TType.STRUCT, 2)
            self.inferenceSpec.write(oprot)
            oprot.writeFieldEnd()
        if self.inputMapping is not None:
            oprot.writeFieldBegin('inputMapping', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.inputMapping))
            for kiter278, viter279 in self.inputMapping.items():
                oprot.writeString(kiter278.encode('utf-8') if sys.version_info[0] == 2 else kiter278)
                oprot.writeString(viter279.encode('utf-8') if sys.version_info[0] == 2 else viter279)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.outputMapping is not None:
            oprot.writeFieldBegin('outputMapping', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.outputMapping))
            for kiter280, viter281 in self.outputMapping.items():
                oprot.writeString(kiter280.encode('utf-8') if sys.version_info[0] == 2 else kiter280)
                oprot.writeString(viter281.encode('utf-8') if sys.version_info[0] == 2 else viter281)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.valueSchema is not None:
            oprot.writeFieldBegin('valueSchema', TType.STRUCT, 5)
            self.valueSchema.write(oprot)
            oprot.writeFieldEnd()
        if self.modelArtifactBaseUri is not None:
            oprot.writeFieldBegin('modelArtifactBaseUri', TType.STRING, 6)
            oprot.writeString(self.modelArtifactBaseUri.encode('utf-8') if sys.version_info[0] == 2 else self.modelArtifactBaseUri)
            oprot.writeFieldEnd()
        if self.trainingConf is not None:
            oprot.writeFieldBegin('trainingConf', TType.STRUCT, 7)
            self.trainingConf.write(oprot)
            oprot.writeFieldEnd()
        if self.deploymentConf is not None:
            oprot.writeFieldBegin('deploymentConf', TType.STRUCT, 8)
            self.deploymentConf.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InferenceSpec(object):
    """
    Attributes:
     - modelBackend
     - modelBackendParams
     - resourceConfig

    """
    thrift_spec = None


    def __init__(self, modelBackend = None, modelBackendParams = None, resourceConfig = None,):
        self.modelBackend = modelBackend
        self.modelBackendParams = modelBackendParams
        self.resourceConfig = resourceConfig

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.modelBackend = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modelBackendParams = {}
                    (_ktype283, _vtype284, _size282) = iprot.readMapBegin()
                    for _i286 in range(_size282):
                        _key287 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val288 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.modelBackendParams[_key287] = _val288
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.resourceConfig = ResourceConfig()
                    self.resourceConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InferenceSpec')
        if self.modelBackend is not None:
            oprot.writeFieldBegin('modelBackend', TType.I32, 1)
            oprot.writeI32(self.modelBackend)
            oprot.writeFieldEnd()
        if self.modelBackendParams is not None:
            oprot.writeFieldBegin('modelBackendParams', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.modelBackendParams))
            for kiter289, viter290 in self.modelBackendParams.items():
                oprot.writeString(kiter289.encode('utf-8') if sys.version_info[0] == 2 else kiter289)
                oprot.writeString(viter290.encode('utf-8') if sys.version_info[0] == 2 else viter290)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.resourceConfig is not None:
            oprot.writeFieldBegin('resourceConfig', TType.STRUCT, 3)
            self.resourceConfig.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ResourceConfig(object):
    """
    Attributes:
     - minReplicaCount
     - maxReplicaCount
     - machineType

    """
    thrift_spec = None


    def __init__(self, minReplicaCount = None, maxReplicaCount = None, machineType = None,):
        self.minReplicaCount = minReplicaCount
        self.maxReplicaCount = maxReplicaCount
        self.machineType = machineType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.minReplicaCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.maxReplicaCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.machineType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ResourceConfig')
        if self.minReplicaCount is not None:
            oprot.writeFieldBegin('minReplicaCount', TType.I32, 1)
            oprot.writeI32(self.minReplicaCount)
            oprot.writeFieldEnd()
        if self.maxReplicaCount is not None:
            oprot.writeFieldBegin('maxReplicaCount', TType.I32, 2)
            oprot.writeI32(self.maxReplicaCount)
            oprot.writeFieldEnd()
        if self.machineType is not None:
            oprot.writeFieldBegin('machineType', TType.STRING, 3)
            oprot.writeString(self.machineType.encode('utf-8') if sys.version_info[0] == 2 else self.machineType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ModelTransforms(object):
    """
    ModelTransforms allows us to take the output of an existing source (E.g. Event / Entity / Join) and
    enrich it with 1/more model outputs. This in-turn can be fed into downstream computations like GroupBy or hit directly
    via the fetcher. The GroupBy path allows for async materialization of model outputs to the online KV store for low latency
    serving. The fetcher path allows for on-demand model inference during online serving (at the cost of higher latency / more
    model inference calls).


    Attributes:
     - sources
     - models
     - passthroughFields
     - metaData
     - keySchema

    """
    thrift_spec = None


    def __init__(self, sources = None, models = None, passthroughFields = None, metaData = None, keySchema = None,):
        self.sources = sources
        self.models = models
        self.passthroughFields = passthroughFields
        self.metaData = metaData
        self.keySchema = keySchema

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.sources = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = Source()
                        _elem296.read(iprot)
                        self.sources.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.models = []
                    (_etype300, _size297) = iprot.readListBegin()
                    for _i301 in range(_size297):
                        _elem302 = Model()
                        _elem302.read(iprot)
                        self.models.append(_elem302)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.passthroughFields = []
                    (_etype306, _size303) = iprot.readListBegin()
                    for _i307 in range(_size303):
                        _elem308 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.passthroughFields.append(_elem308)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.metaData = MetaData()
                    self.metaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.keySchema = TDataType()
                    self.keySchema.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ModelTransforms')
        if self.sources is not None:
            oprot.writeFieldBegin('sources', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.sources))
            for iter309 in self.sources:
                iter309.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.models is not None:
            oprot.writeFieldBegin('models', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.models))
            for iter310 in self.models:
                iter310.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.passthroughFields is not None:
            oprot.writeFieldBegin('passthroughFields', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.passthroughFields))
            for iter311 in self.passthroughFields:
                oprot.writeString(iter311.encode('utf-8') if sys.version_info[0] == 2 else iter311)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metaData is not None:
            oprot.writeFieldBegin('metaData', TType.STRUCT, 4)
            self.metaData.write(oprot)
            oprot.writeFieldEnd()
        if self.keySchema is not None:
            oprot.writeFieldBegin('keySchema', TType.STRUCT, 5)
            self.keySchema.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TrainingSpec(object):
    """
    Attributes:
     - trainingDataSource
     - trainingDataWindow
     - schedule
     - image
     - pythonModule
     - resourceConfig
     - jobConfigs

    """
    thrift_spec = None


    def __init__(self, trainingDataSource = None, trainingDataWindow = None, schedule = None, image = None, pythonModule = None, resourceConfig = None, jobConfigs = None,):
        self.trainingDataSource = trainingDataSource
        self.trainingDataWindow = trainingDataWindow
        self.schedule = schedule
        self.image = image
        self.pythonModule = pythonModule
        self.resourceConfig = resourceConfig
        self.jobConfigs = jobConfigs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.trainingDataSource = Source()
                    self.trainingDataSource.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.trainingDataWindow = gen_thrift.common.ttypes.Window()
                    self.trainingDataWindow.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.schedule = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.image = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.pythonModule = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.resourceConfig = ResourceConfig()
                    self.resourceConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.jobConfigs = {}
                    (_ktype313, _vtype314, _size312) = iprot.readMapBegin()
                    for _i316 in range(_size312):
                        _key317 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val318 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.jobConfigs[_key317] = _val318
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TrainingSpec')
        if self.trainingDataSource is not None:
            oprot.writeFieldBegin('trainingDataSource', TType.STRUCT, 1)
            self.trainingDataSource.write(oprot)
            oprot.writeFieldEnd()
        if self.trainingDataWindow is not None:
            oprot.writeFieldBegin('trainingDataWindow', TType.STRUCT, 2)
            self.trainingDataWindow.write(oprot)
            oprot.writeFieldEnd()
        if self.schedule is not None:
            oprot.writeFieldBegin('schedule', TType.STRING, 3)
            oprot.writeString(self.schedule.encode('utf-8') if sys.version_info[0] == 2 else self.schedule)
            oprot.writeFieldEnd()
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRING, 4)
            oprot.writeString(self.image.encode('utf-8') if sys.version_info[0] == 2 else self.image)
            oprot.writeFieldEnd()
        if self.pythonModule is not None:
            oprot.writeFieldBegin('pythonModule', TType.STRING, 5)
            oprot.writeString(self.pythonModule.encode('utf-8') if sys.version_info[0] == 2 else self.pythonModule)
            oprot.writeFieldEnd()
        if self.resourceConfig is not None:
            oprot.writeFieldBegin('resourceConfig', TType.STRUCT, 6)
            self.resourceConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.jobConfigs is not None:
            oprot.writeFieldBegin('jobConfigs', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.jobConfigs))
            for kiter319, viter320 in self.jobConfigs.items():
                oprot.writeString(kiter319.encode('utf-8') if sys.version_info[0] == 2 else kiter319)
                oprot.writeString(viter320.encode('utf-8') if sys.version_info[0] == 2 else viter320)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ServingContainerConfig(object):
    """
    Attributes:
     - image
     - servingHealthRoute
     - servingPredictRoute
     - servingContainerEnvVars

    """
    thrift_spec = None


    def __init__(self, image = None, servingHealthRoute = None, servingPredictRoute = None, servingContainerEnvVars = None,):
        self.image = image
        self.servingHealthRoute = servingHealthRoute
        self.servingPredictRoute = servingPredictRoute
        self.servingContainerEnvVars = servingContainerEnvVars

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.image = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.servingHealthRoute = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.servingPredictRoute = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.servingContainerEnvVars = {}
                    (_ktype322, _vtype323, _size321) = iprot.readMapBegin()
                    for _i325 in range(_size321):
                        _key326 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val327 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.servingContainerEnvVars[_key326] = _val327
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ServingContainerConfig')
        if self.image is not None:
            oprot.writeFieldBegin('image', TType.STRING, 1)
            oprot.writeString(self.image.encode('utf-8') if sys.version_info[0] == 2 else self.image)
            oprot.writeFieldEnd()
        if self.servingHealthRoute is not None:
            oprot.writeFieldBegin('servingHealthRoute', TType.STRING, 2)
            oprot.writeString(self.servingHealthRoute.encode('utf-8') if sys.version_info[0] == 2 else self.servingHealthRoute)
            oprot.writeFieldEnd()
        if self.servingPredictRoute is not None:
            oprot.writeFieldBegin('servingPredictRoute', TType.STRING, 3)
            oprot.writeString(self.servingPredictRoute.encode('utf-8') if sys.version_info[0] == 2 else self.servingPredictRoute)
            oprot.writeFieldEnd()
        if self.servingContainerEnvVars is not None:
            oprot.writeFieldBegin('servingContainerEnvVars', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.servingContainerEnvVars))
            for kiter328, viter329 in self.servingContainerEnvVars.items():
                oprot.writeString(kiter328.encode('utf-8') if sys.version_info[0] == 2 else kiter328)
                oprot.writeString(viter329.encode('utf-8') if sys.version_info[0] == 2 else viter329)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EndpointConfig(object):
    """
    Endpoints are the serving targets for deployed models.


    Attributes:
     - endpointName
     - additionalConfigs

    """
    thrift_spec = None


    def __init__(self, endpointName = None, additionalConfigs = None,):
        self.endpointName = endpointName
        self.additionalConfigs = additionalConfigs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.endpointName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.additionalConfigs = {}
                    (_ktype331, _vtype332, _size330) = iprot.readMapBegin()
                    for _i334 in range(_size330):
                        _key335 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val336 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.additionalConfigs[_key335] = _val336
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EndpointConfig')
        if self.endpointName is not None:
            oprot.writeFieldBegin('endpointName', TType.STRING, 1)
            oprot.writeString(self.endpointName.encode('utf-8') if sys.version_info[0] == 2 else self.endpointName)
            oprot.writeFieldEnd()
        if self.additionalConfigs is not None:
            oprot.writeFieldBegin('additionalConfigs', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.additionalConfigs))
            for kiter337, viter338 in self.additionalConfigs.items():
                oprot.writeString(kiter337.encode('utf-8') if sys.version_info[0] == 2 else kiter337)
                oprot.writeString(viter338.encode('utf-8') if sys.version_info[0] == 2 else viter338)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Metric(object):
    """
    Attributes:
     - name
     - threshold

    """
    thrift_spec = None


    def __init__(self, name = None, threshold = None,):
        self.name = name
        self.threshold = threshold

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.threshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Metric')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.threshold is not None:
            oprot.writeFieldBegin('threshold', TType.DOUBLE, 2)
            oprot.writeDouble(self.threshold)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RolloutStrategy(object):
    """
    Attributes:
     - rolloutType
     - validationTrafficPercentRamps
     - validationTrafficDurationMins
     - rolloutMetricThresholds

    """
    thrift_spec = None


    def __init__(self, rolloutType = None, validationTrafficPercentRamps = None, validationTrafficDurationMins = None, rolloutMetricThresholds = None,):
        self.rolloutType = rolloutType
        self.validationTrafficPercentRamps = validationTrafficPercentRamps
        self.validationTrafficDurationMins = validationTrafficDurationMins
        self.rolloutMetricThresholds = rolloutMetricThresholds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.rolloutType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.validationTrafficPercentRamps = []
                    (_etype342, _size339) = iprot.readListBegin()
                    for _i343 in range(_size339):
                        _elem344 = iprot.readI32()
                        self.validationTrafficPercentRamps.append(_elem344)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.validationTrafficDurationMins = []
                    (_etype348, _size345) = iprot.readListBegin()
                    for _i349 in range(_size345):
                        _elem350 = iprot.readI32()
                        self.validationTrafficDurationMins.append(_elem350)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.rolloutMetricThresholds = []
                    (_etype354, _size351) = iprot.readListBegin()
                    for _i355 in range(_size351):
                        _elem356 = Metric()
                        _elem356.read(iprot)
                        self.rolloutMetricThresholds.append(_elem356)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RolloutStrategy')
        if self.rolloutType is not None:
            oprot.writeFieldBegin('rolloutType', TType.I32, 1)
            oprot.writeI32(self.rolloutType)
            oprot.writeFieldEnd()
        if self.validationTrafficPercentRamps is not None:
            oprot.writeFieldBegin('validationTrafficPercentRamps', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.validationTrafficPercentRamps))
            for iter357 in self.validationTrafficPercentRamps:
                oprot.writeI32(iter357)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.validationTrafficDurationMins is not None:
            oprot.writeFieldBegin('validationTrafficDurationMins', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.validationTrafficDurationMins))
            for iter358 in self.validationTrafficDurationMins:
                oprot.writeI32(iter358)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rolloutMetricThresholds is not None:
            oprot.writeFieldBegin('rolloutMetricThresholds', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.rolloutMetricThresholds))
            for iter359 in self.rolloutMetricThresholds:
                iter359.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DeploymentSpec(object):
    """
    Attributes:
     - containerConfig
     - endpointConfig
     - resourceConfig
     - rolloutStrategy

    """
    thrift_spec = None


    def __init__(self, containerConfig = None, endpointConfig = None, resourceConfig = None, rolloutStrategy = None,):
        self.containerConfig = containerConfig
        self.endpointConfig = endpointConfig
        self.resourceConfig = resourceConfig
        self.rolloutStrategy = rolloutStrategy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.containerConfig = ServingContainerConfig()
                    self.containerConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.endpointConfig = EndpointConfig()
                    self.endpointConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.resourceConfig = ResourceConfig()
                    self.resourceConfig.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.rolloutStrategy = RolloutStrategy()
                    self.rolloutStrategy.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeploymentSpec')
        if self.containerConfig is not None:
            oprot.writeFieldBegin('containerConfig', TType.STRUCT, 1)
            self.containerConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.endpointConfig is not None:
            oprot.writeFieldBegin('endpointConfig', TType.STRUCT, 2)
            self.endpointConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.resourceConfig is not None:
            oprot.writeFieldBegin('resourceConfig', TType.STRUCT, 3)
            self.resourceConfig.write(oprot)
            oprot.writeFieldEnd()
        if self.rolloutStrategy is not None:
            oprot.writeFieldBegin('rolloutStrategy', TType.STRUCT, 4)
            self.rolloutStrategy.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Query)
Query.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'selects', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'wheres', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'startPartition', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'endPartition', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'timeColumn', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'setups', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRING, 'mutationTimeColumn', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'reversalColumn', 'UTF8', None, ),  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRING, 'partitionColumn', 'UTF8', None, ),  # 20
    (21, TType.STRING, 'partitionFormat', 'UTF8', None, ),  # 21
    (22, TType.STRUCT, 'partitionInterval', [gen_thrift.common.ttypes.Window, None], None, ),  # 22
    (23, TType.STRUCT, 'partitionLag', [gen_thrift.common.ttypes.Window, None], None, ),  # 23
    (24, TType.LIST, 'subPartitionsToWaitFor', (TType.STRING, 'UTF8', False), None, ),  # 24
    (25, TType.BOOL, 'clustered', None, None, ),  # 25
)
all_structs.append(StagingQuery)
StagingQuery.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRING, 'query', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'startPartition', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'setups', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I32, 'engineType', None, None, ),  # 5
    (6, TType.LIST, 'tableDependencies', (TType.STRUCT, [gen_thrift.common.ttypes.TableDependency, None], False), None, ),  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.I32, 'recomputeDays', None, None, ),  # 20
)
all_structs.append(EventSource)
EventSource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'topic', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'query', [Query, None], None, ),  # 3
    (4, TType.BOOL, 'isCumulative', None, None, ),  # 4
)
all_structs.append(EntitySource)
EntitySource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'snapshotTable', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mutationTable', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'mutationTopic', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'query', [Query, None], None, ),  # 4
)
all_structs.append(ExternalSource)
ExternalSource.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metadata', [MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'keySchema', [TDataType, None], None, ),  # 2
    (3, TType.STRUCT, 'valueSchema', [TDataType, None], None, ),  # 3
)
all_structs.append(JoinSource)
JoinSource.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'join', [Join, None], None, ),  # 1
    (2, TType.STRUCT, 'query', [Query, None], None, ),  # 2
)
all_structs.append(Source)
Source.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'events', [EventSource, None], None, ),  # 1
    (2, TType.STRUCT, 'entities', [EntitySource, None], None, ),  # 2
    (3, TType.STRUCT, 'joinSource', [JoinSource, None], None, ),  # 3
    (4, TType.STRUCT, 'modelTransforms', [ModelTransforms, None], None, ),  # 4
)
all_structs.append(Aggregation)
Aggregation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'inputColumn', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operation', None, None, ),  # 2
    (3, TType.MAP, 'argMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'windows', (TType.STRUCT, [gen_thrift.common.ttypes.Window, None], False), None, ),  # 4
    (5, TType.LIST, 'buckets', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(AggregationPart)
AggregationPart.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'inputColumn', 'UTF8', None, ),  # 1
    (2, TType.I32, 'operation', None, None, ),  # 2
    (3, TType.MAP, 'argMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'window', [gen_thrift.common.ttypes.Window, None], None, ),  # 4
    (5, TType.STRING, 'bucket', 'UTF8', None, ),  # 5
)
all_structs.append(MetaData)
MetaData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'team', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'version', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'outputNamespace', 'UTF8', None, ),  # 4
    (5, TType.LIST, 'additionalOutputPartitionColumns', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.MAP, 'tableProperties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.MAP, 'tags', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 20
    (21, TType.MAP, 'columnTags', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 21
    (22, TType.MAP, 'columnHashes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.BOOL, 'online', None, None, ),  # 100
    (101, TType.BOOL, 'production', None, None, ),  # 101
    (102, TType.STRING, 'sourceFile', 'UTF8', None, ),  # 102
    (103, TType.STRING, 'customJson', 'UTF8', None, ),  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.BOOL, 'consistencyCheck', None, None, ),  # 200
    (201, TType.DOUBLE, 'samplePercent', None, None, ),  # 201
    (202, TType.DOUBLE, 'consistencySamplePercent', None, None, ),  # 202
    (203, TType.STRUCT, 'driftSpec', [gen_thrift.observability.ttypes.DriftSpec, None], None, ),  # 203
    (204, TType.STRUCT, 'executionInfo', [gen_thrift.common.ttypes.ExecutionInfo, None], None, ),  # 204
)
all_structs.append(Conf)
Conf.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'hash', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'contents', 'UTF8', None, ),  # 3
    (4, TType.I32, 'confType', None, None, ),  # 4
)
all_structs.append(GroupBy)
GroupBy.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.LIST, 'sources', (TType.STRUCT, [Source, None], False), None, ),  # 2
    (3, TType.LIST, 'keyColumns', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'aggregations', (TType.STRUCT, [Aggregation, None], False), None, ),  # 4
    (5, TType.I32, 'accuracy', None, None, ),  # 5
    None,  # 6
    (7, TType.LIST, 'derivations', (TType.STRUCT, [Derivation, None], False), None, ),  # 7
)
all_structs.append(JoinPart)
JoinPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'groupBy', [GroupBy, None], None, ),  # 1
    (2, TType.MAP, 'keyMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'prefix', 'UTF8', None, ),  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.BOOL, 'useLongNames', None, None, ),  # 10
)
all_structs.append(ExternalPart)
ExternalPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'source', [ExternalSource, None], None, ),  # 1
    (2, TType.MAP, 'keyMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'prefix', 'UTF8', None, ),  # 3
)
all_structs.append(Derivation)
Derivation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'expression', 'UTF8', None, ),  # 2
)
all_structs.append(Join)
Join.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'left', [Source, None], None, ),  # 2
    (3, TType.LIST, 'joinParts', (TType.STRUCT, [JoinPart, None], False), None, ),  # 3
    (4, TType.MAP, 'skewKeys', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'onlineExternalParts', (TType.STRUCT, [ExternalPart, None], False), None, ),  # 5
    None,  # 6
    (7, TType.LIST, 'bootstrapParts', (TType.STRUCT, [BootstrapPart, None], False), None, ),  # 7
    (8, TType.LIST, 'rowIds', (TType.STRING, 'UTF8', False), None, ),  # 8
    (9, TType.LIST, 'derivations', (TType.STRUCT, [Derivation, None], False), None, ),  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    (50, TType.BOOL, 'useLongNames', None, None, ),  # 50
)
all_structs.append(BootstrapPart)
BootstrapPart.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRING, 'table', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'query', [Query, None], None, ),  # 3
    (4, TType.LIST, 'keyColumns', (TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(GroupByServingInfo)
GroupByServingInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'groupBy', [GroupBy, None], None, ),  # 1
    (2, TType.STRING, 'inputAvroSchema', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'selectedAvroSchema', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'keyAvroSchema', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'batchEndDate', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'dateFormat', 'UTF8', None, ),  # 6
)
all_structs.append(DataField)
DataField.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'dataType', [TDataType, None], None, ),  # 2
)
all_structs.append(TDataType)
TDataType.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'kind', None, None, ),  # 1
    (2, TType.LIST, 'params', (TType.STRUCT, [DataField, None], False), None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
)
all_structs.append(DataSpec)
DataSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'schema', [TDataType, None], None, ),  # 1
    (2, TType.LIST, 'partitionColumns', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'retentionDays', None, None, ),  # 3
    (4, TType.MAP, 'props', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(Team)
Team.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'description', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'email', 'UTF8', None, ),  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.STRING, 'outputNamespace', 'UTF8', None, ),  # 10
    (11, TType.MAP, 'tableProperties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.STRUCT, 'env', [gen_thrift.common.ttypes.EnvironmentVariables, None], None, ),  # 20
    (21, TType.STRUCT, 'conf', [gen_thrift.common.ttypes.ConfigProperties, None], None, ),  # 21
    (22, TType.STRUCT, 'clusterConf', [gen_thrift.common.ttypes.ClusterConfigProperties, None], None, ),  # 22
)
all_structs.append(Model)
Model.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 1
    (2, TType.STRUCT, 'inferenceSpec', [InferenceSpec, None], None, ),  # 2
    (3, TType.MAP, 'inputMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.MAP, 'outputMapping', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'valueSchema', [TDataType, None], None, ),  # 5
    (6, TType.STRING, 'modelArtifactBaseUri', 'UTF8', None, ),  # 6
    (7, TType.STRUCT, 'trainingConf', [TrainingSpec, None], None, ),  # 7
    (8, TType.STRUCT, 'deploymentConf', [DeploymentSpec, None], None, ),  # 8
)
all_structs.append(InferenceSpec)
InferenceSpec.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'modelBackend', None, None, ),  # 1
    (2, TType.MAP, 'modelBackendParams', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRUCT, 'resourceConfig', [ResourceConfig, None], None, ),  # 3
)
all_structs.append(ResourceConfig)
ResourceConfig.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'minReplicaCount', None, None, ),  # 1
    (2, TType.I32, 'maxReplicaCount', None, None, ),  # 2
    (3, TType.STRING, 'machineType', 'UTF8', None, ),  # 3
)
all_structs.append(ModelTransforms)
ModelTransforms.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'sources', (TType.STRUCT, [Source, None], False), None, ),  # 1
    (2, TType.LIST, 'models', (TType.STRUCT, [Model, None], False), None, ),  # 2
    (3, TType.LIST, 'passthroughFields', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRUCT, 'metaData', [MetaData, None], None, ),  # 4
    (5, TType.STRUCT, 'keySchema', [TDataType, None], None, ),  # 5
)
all_structs.append(TrainingSpec)
TrainingSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'trainingDataSource', [Source, None], None, ),  # 1
    (2, TType.STRUCT, 'trainingDataWindow', [gen_thrift.common.ttypes.Window, None], None, ),  # 2
    (3, TType.STRING, 'schedule', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'image', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'pythonModule', 'UTF8', None, ),  # 5
    (6, TType.STRUCT, 'resourceConfig', [ResourceConfig, None], None, ),  # 6
    (7, TType.MAP, 'jobConfigs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 7
)
all_structs.append(ServingContainerConfig)
ServingContainerConfig.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'image', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'servingHealthRoute', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'servingPredictRoute', 'UTF8', None, ),  # 3
    (4, TType.MAP, 'servingContainerEnvVars', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(EndpointConfig)
EndpointConfig.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'endpointName', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'additionalConfigs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(Metric)
Metric.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'threshold', None, None, ),  # 2
)
all_structs.append(RolloutStrategy)
RolloutStrategy.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'rolloutType', None, None, ),  # 1
    (2, TType.LIST, 'validationTrafficPercentRamps', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'validationTrafficDurationMins', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'rolloutMetricThresholds', (TType.STRUCT, [Metric, None], False), None, ),  # 4
)
all_structs.append(DeploymentSpec)
DeploymentSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'containerConfig', [ServingContainerConfig, None], None, ),  # 1
    (2, TType.STRUCT, 'endpointConfig', [EndpointConfig, None], None, ),  # 2
    (3, TType.STRUCT, 'resourceConfig', [ResourceConfig, None], None, ),  # 3
    (4, TType.STRUCT, 'rolloutStrategy', [RolloutStrategy, None], None, ),  # 4
)
fix_spec(all_structs)
del all_structs
