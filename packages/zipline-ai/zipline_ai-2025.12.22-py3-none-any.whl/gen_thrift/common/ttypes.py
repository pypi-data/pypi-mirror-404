#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec
from uuid import UUID

import sys

from thrift.transport import TTransport
all_structs = []


class TimeUnit(object):
    HOURS = 0
    DAYS = 1
    MINUTES = 2

    _VALUES_TO_NAMES = {
        0: "HOURS",
        1: "DAYS",
        2: "MINUTES",
    }

    _NAMES_TO_VALUES = {
        "HOURS": 0,
        "DAYS": 1,
        "MINUTES": 2,
    }


class KvScanStrategy(object):
    ALL = 0
    LATEST = 1

    _VALUES_TO_NAMES = {
        0: "ALL",
        1: "LATEST",
    }

    _NAMES_TO_VALUES = {
        "ALL": 0,
        "LATEST": 1,
    }


class Window(object):
    """
    Attributes:
     - length
     - timeUnit

    """
    thrift_spec = None


    def __init__(self, length = None, timeUnit = None,):
        self.length = length
        self.timeUnit = timeUnit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeUnit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Window')
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 1)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        if self.timeUnit is not None:
            oprot.writeFieldBegin('timeUnit', TType.I32, 2)
            oprot.writeI32(self.timeUnit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DateRange(object):
    """
    Attributes:
     - startDate
     - endDate

    """
    thrift_spec = None


    def __init__(self, startDate = None, endDate = None,):
        self.startDate = startDate
        self.endDate = endDate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.startDate = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.endDate = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DateRange')
        if self.startDate is not None:
            oprot.writeFieldBegin('startDate', TType.STRING, 1)
            oprot.writeString(self.startDate.encode('utf-8') if sys.version_info[0] == 2 else self.startDate)
            oprot.writeFieldEnd()
        if self.endDate is not None:
            oprot.writeFieldBegin('endDate', TType.STRING, 2)
            oprot.writeString(self.endDate.encode('utf-8') if sys.version_info[0] == 2 else self.endDate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EnvironmentVariables(object):
    """
    env vars for different modes of execution - with "common" applying to all modes
    the submitter will set these env vars prior to launching the job

    these env vars are layered in order of priority
      1. company file defaults specified in teams.py - in the "common" team
      2. team wide defaults that apply to all objects in the team folder
      3. object specific defaults - applies to only the object that are declares them

    All the maps from the above three places are merged to create final env var


    Attributes:
     - common
     - modeEnvironments

    """
    thrift_spec = None


    def __init__(self, common = None, modeEnvironments = None,):
        self.common = common
        self.modeEnvironments = modeEnvironments

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.common = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.common[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modeEnvironments = {}
                    (_ktype8, _vtype9, _size7) = iprot.readMapBegin()
                    for _i11 in range(_size7):
                        _key12 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val13 = {}
                        (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
                        for _i18 in range(_size14):
                            _key19 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val20 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val13[_key19] = _val20
                        iprot.readMapEnd()
                        self.modeEnvironments[_key12] = _val13
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EnvironmentVariables')
        if self.common is not None:
            oprot.writeFieldBegin('common', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.common))
            for kiter21, viter22 in self.common.items():
                oprot.writeString(kiter21.encode('utf-8') if sys.version_info[0] == 2 else kiter21)
                oprot.writeString(viter22.encode('utf-8') if sys.version_info[0] == 2 else viter22)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.modeEnvironments is not None:
            oprot.writeFieldBegin('modeEnvironments', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.modeEnvironments))
            for kiter23, viter24 in self.modeEnvironments.items():
                oprot.writeString(kiter23.encode('utf-8') if sys.version_info[0] == 2 else kiter23)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter24))
                for kiter25, viter26 in viter24.items():
                    oprot.writeString(kiter25.encode('utf-8') if sys.version_info[0] == 2 else kiter25)
                    oprot.writeString(viter26.encode('utf-8') if sys.version_info[0] == 2 else viter26)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfigProperties(object):
    """
    job config for different modes of execution - with "common" applying to all modes
    usually these are spark or flink conf params like "spark.executor.memory" etc

    these confs are layered in order of priority
      1. company file defaults specified in teams.py - in the "common" team
      2. team wide defaults that apply to all objects in the team folder
      3. object specific defaults - applies to only the object that are declares them

    All the maps from the above three places are merged to create final conf map


    Attributes:
     - common
     - modeConfigs

    """
    thrift_spec = None


    def __init__(self, common = None, modeConfigs = None,):
        self.common = common
        self.modeConfigs = modeConfigs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.common = {}
                    (_ktype28, _vtype29, _size27) = iprot.readMapBegin()
                    for _i31 in range(_size27):
                        _key32 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.common[_key32] = _val33
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modeConfigs = {}
                    (_ktype35, _vtype36, _size34) = iprot.readMapBegin()
                    for _i38 in range(_size34):
                        _key39 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val40 = {}
                        (_ktype42, _vtype43, _size41) = iprot.readMapBegin()
                        for _i45 in range(_size41):
                            _key46 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val47 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val40[_key46] = _val47
                        iprot.readMapEnd()
                        self.modeConfigs[_key39] = _val40
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfigProperties')
        if self.common is not None:
            oprot.writeFieldBegin('common', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.common))
            for kiter48, viter49 in self.common.items():
                oprot.writeString(kiter48.encode('utf-8') if sys.version_info[0] == 2 else kiter48)
                oprot.writeString(viter49.encode('utf-8') if sys.version_info[0] == 2 else viter49)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.modeConfigs is not None:
            oprot.writeFieldBegin('modeConfigs', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.modeConfigs))
            for kiter50, viter51 in self.modeConfigs.items():
                oprot.writeString(kiter50.encode('utf-8') if sys.version_info[0] == 2 else kiter50)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter51))
                for kiter52, viter53 in viter51.items():
                    oprot.writeString(kiter52.encode('utf-8') if sys.version_info[0] == 2 else kiter52)
                    oprot.writeString(viter53.encode('utf-8') if sys.version_info[0] == 2 else viter53)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ClusterConfigProperties(object):
    """
    Cluster config for different modes of execution as a json string - with "common" applying to all modes
    These are settings for creating a new cluster for running the job

    these confs are layered in order of priority
      1. company file defaults specified in teams.py - in the "common" team
      2. team wide defaults that apply to all objects in the team folder
      3. object specific defaults - applies to only the object that are declares them

      All the maps from the above three places are merged to create final cluster config


    Attributes:
     - common
     - modeClusterConfigs

    """
    thrift_spec = None


    def __init__(self, common = None, modeClusterConfigs = None,):
        self.common = common
        self.modeClusterConfigs = modeClusterConfigs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.common = {}
                    (_ktype55, _vtype56, _size54) = iprot.readMapBegin()
                    for _i58 in range(_size54):
                        _key59 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val60 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.common[_key59] = _val60
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.modeClusterConfigs = {}
                    (_ktype62, _vtype63, _size61) = iprot.readMapBegin()
                    for _i65 in range(_size61):
                        _key66 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val67 = {}
                        (_ktype69, _vtype70, _size68) = iprot.readMapBegin()
                        for _i72 in range(_size68):
                            _key73 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val74 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val67[_key73] = _val74
                        iprot.readMapEnd()
                        self.modeClusterConfigs[_key66] = _val67
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ClusterConfigProperties')
        if self.common is not None:
            oprot.writeFieldBegin('common', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.common))
            for kiter75, viter76 in self.common.items():
                oprot.writeString(kiter75.encode('utf-8') if sys.version_info[0] == 2 else kiter75)
                oprot.writeString(viter76.encode('utf-8') if sys.version_info[0] == 2 else viter76)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.modeClusterConfigs is not None:
            oprot.writeFieldBegin('modeClusterConfigs', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.modeClusterConfigs))
            for kiter77, viter78 in self.modeClusterConfigs.items():
                oprot.writeString(kiter77.encode('utf-8') if sys.version_info[0] == 2 else kiter77)
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter78))
                for kiter79, viter80 in viter78.items():
                    oprot.writeString(kiter79.encode('utf-8') if sys.version_info[0] == 2 else kiter79)
                    oprot.writeString(viter80.encode('utf-8') if sys.version_info[0] == 2 else viter80)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableInfo(object):
    """
    Attributes:
     - table
     - partitionColumn
     - partitionFormat
     - partitionInterval
     - isCumulative: If isCumulative is true, then for a given output partition any single partition from input on or after the output
    is sufficient. What this means is that latest available partition prior to end cut off will be used.

     - triggerExpr: Some append only, unpartitioned tables (bigtable subscriptions, delta tables) may require special handling for
    when to trigger the downstream nodes. For this case we add a trigger expression that is going to be compared
    against the end of the partition range to compute.
    For example. If there's a timestamp in defined.
    triggerExpr = DATE(MAX(ts)) generates a sensor that triggers when
    SELECT DATE(MAX(ts)) > DATE '{{ ds }}' FROM table
    returns true.
    This only takes effect for the external tables -> Chronon tables entrypoint. All chronon tables are partitioned.


    """
    thrift_spec = None


    def __init__(self, table = None, partitionColumn = None, partitionFormat = None, partitionInterval = None, isCumulative = None, triggerExpr = None,):
        self.table = table
        self.partitionColumn = partitionColumn
        self.partitionFormat = partitionFormat
        self.partitionInterval = partitionInterval
        self.isCumulative = isCumulative
        self.triggerExpr = triggerExpr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 100:
                if ftype == TType.STRING:
                    self.partitionColumn = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 101:
                if ftype == TType.STRING:
                    self.partitionFormat = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 102:
                if ftype == TType.STRUCT:
                    self.partitionInterval = Window()
                    self.partitionInterval.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.BOOL:
                    self.isCumulative = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 300:
                if ftype == TType.STRING:
                    self.triggerExpr = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableInfo')
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 1)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.partitionColumn is not None:
            oprot.writeFieldBegin('partitionColumn', TType.STRING, 100)
            oprot.writeString(self.partitionColumn.encode('utf-8') if sys.version_info[0] == 2 else self.partitionColumn)
            oprot.writeFieldEnd()
        if self.partitionFormat is not None:
            oprot.writeFieldBegin('partitionFormat', TType.STRING, 101)
            oprot.writeString(self.partitionFormat.encode('utf-8') if sys.version_info[0] == 2 else self.partitionFormat)
            oprot.writeFieldEnd()
        if self.partitionInterval is not None:
            oprot.writeFieldBegin('partitionInterval', TType.STRUCT, 102)
            self.partitionInterval.write(oprot)
            oprot.writeFieldEnd()
        if self.isCumulative is not None:
            oprot.writeFieldBegin('isCumulative', TType.BOOL, 200)
            oprot.writeBool(self.isCumulative)
            oprot.writeFieldEnd()
        if self.triggerExpr is not None:
            oprot.writeFieldBegin('triggerExpr', TType.STRING, 300)
            oprot.writeString(self.triggerExpr.encode('utf-8') if sys.version_info[0] == 2 else self.triggerExpr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TableDependency(object):
    """
    Attributes:
     - tableInfo
     - startOffset
     - endOffset
     - startCutOff
     - endCutOff
     - isSoftNodeDependency
     - semanticHash
     - forceCompute: JoinParts could use data from batch backfill-s or upload tables when available
    When not available they shouldn't force computation of the backfills and upload tables.


    """
    thrift_spec = None


    def __init__(self, tableInfo = None, startOffset = None, endOffset = None, startCutOff = None, endCutOff = None, isSoftNodeDependency = None, semanticHash = None, forceCompute = None,):
        self.tableInfo = tableInfo
        self.startOffset = startOffset
        self.endOffset = endOffset
        self.startCutOff = startCutOff
        self.endCutOff = endCutOff
        self.isSoftNodeDependency = isSoftNodeDependency
        self.semanticHash = semanticHash
        self.forceCompute = forceCompute

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tableInfo = TableInfo()
                    self.tableInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.startOffset = Window()
                    self.startOffset.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.endOffset = Window()
                    self.endOffset.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.startCutOff = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.endCutOff = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isSoftNodeDependency = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.semanticHash = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 201:
                if ftype == TType.BOOL:
                    self.forceCompute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TableDependency')
        if self.tableInfo is not None:
            oprot.writeFieldBegin('tableInfo', TType.STRUCT, 1)
            self.tableInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.startOffset is not None:
            oprot.writeFieldBegin('startOffset', TType.STRUCT, 2)
            self.startOffset.write(oprot)
            oprot.writeFieldEnd()
        if self.endOffset is not None:
            oprot.writeFieldBegin('endOffset', TType.STRUCT, 3)
            self.endOffset.write(oprot)
            oprot.writeFieldEnd()
        if self.startCutOff is not None:
            oprot.writeFieldBegin('startCutOff', TType.STRING, 4)
            oprot.writeString(self.startCutOff.encode('utf-8') if sys.version_info[0] == 2 else self.startCutOff)
            oprot.writeFieldEnd()
        if self.endCutOff is not None:
            oprot.writeFieldBegin('endCutOff', TType.STRING, 5)
            oprot.writeString(self.endCutOff.encode('utf-8') if sys.version_info[0] == 2 else self.endCutOff)
            oprot.writeFieldEnd()
        if self.isSoftNodeDependency is not None:
            oprot.writeFieldBegin('isSoftNodeDependency', TType.BOOL, 6)
            oprot.writeBool(self.isSoftNodeDependency)
            oprot.writeFieldEnd()
        if self.semanticHash is not None:
            oprot.writeFieldBegin('semanticHash', TType.STRING, 7)
            oprot.writeString(self.semanticHash.encode('utf-8') if sys.version_info[0] == 2 else self.semanticHash)
            oprot.writeFieldEnd()
        if self.forceCompute is not None:
            oprot.writeFieldBegin('forceCompute', TType.BOOL, 201)
            oprot.writeBool(self.forceCompute)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KvInfo(object):
    """
    Attributes:
     - cluster
     - table
     - keyBase64

    """
    thrift_spec = None


    def __init__(self, cluster = None, table = None, keyBase64 = None,):
        self.cluster = cluster
        self.table = table
        self.keyBase64 = keyBase64

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.keyBase64 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KvInfo')
        if self.cluster is not None:
            oprot.writeFieldBegin('cluster', TType.STRING, 1)
            oprot.writeString(self.cluster.encode('utf-8') if sys.version_info[0] == 2 else self.cluster)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRING, 2)
            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
            oprot.writeFieldEnd()
        if self.keyBase64 is not None:
            oprot.writeFieldBegin('keyBase64', TType.STRING, 3)
            oprot.writeString(self.keyBase64.encode('utf-8') if sys.version_info[0] == 2 else self.keyBase64)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class KvDependency(object):
    """
    Attributes:
     - kvInfo
     - startMillis
     - endMillis
     - scanStrategy

    """
    thrift_spec = None


    def __init__(self, kvInfo = None, startMillis = None, endMillis = None, scanStrategy = None,):
        self.kvInfo = kvInfo
        self.startMillis = startMillis
        self.endMillis = endMillis
        self.scanStrategy = scanStrategy

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.kvInfo = KvInfo()
                    self.kvInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.startMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.endMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I32:
                    self.scanStrategy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KvDependency')
        if self.kvInfo is not None:
            oprot.writeFieldBegin('kvInfo', TType.STRUCT, 1)
            self.kvInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.startMillis is not None:
            oprot.writeFieldBegin('startMillis', TType.I64, 10)
            oprot.writeI64(self.startMillis)
            oprot.writeFieldEnd()
        if self.endMillis is not None:
            oprot.writeFieldBegin('endMillis', TType.I64, 11)
            oprot.writeI64(self.endMillis)
            oprot.writeFieldEnd()
        if self.scanStrategy is not None:
            oprot.writeFieldBegin('scanStrategy', TType.I32, 20)
            oprot.writeI32(self.scanStrategy)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExecutionInfo(object):
    """
    Attributes:
     - env
     - conf
     - dependencyPollIntervalMillis
     - healthCheckIntervalMillis
     - clusterConf
     - offlineSchedule
     - stepDays
     - historicalBackfill
     - tableDependencies
     - outputTableInfo
     - enableStatsCompute
     - onlineSchedule
     - kvDependencies
     - outputKvInfo
     - kvPollIntervalMillis

    """
    thrift_spec = None


    def __init__(self, env = None, conf = None, dependencyPollIntervalMillis = None, healthCheckIntervalMillis = None, clusterConf = None, offlineSchedule = None, stepDays = None, historicalBackfill = None, tableDependencies = None, outputTableInfo = None, enableStatsCompute = None, onlineSchedule = None, kvDependencies = None, outputKvInfo = None, kvPollIntervalMillis = None,):
        self.env = env
        self.conf = conf
        self.dependencyPollIntervalMillis = dependencyPollIntervalMillis
        self.healthCheckIntervalMillis = healthCheckIntervalMillis
        self.clusterConf = clusterConf
        self.offlineSchedule = offlineSchedule
        self.stepDays = stepDays
        self.historicalBackfill = historicalBackfill
        self.tableDependencies = tableDependencies
        self.outputTableInfo = outputTableInfo
        self.enableStatsCompute = enableStatsCompute
        self.onlineSchedule = onlineSchedule
        self.kvDependencies = kvDependencies
        self.outputKvInfo = outputKvInfo
        self.kvPollIntervalMillis = kvPollIntervalMillis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.env = EnvironmentVariables()
                    self.env.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.conf = ConfigProperties()
                    self.conf.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.dependencyPollIntervalMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.healthCheckIntervalMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.clusterConf = ClusterConfigProperties()
                    self.clusterConf.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.offlineSchedule = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.stepDays = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.historicalBackfill = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.tableDependencies = []
                    (_etype84, _size81) = iprot.readListBegin()
                    for _i85 in range(_size81):
                        _elem86 = TableDependency()
                        _elem86.read(iprot)
                        self.tableDependencies.append(_elem86)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.outputTableInfo = TableInfo()
                    self.outputTableInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.enableStatsCompute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRING:
                    self.onlineSchedule = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 200:
                if ftype == TType.LIST:
                    self.kvDependencies = []
                    (_etype90, _size87) = iprot.readListBegin()
                    for _i91 in range(_size87):
                        _elem92 = KvDependency()
                        _elem92.read(iprot)
                        self.kvDependencies.append(_elem92)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 201:
                if ftype == TType.STRUCT:
                    self.outputKvInfo = KvInfo()
                    self.outputKvInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 202:
                if ftype == TType.I64:
                    self.kvPollIntervalMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecutionInfo')
        if self.env is not None:
            oprot.writeFieldBegin('env', TType.STRUCT, 1)
            self.env.write(oprot)
            oprot.writeFieldEnd()
        if self.conf is not None:
            oprot.writeFieldBegin('conf', TType.STRUCT, 2)
            self.conf.write(oprot)
            oprot.writeFieldEnd()
        if self.dependencyPollIntervalMillis is not None:
            oprot.writeFieldBegin('dependencyPollIntervalMillis', TType.I64, 3)
            oprot.writeI64(self.dependencyPollIntervalMillis)
            oprot.writeFieldEnd()
        if self.healthCheckIntervalMillis is not None:
            oprot.writeFieldBegin('healthCheckIntervalMillis', TType.I64, 4)
            oprot.writeI64(self.healthCheckIntervalMillis)
            oprot.writeFieldEnd()
        if self.clusterConf is not None:
            oprot.writeFieldBegin('clusterConf', TType.STRUCT, 5)
            self.clusterConf.write(oprot)
            oprot.writeFieldEnd()
        if self.offlineSchedule is not None:
            oprot.writeFieldBegin('offlineSchedule', TType.STRING, 10)
            oprot.writeString(self.offlineSchedule.encode('utf-8') if sys.version_info[0] == 2 else self.offlineSchedule)
            oprot.writeFieldEnd()
        if self.stepDays is not None:
            oprot.writeFieldBegin('stepDays', TType.I32, 11)
            oprot.writeI32(self.stepDays)
            oprot.writeFieldEnd()
        if self.historicalBackfill is not None:
            oprot.writeFieldBegin('historicalBackfill', TType.BOOL, 12)
            oprot.writeBool(self.historicalBackfill)
            oprot.writeFieldEnd()
        if self.tableDependencies is not None:
            oprot.writeFieldBegin('tableDependencies', TType.LIST, 13)
            oprot.writeListBegin(TType.STRUCT, len(self.tableDependencies))
            for iter93 in self.tableDependencies:
                iter93.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.outputTableInfo is not None:
            oprot.writeFieldBegin('outputTableInfo', TType.STRUCT, 14)
            self.outputTableInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.enableStatsCompute is not None:
            oprot.writeFieldBegin('enableStatsCompute', TType.BOOL, 15)
            oprot.writeBool(self.enableStatsCompute)
            oprot.writeFieldEnd()
        if self.onlineSchedule is not None:
            oprot.writeFieldBegin('onlineSchedule', TType.STRING, 16)
            oprot.writeString(self.onlineSchedule.encode('utf-8') if sys.version_info[0] == 2 else self.onlineSchedule)
            oprot.writeFieldEnd()
        if self.kvDependencies is not None:
            oprot.writeFieldBegin('kvDependencies', TType.LIST, 200)
            oprot.writeListBegin(TType.STRUCT, len(self.kvDependencies))
            for iter94 in self.kvDependencies:
                iter94.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.outputKvInfo is not None:
            oprot.writeFieldBegin('outputKvInfo', TType.STRUCT, 201)
            self.outputKvInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.kvPollIntervalMillis is not None:
            oprot.writeFieldBegin('kvPollIntervalMillis', TType.I64, 202)
            oprot.writeI64(self.kvPollIntervalMillis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Window)
Window.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'length', None, None, ),  # 1
    (2, TType.I32, 'timeUnit', None, None, ),  # 2
)
all_structs.append(DateRange)
DateRange.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'startDate', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'endDate', 'UTF8', None, ),  # 2
)
all_structs.append(EnvironmentVariables)
EnvironmentVariables.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'common', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.MAP, 'modeEnvironments', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 2
)
all_structs.append(ConfigProperties)
ConfigProperties.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'common', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.MAP, 'modeConfigs', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 2
)
all_structs.append(ClusterConfigProperties)
ClusterConfigProperties.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'common', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.MAP, 'modeClusterConfigs', (TType.STRING, 'UTF8', TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 2
)
all_structs.append(TableInfo)
TableInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table', 'UTF8', None, ),  # 1
    None,  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    (100, TType.STRING, 'partitionColumn', 'UTF8', None, ),  # 100
    (101, TType.STRING, 'partitionFormat', 'UTF8', None, ),  # 101
    (102, TType.STRUCT, 'partitionInterval', [Window, None], None, ),  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.BOOL, 'isCumulative', None, None, ),  # 200
    None,  # 201
    None,  # 202
    None,  # 203
    None,  # 204
    None,  # 205
    None,  # 206
    None,  # 207
    None,  # 208
    None,  # 209
    None,  # 210
    None,  # 211
    None,  # 212
    None,  # 213
    None,  # 214
    None,  # 215
    None,  # 216
    None,  # 217
    None,  # 218
    None,  # 219
    None,  # 220
    None,  # 221
    None,  # 222
    None,  # 223
    None,  # 224
    None,  # 225
    None,  # 226
    None,  # 227
    None,  # 228
    None,  # 229
    None,  # 230
    None,  # 231
    None,  # 232
    None,  # 233
    None,  # 234
    None,  # 235
    None,  # 236
    None,  # 237
    None,  # 238
    None,  # 239
    None,  # 240
    None,  # 241
    None,  # 242
    None,  # 243
    None,  # 244
    None,  # 245
    None,  # 246
    None,  # 247
    None,  # 248
    None,  # 249
    None,  # 250
    None,  # 251
    None,  # 252
    None,  # 253
    None,  # 254
    None,  # 255
    None,  # 256
    None,  # 257
    None,  # 258
    None,  # 259
    None,  # 260
    None,  # 261
    None,  # 262
    None,  # 263
    None,  # 264
    None,  # 265
    None,  # 266
    None,  # 267
    None,  # 268
    None,  # 269
    None,  # 270
    None,  # 271
    None,  # 272
    None,  # 273
    None,  # 274
    None,  # 275
    None,  # 276
    None,  # 277
    None,  # 278
    None,  # 279
    None,  # 280
    None,  # 281
    None,  # 282
    None,  # 283
    None,  # 284
    None,  # 285
    None,  # 286
    None,  # 287
    None,  # 288
    None,  # 289
    None,  # 290
    None,  # 291
    None,  # 292
    None,  # 293
    None,  # 294
    None,  # 295
    None,  # 296
    None,  # 297
    None,  # 298
    None,  # 299
    (300, TType.STRING, 'triggerExpr', 'UTF8', None, ),  # 300
)
all_structs.append(TableDependency)
TableDependency.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tableInfo', [TableInfo, None], None, ),  # 1
    (2, TType.STRUCT, 'startOffset', [Window, None], None, ),  # 2
    (3, TType.STRUCT, 'endOffset', [Window, None], None, ),  # 3
    (4, TType.STRING, 'startCutOff', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'endCutOff', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'isSoftNodeDependency', None, None, ),  # 6
    (7, TType.STRING, 'semanticHash', 'UTF8', None, ),  # 7
    None,  # 8
    None,  # 9
    None,  # 10
    None,  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    None,  # 100
    None,  # 101
    None,  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    None,  # 200
    (201, TType.BOOL, 'forceCompute', None, None, ),  # 201
)
all_structs.append(KvInfo)
KvInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'cluster', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'table', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'keyBase64', 'UTF8', None, ),  # 3
)
all_structs.append(KvDependency)
KvDependency.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'kvInfo', [KvInfo, None], None, ),  # 1
    None,  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.I64, 'startMillis', None, None, ),  # 10
    (11, TType.I64, 'endMillis', None, None, ),  # 11
    None,  # 12
    None,  # 13
    None,  # 14
    None,  # 15
    None,  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    (20, TType.I32, 'scanStrategy', None, None, ),  # 20
)
all_structs.append(ExecutionInfo)
ExecutionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'env', [EnvironmentVariables, None], None, ),  # 1
    (2, TType.STRUCT, 'conf', [ConfigProperties, None], None, ),  # 2
    (3, TType.I64, 'dependencyPollIntervalMillis', None, None, ),  # 3
    (4, TType.I64, 'healthCheckIntervalMillis', None, None, ),  # 4
    (5, TType.STRUCT, 'clusterConf', [ClusterConfigProperties, None], None, ),  # 5
    None,  # 6
    None,  # 7
    None,  # 8
    None,  # 9
    (10, TType.STRING, 'offlineSchedule', 'UTF8', None, ),  # 10
    (11, TType.I32, 'stepDays', None, None, ),  # 11
    (12, TType.BOOL, 'historicalBackfill', None, None, ),  # 12
    (13, TType.LIST, 'tableDependencies', (TType.STRUCT, [TableDependency, None], False), None, ),  # 13
    (14, TType.STRUCT, 'outputTableInfo', [TableInfo, None], None, ),  # 14
    (15, TType.BOOL, 'enableStatsCompute', None, None, ),  # 15
    (16, TType.STRING, 'onlineSchedule', 'UTF8', None, ),  # 16
    None,  # 17
    None,  # 18
    None,  # 19
    None,  # 20
    None,  # 21
    None,  # 22
    None,  # 23
    None,  # 24
    None,  # 25
    None,  # 26
    None,  # 27
    None,  # 28
    None,  # 29
    None,  # 30
    None,  # 31
    None,  # 32
    None,  # 33
    None,  # 34
    None,  # 35
    None,  # 36
    None,  # 37
    None,  # 38
    None,  # 39
    None,  # 40
    None,  # 41
    None,  # 42
    None,  # 43
    None,  # 44
    None,  # 45
    None,  # 46
    None,  # 47
    None,  # 48
    None,  # 49
    None,  # 50
    None,  # 51
    None,  # 52
    None,  # 53
    None,  # 54
    None,  # 55
    None,  # 56
    None,  # 57
    None,  # 58
    None,  # 59
    None,  # 60
    None,  # 61
    None,  # 62
    None,  # 63
    None,  # 64
    None,  # 65
    None,  # 66
    None,  # 67
    None,  # 68
    None,  # 69
    None,  # 70
    None,  # 71
    None,  # 72
    None,  # 73
    None,  # 74
    None,  # 75
    None,  # 76
    None,  # 77
    None,  # 78
    None,  # 79
    None,  # 80
    None,  # 81
    None,  # 82
    None,  # 83
    None,  # 84
    None,  # 85
    None,  # 86
    None,  # 87
    None,  # 88
    None,  # 89
    None,  # 90
    None,  # 91
    None,  # 92
    None,  # 93
    None,  # 94
    None,  # 95
    None,  # 96
    None,  # 97
    None,  # 98
    None,  # 99
    None,  # 100
    None,  # 101
    None,  # 102
    None,  # 103
    None,  # 104
    None,  # 105
    None,  # 106
    None,  # 107
    None,  # 108
    None,  # 109
    None,  # 110
    None,  # 111
    None,  # 112
    None,  # 113
    None,  # 114
    None,  # 115
    None,  # 116
    None,  # 117
    None,  # 118
    None,  # 119
    None,  # 120
    None,  # 121
    None,  # 122
    None,  # 123
    None,  # 124
    None,  # 125
    None,  # 126
    None,  # 127
    None,  # 128
    None,  # 129
    None,  # 130
    None,  # 131
    None,  # 132
    None,  # 133
    None,  # 134
    None,  # 135
    None,  # 136
    None,  # 137
    None,  # 138
    None,  # 139
    None,  # 140
    None,  # 141
    None,  # 142
    None,  # 143
    None,  # 144
    None,  # 145
    None,  # 146
    None,  # 147
    None,  # 148
    None,  # 149
    None,  # 150
    None,  # 151
    None,  # 152
    None,  # 153
    None,  # 154
    None,  # 155
    None,  # 156
    None,  # 157
    None,  # 158
    None,  # 159
    None,  # 160
    None,  # 161
    None,  # 162
    None,  # 163
    None,  # 164
    None,  # 165
    None,  # 166
    None,  # 167
    None,  # 168
    None,  # 169
    None,  # 170
    None,  # 171
    None,  # 172
    None,  # 173
    None,  # 174
    None,  # 175
    None,  # 176
    None,  # 177
    None,  # 178
    None,  # 179
    None,  # 180
    None,  # 181
    None,  # 182
    None,  # 183
    None,  # 184
    None,  # 185
    None,  # 186
    None,  # 187
    None,  # 188
    None,  # 189
    None,  # 190
    None,  # 191
    None,  # 192
    None,  # 193
    None,  # 194
    None,  # 195
    None,  # 196
    None,  # 197
    None,  # 198
    None,  # 199
    (200, TType.LIST, 'kvDependencies', (TType.STRUCT, [KvDependency, None], False), None, ),  # 200
    (201, TType.STRUCT, 'outputKvInfo', [KvInfo, None], None, ),  # 201
    (202, TType.I64, 'kvPollIntervalMillis', None, None, ),  # 202
)
fix_spec(all_structs)
del all_structs
