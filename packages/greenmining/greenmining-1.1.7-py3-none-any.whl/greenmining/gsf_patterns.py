# Green Software Foundation Patterns

GSF_PATTERNS = {
    # ==================== CLOUD PATTERNS (40+) ====================
    "cache_static_data": {
        "name": "Cache Static Data",
        "category": "cloud",
        "keywords": ["cache", "caching", "static", "cdn", "redis", "memcache", "cached"],
        "description": "Cache static content to reduce server load and network transfers",
        "sci_impact": "Reduces energy by minimizing redundant compute and network operations",
    },
    "choose_region_closest": {
        "name": "Choose Region Closest to Users",
        "category": "cloud",
        "keywords": ["region", "closest", "proximity", "latency", "location", "geographic"],
        "description": "Deploy in regions closest to users to reduce network distance",
        "sci_impact": "Less energy for network transmission, lower latency",
    },
    "compress_stored_data": {
        "name": "Compress Stored Data",
        "category": "cloud",
        "keywords": ["compress", "compression", "stored", "storage", "gzip", "zstd"],
        "description": "Compress data at rest to reduce storage footprint",
        "sci_impact": "Lower embodied carbon from reduced storage infrastructure",
    },
    "compress_transmitted_data": {
        "name": "Compress Transmitted Data",
        "category": "cloud",
        "keywords": ["compress", "transmission", "gzip", "brotli", "network"],
        "description": "Compress data before transmission over network",
        "sci_impact": "Reduces network energy consumption and transfer time",
    },
    "containerize_workload": {
        "name": "Containerize Your Workload",
        "category": "cloud",
        "keywords": ["container", "docker", "kubernetes", "containerize", "pod"],
        "description": "Use containers for better resource utilization",
        "sci_impact": "Improved resource density and efficiency",
    },
    "delete_unused_storage": {
        "name": "Delete Unused Storage Resources",
        "category": "cloud",
        "keywords": ["delete", "remove", "unused", "storage", "cleanup", "orphan"],
        "description": "Remove storage resources that are no longer needed",
        "sci_impact": "Eliminates wasted energy and embodied carbon",
    },
    "encrypt_necessary": {
        "name": "Encrypt What Is Necessary",
        "category": "cloud",
        "keywords": ["encrypt", "encryption", "tls", "ssl", "crypto"],
        "description": "Only encrypt data that requires protection",
        "sci_impact": "Reduces CPU overhead from unnecessary encryption",
    },
    "evaluate_cpu_architectures": {
        "name": "Evaluate Other CPU Architectures",
        "category": "cloud",
        "keywords": ["cpu", "architecture", "arm", "graviton", "processor"],
        "description": "Consider ARM and other efficient CPU architectures",
        "sci_impact": "Some architectures offer better energy efficiency",
    },
    "service_mesh": {
        "name": "Evaluate Using a Service Mesh",
        "category": "cloud",
        "keywords": ["service mesh", "istio", "linkerd", "envoy"],
        "description": "Use service mesh for efficient service-to-service communication",
        "sci_impact": "Optimizes network traffic and observability overhead",
    },
    "tls_termination": {
        "name": "Evaluate TLS Termination",
        "category": "cloud",
        "keywords": ["tls", "termination", "ssl", "offload"],
        "description": "Terminate TLS at edge to reduce encryption overhead",
        "sci_impact": "Reduces CPU load on backend services",
    },
    "stateless_design": {
        "name": "Implement Stateless Design",
        "category": "cloud",
        "keywords": ["stateless", "state", "session", "horizontal"],
        "description": "Design services without server-side state",
        "sci_impact": "Enables better scaling and resource utilization",
    },
    "match_slo": {
        "name": "Match SLO Requirements",
        "category": "cloud",
        "keywords": ["slo", "sla", "service level", "objective"],
        "description": "Don't over-engineer beyond required SLO",
        "sci_impact": "Avoids wasted resources on unnecessary performance",
    },
    "match_vm_utilization": {
        "name": "Match VM Utilization Requirements",
        "category": "cloud",
        "keywords": ["vm", "virtual machine", "instance", "size", "utilization"],
        "description": "Right-size VMs to actual workload needs",
        "sci_impact": "Eliminates idle resources and wasted energy",
    },
    "minimize_environments": {
        "name": "Minimize Deployed Environments",
        "category": "cloud",
        "keywords": ["environment", "dev", "staging", "ephemeral"],
        "description": "Reduce number of permanent test/dev environments",
        "sci_impact": "Less idle infrastructure consuming energy",
    },
    "optimize_storage_utilization": {
        "name": "Optimize Storage Resource Utilization",
        "category": "cloud",
        "keywords": ["storage", "optimize", "utilization", "efficiency"],
        "description": "Maximize usage of provisioned storage",
        "sci_impact": "Better hardware efficiency, less waste",
    },
    "optimize_avg_cpu": {
        "name": "Optimize Average CPU Utilization",
        "category": "cloud",
        "keywords": ["cpu", "utilization", "average", "optimize"],
        "description": "Increase average CPU utilization across fleet",
        "sci_impact": "More work per unit of energy consumed",
    },
    "optimize_peak_cpu": {
        "name": "Optimize Peak CPU Utilization",
        "category": "cloud",
        "keywords": ["cpu", "peak", "spike", "burst"],
        "description": "Handle peaks efficiently without over-provisioning",
        "sci_impact": "Reduces need for excess capacity",
    },
    "queue_non_urgent": {
        "name": "Queue Non-Urgent Requests",
        "category": "cloud",
        "keywords": ["queue", "async", "batch", "defer", "background"],
        "description": "Queue non-urgent work for batch processing",
        "sci_impact": "Better resource utilization and scheduling",
    },
    "reduce_network_traversal": {
        "name": "Reduce Network Traversal Between VMs",
        "category": "cloud",
        "keywords": ["network", "traversal", "hop", "latency", "cross-az"],
        "description": "Minimize network hops between services",
        "sci_impact": "Less network equipment and energy per request",
    },
    "reduce_transmitted_data": {
        "name": "Reduce Transmitted Data",
        "category": "cloud",
        "keywords": ["reduce", "data", "transmission", "payload", "bandwidth"],
        "description": "Send only necessary data over network",
        "sci_impact": "Lower network energy consumption",
    },
    "remove_unused_assets": {
        "name": "Remove Unused Assets",
        "category": "cloud",
        "keywords": ["remove", "unused", "asset", "cleanup", "garbage"],
        "description": "Delete unused code, images, dependencies",
        "sci_impact": "Reduces storage and deployment footprint",
    },
    "scale_down_k8s": {
        "name": "Scale Down Kubernetes Workloads",
        "category": "cloud",
        "keywords": ["scale down", "kubernetes", "k8s", "downscale", "hpa"],
        "description": "Automatically scale down idle K8s workloads",
        "sci_impact": "Eliminates idle resource consumption",
    },
    "scale_down_apps": {
        "name": "Scale Down Unused Applications",
        "category": "cloud",
        "keywords": ["scale", "down", "idle", "suspend", "hibernate"],
        "description": "Scale down or shut down idle applications",
        "sci_impact": "Reduces energy from idle services",
    },
    "scale_with_load": {
        "name": "Scale Infrastructure with User Load",
        "category": "cloud",
        "keywords": ["autoscale", "scale", "elastic", "demand", "load"],
        "description": "Automatically scale based on actual demand",
        "sci_impact": "Matches resources to need, eliminates waste",
    },
    "k8s_event_scaling": {
        "name": "Scale Kubernetes Workloads Based on Events",
        "category": "cloud",
        "keywords": ["keda", "event", "scale", "kubernetes", "queue"],
        "description": "Scale based on queue depth or event metrics",
        "sci_impact": "Precise scaling to actual workload",
    },
    "scale_logical_components": {
        "name": "Scale Logical Components Independently",
        "category": "cloud",
        "keywords": ["microservice", "component", "independent", "decouple"],
        "description": "Scale services independently based on their load",
        "sci_impact": "Avoids scaling entire application for one bottleneck",
    },
    "scan_vulnerabilities": {
        "name": "Scan for Vulnerabilities",
        "category": "cloud",
        "keywords": ["security", "vulnerability", "scan", "cve"],
        "description": "Regular security scans to prevent breaches",
        "sci_impact": "Prevents energy waste from attacks and remediation",
    },
    "retention_policy": {
        "name": "Set Retention Policy on Storage",
        "category": "cloud",
        "keywords": ["retention", "policy", "lifecycle", "expire", "ttl"],
        "description": "Automatically delete old data per policy",
        "sci_impact": "Reduces storage footprint over time",
    },
    "shed_lower_priority": {
        "name": "Shed Lower Priority Traffic",
        "category": "cloud",
        "keywords": ["shed", "priority", "throttle", "rate limit", "backpressure"],
        "description": "Drop low-priority requests under load",
        "sci_impact": "Protects resources for important work",
    },
    "time_shift_cron": {
        "name": "Time-Shift Kubernetes Cron Jobs",
        "category": "cloud",
        "keywords": ["time shift", "cron", "schedule", "carbon aware", "renewable"],
        "description": "Run batch jobs when renewable energy is available",
        "sci_impact": "Uses cleaner energy sources",
    },
    "async_not_sync": {
        "name": "Use Async Instead of Sync",
        "category": "cloud",
        "keywords": ["async", "asynchronous", "non-blocking", "await"],
        "description": "Use asynchronous processing patterns",
        "sci_impact": "Better CPU utilization, less idle time",
    },
    "circuit_breaker": {
        "name": "Use Circuit Breaker",
        "category": "cloud",
        "keywords": ["circuit breaker", "fault tolerance", "resilience", "fallback"],
        "description": "Prevent cascading failures with circuit breakers",
        "sci_impact": "Avoids wasted energy on failing requests",
    },
    "cloud_native_security": {
        "name": "Use Cloud Native Security Tools",
        "category": "cloud",
        "keywords": ["security", "native", "managed", "cloud"],
        "description": "Use cloud provider's native security services",
        "sci_impact": "More efficient than running own security infrastructure",
    },
    "compiled_languages": {
        "name": "Use Compiled Languages",
        "category": "cloud",
        "keywords": ["compile", "compiled", "rust", "go", "c++"],
        "description": "Consider compiled languages for CPU-intensive tasks",
        "sci_impact": "Better runtime performance and energy efficiency",
    },
    "ddos_protection": {
        "name": "Use DDoS Protection",
        "category": "cloud",
        "keywords": ["ddos", "protection", "shield", "waf"],
        "description": "Protect against distributed denial of service",
        "sci_impact": "Prevents energy waste from malicious traffic",
    },
    "energy_efficient_hardware": {
        "name": "Use Energy Efficient Hardware",
        "category": "cloud",
        "keywords": ["energy", "efficient", "hardware", "green", "sustainable"],
        "description": "Choose hardware optimized for energy efficiency",
        "sci_impact": "Direct reduction in energy consumption",
    },
    # ==================== WEB PATTERNS (15+) ====================
    "avoid_chaining_requests": {
        "name": "Avoid Chaining Critical Requests",
        "category": "web",
        "keywords": ["chain", "critical", "request", "waterfall", "sequential"],
        "description": "Avoid serialized network requests that block rendering",
        "sci_impact": "Faster page load, less energy for rendering",
    },
    "avoid_excessive_dom": {
        "name": "Avoid Excessive DOM Size",
        "category": "web",
        "keywords": ["dom", "size", "excessive", "tree", "nodes"],
        "description": "Keep DOM tree small and shallow",
        "sci_impact": "Reduces memory and rendering energy",
    },
    "avoid_tracking_unnecessary": {
        "name": "Avoid Tracking Unnecessary Data",
        "category": "web",
        "keywords": ["tracking", "analytics", "telemetry", "unnecessary"],
        "description": "Don't track data you won't use",
        "sci_impact": "Reduces network and storage overhead",
    },
    "defer_offscreen_images": {
        "name": "Defer Offscreen Images",
        "category": "web",
        "keywords": ["defer", "offscreen", "image", "lazy load", "viewport"],
        "description": "Load images only when they enter viewport",
        "sci_impact": "Reduces initial load energy and bandwidth",
    },
    "deprecate_gifs": {
        "name": "Deprecate GIFs",
        "category": "web",
        "keywords": ["gif", "video", "webm", "mp4", "animation"],
        "description": "Use video formats instead of animated GIFs",
        "sci_impact": "Video formats are much more efficient than GIF",
    },
    "enable_text_compression": {
        "name": "Enable Text Compression",
        "category": "web",
        "keywords": ["compress", "text", "gzip", "brotli", "minify"],
        "description": "Compress HTML, CSS, JS before transmission",
        "sci_impact": "Reduces bandwidth and transfer energy",
    },
    "keep_request_counts_low": {
        "name": "Keep Request Counts Low",
        "category": "web",
        "keywords": ["request", "count", "http", "reduce", "combine"],
        "description": "Minimize number of HTTP requests",
        "sci_impact": "Lower network overhead per page load",
    },
    "minify_web_assets": {
        "name": "Minify Web Assets",
        "category": "web",
        "keywords": ["minify", "minification", "uglify", "compress"],
        "description": "Remove whitespace and unnecessary code",
        "sci_impact": "Smaller files, less bandwidth",
    },
    "minimize_main_thread": {
        "name": "Minimize Main Thread Work",
        "category": "web",
        "keywords": ["main thread", "worker", "offload", "javascript"],
        "description": "Offload work from main thread to web workers",
        "sci_impact": "Better CPU utilization, faster page loads",
    },
    "properly_sized_images": {
        "name": "Properly Sized Images",
        "category": "web",
        "keywords": ["image", "size", "resize", "responsive", "srcset"],
        "description": "Serve images at correct display size",
        "sci_impact": "Avoids transferring and processing oversized images",
    },
    "remove_unused_css": {
        "name": "Remove Unused CSS",
        "category": "web",
        "keywords": ["css", "unused", "purge", "tree shake"],
        "description": "Eliminate CSS that isn't used on page",
        "sci_impact": "Smaller CSS files, faster parsing",
    },
    "serve_modern_image_formats": {
        "name": "Serve Images in Modern Formats",
        "category": "web",
        "keywords": ["webp", "avif", "image", "format", "modern"],
        "description": "Use WebP or AVIF instead of JPEG/PNG",
        "sci_impact": "Modern formats are significantly more efficient",
    },
    "server_side_rendering": {
        "name": "Use Server-Side Rendering",
        "category": "web",
        "keywords": ["ssr", "server side", "rendering", "nextjs"],
        "description": "Pre-render pages on server when appropriate",
        "sci_impact": "Reduces client-side computation energy",
    },
    # ==================== AI/ML PATTERNS (10+) ====================
    "compress_ml_models": {
        "name": "Compress ML Models for Inference",
        "category": "ai",
        "keywords": [
            "model compression",
            "quantization",
            "model pruning",
            "knowledge distillation",
        ],
        "description": "Reduce model size through quantization, pruning, distillation",
        "sci_impact": "Dramatically reduces inference energy and memory",
    },
    "efficient_format_training": {
        "name": "Efficient Format for Model Training",
        "category": "ai",
        "keywords": ["format", "training", "tfrecord", "parquet", "efficient"],
        "description": "Use efficient data formats for training",
        "sci_impact": "Faster I/O, less storage, quicker training",
    },
    "energy_efficient_ai_edge": {
        "name": "Energy Efficient AI at Edge",
        "category": "ai",
        "keywords": ["edge inference", "edge ai", "edge ml", "tflite", "onnx runtime"],
        "description": "Run inference on edge devices when possible",
        "sci_impact": "Eliminates network transfer, uses local compute",
    },
    "energy_efficient_framework": {
        "name": "Energy Efficient Framework",
        "category": "ai",
        "keywords": ["tensorflow", "pytorch", "onnx", "jax", "huggingface"],
        "description": "Choose ML frameworks optimized for efficiency",
        "sci_impact": "Different frameworks have different energy profiles",
    },
    "energy_efficient_models": {
        "name": "Energy Efficient Models",
        "category": "ai",
        "keywords": ["model", "efficient", "mobilenet", "efficientnet"],
        "description": "Use models designed for efficiency (e.g., MobileNet)",
        "sci_impact": "Purpose-built efficient architectures",
    },
    "leverage_sustainable_regions_ai": {
        "name": "Leverage Sustainable Regions for AI",
        "category": "ai",
        "keywords": ["region", "sustainable", "renewable", "carbon"],
        "description": "Train models in regions with clean energy",
        "sci_impact": "Lower carbon intensity for training",
    },
    "pretrained_transfer_learning": {
        "name": "Pre-trained Transfer Learning",
        "category": "ai",
        "keywords": ["transfer", "learning", "pretrain", "fine-tune"],
        "description": "Start from pre-trained models instead of training from scratch",
        "sci_impact": "Avoids massive energy cost of full training",
    },
    "right_hardware_ai": {
        "name": "Right Hardware Type for AI",
        "category": "ai",
        "keywords": ["gpu training", "tpu", "cuda", "nvidia ai", "ml accelerator"],
        "description": "Use appropriate hardware (GPU/TPU) for AI workloads",
        "sci_impact": "Specialized hardware is more energy efficient",
    },
    "serverless_ml": {
        "name": "Serverless Model Development",
        "category": "ai",
        "keywords": ["sagemaker", "vertex ai", "azure ml", "lambda inference", "serverless ml"],
        "description": "Use serverless platforms for ML development",
        "sci_impact": "Pay-per-use, no idle resources",
    },
    # ==================== GENERAL PATTERNS ====================
    "autoscaling": {
        "name": "Autoscaling",
        "category": "cloud",
        "keywords": ["autoscal", "scale", "elastic", "horizontal scaling", "hpa", "scaling policy"],
        "description": "Automatically scale resources based on demand",
        "sci_impact": "Reduces carbon emissions by matching resources to actual demand",
    },
    "optimize_storage": {
        "name": "Optimize Storage",
        "category": "cloud",
        "keywords": ["compress", "deduplicate", "archive", "storage tier", "lifecycle policy"],
        "description": "Reduce storage footprint through compression and deduplication",
        "sci_impact": "Lower embodied carbon through reduced storage infrastructure",
    },
    "serverless": {
        "name": "Use Serverless",
        "category": "cloud",
        "keywords": ["serverless", "lambda", "function", "faas", "cloud function"],
        "description": "Use serverless computing for event-driven workloads",
        "sci_impact": "Pay-per-use model ensures zero idle resource consumption",
    },
    "right_sizing": {
        "name": "Right-size Resources",
        "category": "cloud",
        "keywords": [
            "right-size",
            "rightsize",
            "downsize",
            "optimize instance",
            "resource optimization",
        ],
        "description": "Match compute resources to actual workload requirements",
        "sci_impact": "Eliminates over-provisioning and reduces wasted energy",
    },
    # WEB PATTERNS
    "lazy_loading": {
        "name": "Lazy Loading",
        "category": "web",
        "keywords": ["lazy load", "lazy", "defer", "async", "on-demand"],
        "description": "Load resources only when needed",
        "sci_impact": "Reduces unnecessary data transfer and processing",
    },
    "minimize_data_transfer": {
        "name": "Minimize Data Transfer",
        "category": "web",
        "keywords": ["minif", "compress", "gzip", "brotli", "optimize payload", "reduce bundle"],
        "description": "Reduce size of data transferred over network",
        "sci_impact": "Lower network energy consumption and faster load times",
    },
    "optimize_images": {
        "name": "Optimize Images",
        "category": "web",
        "keywords": ["image optim", "webp", "responsive image", "lazy image", "compress image"],
        "description": "Use efficient image formats and sizing",
        "sci_impact": "Reduces bandwidth and storage requirements",
    },
    "reduce_http_requests": {
        "name": "Reduce HTTP Requests",
        "category": "web",
        "keywords": ["bundle", "sprite", "inline", "combine", "reduce request"],
        "description": "Minimize number of network requests",
        "sci_impact": "Lower network overhead and latency",
    },
    # AI/ML PATTERNS
    "model_optimization": {
        "name": "Optimize ML Models",
        "category": "ai",
        "keywords": ["quantiz", "prune", "distill", "model compress", "optimize model"],
        "description": "Reduce model size and complexity",
        "sci_impact": "Dramatically reduces compute and memory requirements",
    },
    "batch_inference": {
        "name": "Batch Inference",
        "category": "ai",
        "keywords": ["batch inference", "batch predict", "batch processing"],
        "description": "Process ML predictions in batches",
        "sci_impact": "More efficient GPU utilization",
    },
    # NETWORKING PATTERNS
    "connection_pooling": {
        "name": "Connection Pooling",
        "category": "networking",
        "keywords": ["connection pool", "pool", "reuse connection", "persistent connection"],
        "description": "Reuse network connections instead of creating new ones",
        "sci_impact": "Reduces connection overhead and resource consumption",
    },
    "rate_limiting": {
        "name": "Rate Limiting",
        "category": "networking",
        "keywords": ["rate limit", "throttle", "backpressure", "circuit breaker"],
        "description": "Control request rate to prevent resource exhaustion",
        "sci_impact": "Prevents waste from processing excessive or malicious traffic",
    },
    # DATABASE PATTERNS
    "database_indexing": {
        "name": "Database Indexing",
        "category": "database",
        "keywords": ["index", "query optim", "explain", "slow query"],
        "description": "Optimize database queries with proper indexing",
        "sci_impact": "Reduces compute cycles for data retrieval",
    },
    "data_partitioning": {
        "name": "Data Partitioning",
        "category": "database",
        "keywords": ["partition", "shard", "segment", "distribute data"],
        "description": "Distribute data across multiple nodes",
        "sci_impact": "Improves query efficiency and resource utilization",
    },
    # GENERAL PATTERNS
    "async_processing": {
        "name": "Asynchronous Processing",
        "category": "general",
        "keywords": ["async", "asynchronous", "non-blocking", "event-driven", "queue"],
        "description": "Process tasks asynchronously to improve resource utilization",
        "sci_impact": "Better CPU utilization and reduced idle time",
    },
    "resource_pooling": {
        "name": "Resource Pooling",
        "category": "general",
        "keywords": ["thread pool", "worker pool", "object pool", "resource pool"],
        "description": "Reuse expensive resources instead of creating new ones",
        "sci_impact": "Reduces initialization overhead and memory pressure",
    },
    "memoization": {
        "name": "Memoization",
        "category": "general",
        "keywords": ["memoize", "memoization", "cache result", "remember"],
        "description": "Cache results of expensive function calls",
        "sci_impact": "Avoids redundant computation",
    },
    "batch_processing": {
        "name": "Batch Processing",
        "category": "general",
        "keywords": ["batch", "bulk", "batch insert", "batch update"],
        "description": "Process multiple items together instead of one at a time",
        "sci_impact": "Reduces per-item overhead and improves throughput",
    },
    # ==================== RESOURCE OPTIMIZATION (Expanded from VU Amsterdam) ====================
    "resource_limits": {
        "name": "Resource Limits & Constraints",
        "category": "resource",
        "keywords": [
            "limit",
            "limits",
            "constraint",
            "constraints",
            "quota",
            "cap",
            "memory limit",
            "cpu limit",
            "resource limit",
            "timeout",
            "max threads",
            "thread limit",
        ],
        "description": "Set hard limits on resource consumption to prevent waste",
        "sci_impact": "Prevents resource exhaustion and runaway processes",
    },
    "dynamic_resource_allocation": {
        "name": "Dynamic Resource Allocation",
        "category": "resource",
        "keywords": [
            "dynamic allocation",
            "vpa",
            "vertical pod autoscaling",
            "custom metric",
            "scaling policy",
            "predictive scaling",
        ],
        "description": "Dynamically adjust resource allocation based on actual usage",
        "sci_impact": "Eliminates over-provisioning and improves efficiency",
    },
    # ==================== CACHING & DATA EFFICIENCY (Expanded) ====================
    "multi_level_caching": {
        "name": "Multi-Level Caching",
        "category": "caching",
        "keywords": [
            "multi level cache",
            "l1 cache",
            "l2 cache",
            "cache layer",
            "distributed cache",
            "local cache",
            "cache hierarchy",
        ],
        "description": "Implement multiple caching levels for optimal efficiency",
        "sci_impact": "Reduces redundant computation and network traffic",
    },
    "cache_invalidation": {
        "name": "Cache Invalidation Strategy",
        "category": "caching",
        "keywords": [
            "cache invalidation",
            "cache invalidate",
            "ttl",
            "time to live",
            "eviction",
            "cache expir",
            "cache refresh",
            "stale while revalidate",
        ],
        "description": "Implement efficient cache invalidation to balance freshness and efficiency",
        "sci_impact": "Optimizes cache hit rates and reduces unnecessary refreshes",
    },
    "data_deduplication": {
        "name": "Data Deduplication",
        "category": "data",
        "keywords": [
            "deduplicate",
            "deduplication",
            "redundancy",
            "duplicate",
            "unique",
            "eliminate redundant",
        ],
        "description": "Eliminate redundant data storage and processing",
        "sci_impact": "Reduces storage footprint and processing overhead",
    },
    "efficient_serialization": {
        "name": "Efficient Serialization",
        "category": "data",
        "keywords": [
            "protobuf",
            "protocol buffer",
            "avro",
            "messagepack",
            "serialization",
            "binary format",
            "efficient format",
        ],
        "description": "Use efficient binary serialization formats",
        "sci_impact": "Reduces network bandwidth and serialization overhead",
    },
    "pagination": {
        "name": "Pagination & Lazy Loading",
        "category": "data",
        "keywords": [
            "pagination",
            "paginate",
            "page size",
            "limit offset",
            "lazy load",
            "on demand",
            "defer load",
        ],
        "description": "Load data incrementally instead of all at once",
        "sci_impact": "Reduces memory usage and initial load time",
    },
    # ==================== EVENT-DRIVEN & ASYNCHRONOUS (Expanded) ====================
    "event_driven_architecture": {
        "name": "Event-Driven Architecture",
        "category": "async",
        "keywords": [
            "event driven",
            "event sourcing",
            "event listener",
            "kafka",
            "rabbitmq",
            "message broker",
            "pub sub",
            "publish subscribe",
            "webhook",
        ],
        "description": "Use events instead of polling to reduce unnecessary CPU cycles",
        "sci_impact": "Eliminates wasteful polling and enables reactive processing",
    },
    "eliminate_polling": {
        "name": "Eliminate Polling",
        "category": "async",
        "keywords": [
            "poll",
            "polling",
            "reduce poll",
            "stop poll",
            "websocket",
            "sse",
            "server sent event",
            "push notification",
        ],
        "description": "Replace polling with push-based notifications",
        "sci_impact": "Dramatically reduces unnecessary CPU and network usage",
    },
    "reactive_streams": {
        "name": "Reactive Streams",
        "category": "async",
        "keywords": [
            "reactive",
            "reactor",
            "rxjava",
            "completablefuture",
            "webflux",
            "project reactor",
            "coroutine",
            "suspend",
        ],
        "description": "Use reactive programming for non-blocking I/O",
        "sci_impact": "Improves thread utilization and reduces blocking operations",
    },
    # ==================== DATABASE OPTIMIZATION (Expanded) ====================
    "query_optimization": {
        "name": "Query Optimization",
        "category": "database",
        "keywords": [
            "query optim",
            "explain plan",
            "query plan",
            "n+1",
            "n plus 1",
            "eager load",
            "batch query",
            "select star",
        ],
        "description": "Optimize database queries to reduce CPU and I/O",
        "sci_impact": "Reduces database server load and query execution time",
    },
    "prepared_statements": {
        "name": "Prepared Statements",
        "category": "database",
        "keywords": [
            "prepared statement",
            "statement cache",
            "statement pool",
            "parameterized query",
            "bind variable",
        ],
        "description": "Use prepared statements for repeated queries",
        "sci_impact": "Reduces query parsing overhead and improves security",
    },
    "database_views": {
        "name": "Database Views & Materialized Views",
        "category": "database",
        "keywords": [
            "database view",
            "materialized view",
            "view",
            "precompute",
            "aggregate table",
        ],
        "description": "Use views to precompute complex queries",
        "sci_impact": "Reduces redundant computation for common queries",
    },
    # ==================== ALGORITHM & CODE EFFICIENCY ====================
    "algorithm_optimization": {
        "name": "Algorithm Optimization",
        "category": "code",
        "keywords": [
            "algorithm optim",
            "complexity",
            "big o",
            "o(n)",
            "memoiz",
            "dynamic programming",
            "efficient algorithm",
        ],
        "description": "Use efficient algorithms to reduce CPU cycles",
        "sci_impact": "Reduces computational overhead and execution time",
    },
    "code_efficiency": {
        "name": "Code Efficiency & Lean Code",
        "category": "code",
        "keywords": [
            "dead code",
            "unused code",
            "remove code",
            "efficient code",
            "lean code",
            "minimize allocation",
            "object pool",
        ],
        "description": "Write efficient, minimal code that uses fewer resources",
        "sci_impact": "Reduces memory pressure and garbage collection overhead",
    },
    "reduce_reflection": {
        "name": "Reduce Reflection Usage",
        "category": "code",
        "keywords": [
            "reflection",
            "avoid reflection",
            "introspection",
            "dynamic lookup",
            "hot path",
        ],
        "description": "Avoid reflection in performance-critical code paths",
        "sci_impact": "Reduces CPU overhead in frequently executed code",
    },
    "garbage_collection_tuning": {
        "name": "Garbage Collection Tuning",
        "category": "code",
        "keywords": [
            "garbage collection",
            "gc tune",
            "gc pause",
            "gc optim",
            "memory management",
            "heap size",
        ],
        "description": "Optimize garbage collection settings for efficiency",
        "sci_impact": "Reduces GC overhead and improves application responsiveness",
    },
    # ==================== NETWORK OPTIMIZATION (Expanded) ====================
    "grpc_optimization": {
        "name": "gRPC for Service Communication",
        "category": "network",
        "keywords": [
            "grpc",
            "http2",
            "h2",
            "multiplexing",
            "protocol buffer",
            "efficient protocol",
        ],
        "description": "Use gRPC instead of REST for high-traffic inter-service communication",
        "sci_impact": "Reduces network overhead through binary protocols and multiplexing",
    },
    "request_batching": {
        "name": "Request Batching & Aggregation",
        "category": "network",
        "keywords": [
            "batch request",
            "request batch",
            "aggregate request",
            "coalesce",
            "reduce call",
            "bulk request",
        ],
        "description": "Aggregate multiple requests into batches",
        "sci_impact": "Reduces network overhead and context switching",
    },
    "graphql_optimization": {
        "name": "GraphQL for Selective Retrieval",
        "category": "network",
        "keywords": [
            "graphql",
            "selective field",
            "field selection",
            "overfetch",
            "underfetch",
        ],
        "description": "Use GraphQL to retrieve only required fields",
        "sci_impact": "Eliminates over-fetching and reduces payload size",
    },
    "api_gateway": {
        "name": "API Gateway Pattern",
        "category": "network",
        "keywords": [
            "api gateway",
            "gateway",
            "aggregation gateway",
            "bff",
            "backend for frontend",
        ],
        "description": "Use API gateway for request aggregation and routing",
        "sci_impact": "Reduces client-server roundtrips and enables caching",
    },
    "circuit_breaker_advanced": {
        "name": "Circuit Breaker & Bulkhead",
        "category": "network",
        "keywords": [
            "circuit breaker",
            "bulkhead",
            "isolation",
            "fault tolerance",
            "retry backoff",
            "exponential backoff",
        ],
        "description": "Prevent cascading failures and isolate resources",
        "sci_impact": "Avoids wasted energy on failing requests and protects resources",
    },
    "keep_alive_connections": {
        "name": "Keep-Alive Connections",
        "category": "network",
        "keywords": [
            "keep alive",
            "persistent connection",
            "connection reuse",
            "http keep-alive",
            "tcp keep-alive",
        ],
        "description": "Maintain persistent connections to avoid handshake overhead",
        "sci_impact": "Reduces TCP/TLS handshake energy consumption",
    },
    # ==================== MONITORING & OBSERVABILITY ====================
    "energy_monitoring": {
        "name": "Energy-Aware Monitoring",
        "category": "monitoring",
        "keywords": [
            "rapl",
            "power consumption",
            "energy monitor",
            "carbon footprint",
            "energy metric",
            "watt",
            "power usage",
        ],
        "description": "Monitor and measure energy consumption",
        "sci_impact": "Enables identification of energy optimization opportunities",
    },
    "performance_profiling": {
        "name": "Performance Profiling",
        "category": "monitoring",
        "keywords": [
            "profil",
            "flame graph",
            "cpu profile",
            "memory profile",
            "perf",
            "benchmark",
        ],
        "description": "Profile application performance to identify bottlenecks",
        "sci_impact": "Enables targeted optimization of resource-intensive operations",
    },
    "apm_monitoring": {
        "name": "Application Performance Monitoring",
        "category": "monitoring",
        "keywords": [
            "apm",
            "application performance",
            "latency tracking",
            "throughput",
            "response time",
            "slow query",
        ],
        "description": "Monitor application performance metrics",
        "sci_impact": "Identifies performance degradation and optimization opportunities",
    },
    # ==================== AI/ML OPTIMIZATION (Expanded from VU Amsterdam) ====================
    "model_pruning": {
        "name": "Model Pruning",
        "category": "ai",
        "keywords": [
            "prune",
            "pruning",
            "model prune",
            "weight pruning",
            "sparse model",
        ],
        "description": "Remove unnecessary model weights to reduce size",
        "sci_impact": "Reduces inference time and memory requirements",
    },
    "model_quantization": {
        "name": "Model Quantization",
        "category": "ai",
        "keywords": [
            "quantiz",
            "quantization",
            "int8",
            "fp16",
            "mixed precision",
            "lower precision",
        ],
        "description": "Reduce model precision to improve efficiency",
        "sci_impact": "Dramatically reduces memory and compute requirements",
    },
    "knowledge_distillation": {
        "name": "Knowledge Distillation",
        "category": "ai",
        "keywords": [
            "distill",
            "distillation",
            "knowledge distill",
            "teacher student",
            "model compress",
        ],
        "description": "Compress large models into smaller ones",
        "sci_impact": "Maintains accuracy while reducing model size and energy",
    },
    "early_stopping": {
        "name": "Early Stopping",
        "category": "ai",
        "keywords": [
            "early stop",
            "early stopping",
            "stop training",
            "convergence",
            "plateau",
        ],
        "description": "Stop training when model performance plateaus",
        "sci_impact": "Prevents wasted training energy after convergence",
    },
    "efficient_ml_framework": {
        "name": "Efficient ML Framework",
        "category": "ai",
        "keywords": [
            "tensorflow lite",
            "onnx",
            "onnx runtime",
            "tflite",
            "efficient framework",
            "optimized runtime",
        ],
        "description": "Use ML frameworks optimized for efficiency",
        "sci_impact": "Reduces inference overhead and energy consumption",
    },
    "edge_inference": {
        "name": "Edge Inference",
        "category": "ai",
        "keywords": [
            "edge inference",
            "edge computing",
            "edge ai",
            "on device",
            "local inference",
        ],
        "description": "Run inference on edge devices to reduce network transfers",
        "sci_impact": "Eliminates cloud round-trip and reduces data center load",
    },
    "batch_inference_optimization": {
        "name": "Batch Inference Optimization",
        "category": "ai",
        "keywords": [
            "batch inference",
            "batch predict",
            "inference batch",
            "batch size",
            "throughput optim",
        ],
        "description": "Optimize batch size for efficient inference",
        "sci_impact": "Maximizes GPU utilization and throughput",
    },
    "model_caching": {
        "name": "Model Prediction Caching",
        "category": "ai",
        "keywords": [
            "prediction cache",
            "inference cache",
            "model cache",
            "cache prediction",
        ],
        "description": "Cache predictions for repeated inputs",
        "sci_impact": "Avoids redundant inference computations",
    },
    # ==================== MICROSERVICES-SPECIFIC PATTERNS ====================
    "service_decomposition": {
        "name": "Service Decomposition & Right-Sizing",
        "category": "microservices",
        "keywords": [
            "service decomp",
            "decomposition",
            "right size service",
            "service boundary",
            "ddd",
            "domain driven",
        ],
        "description": "Decompose services appropriately to minimize overhead",
        "sci_impact": "Reduces inter-service communication overhead",
    },
    "service_colocation": {
        "name": "Service Co-location",
        "category": "microservices",
        "keywords": [
            "co-location",
            "colocation",
            "colocate",
            "data locality",
            "same host",
            "affinity",
        ],
        "description": "Co-locate related services to reduce network hops",
        "sci_impact": "Minimizes network latency and energy consumption",
    },
    "graceful_shutdown": {
        "name": "Graceful Shutdown",
        "category": "microservices",
        "keywords": [
            "graceful shutdown",
            "drain connection",
            "shutdown hook",
            "termination handler",
            "sigterm",
        ],
        "description": "Implement graceful service shutdown procedures",
        "sci_impact": "Prevents wasted work and enables efficient decommissioning",
    },
    "service_mesh_optimization": {
        "name": "Service Mesh Optimization",
        "category": "microservices",
        "keywords": [
            "service mesh",
            "istio",
            "linkerd",
            "envoy proxy",
            "sidecar",
            "mesh config",
        ],
        "description": "Optimize service mesh configuration for efficiency",
        "sci_impact": "Reduces proxy overhead and improves observability efficiency",
    },
    # ==================== INFRASTRUCTURE PATTERNS ====================
    "alpine_containers": {
        "name": "Minimal Container Images",
        "category": "infrastructure",
        "keywords": [
            "alpine",
            "lightweight image",
            "minimal image",
            "distroless",
            "slim image",
            "reduce image size",
        ],
        "description": "Use minimal base images for containers",
        "sci_impact": "Reduces storage, network transfer, and attack surface",
    },
    "infrastructure_as_code": {
        "name": "Infrastructure as Code Optimization",
        "category": "infrastructure",
        "keywords": [
            "terraform",
            "cloudformation",
            "infrastructure code",
            "iac",
            "infra automation",
        ],
        "description": "Automate infrastructure management for consistency",
        "sci_impact": "Enables consistent resource optimization and right-sizing",
    },
    "renewable_energy_regions": {
        "name": "Renewable Energy Regions",
        "category": "infrastructure",
        "keywords": [
            "renewable energy",
            "green region",
            "sustainable region",
            "clean energy",
            "carbon aware",
        ],
        "description": "Deploy in regions with renewable energy",
        "sci_impact": "Reduces carbon intensity of operations",
    },
    "pod_disruption_budget": {
        "name": "Pod Disruption Budget",
        "category": "infrastructure",
        "keywords": [
            "pod disruption",
            "pdb",
            "disruption budget",
            "availability",
            "maintenance",
        ],
        "description": "Configure pod disruption budgets for efficient updates",
        "sci_impact": "Enables efficient rolling updates without over-provisioning",
    },
    # ==================== GENERAL OPTIMIZATION PATTERNS ====================
    "feature_flags": {
        "name": "Feature Flags for Resource Control",
        "category": "general",
        "keywords": [
            "feature flag",
            "feature toggle",
            "flag",
            "toggle",
            "conditional feature",
        ],
        "description": "Use feature flags to control expensive features",
        "sci_impact": "Enables selective activation of resource-intensive features",
    },
    "incremental_processing": {
        "name": "Incremental Processing",
        "category": "general",
        "keywords": [
            "incremental",
            "delta",
            "diff",
            "change data capture",
            "cdc",
            "streaming",
        ],
        "description": "Process only changed data instead of full datasets",
        "sci_impact": "Dramatically reduces processing overhead for large datasets",
    },
    "precomputation": {
        "name": "Precomputation & Pre-aggregation",
        "category": "general",
        "keywords": [
            "precompute",
            "pre-aggregate",
            "preaggregate",
            "compute once",
            "precalculate",
        ],
        "description": "Precompute expensive operations ahead of time",
        "sci_impact": "Avoids redundant computation at query time",
    },
    "approximation_algorithms": {
        "name": "Approximation Algorithms",
        "category": "general",
        "keywords": [
            "approximate",
            "approximation",
            "heuristic",
            "estimation",
            "sampling",
        ],
        "description": "Use approximation for non-critical calculations",
        "sci_impact": "Reduces computational complexity with acceptable accuracy",
    },
}

# Green software keywords (comprehensive list from all GSF patterns)
GREEN_KEYWORDS = [
    # Core sustainability terms
    "energy",
    "power",
    "carbon",
    "emission",
    "footprint",
    "sustainability",
    "sustainable",
    "green",
    "efficient",
    "efficiency",
    "eco",
    "environment",
    "renewable",
    "clean energy",
    # Performance & optimization
    "optimize",
    "optimization",
    "optimise",
    "optimisation",
    "performance",
    "performant",
    "fast",
    "faster",
    "speed",
    "speedup",
    "latency",
    "throughput",
    "utilization",
    "improve",
    "improvement",
    "enhance",
    "enhancement",
    # Caching & storage
    "cache",
    "caching",
    "cached",
    "redis",
    "memcache",
    "memcached",
    "cdn",
    "storage",
    "compress",
    "compression",
    "compressed",
    "gzip",
    "brotli",
    "zstd",
    "deflate",
    "deduplicate",
    "deduplication",
    "dedup",
    "archive",
    "retention",
    "ttl",
    "time to live",
    "eviction",
    "invalidation",
    "invalidate",
    # Resource management
    "pool",
    "pooling",
    "connection pool",
    "thread pool",
    "worker pool",
    "resource pool",
    "object pool",
    "reuse",
    "recycle",
    "cleanup",
    "garbage",
    "remove unused",
    "delete unused",
    "limit",
    "limits",
    "constraint",
    "quota",
    "cap",
    "timeout",
    "idle",
    # Async & concurrency
    "async",
    "asynchronous",
    "non-blocking",
    "await",
    "promise",
    "queue",
    "background",
    "worker",
    "job",
    "batch",
    "batching",
    "concurrent",
    "parallel",
    "reactive",
    "event-driven",
    "event driven",
    "webhook",
    "callback",
    # Scaling & sizing
    "scale",
    "scaling",
    "autoscale",
    "autoscaling",
    "elastic",
    "elasticity",
    "horizontal",
    "vertical",
    "right-size",
    "rightsize",
    "right size",
    "downsize",
    "upsize",
    "hpa",
    "vpa",
    "keda",
    "demand",
    "load",
    "replica",
    "replicas",
    # Cloud native
    "serverless",
    "lambda",
    "function",
    "faas",
    "cloud function",
    "container",
    "docker",
    "kubernetes",
    "k8s",
    "pod",
    "microservice",
    "service mesh",
    "istio",
    "linkerd",
    "envoy",
    "sidecar",
    # Network optimization
    "network",
    "bandwidth",
    "transmission",
    "transfer",
    "latency",
    "proximity",
    "region",
    "closest",
    "edge",
    "cdn",
    "rate limit",
    "throttle",
    "backpressure",
    "circuit breaker",
    "bulkhead",
    "shed",
    "reduce request",
    "minimize request",
    "http2",
    "h2",
    "grpc",
    "protobuf",
    "protocol buffer",
    "multiplexing",
    "keep-alive",
    "keep alive",
    "persistent connection",
    # Data & database
    "index",
    "indexing",
    "query",
    "optimize query",
    "query optimization",
    "partition",
    "partitioning",
    "shard",
    "sharding",
    "database",
    "db",
    "sql",
    "nosql",
    "n+1",
    "n plus 1",
    "eager load",
    "prepared statement",
    "materialized view",
    "explain",
    "slow query",
    # Web optimization
    "minify",
    "minification",
    "uglify",
    "tree shake",
    "bundle",
    "lazy load",
    "defer",
    "offscreen",
    "viewport",
    "dom",
    "ssr",
    "server side rendering",
    "hydration",
    "webp",
    "avif",
    "image",
    "responsive",
    "pagination",
    "paginate",
    # AI/ML
    "model",
    "quantiz",
    "quantization",
    "prune",
    "pruning",
    "distill",
    "distillation",
    "inference",
    "training",
    "pretrain",
    "pre-trained",
    "transfer learning",
    "gpu",
    "tpu",
    "accelerator",
    "mobilenet",
    "efficientnet",
    "edge ai",
    "tflite",
    "tensorflow lite",
    "onnx",
    "fp16",
    "int8",
    "mixed precision",
    "early stop",
    # Code & architecture
    "stateless",
    "decouple",
    "independent",
    "component",
    "compiled",
    "rust",
    "go",
    "c++",
    "refactor",
    "dead code",
    "unused",
    "deprecate",
    "algorithm",
    "complexity",
    "big o",
    "memoize",
    "memoization",
    "reflection",
    "garbage collection",
    "gc",
    "memory leak",
    # Security (energy-related)
    "ddos",
    "vulnerability",
    "scan",
    "security",
    "waf",
    # Monitoring & SLO
    "slo",
    "sla",
    "metric",
    "monitor",
    "monitoring",
    "observability",
    "observ",
    "telemetry",
    "apm",
    "profiling",
    "profile",
    "flame graph",
    "benchmark",
    "rapl",
    "watt",
    # Specific technologies
    "redis",
    "memcached",
    "nginx",
    "envoy",
    "linkerd",
    "karpenter",
    "cluster autoscaler",
    "spot instance",
    "graviton",
    "arm",
    "architecture",
    "kafka",
    "rabbitmq",
    "message broker",
    "pub/sub",
    "publish",
    "subscribe",
    # Microservices specific
    "service",
    "decomposition",
    "boundary",
    "colocation",
    "co-location",
    "locality",
    "graceful shutdown",
    "drain",
    "api gateway",
    "graphql",
    "bff",
    # Infrastructure
    "alpine",
    "distroless",
    "lightweight",
    "minimal",
    "terraform",
    "cloudformation",
    "iac",
    "infrastructure as code",
    "pdb",
    "disruption budget",
    # General optimization
    "feature flag",
    "toggle",
    "incremental",
    "delta",
    "streaming",
    "precompute",
    "pre-aggregate",
    "approximate",
    "approximation",
    "heuristic",
    "sampling",
    # Additional VU Amsterdam terms
    "dvfs",
    "frequency scaling",
    "power state",
    "dynamic allocation",
    "adaptive",
    "predictive",
    "forecasting",
    "workload",
    "overhead",
    "footprint",
]


def get_pattern_by_keywords(commit_message: str) -> list:
    # Match commit message against GSF patterns.
    message_lower = commit_message.lower()
    matched_patterns = []

    for _pattern_id, pattern in GSF_PATTERNS.items():
        for keyword in pattern["keywords"]:
            if keyword.lower() in message_lower:
                matched_patterns.append(pattern["name"])
                break

    return matched_patterns


def is_green_aware(commit_message: str) -> bool:
    # Check if commit shows green software awareness.
    message_lower = commit_message.lower()
    return any(keyword.lower() in message_lower for keyword in GREEN_KEYWORDS)
