"""API types for the Refyne SDK.

These types are generated from the OpenAPI specification using datamodel-code-generator.
Do not edit this file manually - run `python scripts/generate_types.py` to regenerate.

Generated from API version: 0.0.0-dev

Documentation: https://refyne.uk/docs
"""

from __future__ import annotations

from typing import Any, Literal

from pydantic import AnyUrl, BaseModel, ConfigDict, Field, conint, constr


class APIKeyResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    created_at: str
    expires_at: str | None = None
    id: str
    key_prefix: str
    last_used_at: str | None = None
    name: str
    scopes: list[str]


class AdminJobResultsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    download_url: str = Field(
        ..., description="Presigned URL to download results (valid for 1 hour)"
    )
    expires_at: str = Field(..., description="URL expiration time")
    job_id: str = Field(..., description="Job ID")


class AnalyticsJobResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    completed_at: str | None = None
    cost_usd: float
    created_at: str
    discovery_method: str | None = None
    error_category: str | None = None
    error_message: str | None = None
    id: str
    is_byok: bool
    llm_cost_usd: float
    model: str | None = None
    provider: str | None = None
    status: str
    tokens_input: int
    tokens_output: int
    type: str
    url: str
    user_id: str


class AnalyzeInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    capture_debug: bool | None = Field(
        None,
        description="Enable debug capture to store raw LLM request/response for troubleshooting. Defaults to true for analyze jobs.",
    )
    depth: conint(ge=0, le=1) = Field(
        0, description="Crawl depth: 0=single page, 1=one level deep"
    )
    fetch_mode: Literal["auto", "static", "dynamic"] = Field(
        "auto", description="Fetch mode: auto, static, or dynamic"
    )
    url: constr(min_length=1) = Field(..., description="URL to analyze")


class CleanerChainItemResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: str = Field(..., description="Cleaner name")


class CleanerOptionResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    default: Any = Field(..., description="Default value if not specified")
    description: str = Field(..., description="Description of what this option does")
    name: str = Field(..., description="Option name (e.g., 'output', 'tables')")
    type: str = Field(..., description="Option type (string, boolean)")


class CleanerOptionsInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    base_url: str | None = Field(
        None, description="Base URL for resolving relative links"
    )
    extract_headings: bool | None = Field(
        None, description="Extract heading structure to frontmatter (markdown)"
    )
    extract_images: bool | None = Field(
        None,
        description="Extract images to frontmatter with {{IMG_001}} placeholders (markdown)",
    )
    include_frontmatter: bool | None = Field(
        None, description="Prepend YAML frontmatter with metadata (markdown output)"
    )
    keep_selectors: list[str] | None = Field(
        None, description="CSS selectors for elements to always keep"
    )
    output: Literal["html", "text", "markdown"] = Field(
        "html", description="Output format: html, text, or markdown"
    )
    preset: Literal["default", "minimal", "aggressive"] | None = Field(
        None, description="Preset: default, minimal, or aggressive"
    )
    remove_selectors: list[str] | None = Field(
        None, description="CSS selectors for elements to remove"
    )
    resolve_urls: bool | None = Field(
        None, description="Resolve relative URLs to absolute using base_url"
    )


class CleanerResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    description: str = Field(..., description="Description of what this cleaner does")
    name: str = Field(..., description="Cleaner name to use in cleaner_chain")
    options: list[CleanerOptionResponse] | None = Field(
        None, description="Available options for this cleaner"
    )


class CrawlMapEntry(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    completed_at: str | None = Field(None, description="When processing completed")
    depth: int = Field(..., description="Crawl depth (0 for seed URL)")
    discovered_at: str | None = Field(None, description="When URL was discovered")
    error_category: str | None = Field(
        None,
        description="Error classification: rate_limit, quota_exceeded, provider_error, invalid_key, context_length, invalid_response, network_error, unknown",
    )
    error_details: str | None = Field(
        None, description="Full error details (BYOK users only)"
    )
    error_message: str | None = Field(None, description="Error message if failed")
    extract_duration_ms: int = Field(..., description="Time to extract data in ms")
    fetch_duration_ms: int = Field(..., description="Time to fetch page in ms")
    id: str = Field(..., description="Result ID")
    llm_model: str | None = Field(None, description="LLM model used (BYOK users only)")
    llm_provider: str | None = Field(
        None, description="LLM provider used (BYOK users only)"
    )
    parent_url: str | None = Field(
        None, description="URL that discovered this page (null for seed)"
    )
    status: str = Field(
        ..., description="Crawl status: pending, crawling, completed, failed, skipped"
    )
    token_usage_input: int = Field(..., description="Input tokens used")
    token_usage_output: int = Field(..., description="Output tokens used")
    url: str = Field(..., description="Page URL")


class CrawlOptions(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    concurrency: conint(le=10) = Field(
        3, description="Concurrent extraction requests", examples=[5]
    )
    delay: str = Field(
        "500ms",
        description="Delay between requests (e.g., 500ms, 1s, 2s)",
        examples=["1s"],
    )
    extract_from_seeds: bool | None = Field(
        None,
        description="Extract data from the seed URL (not just discovered pages)",
        examples=[True],
    )
    fetch_mode: Literal["auto", "static", "dynamic"] = Field(
        "auto",
        description="Page fetching mode: auto (detect and retry with browser if needed), static (fast, Colly-based), dynamic (browser rendering for JS-heavy sites, requires content_dynamic feature)",
    )
    follow_pattern: str | None = Field(
        None,
        description="Regex pattern to filter URLs. Only matching URLs are crawled.",
        examples=["/product/.*|/item/.*"],
    )
    follow_selector: str | None = Field(
        None,
        description="CSS selector(s) for links to follow. Comma-separated or newline-separated.",
        examples=["a.product-link, a[href*='/product/']"],
    )
    max_depth: conint(le=5) = Field(
        1,
        description="Maximum crawl depth from seed URL (1 = seed + direct links)",
        examples=[2],
    )
    max_pages: conint(le=100) = Field(
        10,
        description="Maximum total pages to crawl (0 = no limit, up to tier max)",
        examples=[20],
    )
    max_urls: conint(le=500) = Field(
        50, description="Maximum URLs to discover and queue", examples=[100]
    )
    next_selector: str | None = Field(
        None,
        description="CSS selector for pagination 'next' link",
        examples=["a.pagination-next"],
    )
    same_domain_only: bool = Field(
        True, description="Only follow links on the same domain as seed URL"
    )
    use_sitemap: bool | None = Field(
        None, description="Discover URLs from sitemap.xml instead of CSS selectors"
    )


class CrawlOptionsInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    follow_pattern: str | None = Field(
        None, description="Regex pattern for URLs to filter"
    )
    follow_selector: str | None = Field(
        None, description="CSS selector for links to follow"
    )
    max_depth: int | None = Field(None, description="Max crawl depth")
    max_pages: int | None = Field(None, description="Max pages (0 = no limit)")


class CrawlOptionsOutput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    follow_pattern: str | None = Field(
        None, description="Regex pattern for URLs to filter"
    )
    follow_selector: str | None = Field(
        None, description="CSS selector for links to follow"
    )
    max_depth: int | None = Field(None, description="Max crawl depth")
    max_pages: int | None = Field(None, description="Max pages (0 = no limit)")


class CrawlWebhookHeaderInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: constr(min_length=1, max_length=256) = Field(..., description="Header name")
    value: constr(max_length=4096) = Field(..., description="Header value")


class CreateKeyInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    expires_at: str | None = Field(None, description="Expiration date (RFC3339)")
    name: constr(min_length=1) = Field(..., description="Descriptive name for the key")
    scopes: list[str] | None = Field(
        None, description="Permitted scopes (extract, crawl, jobs)"
    )


class CreateKeyOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    created_at: str
    expires_at: str | None = None
    id: str
    key: str = Field(..., description="Full API key - only shown once!")
    key_prefix: str
    name: str
    scopes: list[str]


class CreatePlatformSchemaInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    category: str = Field(..., description="Schema category")
    description: str | None = Field(None, description="Schema description")
    name: constr(min_length=1) = Field(..., description="Schema name")
    schema_yaml: constr(min_length=1) = Field(..., description="YAML schema content")
    tags: list[str] | None = Field(None, description="Schema tags")


class CreateSchemaInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    category: str | None = Field(None, description="Schema category")
    description: str | None = Field(None, description="Schema description")
    name: constr(min_length=1) = Field(..., description="Schema name")
    schema_yaml: constr(min_length=1) = Field(..., description="YAML schema content")
    tags: list[str] | None = Field(None, description="Schema tags")
    visibility: Literal["private", "public"] = Field(
        ..., description="Schema visibility"
    )


class DebugCaptureLLMRequest(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    content_size: int = Field(..., description="Size of content sent to LLM")
    fallback_position: int | None = Field(
        None, description="Position in fallback chain (0=primary)"
    )
    fetch_mode: str | None = Field(None, description="Content fetch mode")
    hints_applied: dict[str, str] | None = Field(
        None, description="Preprocessing hints applied"
    )
    is_retry: bool | None = Field(None, description="Whether this was a retry attempt")
    json_mode: bool | None = Field(None, description="Whether JSON mode was enabled")
    max_tokens: int | None = Field(None, description="Max tokens requested")
    model: str = Field(..., description="LLM model used")
    page_content: str | None = Field(
        None, description="Cleaned page content sent to LLM"
    )
    prompt: str | None = Field(
        None, description="Full prompt sent to LLM (for analyze jobs)"
    )
    prompt_size: int = Field(
        ..., description="Total prompt size including system instructions"
    )
    provider: str = Field(..., description="LLM provider used")
    schema_: str | None = Field(
        None, alias="schema", description="Schema used for extraction"
    )
    system_prompt: str | None = Field(
        None, description="System instructions sent to LLM"
    )
    temperature: float | None = Field(None, description="Temperature setting")
    user_prompt: str | None = Field(None, description="Formatted user content/prompt")


class DebugCaptureLLMResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    cost_usd: float | None = Field(None, description="Cost of this request in USD")
    duration_ms: int = Field(..., description="Request duration in milliseconds")
    error: str | None = Field(None, description="Error message if failed")
    error_category: str | None = Field(None, description="Error classification")
    input_tokens: int = Field(..., description="Input tokens consumed")
    output_tokens: int = Field(..., description="Output tokens generated")
    parse_error: str | None = Field(None, description="Error if JSON parsing failed")
    parsed_output: Any | None = Field(
        None, description="Structured data (if successfully parsed)"
    )
    raw_output: str | None = Field(None, description="Raw LLM response text")
    success: bool = Field(..., description="Whether the request succeeded")


class DeleteSavedSiteOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    success: bool = Field(..., description="Whether deletion was successful")


class DeleteSchemaOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    success: bool = Field(..., description="Whether deletion was successful")


class DeleteServiceKeyOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    success: bool


class DeleteUserServiceKeyOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    success: bool


class DeleteWebhookOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    success: bool = Field(..., description="Whether deletion was successful")


class DetectedElementInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    count: int | None = Field(None, description="Element count")
    description: str | None = Field(None, description="Element description")
    name: str | None = Field(None, description="Element name")
    type: str | None = Field(None, description="Element type")


class DetectedElementOutput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    count: int | None = Field(None, description="Number of occurrences")
    description: str = Field(..., description="What this element represents")
    name: str = Field(..., description="Suggested field name")
    type: str = Field(
        ..., description="Data type: string, number, boolean, array, url, date"
    )


class DownloadJobDebugCaptureOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    download_url: str = Field(
        ..., description="Signed URL for downloading the debug capture file"
    )
    expires_at: str = Field(..., description="When the download URL expires")
    filename: str = Field(..., description="Suggested filename for the download")
    job_id: str = Field(..., description="Job ID")


class ErrorCategoryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    category: str
    count: int
    percentage: float
    sample_messages: list[str] | None = None


class ErrorDetail(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    location: str | None = Field(
        None,
        description="Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'",
    )
    message: str | None = Field(None, description="Error message text")
    value: Any | None = Field(None, description="The value at the given location")


class ErrorModel(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    detail: str | None = Field(
        None,
        description="A human-readable explanation specific to this occurrence of the problem.",
        examples=["Property foo is required but is missing."],
    )
    errors: list[ErrorDetail] | None = Field(
        None, description="Optional list of individual error details"
    )
    instance: AnyUrl | None = Field(
        None,
        description="A URI reference that identifies the specific occurrence of the problem.",
        examples=["https://example.com/error-log/abc123"],
    )
    status: int | None = Field(None, description="HTTP status code", examples=[400])
    title: str | None = Field(
        None,
        description="A short, human-readable summary of the problem type. This value should not change between occurrences of the error.",
        examples=["Bad Request"],
    )
    type: AnyUrl = Field(
        "about:blank",
        description="A URI reference to human-readable documentation for the error.",
        examples=["https://example.com/errors/example"],
    )


class ErrorSummary(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    by_category: dict[str, int] = Field(
        ...,
        description="Count of errors by category (rate_limit, quota_exceeded, etc.)",
    )
    has_rate_limit: bool = Field(
        ..., description="True if any rate_limit errors occurred"
    )
    total: int = Field(..., description="Total number of failed pages")


class FailingURLResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    count: int
    url: str


class FallbackChainEntryInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    is_enabled: bool = Field(..., description="Whether this entry is enabled")
    max_tokens: int | None = Field(
        None, description="Max output tokens (nil for default)"
    )
    model: constr(min_length=1) = Field(..., description="Model identifier")
    provider: str = Field(
        ..., description="LLM provider name (see /llm/providers for available options)"
    )
    temperature: float | None = Field(
        None, description="Temperature setting (0.0-1.0, nil for default)"
    )


class FallbackChainEntryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    created_at: str
    id: str
    is_enabled: bool
    max_tokens: int | None = None
    model: str
    position: int
    provider: str
    temperature: float | None = None
    tier: str | None = None
    updated_at: str


class FollowPatternInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    description: str | None = Field(None, description="Pattern description")
    pattern: str | None = Field(None, description="URL pattern")
    sample_urls: list[str] | None = Field(None, description="Sample matching URLs")


class FollowPatternOutput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    description: str = Field(..., description="What this pattern targets")
    pattern: str = Field(..., description="CSS selector or URL pattern")
    sample_urls: list[str] | None = Field(
        None, description="Example URLs matching this pattern"
    )


class GetAnalyticsJobsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    jobs: list[AnalyticsJobResponse]
    total_count: int


class GetCrawlMapOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    completed: int = Field(..., description="Number of successfully completed pages")
    entries: list[CrawlMapEntry] = Field(
        ..., description="Crawl map entries ordered by depth"
    )
    error_summary: ErrorSummary | None = Field(
        None, description="Summary of errors if any pages failed"
    )
    failed: int = Field(..., description="Number of failed pages")
    job_id: str = Field(..., description="Job ID")
    max_depth: int = Field(..., description="Maximum depth reached")
    seed_url: str = Field(..., description="Initial seed URL")
    total: int = Field(..., description="Total pages in crawl map")


class GetFallbackChainOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    chain: list[FallbackChainEntryResponse]
    tiers: list[str]


class GetJobResultsDownloadOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    download_url: str = Field(
        ..., description="Presigned URL to download results (valid for 1 hour)"
    )
    expires_at: str = Field(..., description="URL expiration time")
    job_id: str = Field(..., description="Job ID")


class GetUsageOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    byok_jobs: int = Field(
        ..., description="Jobs using user's own API keys (not charged)"
    )
    total_charged_usd: float = Field(..., description="Total USD charged for usage")
    total_jobs: int = Field(..., description="Total number of jobs")


class HealthCheckOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    status: str
    version: str


class JobCleanerOptionsInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    base_url: str | None = Field(
        None, description="Base URL for resolving relative links"
    )
    extract_headings: bool | None = Field(
        None, description="Extract heading structure to frontmatter (markdown)"
    )
    extract_images: bool | None = Field(
        None,
        description="Extract images to frontmatter with {{IMG_001}} placeholders (markdown)",
    )
    include_frontmatter: bool | None = Field(
        None, description="Prepend YAML frontmatter with metadata (markdown output)"
    )
    keep_selectors: list[str] | None = Field(
        None, description="CSS selectors for elements to always keep"
    )
    output: Literal["html", "text", "markdown"] = Field(
        "html", description="Output format: html, text, or markdown"
    )
    preset: Literal["default", "minimal", "aggressive"] | None = Field(
        None, description="Preset: default, minimal, or aggressive"
    )
    remove_selectors: list[str] | None = Field(
        None, description="CSS selectors for elements to remove"
    )
    resolve_urls: bool | None = Field(
        None, description="Resolve relative URLs to absolute using base_url"
    )


class JobQueueStats(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    pending_by_tier: dict[str, int] = Field(..., description="Pending jobs by tier")
    pending_total: int = Field(..., description="Total pending jobs")
    running_by_tier: dict[str, int] = Field(..., description="Running jobs by tier")
    running_by_user: dict[str, int] = Field(..., description="Running jobs by user ID")
    running_total: int = Field(..., description="Total running jobs")


class JobResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    capture_debug: bool
    completed_at: str | None = None
    cost_usd: float
    created_at: str
    error_category: str | None = None
    error_message: str | None = None
    id: str
    page_count: int
    queue_position: int
    started_at: str | None = None
    status: str
    token_usage_input: int
    token_usage_output: int
    type: str
    url: str
    urls_queued: int


class JobWebhookDeliveryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    attempt_number: int = Field(..., description="Current attempt number")
    created_at: str = Field(..., description="Creation timestamp")
    delivered_at: str | None = Field(None, description="Successful delivery timestamp")
    error_message: str | None = Field(None, description="Error message if failed")
    event_type: str = Field(..., description="Event type that triggered this delivery")
    id: str = Field(..., description="Delivery ID")
    max_attempts: int = Field(..., description="Maximum retry attempts")
    response_time_ms: int | None = Field(
        None, description="Response time in milliseconds"
    )
    status: str = Field(
        ..., description="Delivery status (pending, success, failed, retrying)"
    )
    status_code: int | None = Field(None, description="HTTP status code received")
    url: str = Field(..., description="Destination URL")
    webhook_id: str | None = Field(None, description="Webhook ID (null for ephemeral)")


class LLMConfigInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    api_key: str | None = Field(None, description="API key for the provider")
    base_url: str | None = Field(
        None, description="Custom base URL (for Ollama or self-hosted Helicone)"
    )
    model: str | None = Field(None, description="Model to use")
    provider: (
        Literal["anthropic", "openai", "openrouter", "ollama", "helicone", "credits"]
        | None
    ) = Field(None, description="LLM provider")
    target_api_key: str | None = Field(
        None, description="Underlying provider's API key for Helicone self-hosted mode"
    )
    target_provider: str | None = Field(
        None, description="Underlying provider for Helicone self-hosted mode"
    )


class ListCleanersOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    cleaners: list[CleanerResponse] = Field(
        ..., description="List of available cleaners"
    )
    default_analysis_chain: list[CleanerChainItemResponse] = Field(
        ..., description="Default cleaner chain for analysis operations"
    )
    default_extraction_chain: list[CleanerChainItemResponse] = Field(
        ..., description="Default cleaner chain for extraction operations"
    )


class ListJobsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    jobs: list[JobResponse]


class ListKeysOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    keys: list[APIKeyResponse]


class LivezOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    status: str = Field(..., description="Liveness status")


class MetadataResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    extract_duration_ms: int = Field(
        ..., description="Time to extract data in milliseconds"
    )
    fetch_duration_ms: int = Field(
        ..., description="Time to fetch the page in milliseconds"
    )
    model: str = Field(..., description="Model used for extraction")
    provider: str = Field(..., description="LLM provider used")


class ModelValidationRequest(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    model: str = Field(..., description="Model identifier")
    provider: str = Field(..., description="Provider name")


class ModelValidationResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    message: str | None = None
    model: str
    provider: str
    status: str


class OverviewResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    active_users: int = Field(..., description="Number of unique users with jobs")
    byok_jobs: int = Field(..., description="Jobs using user API keys")
    completed_jobs: int = Field(..., description="Number of completed jobs")
    error_rate: float = Field(..., description="Error rate percentage")
    failed_jobs: int = Field(..., description="Number of failed jobs")
    platform_jobs: int = Field(..., description="Jobs using platform API keys")
    total_cost_usd: float = Field(..., description="Total cost in USD")
    total_jobs: int = Field(..., description="Total number of jobs")
    total_tokens_input: int = Field(..., description="Total input tokens")
    total_tokens_output: int = Field(..., description="Total output tokens")


class ProviderErrorResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    count: int
    model: str
    provider: str


class ProviderInfo(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    allow_base_url_override: bool
    base_url_hint: str | None = None
    decommission_note: str | None = None
    description: str
    display_name: str
    docs_url: str | None = None
    key_placeholder: str | None = None
    name: str
    required_features: list[str] | None = None
    requires_key: bool
    status: str
    successor_provider: str | None = None


class ProviderModelResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    context_size: int | None = None
    description: str | None = None
    id: str
    is_free: bool
    name: str


class RateLimitStats(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    active_suspensions: int = Field(
        ..., description="Number of currently suspended API keys"
    )
    total_entries: int = Field(..., description="Total rate limit entries in database")


class ReadyzOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    status: str = Field(..., description="Readiness status")


class RevokeKeyOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    success: bool


class SSECompleteEvent(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    cost_usd: float | None = Field(None, description="Total cost in USD")
    error_category: str | None = Field(None, description="Error category if job failed")
    error_message: str | None = Field(None, description="Error message if job failed")
    job_id: str = Field(..., description="Job ID")
    page_count: int = Field(..., description="Total pages processed")
    results_url: str = Field(..., description="URL to fetch full results")
    status: str = Field(..., description="Final job status")


class SSEErrorEvent(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    message: str = Field(..., description="Error message")


class SSEResultEvent(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    error_category: str | None = Field(None, description="Error category if failed")
    error_message: str | None = Field(None, description="Error message if failed")
    id: str = Field(..., description="Result ID")
    llm_model: str | None = Field(None, description="LLM model used")
    llm_provider: str | None = Field(None, description="LLM provider used")
    status: str = Field(..., description="Crawl status (pending, completed, failed)")
    url: str = Field(..., description="Source URL")


class SSEStatusEvent(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    job_id: str = Field(..., description="Job ID")
    page_count: int = Field(..., description="Number of pages processed so far")
    status: str = Field(
        ..., description="Job status (pending, running, completed, failed)"
    )
    urls_queued: int = Field(..., description="Number of URLs queued for processing")


class SchemaOutput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    category: str | None = Field(None, description="Schema category")
    created_at: str = Field(..., description="Creation timestamp")
    description: str | None = Field(None, description="Schema description")
    id: str = Field(..., description="Schema ID")
    is_platform: bool = Field(..., description="True for admin-managed schemas")
    name: str = Field(..., description="Schema name")
    organization_id: str | None = Field(None, description="Organization ID (Clerk)")
    schema_yaml: str = Field(..., description="YAML schema content")
    tags: list[str] | None = Field(None, description="Schema tags")
    updated_at: str = Field(..., description="Last update timestamp")
    usage_count: int = Field(..., description="Number of times schema has been used")
    user_id: str | None = Field(None, description="Creator user ID")
    visibility: str = Field(..., description="Visibility: platform, public, private")


class ServiceKeyInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    api_key: str | None = Field(
        None,
        description="API key for the provider (required for new keys, optional for updates)",
    )
    is_enabled: bool = Field(..., description="Whether this provider is enabled")
    provider: str = Field(
        ..., description="LLM provider name (see /llm/providers for available options)"
    )


class ServiceKeyResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    created_at: str
    has_key: bool
    is_enabled: bool
    provider: str
    updated_at: str


class SetFallbackChainInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    chain: list[FallbackChainEntryInput] = Field(
        ..., description="Ordered list of provider:model pairs"
    )
    tier: str | None = Field(
        None, description="Tier to set chain for (null for default chain)"
    )


class SetFallbackChainOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    chain: list[FallbackChainEntryResponse]


class SubscriptionTierResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    description: str | None = None
    id: str
    is_default: bool
    name: str
    slug: str


class SyncTiersOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    message: str = Field(..., description="Sync result message")


class SystemMetrics(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    job_queue: JobQueueStats = Field(..., description="Job queue statistics")
    rate_limits: RateLimitStats = Field(
        ..., description="API key rate limit statistics"
    )


class TierLimitsResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    credit_allocation_usd: float = Field(
        ..., description="Monthly USD credit for premium model calls (0 = none)"
    )
    credit_rollover_months: int = Field(
        ...,
        description="Credit expiry: -1 = never, 0 = current period, N = N additional periods",
    )
    display_name: str = Field(
        ..., description="Human-readable tier name (from Clerk Commerce)"
    )
    max_concurrent_jobs: int = Field(
        ..., description="Max concurrent jobs (0 = unlimited)"
    )
    max_pages_per_crawl: int = Field(
        ..., description="Max pages per crawl job (0 = unlimited)"
    )
    monthly_extractions: int = Field(
        ..., description="Monthly extraction limit (0 = unlimited)"
    )
    name: str = Field(..., description="Tier name (free, standard, pro, selfhosted)")
    requests_per_minute: int = Field(
        ..., description="API requests per minute limit (0 = unlimited)"
    )


class TierValidationRequest(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    tier_id: str = Field(..., description="Tier ID or slug to validate")


class TierValidationResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    current_slug: str | None = None
    message: str | None = None
    status: str
    tier_id: str


class TokenUsage(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    input: int = Field(
        ...,
        description="Total input tokens consumed across all extractions",
        examples=[8500],
    )
    output: int = Field(
        ...,
        description="Total output tokens generated across all extractions",
        examples=[2100],
    )


class TrendPointResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    cost_usd: float
    date: str
    error_count: int
    job_count: int
    tokens: int


class UpdateSchemaInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    category: str | None = Field(None, description="Schema category")
    description: str | None = Field(None, description="Schema description")
    name: str | None = Field(None, description="Schema name")
    schema_yaml: str | None = Field(None, description="YAML schema content")
    tags: list[str] | None = Field(None, description="Schema tags")
    visibility: Literal["private", "public"] | None = Field(
        None, description="Schema visibility"
    )


class UsageResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    cost_usd: float = Field(
        ..., description="Total USD cost charged for this extraction"
    )
    input_tokens: int = Field(..., description="Number of input tokens used")
    is_byok: bool = Field(
        ..., description="True if user's own API key was used (no charge)"
    )
    llm_cost_usd: float = Field(..., description="Actual LLM cost from provider")
    output_tokens: int = Field(..., description="Number of output tokens used")


class UserFallbackChainEntryInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    is_enabled: bool = Field(..., description="Whether this entry is enabled")
    max_tokens: int | None = Field(
        None, description="Max output tokens (nil for default)"
    )
    model: constr(min_length=1) = Field(..., description="Model identifier")
    provider: str = Field(
        ..., description="LLM provider name (see /llm/providers for available options)"
    )
    temperature: float | None = Field(
        None, description="Temperature setting (0.0-1.0, nil for default)"
    )


class UserFallbackChainEntryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    created_at: str
    id: str
    is_enabled: bool
    max_tokens: int | None = None
    model: str
    position: int
    provider: str
    temperature: float | None = None
    updated_at: str


class UserModelResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    context_size: int | None = None
    description: str | None = None
    id: str
    is_free: bool
    name: str


class UserServiceKeyInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    api_key: str | None = Field(
        None, description="API key for the provider (leave empty to keep existing)"
    )
    base_url: str | None = Field(
        None, description="Base URL for the provider (for Ollama or custom endpoints)"
    )
    is_enabled: bool = Field(..., description="Whether this provider is enabled")
    provider: str = Field(
        ..., description="LLM provider name (see /llm/providers for available options)"
    )


class UserServiceKeyResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    base_url: str | None = None
    created_at: str
    has_key: bool
    id: str
    is_enabled: bool
    provider: str
    updated_at: str


class UserSummaryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    completed_jobs: int
    failed_jobs: int
    last_active: str | None = None
    total_cost_usd: float
    total_jobs: int
    total_tokens: int
    user_id: str


class ValidateModelsInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    models: list[ModelValidationRequest] = Field(..., description="Models to validate")


class ValidateModelsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    results: list[ModelValidationResponse]


class ValidateTiersInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    tiers: list[TierValidationRequest] = Field(..., description="Tiers to validate")


class ValidateTiersOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    results: list[TierValidationResponse]


class WebhookDeliveryResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    attempt_number: int = Field(..., description="Current attempt number")
    created_at: str = Field(..., description="Creation timestamp")
    delivered_at: str | None = Field(None, description="Successful delivery timestamp")
    error_message: str | None = Field(None, description="Error message if failed")
    event_type: str = Field(..., description="Event type that triggered this delivery")
    id: str = Field(..., description="Delivery ID")
    job_id: str = Field(..., description="Associated job ID")
    max_attempts: int = Field(..., description="Maximum retry attempts")
    next_retry_at: str | None = Field(None, description="Next retry time if retrying")
    response_time_ms: int | None = Field(
        None, description="Response time in milliseconds"
    )
    status: str = Field(
        ..., description="Delivery status (pending, success, failed, retrying)"
    )
    status_code: int | None = Field(None, description="HTTP status code received")
    url: str = Field(..., description="Destination URL")
    webhook_id: str | None = Field(
        None, description="Webhook ID (null for ephemeral webhooks)"
    )


class WebhookHeaderInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: constr(min_length=1, max_length=256) = Field(..., description="Header name")
    value: constr(max_length=4096) = Field(..., description="Header value")


class WebhookInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    events: list[str] | None = Field(
        None, description='Event types to subscribe to (empty or ["*"] for all events)'
    )
    headers: list[WebhookHeaderInput] | None = Field(
        None, description="Custom headers to include in webhook requests", max_length=10
    )
    is_active: bool = Field(..., description="Whether this webhook is active")
    name: constr(min_length=1, max_length=64) = Field(
        ..., description="Unique name for this webhook"
    )
    secret: constr(max_length=256) | None = Field(
        None,
        description="Secret for HMAC-SHA256 signature (leave empty to disable signing)",
    )
    url: AnyUrl = Field(..., description="Webhook URL to send events to")


class WebhookResponse(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    created_at: str = Field(..., description="Creation timestamp")
    events: list[str] = Field(..., description="Subscribed event types")
    has_secret: bool = Field(
        ..., description="Whether this webhook has a secret configured"
    )
    headers: list[WebhookHeaderInput] | None = Field(None, description="Custom headers")
    id: str = Field(..., description="Unique webhook ID")
    is_active: bool = Field(..., description="Whether this webhook is active")
    name: str = Field(..., description="Webhook name")
    updated_at: str = Field(..., description="Last update timestamp")
    url: str = Field(..., description="Webhook URL")


class AnalysisResultInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    detected_elements: list[DetectedElementInput] | None = Field(
        None, description="Detected data elements"
    )
    follow_patterns: list[FollowPatternInput] | None = Field(
        None, description="Follow patterns"
    )
    page_type: str | None = Field(None, description="Detected page type")
    recommended_fetch_mode: str | None = Field(
        None, description="Recommended fetch mode"
    )
    sample_links: list[str] | None = Field(None, description="Sample links found")
    site_summary: str | None = Field(None, description="Brief site description")
    suggested_schema: str | None = Field(
        None, description="Schema (JSON or YAML format)"
    )


class AnalysisResultOutput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    detected_elements: list[DetectedElementOutput] = Field(
        ..., description="Detected data elements"
    )
    follow_patterns: list[FollowPatternOutput] = Field(
        ..., description="Follow patterns"
    )
    page_type: str = Field(..., description="Detected page type")
    recommended_fetch_mode: str = Field(..., description="Recommended fetch mode")
    sample_links: list[str] = Field(..., description="Sample links found")
    site_summary: str = Field(..., description="Brief site description")
    suggested_schema: str = Field(..., description="Schema suggestion (JSON format)")


class AnalyzeResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    detected_elements: list[DetectedElementOutput] = Field(
        ..., description="Data elements detected on the page"
    )
    follow_patterns: list[FollowPatternOutput] = Field(
        ..., description="URL/selector patterns for crawling"
    )
    job_id: str = Field(
        ..., description="Unique job ID for this analysis (for tracking/history)"
    )
    page_type: str = Field(
        ...,
        description="Detected page type: listing, detail, article, product, recipe, unknown",
    )
    recommended_fetch_mode: str = Field(
        ..., description="Recommended fetch mode: static or dynamic"
    )
    sample_data: Any | None = Field(
        None, description="Optional preview extraction result"
    )
    sample_links: list[str] = Field(..., description="Sample links found on the page")
    site_summary: str = Field(
        ..., description="Brief description of what the site/page is about"
    )
    suggested_schema: str = Field(
        ..., description="Schema suggestion for extraction (JSON format)"
    )


class CleanerConfigInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: constr(min_length=1) = Field(..., description="Cleaner name (noop, refyne)")
    options: CleanerOptionsInput | None = Field(
        None, description="Cleaner-specific options"
    )


class CrawlInlineWebhookInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    events: list[str] | None = Field(
        None, description="Event types to subscribe to (empty for all)"
    )
    headers: list[CrawlWebhookHeaderInput] | None = Field(
        None, description="Custom headers", max_length=10
    )
    secret: constr(max_length=256) | None = Field(
        None, description="Secret for HMAC-SHA256 signature"
    )
    url: AnyUrl = Field(..., description="Webhook URL")


class CrawlJobResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    cost_usd: float | None = Field(
        None, description="Total USD cost charged (sync mode)", examples=[0.15]
    )
    data: dict[str, Any] | None = Field(
        None,
        description="Merged extraction results from all pages (sync mode, completed only)",
    )
    duration_ms: int | None = Field(
        None,
        description="Total job duration in milliseconds (sync mode)",
        examples=[12500],
    )
    error_message: str | None = Field(
        None, description="Error message if job failed or timed out"
    )
    job_id: str = Field(
        ...,
        description="Unique job identifier (ULID)",
        examples=["01HXYZ123ABC456DEF789"],
    )
    page_count: int | None = Field(
        None,
        description="Number of pages successfully extracted (sync mode)",
        examples=[5],
    )
    queue_position: int | None = Field(
        None,
        description="Position in queue (1-indexed, only for pending jobs)",
        examples=[3],
    )
    status: str = Field(
        ...,
        description="Job status: pending, running, completed, failed",
        examples=["completed"],
    )
    status_url: str | None = Field(
        None,
        description="URL to poll for job status (async mode)",
        examples=["https://api.refyne.uk/api/v1/jobs/01HXYZ123ABC456DEF789"],
    )
    token_usage: TokenUsage | None = Field(
        None, description="Token usage statistics (sync mode)"
    )


class CreateSavedSiteInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    analysis_result: AnalysisResultInput | None = Field(
        None, description="Analysis result to save"
    )
    crawl_options: CrawlOptionsInput | None = Field(None, description="Crawl options")
    default_schema_id: str | None = Field(None, description="Default schema ID")
    fetch_mode: Literal["auto", "static", "dynamic"] = Field(
        "auto", description="Fetch mode"
    )
    name: str | None = Field(None, description="User-friendly name")
    url: constr(min_length=1) = Field(..., description="Site URL")


class DebugCaptureEntry(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    api_version: str | None = Field(
        None, description="API version that processed this request"
    )
    id: str = Field(..., description="Capture ID")
    is_byok: bool | None = Field(
        None, description="Whether user's own API key was used"
    )
    job_type: str = Field(..., description="Job type (analyze, extract, crawl)")
    request: DebugCaptureLLMRequest = Field(
        ..., description="LLM request with metadata and payload"
    )
    response: DebugCaptureLLMResponse = Field(
        ..., description="LLM response with metadata and payload"
    )
    sequence: int | None = Field(None, description="Order within job (0-indexed)")
    timestamp: str = Field(..., description="When the request was made")
    url: str = Field(..., description="Page URL being processed")


class ExtractOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    data: Any = Field(..., description="Extracted data matching the schema")
    fetched_at: str = Field(..., description="Timestamp when the page was fetched")
    input_format: str = Field(
        ...,
        description="How the input was interpreted: 'schema' (structured YAML/JSON) or 'prompt' (freeform text)",
    )
    job_id: str = Field(
        ..., description="Job ID for this extraction (for history/tracking)"
    )
    metadata: MetadataResponse = Field(..., description="Extraction metadata")
    url: str = Field(..., description="URL that was extracted")
    usage: UsageResponse = Field(..., description="Token usage information")


class GetAnalyticsUsersOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    total_count: int
    users: list[UserSummaryResponse]


class GetErrorsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    by_category: list[ErrorCategoryResponse]
    by_provider: list[ProviderErrorResponse]
    top_failing_urls: list[FailingURLResponse]


class GetJobDebugCaptureOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    api_version: str | None = Field(
        None, description="API version that processed this job"
    )
    captures: list[DebugCaptureEntry] = Field(..., description="Captured LLM requests")
    enabled: bool = Field(
        ..., description="Whether debug capture was enabled for this job"
    )
    is_byok: bool | None = Field(
        None, description="Whether user's own API key was used"
    )
    job_id: str = Field(..., description="Job ID")
    job_type: str | None = Field(None, description="Job type (analyze, extract, crawl)")
    total_cost_usd: float | None = Field(None, description="Total cost in USD")
    total_duration_ms: int | None = Field(
        None, description="Total duration in milliseconds"
    )
    total_requests: int | None = Field(None, description="Number of LLM requests")
    total_tokens_in: int | None = Field(None, description="Total input tokens")
    total_tokens_out: int | None = Field(None, description="Total output tokens")


class GetJobWebhookDeliveriesOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    deliveries: list[JobWebhookDeliveryResponse] = Field(
        ..., description="Webhook deliveries for this job"
    )
    job_id: str = Field(..., description="Job ID")


class GetTrendsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    trends: list[TrendPointResponse]


class GetUserFallbackChainOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    chain: list[UserFallbackChainEntryResponse]


class InlineWebhookInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    events: list[str] | None = Field(
        None, description="Event types to subscribe to (empty for all)"
    )
    headers: list[WebhookHeaderInput] | None = Field(
        None, description="Custom headers", max_length=10
    )
    secret: constr(max_length=256) | None = Field(
        None, description="Secret for HMAC-SHA256 signature"
    )
    url: AnyUrl = Field(..., description="Webhook URL")


class JobCleanerConfigInput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    name: constr(min_length=1) = Field(..., description="Cleaner name (noop, refyne)")
    options: JobCleanerOptionsInput | None = Field(
        None, description="Cleaner-specific options"
    )


class ListAllSchemasOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    schemas: list[SchemaOutput] = Field(..., description="List of all schemas")


class ListModelsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    models: list[ProviderModelResponse]


class ListProvidersOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    providers: list[ProviderInfo]


class ListSchemasOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    schemas: list[SchemaOutput] = Field(..., description="List of schemas")


class ListServiceKeysOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    keys: list[ServiceKeyResponse]


class ListTierLimitsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    tiers: list[TierLimitsResponse] = Field(
        ..., description="List of visible tiers and their limits"
    )


class ListTiersOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    tiers: list[SubscriptionTierResponse]


class ListUserServiceKeysOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    keys: list[UserServiceKeyResponse]


class ListWebhookDeliveriesOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    deliveries: list[WebhookDeliveryResponse] = Field(
        ..., description="List of webhook deliveries"
    )


class ListWebhooksOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    webhooks: list[WebhookResponse] = Field(..., description="List of user's webhooks")


class SavedSiteOutput(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    analysis_result: AnalysisResultOutput | None = Field(
        None, description="Analysis result"
    )
    crawl_options: CrawlOptionsOutput | None = Field(
        None, description="Saved crawl options"
    )
    created_at: str = Field(..., description="Creation timestamp")
    default_schema_id: str | None = Field(None, description="Default schema to use")
    domain: str = Field(..., description="Extracted domain")
    fetch_mode: str = Field(..., description="Fetch mode: auto, static, dynamic")
    id: str = Field(..., description="Site ID")
    name: str | None = Field(None, description="User-friendly name")
    organization_id: str | None = Field(None, description="Organization ID for sharing")
    updated_at: str = Field(..., description="Last update timestamp")
    url: str = Field(..., description="Site URL")
    user_id: str = Field(..., description="Owner user ID")


class SetUserFallbackChainInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    chain: list[UserFallbackChainEntryInput] = Field(
        ..., description="Ordered list of provider:model pairs"
    )


class SetUserFallbackChainOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    chain: list[UserFallbackChainEntryResponse]


class UpdateSavedSiteInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    analysis_result: AnalysisResultInput | None = Field(
        None, description="Analysis result to update"
    )
    crawl_options: CrawlOptionsInput | None = Field(None, description="Crawl options")
    default_schema_id: str | None = Field(None, description="Default schema ID")
    fetch_mode: Literal["auto", "static", "dynamic"] | None = Field(
        None, description="Fetch mode"
    )
    name: str | None = Field(None, description="User-friendly name")
    url: str | None = Field(None, description="Site URL (ignored on update)")


class UserListModelsOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    models: list[UserModelResponse]


class CreateCrawlJobInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    capture_debug: bool | None = Field(
        None,
        description="Enable debug capture to store raw LLM request/response for troubleshooting",
    )
    cleaner_chain: list[JobCleanerConfigInput] | None = Field(
        None, description="Content cleaner chain (default: [markdown])"
    )
    llm_config: LLMConfigInput | None = Field(
        None, description="Optional LLM configuration override (BYOK)"
    )
    options: CrawlOptions | None = Field(
        None, description="Crawl configuration options"
    )
    schema_: Any = Field(
        ...,
        alias="schema",
        description="Extraction instructions - either a structured schema (YAML/JSON with 'name' and 'fields') or freeform natural language prompt. The API auto-detects the format.",
    )
    url: constr(min_length=1) = Field(
        ...,
        description="Seed URL to start crawling from",
        examples=["https://example.com/products"],
    )
    webhook: CrawlInlineWebhookInput | None = Field(
        None, description="Inline ephemeral webhook configuration"
    )
    webhook_id: str | None = Field(
        None, description="ID of a saved webhook to call on job events"
    )
    webhook_url: AnyUrl | None = Field(
        None,
        description="Simple webhook URL (backward compatible)",
        examples=["https://my-app.com/webhook/crawl-complete"],
    )


class ExtractInputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    capture_debug: bool | None = Field(
        None,
        description="Enable debug capture to store raw LLM request/response for troubleshooting",
    )
    cleaner_chain: list[CleanerConfigInput] | None = Field(
        None, description="Content cleaner chain (default: [markdown])"
    )
    fetch_mode: Literal["auto", "static", "dynamic"] = Field(
        "auto", description="Fetch mode: auto, static, or dynamic"
    )
    llm_config: LLMConfigInput | None = Field(
        None, description="Optional LLM configuration override"
    )
    schema_: Any = Field(
        ...,
        alias="schema",
        description="Extraction instructions - either a structured schema (YAML/JSON with 'name' and 'fields') or freeform natural language prompt. The API auto-detects the format and returns 'input_format' in the response.",
    )
    url: constr(min_length=1) = Field(..., description="URL to extract data from")
    webhook: InlineWebhookInput | None = Field(
        None, description="Inline ephemeral webhook configuration"
    )
    webhook_id: str | None = Field(
        None, description="ID of a saved webhook to call on completion"
    )
    webhook_url: AnyUrl | None = Field(
        None, description="Simple webhook URL (backward compatible)"
    )


class ListSavedSitesOutputBody(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
        populate_by_name=True,
    )
    sites: list[SavedSiteOutput] = Field(..., description="List of saved sites")
