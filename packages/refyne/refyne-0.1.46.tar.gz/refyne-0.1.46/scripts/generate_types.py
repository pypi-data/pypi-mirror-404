#!/usr/bin/env python3
"""Generate Python types from the Refyne API OpenAPI specification.

This script uses datamodel-code-generator to generate Pydantic models from
the OpenAPI spec. The output is written to src/refyne/types.py.

Usage:
    python scripts/generate_types.py [options]
    # Or via uv:
    uvx --from datamodel-code-generator datamodel-codegen --input openapi.json --output src/refyne/types.py

Options:
    --url <url>      Fetch spec from URL (default: http://localhost:8080/openapi.json)
    --file <path>    Read spec from local file
    --output <path>  Output file path (default: src/refyne/types.py)
    --help           Show this help message

Environment Variables:
    OPENAPI_SPEC_URL   Override the default URL
    OPENAPI_SPEC_FILE  Use a local file instead of fetching

Documentation: https://refyne.uk/docs
"""

from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
import tempfile
import urllib.request
from pathlib import Path
from typing import Any

DEFAULT_SPEC_URL = "http://localhost:8080/openapi.json"
DEFAULT_OUTPUT = "src/refyne/types.py"


def fetch_spec(url: str) -> dict[str, Any]:
    """Fetch the OpenAPI spec from a URL."""
    print(f"Fetching OpenAPI spec from: {url}")
    try:
        with urllib.request.urlopen(url, timeout=30) as response:
            return json.loads(response.read().decode("utf-8"))
    except urllib.error.URLError as e:
        raise RuntimeError(f"Failed to fetch spec: {e}") from e


def load_spec_from_file(file_path: str) -> dict[str, Any]:
    """Load the OpenAPI spec from a local file."""
    print(f"Loading OpenAPI spec from file: {file_path}")
    path = Path(file_path).resolve()
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def run_datamodel_codegen(input_path: Path, output_path: Path) -> None:
    """Run datamodel-code-generator to generate Pydantic models."""
    cmd = [
        sys.executable,
        "-m",
        "datamodel_code_generator",
        "--input",
        str(input_path),
        "--output",
        str(output_path),
        "--output-model-type",
        "pydantic_v2.BaseModel",
        "--target-python-version",
        "3.10",
        "--use-standard-collections",
        "--use-union-operator",
        "--enum-field-as-literal",
        "all",
        "--input-file-type",
        "openapi",
        "--collapse-root-models",
        "--use-double-quotes",
        "--allow-population-by-field-name",
        "--strict-nullable",
    ]

    print(f"Running: {' '.join(cmd)}")

    try:
        subprocess.run(cmd, check=True, capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Error running datamodel-code-generator: {e.stderr}", file=sys.stderr)
        raise


def add_header_to_generated_file(output_path: Path, api_version: str) -> None:
    """Add a header comment to the generated file."""
    content = output_path.read_text(encoding="utf-8")

    header = f'''"""API types for the Refyne SDK.

These types are generated from the OpenAPI specification using datamodel-code-generator.
Do not edit this file manually - run `python scripts/generate_types.py` to regenerate.

Generated from API version: {api_version}

Documentation: https://refyne.uk/docs
"""

'''

    # Replace the default generated header
    if content.startswith("# generated by datamodel-codegen"):
        # Find the end of the header block (after the timestamp line)
        lines = content.split("\n")
        start_idx = 0
        for i, line in enumerate(lines):
            if line and not line.startswith("#"):
                start_idx = i
                break
        content = "\n".join(lines[start_idx:])

    output_path.write_text(header + content, encoding="utf-8")


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Generate Python types from the Refyne API OpenAPI specification.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Fetch from local development server
  python scripts/generate_types.py

  # Fetch from production API
  python scripts/generate_types.py --url https://api.refyne.uk/openapi.json

  # Documentation: https://refyne.uk/docs

  # Use a local file
  python scripts/generate_types.py --file ./openapi.json

  # Using environment variables
  OPENAPI_SPEC_URL=http://localhost:8080/openapi.json python scripts/generate_types.py
""",
    )
    parser.add_argument(
        "--url",
        help=f"Fetch spec from URL (default: {DEFAULT_SPEC_URL})",
    )
    parser.add_argument(
        "--file",
        help="Read spec from local file",
    )
    parser.add_argument(
        "--output",
        default=DEFAULT_OUTPUT,
        help=f"Output file path (default: {DEFAULT_OUTPUT})",
    )
    return parser.parse_args()


def main() -> int:
    """Main entry point."""
    args = parse_args()

    # Determine source: CLI args override env vars
    spec_url = args.url or os.environ.get("OPENAPI_SPEC_URL")
    spec_file = args.file or os.environ.get("OPENAPI_SPEC_FILE")

    # File takes precedence if both specified
    if spec_file:
        spec_url = None
    elif not spec_url:
        spec_url = DEFAULT_SPEC_URL

    try:
        # Either load from file or fetch from URL
        if spec_file:
            spec = load_spec_from_file(spec_file)
            input_path = Path(spec_file).resolve()
        else:
            assert spec_url is not None
            spec = fetch_spec(spec_url)
            # Write to temp file for datamodel-codegen
            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".json", delete=False, encoding="utf-8"
            ) as f:
                json.dump(spec, f)
                input_path = Path(f.name)

        print(f"OpenAPI version: {spec.get('openapi', 'unknown')}")
        print(f"API title: {spec.get('info', {}).get('title', 'unknown')}")
        api_version = spec.get("info", {}).get("version", "unknown")
        print(f"API version: {api_version}")

        schema_count = len(spec.get("components", {}).get("schemas", {}))
        print(f"Schema count: {schema_count}")

        output_path = Path(args.output).resolve()
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Run datamodel-code-generator
        run_datamodel_codegen(input_path, output_path)

        # Add custom header
        add_header_to_generated_file(output_path, api_version)

        print(f"Types written to: {output_path}")

        # Clean up temp file if we created one
        if not spec_file:
            input_path.unlink()

        return 0

    except Exception as e:
        print(f"Error generating types: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
