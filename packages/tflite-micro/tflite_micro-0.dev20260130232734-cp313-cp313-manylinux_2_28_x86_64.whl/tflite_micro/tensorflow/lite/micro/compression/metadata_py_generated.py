import flatbuffers

# automatically generated by the FlatBuffers compiler, do not modify

# namespace: compression

from flatbuffers.compat import import_numpy
np = import_numpy()

class Metadata(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Metadata()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMetadata(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Metadata
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Metadata
    def SchemaVersion(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 1

    # Metadata
    def Subgraphs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Subgraph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Metadata
    def SubgraphsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Metadata
    def SubgraphsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def MetadataStart(builder):
    builder.StartObject(2)

def MetadataAddSchemaVersion(builder, schemaVersion):
    builder.PrependUint32Slot(0, schemaVersion, 1)

def MetadataAddSubgraphs(builder, subgraphs):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(subgraphs), 0)

def MetadataStartSubgraphsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def MetadataEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class MetadataT(object):

    # MetadataT
    def __init__(
        self,
        schemaVersion = 1,
        subgraphs = None,
    ):
        self.schemaVersion = schemaVersion  # type: int
        self.subgraphs = subgraphs  # type: Optional[List[SubgraphT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        metadata = Metadata()
        metadata.Init(buf, pos)
        return cls.InitFromObj(metadata)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, metadata):
        x = MetadataT()
        x._UnPack(metadata)
        return x

    # MetadataT
    def _UnPack(self, metadata):
        if metadata is None:
            return
        self.schemaVersion = metadata.SchemaVersion()
        if not metadata.SubgraphsIsNone():
            self.subgraphs = []
            for i in range(metadata.SubgraphsLength()):
                if metadata.Subgraphs(i) is None:
                    self.subgraphs.append(None)
                else:
                    subgraph_ = SubgraphT.InitFromObj(metadata.Subgraphs(i))
                    self.subgraphs.append(subgraph_)

    # MetadataT
    def Pack(self, builder):
        if self.subgraphs is not None:
            subgraphslist = []
            for i in range(len(self.subgraphs)):
                subgraphslist.append(self.subgraphs[i].Pack(builder))
            MetadataStartSubgraphsVector(builder, len(self.subgraphs))
            for i in reversed(range(len(self.subgraphs))):
                builder.PrependUOffsetTRelative(subgraphslist[i])
            subgraphs = builder.EndVector()
        MetadataStart(builder)
        MetadataAddSchemaVersion(builder, self.schemaVersion)
        if self.subgraphs is not None:
            MetadataAddSubgraphs(builder, subgraphs)
        metadata = MetadataEnd(builder)
        return metadata


class Subgraph(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Subgraph()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSubgraph(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Subgraph
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Subgraph
    def LutTensors(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = LutTensor()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Subgraph
    def LutTensorsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Subgraph
    def LutTensorsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def SubgraphStart(builder):
    builder.StartObject(1)

def SubgraphAddLutTensors(builder, lutTensors):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(lutTensors), 0)

def SubgraphStartLutTensorsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SubgraphEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class SubgraphT(object):

    # SubgraphT
    def __init__(
        self,
        lutTensors = None,
    ):
        self.lutTensors = lutTensors  # type: Optional[List[LutTensorT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        subgraph = Subgraph()
        subgraph.Init(buf, pos)
        return cls.InitFromObj(subgraph)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, subgraph):
        x = SubgraphT()
        x._UnPack(subgraph)
        return x

    # SubgraphT
    def _UnPack(self, subgraph):
        if subgraph is None:
            return
        if not subgraph.LutTensorsIsNone():
            self.lutTensors = []
            for i in range(subgraph.LutTensorsLength()):
                if subgraph.LutTensors(i) is None:
                    self.lutTensors.append(None)
                else:
                    lutTensor_ = LutTensorT.InitFromObj(subgraph.LutTensors(i))
                    self.lutTensors.append(lutTensor_)

    # SubgraphT
    def Pack(self, builder):
        if self.lutTensors is not None:
            lutTensorslist = []
            for i in range(len(self.lutTensors)):
                lutTensorslist.append(self.lutTensors[i].Pack(builder))
            SubgraphStartLutTensorsVector(builder, len(self.lutTensors))
            for i in reversed(range(len(self.lutTensors))):
                builder.PrependUOffsetTRelative(lutTensorslist[i])
            lutTensors = builder.EndVector()
        SubgraphStart(builder)
        if self.lutTensors is not None:
            SubgraphAddLutTensors(builder, lutTensors)
        subgraph = SubgraphEnd(builder)
        return subgraph


class LutTensor(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LutTensor()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLutTensor(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # LutTensor
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # LutTensor
    def Tensor(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # LutTensor
    def ValueBuffer(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # LutTensor
    def IndexBitwidth(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

def LutTensorStart(builder):
    builder.StartObject(3)

def LutTensorAddTensor(builder, tensor):
    builder.PrependInt32Slot(0, tensor, 0)

def LutTensorAddValueBuffer(builder, valueBuffer):
    builder.PrependUint32Slot(1, valueBuffer, 0)

def LutTensorAddIndexBitwidth(builder, indexBitwidth):
    builder.PrependUint8Slot(2, indexBitwidth, 0)

def LutTensorEnd(builder):
    return builder.EndObject()



class LutTensorT(object):

    # LutTensorT
    def __init__(
        self,
        tensor = 0,
        valueBuffer = 0,
        indexBitwidth = 0,
    ):
        self.tensor = tensor  # type: int
        self.valueBuffer = valueBuffer  # type: int
        self.indexBitwidth = indexBitwidth  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        lutTensor = LutTensor()
        lutTensor.Init(buf, pos)
        return cls.InitFromObj(lutTensor)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, lutTensor):
        x = LutTensorT()
        x._UnPack(lutTensor)
        return x

    # LutTensorT
    def _UnPack(self, lutTensor):
        if lutTensor is None:
            return
        self.tensor = lutTensor.Tensor()
        self.valueBuffer = lutTensor.ValueBuffer()
        self.indexBitwidth = lutTensor.IndexBitwidth()

    # LutTensorT
    def Pack(self, builder):
        LutTensorStart(builder)
        LutTensorAddTensor(builder, self.tensor)
        LutTensorAddValueBuffer(builder, self.valueBuffer)
        LutTensorAddIndexBitwidth(builder, self.indexBitwidth)
        lutTensor = LutTensorEnd(builder)
        return lutTensor


