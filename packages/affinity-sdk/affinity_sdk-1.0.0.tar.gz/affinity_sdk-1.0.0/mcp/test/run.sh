#!/usr/bin/env bash
# Test runner for MCP tools - generated by mcp-bash scaffold test
# Usage: ./test/run.sh [--verbose] [--force]
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
export MCPBASH_PROJECT_ROOT="${PROJECT_ROOT}"

case "$(uname -s 2>/dev/null)" in
MINGW* | MSYS*)
	# Keep path conversion enabled so Windows-native jq/gojq can open temp files.
	unset MSYS2_ARG_CONV_EXCL
	;;
esac

# Locate mcp-bash binary
MCPBASH_BIN="${MCPBASH_BIN:-}"
if [[ -z "${MCPBASH_BIN}" ]] && command -v mcp-bash >/dev/null 2>&1; then
	MCPBASH_BIN="$(command -v mcp-bash)"
fi
if [[ -z "${MCPBASH_BIN}" ]] && [[ -n "${MCPBASH_HOME:-}" ]] && [[ -x "${MCPBASH_HOME}/bin/mcp-bash" ]]; then
	MCPBASH_BIN="${MCPBASH_HOME}/bin/mcp-bash"
fi
if [[ -z "${MCPBASH_BIN}" ]] && [[ -x "${PROJECT_ROOT}/../bin/mcp-bash" ]]; then
	MCPBASH_BIN="${PROJECT_ROOT}/../bin/mcp-bash"
fi
if [[ -z "${MCPBASH_BIN}" ]] && [[ -x "${PROJECT_ROOT}/bin/mcp-bash" ]]; then
	MCPBASH_BIN="${PROJECT_ROOT}/bin/mcp-bash"
fi
if [[ -z "${MCPBASH_BIN}" ]]; then
	printf 'mcp-bash not found; add to PATH or set MCPBASH_HOME.\n' >&2
	exit 1
fi

# Derive MCPBASH_HOME from MCPBASH_BIN if not already set
if [[ -z "${MCPBASH_HOME:-}" ]]; then
	# mcp-bash binary is typically at MCPBASH_HOME/bin/mcp-bash or in PATH
	if [[ -d "$(dirname "${MCPBASH_BIN}")/../lib" ]]; then
		export MCPBASH_HOME="$(cd "$(dirname "${MCPBASH_BIN}")/.." && pwd)"
	else
		# Fall back to checking common locations
		for dir in /usr/local/lib/mcp-bash /opt/mcp-bash "${HOME}/.mcp-bash"; do
			if [[ -d "${dir}/lib" ]]; then
				export MCPBASH_HOME="${dir}"
				break
			fi
		done
	fi
fi

VERBOSE="${VERBOSE:-0}"
FORCE="${FORCE:-0}"

while [[ $# -gt 0 ]]; do
	case "$1" in
	--verbose | -v)
		VERBOSE=1
		shift
		;;
	--force | -f)
		FORCE=1
		shift
		;;
	*)
		break
		;;
	esac
done

passed=0
failed=0
skipped=0

# Colors (disabled if not a terminal)
RED=""
GREEN=""
YELLOW=""
RESET=""
if [[ -t 1 ]]; then
	RED="\033[0;31m"
	GREEN="\033[0;32m"
	YELLOW="\033[0;33m"
	RESET="\033[0m"
fi

run_test() {
	local name="$1"
	local args="$2"
	args="${args:-"{}"}"
	local description="${3:-}"

	if [[ -n "${description}" ]]; then
		printf "  %s (%s)... " "${name}" "${description}"
	else
		printf "  %s... " "${name}"
	fi

	local output
	if [[ "${VERBOSE}" == "1" ]]; then
		if "${MCPBASH_BIN}" run-tool "${name}" --args "${args}" --verbose; then
			printf '%sPASS%s\n' "${GREEN}" "${RESET}"
			((++passed)) || true
		else
			printf '%sFAIL%s\n' "${RED}" "${RESET}"
			((++failed)) || true
		fi
	else
		if output=$("${MCPBASH_BIN}" run-tool "${name}" --args "${args}" 2>&1); then
			printf '%sPASS%s\n' "${GREEN}" "${RESET}"
			((++passed)) || true
		else
			printf '%sFAIL%s\n' "${RED}" "${RESET}"
			if [[ -n "${output}" ]]; then
				printf "    Output: %s\n" "${output}" >&2
			fi
			((++failed)) || true
		fi
	fi
}

run_dry_run() {
	local name="$1"
	local args="$2"
	args="${args:-"{}"}"

	printf "  %s (dry-run)... " "${name}"

	local output
	local -a extra_flags=()
	if [[ "${VERBOSE}" == "1" ]]; then
		extra_flags+=(--verbose)
	fi

	# Note: Use ${extra_flags[@]+"${extra_flags[@]}"} for Bash 3.2 compatibility
	if output=$("${MCPBASH_BIN}" run-tool "${name}" --args "${args}" --dry-run ${extra_flags[@]+"${extra_flags[@]}"} 2>&1); then
		printf '%sPASS%s\n' "${GREEN}" "${RESET}"
		((++passed)) || true
	else
		printf '%sFAIL%s\n' "${RED}" "${RESET}"
		if [[ -n "${output}" ]]; then
			printf "    Output: %s\n" "${output}" >&2
		fi
		((++failed)) || true
	fi
}

skip_test() {
	local name="$1"
	local reason="${2:-}"

	printf "  %s... ${YELLOW}SKIP${RESET}" "${name}"
	if [[ -n "${reason}" ]]; then
		printf " (%s)" "${reason}"
	fi
	printf "\n"
	((++skipped)) || true
}

# Discover and validate tools exist
printf "Discovering tools...\n"
if ! "${MCPBASH_BIN}" validate --project-root "${PROJECT_ROOT}" >/dev/null 2>&1; then
	printf '%sError: Project validation failed. Run '\''mcp-bash validate'\'' for details.%s\n' "${RED}" "${RESET}" >&2
	if [[ "${FORCE}" != "1" ]]; then
		printf "Use --force to run tests anyway.\n" >&2
		exit 1
	fi
	printf '%sContinuing anyway (--force)...%s\n' "${YELLOW}" "${RESET}" >&2
fi

printf "\nRunning tests...\n"

# ============================================================================
# XAFFINITY MCP TOOL TESTS
# ============================================================================
# These tests require a configured Affinity API key.
# Run: xaffinity config check-key to verify.
# ============================================================================

# Check if API is configured
if ! xaffinity config check-key --json >/dev/null 2>&1; then
    printf '%sWarning: Affinity API not configured. Some tests will be skipped.%s\n' "${YELLOW}" "${RESET}" >&2
    API_CONFIGURED=0
else
    API_CONFIGURED=1
fi

# Load test configuration from .env.test (not committed)
# Copy .env.test.example to .env.test and configure your test entity IDs
TEST_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "${TEST_DIR}/.env.test" ]]; then
    # shellcheck disable=SC1091
    source "${TEST_DIR}/.env.test"
fi

# Test IDs - must be set in .env.test or environment variables
TEST_PERSON_ID="${TEST_PERSON_ID:-}"
TEST_COMPANY_ID="${TEST_COMPANY_ID:-}"
TEST_LIST_ID="${TEST_LIST_ID:-}"

printf "\n--- Dry-run validation (no API calls) ---\n"

# Dry-run tests validate args and metadata without calling API
# Utility tools
run_dry_run "get-entity-dossier" '{"entityId":"123","entityType":"person"}'
run_dry_run "read-xaffinity-resource" '{"uri":"xaffinity://person/123"}'

# CLI Gateway tools (dry-run only - validates args and registry lookup)
run_dry_run "discover-commands" '{"query":"person"}'
run_dry_run "execute-read-command" '{"command":"person get","argv":["123"],"dryRun":true}'
run_dry_run "execute-write-command" '{"command":"person create","argv":["--first-name","John"],"dryRun":true}'

printf "\n--- CLI Gateway validation tests ---\n"

# Test: discover-commands with category filter
printf "  discover-commands (category=read)... "
output=$("${MCPBASH_BIN}" run-tool "discover-commands" --args '{"query":"get","category":"read","limit":3}' 2>&1)
if echo "$output" | grep -q '"category":"read"'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (expected read category in results)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: discover-commands with local category
printf "  discover-commands (category=local)... "
output=$("${MCPBASH_BIN}" run-tool "discover-commands" --args '{"query":"version","category":"local","limit":3}' 2>&1)
if echo "$output" | grep -q '"category":"local"'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (expected local category in results)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: execute-read-command accepts local commands
printf "  execute-read-command (local command)... "
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"version","dryRun":true}' 2>&1)
if echo "$output" | grep -q '"dryRun":true'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (local command should be accepted)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: execute-write-command rejects read commands
printf "  execute-write-command rejects read command... "
output=$("${MCPBASH_BIN}" run-tool "execute-write-command" --args '{"command":"person get","argv":["123"],"dryRun":true}' 2>&1)
if echo "$output" | grep -q 'validation_error\|execute-read-command'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should reject read command)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: execute-read-command rejects write commands
printf "  execute-read-command rejects write command... "
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"person create","dryRun":true}' 2>&1)
if echo "$output" | grep -q 'validation_error\|execute-write-command'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should reject write command)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: destructive command without confirm is rejected
printf "  execute-write-command (destructive without confirm)... "
output=$("${MCPBASH_BIN}" run-tool "execute-write-command" --args '{"command":"person delete","argv":["123"]}' 2>&1)
if echo "$output" | grep -q 'confirmation_required\|confirm.*true'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should require confirmation)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: unknown command is rejected
printf "  execute-read-command (unknown command)... "
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"nonexistent command","dryRun":true}' 2>&1)
if echo "$output" | grep -q 'command_not_found\|Unknown command'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should reject unknown command)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: flags in command path are rejected
printf "  execute-read-command (flags in command)... "
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"person get --json","dryRun":true}' 2>&1)
if echo "$output" | grep -q 'validation_error\|Flags not allowed'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should reject flags in command path)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

printf "\n--- Policy enforcement tests ---\n"

# Configure mcp-bash to pass through policy environment variables
# (server.d/env.sh sets this for the MCP server, but run-tool needs it explicitly)
export MCPBASH_TOOL_ENV_MODE="allowlist"
export MCPBASH_TOOL_ENV_ALLOWLIST="AFFINITY_MCP_READ_ONLY,AFFINITY_MCP_DISABLE_DESTRUCTIVE"

# Test: Read-only mode restricts discover-commands to read category
printf "  AFFINITY_MCP_READ_ONLY blocks write discovery... "
output=$(AFFINITY_MCP_READ_ONLY=1 "${MCPBASH_BIN}" run-tool "discover-commands" --args '{"query":"create","category":"write","limit":3}' 2>&1)
# In read-only mode, category is forced to "read" so write commands shouldn't appear
if echo "$output" | grep -q '"category":"read"' || ! echo "$output" | grep -q '"category":"write"'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (read-only mode should force category=read)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: Destructive disabled policy blocks delete commands
# NOTE: We use dryRun:true to ensure the command is never actually executed
# The policy check happens before dryRun processing, so this is safe
printf "  AFFINITY_MCP_DISABLE_DESTRUCTIVE blocks delete... "
output=$(AFFINITY_MCP_DISABLE_DESTRUCTIVE=1 "${MCPBASH_BIN}" run-tool "execute-write-command" --args '{"command":"person delete","argv":["123"],"dryRun":true}' 2>&1)
if echo "$output" | grep -q 'destructive_disabled'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    # If policy didn't block, dryRun should have prevented execution
    # But we expect destructive_disabled when policy is set
    printf '%sFAIL%s (destructive commands should be blocked by policy)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: Did you mean suggestion for typos
printf "  command_not_found includes 'Did you mean'... "
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"persn get","dryRun":true}' 2>&1)
if echo "$output" | grep -q 'Did you mean'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should suggest similar command)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: confirmation_required includes example field
printf "  confirmation_required includes example... "
output=$("${MCPBASH_BIN}" run-tool "execute-write-command" --args '{"command":"person delete","argv":["123"]}' 2>&1)
if echo "$output" | grep -q '"example"'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should include example in error)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

printf "\n--- Limit enforcement tests ---\n"

# Test: --all flag is blocked on commands with limitConfig
printf "  --all flag blocked on person ls... "
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"person ls","argv":["--all"],"dryRun":true}' 2>&1)
if echo "$output" | grep -q 'validation_error\|not allowed via MCP\|unbounded'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (--all should be blocked)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: -A alias is also blocked
printf "  -A alias blocked on list export... "
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"list export","argv":["Pipeline","-A"],"dryRun":true}' 2>&1)
if echo "$output" | grep -q 'validation_error\|not allowed via MCP\|unbounded'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (-A alias should be blocked)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: commands without --all flag pass through (interaction ls)
printf "  interaction ls passes without --all... "
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"interaction ls","argv":["--type","all","--person-id","123","--max-results","10"],"dryRun":true}' 2>&1)
if echo "$output" | grep -q '"dryRun":true\|would execute'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (interaction ls should pass validation)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Test: env vars are set for MCP limit enforcement
printf "  MCP limit env vars are set... "
# The env vars should be exported to the CLI subprocess
output=$("${MCPBASH_BIN}" run-tool "execute-read-command" --args '{"command":"person ls","argv":["--max-results","100"],"dryRun":true}' 2>&1)
# dryRun should succeed (env vars don't cause errors)
if echo "$output" | grep -q '"dryRun":true\|would execute'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (command should pass with explicit limit)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

printf "\n--- Query tool tests (dry-run) ---\n"

# Basic query validation
run_dry_run "query" '{"query":{"from":"persons","limit":10},"dryRun":true}'

# Query with where clause
printf "  query (with where clause)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"from":"persons","where":{"path":"email","op":"contains","value":"@test.com"}},"dryRun":true}' 2>&1)
if echo "$output" | grep -q '"from".*persons\|execution\|steps'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (expected dry-run plan output)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Query with include
printf "  query (with include)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"from":"persons","include":["companies"],"limit":5},"dryRun":true}' 2>&1)
if echo "$output" | grep -q 'include\|INCLUDE\|N+1\|companies'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (expected include in plan)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Query with aggregation
printf "  query (with aggregation)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"from":"opportunities","aggregate":{"count":{"count":true}}},"dryRun":true}' 2>&1)
if echo "$output" | grep -q 'aggregate\|AGGREGATE'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (expected aggregate in plan)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Invalid query (missing from)
printf "  query (invalid - missing from)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"limit":10},"dryRun":true}' 2>&1)
if echo "$output" | grep -qi 'error\|from\|required\|invalid'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should reject query missing from)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

# Invalid query (unknown entity)
printf "  query (invalid - unknown entity)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"from":"unknownEntity"},"dryRun":true}' 2>&1)
if echo "$output" | grep -qi 'error\|unknown\|invalid\|unknownEntity'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (should reject unknown entity)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

printf "\n--- Query format parameter tests ---\n"

# Test: format=toon (default) is accepted
printf "  query (format=toon)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"from":"persons","limit":5},"format":"toon","dryRun":true}' 2>&1)
if echo "$output" | grep -qi 'error.*format\|validation_error'; then
    printf '%sFAIL%s (toon should be accepted)\n' "${RED}" "${RESET}"
    ((++failed)) || true
else
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
fi

# Test: format=markdown is accepted
printf "  query (format=markdown)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"from":"persons","limit":5},"format":"markdown","dryRun":true}' 2>&1)
if echo "$output" | grep -qi 'error.*format\|validation_error'; then
    printf '%sFAIL%s (markdown should be accepted)\n' "${RED}" "${RESET}"
    ((++failed)) || true
else
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
fi

# Test: format=json is accepted
printf "  query (format=json)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"from":"persons","limit":5},"format":"json","dryRun":true}' 2>&1)
if echo "$output" | grep -qi 'error.*format\|validation_error'; then
    printf '%sFAIL%s (json should be accepted)\n' "${RED}" "${RESET}"
    ((++failed)) || true
else
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
fi

# Test: invalid format is rejected
printf "  query (invalid format)... "
output=$("${MCPBASH_BIN}" run-tool "query" --args '{"query":{"from":"persons","limit":5},"format":"invalid"}' 2>&1)
if echo "$output" | grep -qi 'validation_error\|format must be'; then
    printf '%sPASS%s\n' "${GREEN}" "${RESET}"
    ((++passed)) || true
else
    printf '%sFAIL%s (invalid format should be rejected)\n' "${RED}" "${RESET}"
    ((++failed)) || true
fi

if [[ "${API_CONFIGURED}" != "1" ]]; then
    skip_test "get-entity-dossier (live)" "API not configured"
elif [[ "${SKIP_LIVE:-0}" == "1" ]]; then
    skip_test "live tests" "SKIP_LIVE=1"
else
    printf "\n--- Live API tests (READ-ONLY) ---\n"

    # Entity dossier tests (requires valid person ID from .env.test)
    if [[ -n "${TEST_PERSON_ID}" ]]; then
        run_test "get-entity-dossier" '{"entityId":"'"${TEST_PERSON_ID}"'","entityType":"person","includeInteractions":true,"includeLists":true}' "person dossier"
    else
        skip_test "get-entity-dossier (person)" "set TEST_PERSON_ID in .env.test"
    fi

    # Company tests (requires valid company ID from .env.test)
    if [[ -n "${TEST_COMPANY_ID}" ]]; then
        run_test "get-entity-dossier" '{"entityId":"'"${TEST_COMPANY_ID}"'","entityType":"company","includeInteractions":true,"includeLists":true}' "company dossier"
    else
        skip_test "get-entity-dossier (company)" "set TEST_COMPANY_ID in .env.test"
    fi
fi

# ============================================================================
# END OF TESTS
# ============================================================================

printf "\n"
printf "Results: ${GREEN}%d passed${RESET}, ${RED}%d failed${RESET}" "${passed}" "${failed}"
if [[ "${skipped}" -gt 0 ]]; then
	printf ", ${YELLOW}%d skipped${RESET}" "${skipped}"
fi
printf "\n"

[[ "${failed}" -eq 0 ]] || exit 1
