#!/usr/bin/env bash
# lib/common.sh - Common utilities for Affinity MCP tools

# ==============================================================================
# Debug Mode Initialization
# ==============================================================================
# Enable debug mode via (checked in priority order):
#   1. XAFFINITY_MCP_DEBUG=1 environment variable (highest priority)
#   2. ~/.config/xaffinity-mcp/debug file (XDG-compliant, persistent)
#   3. .debug file in server directory (development/local testing)
#
# When enabled, cascades to enable mcp-bash and xaffinity logging.
# This is also set in xaffinity-mcp.sh for server startup, but we set it here
# too for direct tool invocation via mcp-bash run-tool.
#
# Quick enable:  mkdir -p ~/.config/xaffinity-mcp && touch ~/.config/xaffinity-mcp/debug
# Quick disable: rm ~/.config/xaffinity-mcp/debug

_XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
_DEBUG_XDG_FILE="${_XDG_CONFIG_HOME}/xaffinity-mcp/debug"
_DEBUG_LOCAL_FILE="${MCPBASH_PROJECT_ROOT}/.debug"

if [[ "${XAFFINITY_MCP_DEBUG:-}" == "1" || -f "$_DEBUG_XDG_FILE" || -f "$_DEBUG_LOCAL_FILE" ]]; then
    export XAFFINITY_MCP_DEBUG=1
    export MCPBASH_LOG_LEVEL="${MCPBASH_LOG_LEVEL:-debug}"
    export XAFFINITY_DEBUG="true"
fi

# Cache version at startup (if not already set by xaffinity-mcp.sh)
if [[ -z "${XAFFINITY_MCP_VERSION:-}" ]]; then
    export XAFFINITY_MCP_VERSION=$(cat "${MCPBASH_PROJECT_ROOT}/VERSION" 2>/dev/null || echo "unknown")
fi

# ==============================================================================
# xaffinity CLI Location (Runtime Detection)
# ==============================================================================
# Some MCP hosts (e.g., Claude Cowork) spawn servers with minimal PATH that
# excludes version manager shims. We detect the CLI at runtime using the
# mcp-bash recommended pattern (see CLI-DETECTION-PATTERN.md).
#
# Override: Set XAFFINITY_CLI=/path/to/xaffinity in your environment.

source "${MCPBASH_PROJECT_ROOT}/lib/cli-detect.sh"

if [[ -z "${XAFFINITY_CLI:-}" ]]; then
    # Detect CLI; don't fail here (tools handle failure appropriately)
    XAFFINITY_CLI=$(mcp_detect_cli xaffinity "pip install affinity-sdk[cli]" 2>/dev/null) || true
    # Fall back to bare name if not found (will fail with clear error at execution)
    : "${XAFFINITY_CLI:=xaffinity}"
    export XAFFINITY_CLI
fi

# Source cache utilities
source "${MCPBASH_PROJECT_ROOT}/lib/cache.sh"

# ==============================================================================
# JSON Tool Wrapper
# ==============================================================================
# Use mcp-bash's JSON tool (jq or gojq) for all JSON processing.
# This respects MCPBASH_JSON_TOOL setting and works with either implementation.
#
# jq_tool() is the canonical name (follows mcp-bash proposal pattern).
# jq() is kept for backwards compatibility with existing tools.

jq_tool() { "${MCPBASH_JSON_TOOL_BIN:-jq}" "$@"; }
jq() { jq_tool "$@"; }

# ==============================================================================
# Version Comparison
# ==============================================================================
# Portable version comparison (works on macOS and Linux)

# Check if version v1 >= v2
# Returns 0 (success) if v1 >= v2, 1 otherwise
# Usage: version_gte "0.6.10" "0.6.0"
version_gte() {
    local v1="$1" v2="$2"
    # v1 >= v2 means v2 should come first (or equal) when sorted
    [ "$v2" = "$(printf '%s\n%s' "$v1" "$v2" | sort -V | head -1)" ] 2>/dev/null && return 0
    # Fallback for systems without sort -V (some minimal containers, old BSD)
    local IFS='.'
    local i v1_parts=($v1) v2_parts=($v2)
    for ((i=0; i<${#v2_parts[@]}; i++)); do
        [[ ${v1_parts[i]:-0} -lt ${v2_parts[i]:-0} ]] && return 1
        [[ ${v1_parts[i]:-0} -gt ${v2_parts[i]:-0} ]] && return 0
    done
    return 0
}

# ==============================================================================
# CLI Gateway Registry
# ==============================================================================
# Pre-generated commands registry for CLI Gateway tools (discover-commands, execute-*-command).
# Generated by tools/generate_mcp_command_registry.py from mcp-commands.json (explicit whitelist).
# Only commands listed in mcp-commands.json are included - MCP exposure is opt-in.
# Bundled via MCPB_INCLUDE in mcpb.conf.

REGISTRY_FILE="${MCPBASH_PROJECT_ROOT}/.registry/commands.generated.json"

# Progress capability requires CLI >= this version (NDJSON progress on stderr)
PROGRESS_MIN_CLI_VERSION="0.6.10"

# ==============================================================================
# Logging Helpers
# ==============================================================================
# These wrap mcp-bash SDK logging with xaffinity-specific context.
# Use XAFFINITY_MCP_DEBUG=1 or MCPBASH_LOG_LEVEL=debug for verbose output.
#
# Log format: [xaffinity:<context>:<version>] <message>
# Version is cached at startup in XAFFINITY_MCP_VERSION (see xaffinity-mcp.sh)

# Log debug message (only when debug mode enabled)
# Usage: xaffinity_log_debug "context" "message"
xaffinity_log_debug() {
    local context="$1"
    local message="$2"
    local version="${XAFFINITY_MCP_VERSION:-?}"
    if [[ "${XAFFINITY_MCP_DEBUG:-}" == "1" || "${MCPBASH_LOG_LEVEL:-info}" == "debug" ]]; then
        if type mcp_log_debug &>/dev/null; then
            mcp_log_debug "xaffinity:$context:$version" "$message"
        fi
    fi
}

# Log info message
# Usage: xaffinity_log_info "context" "message"
xaffinity_log_info() {
    local context="$1"
    local message="$2"
    local version="${XAFFINITY_MCP_VERSION:-?}"
    if type mcp_log_info &>/dev/null; then
        mcp_log_info "xaffinity:$context:$version" "$message"
    fi
}

# Log warning message
# Usage: xaffinity_log_warn "context" "message"
xaffinity_log_warn() {
    local context="$1"
    local message="$2"
    local version="${XAFFINITY_MCP_VERSION:-?}"
    if type mcp_log_warn &>/dev/null; then
        mcp_log_warn "xaffinity:$context:$version" "$message"
    fi
}

# Log error message
# Usage: xaffinity_log_error "context" "message"
xaffinity_log_error() {
    local context="$1"
    local message="$2"
    local version="${XAFFINITY_MCP_VERSION:-?}"
    if type mcp_log_error &>/dev/null; then
        mcp_log_error "xaffinity:$context:$version" "$message"
    fi
}

# Log CLI command execution (debug only, redacts sensitive args)
# Usage: xaffinity_log_cli "subcommand" "exit_code" "output_bytes"
xaffinity_log_cli() {
    local subcommand="$1"
    local exit_code="$2"
    local output_bytes="${3:-0}"
    local version="${XAFFINITY_MCP_VERSION:-?}"
    if [[ "${XAFFINITY_MCP_DEBUG:-}" == "1" || "${MCPBASH_LOG_LEVEL:-info}" == "debug" ]]; then
        if type mcp_log_debug &>/dev/null; then
            mcp_log_debug "xaffinity:cli:$version" "cmd=$subcommand exit=$exit_code bytes=$output_bytes"
        fi
    fi
}

# ==============================================================================
# Metrics Logging
# ==============================================================================
# Log structured metrics for monitoring and alerting.
# Metrics are logged to stderr in a parseable format for log aggregation.
# Usage: log_metric "metric_name" "value" ["tag1=val1" "tag2=val2" ...]
#
# Example output: [METRIC] execute_command_result=success tool=execute-read-command command=person_get
log_metric() {
    local metric="$1"
    local value="$2"
    shift 2
    local tags=""
    for tag in "$@"; do
        tags+=" $tag"
    done
    echo "[METRIC] ${metric}=${value}${tags}" >&2
}

# Build CLI base arguments from XAFFINITY_CLI_PATTERN
# The pattern from check-key looks like: "xaffinity --dotenv --readonly <command> --json"
# We extract flags before <command> and after <command>
build_cli_base_args() {
    local pattern="${XAFFINITY_CLI_PATTERN:-xaffinity --readonly <command> --json}"

    # Extract pre-command flags (everything between "xaffinity" and "<command>")
    local pre_flags=$(echo "$pattern" | sed -E 's/^xaffinity\s+(.*)--readonly\s+<command>.*$/\1--readonly/' | tr -s ' ')

    # Extract post-command flags (everything after "<command>")
    local post_flags=$(echo "$pattern" | sed -E 's/.*<command>\s*(.*)$/\1/' | tr -s ' ')

    # Return the pre-flags (we'll append command-specific flags)
    # Post-flags like --json are typically added per-tool
    echo "$pre_flags"
}

# Run xaffinity with correct flags from check-key pattern
# Usage: run_xaffinity <subcommand> [args...]
# Example: run_xaffinity person ls --query "John"
# Note: --quiet is a global option, so we detect and move it to the right position
# Uses mcp_with_retry for transient failure handling (3 attempts, 0.5s base delay)
run_xaffinity() {
    local pattern="${XAFFINITY_CLI_PATTERN:-xaffinity --readonly <command> --json}"
    local needs_dotenv=false
    local needs_quiet=false
    local session_cache=""

    # Check if pattern includes --dotenv
    if [[ "$pattern" == *"--dotenv"* ]]; then
        needs_dotenv=true
    fi

    # Check for global options in arguments and filter them out
    # These must be placed before the subcommand
    local filtered_args=()
    local args=("$@")
    local i=0
    while [[ $i -lt ${#args[@]} ]]; do
        local arg="${args[$i]}"
        if [[ "$arg" == "--quiet" || "$arg" == "-q" ]]; then
            needs_quiet=true
        elif [[ "$arg" == "--session-cache" && $((i + 1)) -lt ${#args[@]} ]]; then
            session_cache="${args[$((i + 1))]}"
            ((i++))  # Skip the value
        elif [[ "$arg" == --session-cache=* ]]; then
            session_cache="${arg#--session-cache=}"
        else
            filtered_args+=("$arg")
        fi
        ((i++))
    done

    # Build command with global options first
    # Use XAFFINITY_CLI for full path (set by env.sh for Cowork compatibility)
    local cmd=("${XAFFINITY_CLI:-xaffinity}")
    [[ "$needs_dotenv" == "true" ]] && cmd+=(--dotenv)
    [[ "$needs_quiet" == "true" ]] && cmd+=(--quiet)
    [[ -n "$session_cache" ]] && cmd+=(--session-cache "$session_cache")
    # Note: ${arr[@]+...} syntax for Bash 3.2 compatibility with empty arrays
    cmd+=(${filtered_args[@]+"${filtered_args[@]}"})

    # Execute with retry for transient failures
    mcp_with_retry 3 0.5 -- "${cmd[@]}"
}

# Run xaffinity in readonly mode (respects dotenv from check-key)
# Usage: run_xaffinity_readonly <subcommand> [args...]
# Note: --quiet is a global option, so we detect and move it to the right position
# Logs command execution in debug mode (args are not logged for security)
# Uses mcp_with_retry for transient failure handling (3 attempts, 0.5s base delay)
run_xaffinity_readonly() {
    local pattern="${XAFFINITY_CLI_PATTERN:-xaffinity --readonly <command> --json}"
    local needs_dotenv=false
    local needs_quiet=false
    local session_cache=""
    local subcommand="${1:-unknown}"

    if [[ "$pattern" == *"--dotenv"* ]]; then
        needs_dotenv=true
    fi

    # Check for global options in arguments and filter them out
    # These must be placed before the subcommand
    local filtered_args=()
    local args=("$@")
    local i=0
    while [[ $i -lt ${#args[@]} ]]; do
        local arg="${args[$i]}"
        if [[ "$arg" == "--quiet" || "$arg" == "-q" ]]; then
            needs_quiet=true
        elif [[ "$arg" == "--session-cache" && $((i + 1)) -lt ${#args[@]} ]]; then
            session_cache="${args[$((i + 1))]}"
            ((i++))  # Skip the value
        elif [[ "$arg" == --session-cache=* ]]; then
            session_cache="${arg#--session-cache=}"
        else
            filtered_args+=("$arg")
        fi
        ((i++))
    done

    # Build command with global options first
    # Use XAFFINITY_CLI for full path (set by env.sh for Cowork compatibility)
    local cmd=("${XAFFINITY_CLI:-xaffinity}")
    [[ "$needs_dotenv" == "true" ]] && cmd+=(--dotenv)
    cmd+=(--readonly)
    [[ "$needs_quiet" == "true" ]] && cmd+=(--quiet)
    [[ -n "$session_cache" ]] && cmd+=(--session-cache "$session_cache")
    # Note: ${arr[@]+...} syntax for Bash 3.2 compatibility with empty arrays
    cmd+=(${filtered_args[@]+"${filtered_args[@]}"})

    # Log command start in debug mode
    xaffinity_log_debug "cli" "executing: ${XAFFINITY_CLI:-xaffinity} --readonly $subcommand ..."

    # Execute with retry for transient failures (3 attempts, 0.5s base delay)
    # Note: mcp_with_retry is only available in tool contexts (tool-sdk.sh sourced).
    # Resources don't source tool-sdk.sh, so fall back to direct execution.
    local output exit_code=0
    if type mcp_with_retry &>/dev/null; then
        output=$(mcp_with_retry 3 0.5 -- "${cmd[@]}") || exit_code=$?
    else
        output=$("${cmd[@]}") || exit_code=$?
    fi

    # Log result in debug mode
    local output_bytes=${#output}
    xaffinity_log_cli "$subcommand" "$exit_code" "$output_bytes"

    # Output the result
    echo "$output"
    return $exit_code
}

# ==============================================================================
# Progress-Aware CLI Execution
# ==============================================================================
# Execute xaffinity with progress forwarding and timeout extension.
# Uses mcp_run_with_progress from mcp-bash to:
# 1. Parse CLI JSON progress from stderr (for timeout extension)
# 2. Forward progress to MCP clients (when MCP_PROGRESS_STREAM is set)
#
# Usage: run_xaffinity_with_progress [--stdin] [--stderr-file FILE] <command> [args...]
# Example: run_xaffinity_with_progress person files-upload 12345 --file /path/to/file
# Example: run_xaffinity_with_progress --stdin --stderr-file /tmp/err query --json
#
# Options:
#   --stdin         Read input from stdin and pipe to command (for query tool)
#   --stderr-file   Capture non-progress stderr to file (for error reporting)
#
# The CLI emits NDJSON progress to stderr when not connected to a TTY:
#   {"type":"progress","progress":50,"message":"Uploading...","current":50,"total":100}
#
# This helper:
# - ALWAYS uses mcp_run_with_progress for timeout extension (pattern matching on stderr)
# - Forwards progress to MCP client only when MCP_PROGRESS_STREAM is set
# - Falls back to direct execution only when mcp_run_with_progress unavailable
# - Returns stdout (the CLI's JSON result)
# - Preserves exit code
# - Optionally captures non-progress stderr for error reporting (requires mcp-bash 0.9.11+)
#
# NOTE: Timeout extension works independently of progress forwarding. Even if
# Claude Desktop doesn't send progressToken (so MCP_PROGRESS_STREAM is unset),
# mcp-bash still extends the timeout when it detects progress patterns on stderr.
run_xaffinity_with_progress() {
    local use_stdin=false
    local stderr_file=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --stdin)
                use_stdin=true
                shift
                ;;
            --stderr-file)
                stderr_file="$2"
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    local pattern="${XAFFINITY_CLI_PATTERN:-xaffinity --readonly <command> --json}"
    local needs_dotenv=false

    # Check if pattern includes --dotenv
    if [[ "$pattern" == *"--dotenv"* ]]; then
        needs_dotenv=true
    fi

    # Build command array
    # Use XAFFINITY_CLI for full path (set by env.sh for Cowork compatibility)
    local -a cmd=("${XAFFINITY_CLI:-xaffinity}")
    [[ "$needs_dotenv" == "true" ]] && cmd+=(--dotenv)
    cmd+=("$@")

    # ALWAYS use mcp_run_with_progress when available for timeout extension.
    # This enables progressExtendsTimeout even when client doesn't send progressToken.
    # Progress forwarding to client only happens when MCP_PROGRESS_STREAM is set.
    if type mcp_run_with_progress &>/dev/null; then
        # Build mcp_run_with_progress arguments for timeout extension
        local -a progress_args=(
            --pattern '^\{.*"type"[[:space:]]*:[[:space:]]*"progress"'
            --extract json
            --quiet
        )
        [[ -n "$stderr_file" ]] && progress_args+=(--stderr-file "$stderr_file")

        if [[ "$use_stdin" == "true" ]]; then
            # Capture stdin before backgrounding (queries are small, <10KB)
            local stdin_content
            stdin_content=$(cat)
            # Debug: Trace stdin through pipeline (Issue 3 investigation)
            xaffinity_log_debug "run_xaffinity_with_progress" "stdin_content length: ${#stdin_content}"
            xaffinity_log_debug "run_xaffinity_with_progress" "stdin_content first 200 chars: ${stdin_content:0:200}"
            printf '%s' "$stdin_content" | mcp_run_with_progress "${progress_args[@]}" -- "${cmd[@]}"
        else
            mcp_run_with_progress "${progress_args[@]}" -- "${cmd[@]}"
        fi
    else
        # mcp_run_with_progress not available - run directly (no timeout extension)
        xaffinity_log_debug "run_xaffinity_with_progress" "mcp_run_with_progress not available, running directly"
        if [[ "$use_stdin" == "true" ]]; then
            local stdin_content
            stdin_content=$(cat)
            # Debug: Trace stdin through pipeline (Issue 3 investigation)
            xaffinity_log_debug "run_xaffinity_with_progress" "stdin_content length (no progress): ${#stdin_content}"
            xaffinity_log_debug "run_xaffinity_with_progress" "stdin_content first 200 chars: ${stdin_content:0:200}"
            printf '%s' "$stdin_content" | "${cmd[@]}"
        else
            "${cmd[@]}"
        fi
    fi
}

# Check if a command supports progress (from registry metadata AND CLI version)
# Usage: command_supports_progress <command_name>
# Returns: 0 if supports progress, 1 otherwise
# Checks:
#   1. Registry has progressCapable: true for the command
#   2. CLI version >= PROGRESS_MIN_CLI_VERSION (for NDJSON progress support)
command_supports_progress() {
    local command="$1"

    # Check CLI version supports progress output
    if [[ -n "${XAFFINITY_CLI_VERSION:-}" ]]; then
        if ! version_gte "$XAFFINITY_CLI_VERSION" "$PROGRESS_MIN_CLI_VERSION"; then
            xaffinity_log_debug "progress" "CLI $XAFFINITY_CLI_VERSION < $PROGRESS_MIN_CLI_VERSION, progress disabled"
            return 1
        fi
    fi

    if [[ ! -f "$REGISTRY_FILE" ]]; then
        return 1
    fi

    local supports
    supports=$(jq_tool -r --arg cmd "$command" \
        '.commands[] | select(.name == $cmd) | .progressCapable // false' \
        "$REGISTRY_FILE" 2>/dev/null)

    [[ "$supports" == "true" ]]
}

# Fetch or retrieve cached workflow config for a list
# Returns the full workflow config schema: {list, statusField, savedViews, fieldIndex}
# Usage: get_or_fetch_workflow_config <list_id>
get_or_fetch_workflow_config() {
    local list_id="$1"

    # Try cache first
    if cached=$(get_workflow_config_cached "$list_id" 2>/dev/null); then
        echo "$cached"
        return 0
    fi

    # Cache miss - fetch and compute the workflow config schema
    local cli_base_args=(--output json --quiet)
    [[ -n "${AFFINITY_SESSION_CACHE:-}" ]] && cli_base_args+=(--session-cache "$AFFINITY_SESSION_CACHE")

    # Fetch list metadata (capture stderr for error reporting)
    local list_data list_stderr
    list_stderr=$(mktemp)
    if ! list_data=$(run_xaffinity_readonly list get "$list_id" "${cli_base_args[@]}" 2>"$list_stderr"); then
        local cli_error
        cli_error=$(cat "$list_stderr" 2>/dev/null | head -c 200 || echo "unknown error")
        xaffinity_log_warn "workflow-config" "list get $list_id failed: $cli_error"
        list_data='{}'
    fi
    rm -f "$list_stderr"
    list_data=$(echo "$list_data" | jq_tool -c '.data // {}')
    local list_name=$(echo "$list_data" | jq_tool -r '.list.name // "Unknown"')
    local list_type=$(echo "$list_data" | jq_tool -r '.list.type // "unknown"')

    # Fetch fields for this list
    local fields_data fields_stderr
    fields_stderr=$(mktemp)
    if ! fields_data=$(run_xaffinity_readonly field ls --list-id "$list_id" "${cli_base_args[@]}" 2>"$fields_stderr"); then
        local cli_error
        cli_error=$(cat "$fields_stderr" 2>/dev/null | head -c 200 || echo "unknown error")
        xaffinity_log_warn "workflow-config" "field ls for list $list_id failed: $cli_error"
        fields_data='{"data":{"fields":[]}}'
    fi
    rm -f "$fields_stderr"
    fields_data=$(echo "$fields_data" | jq_tool -c '.data.fields // []')

    # Find Status field (ranked dropdown with name containing "status")
    local status_field
    status_field=$(echo "$fields_data" | jq_tool -c '
        [.[] | select(
            (.name | ascii_downcase | contains("status")) and
            .valueType == "ranked-dropdown"
        )] | first // null
    ')

    local status_field_output="null"
    if [[ "$status_field" != "null" ]]; then
        local field_id=$(echo "$status_field" | jq_tool -r '.id')
        local field_name=$(echo "$status_field" | jq_tool -r '.name')
        local options=$(echo "$status_field" | jq_tool -c '.dropdownOptions // []')
        status_field_output=$(jq_tool -n \
            --arg fid "$field_id" \
            --arg fname "$field_name" \
            --argjson opts "$options" \
            '{fieldId: $fid, name: $fname, options: $opts}'
        )
    fi

    # Fetch saved views
    local saved_views
    saved_views=$(echo "$list_data" | jq_tool -c '.savedViews // []' | jq_tool -c 'map({viewId: .id, name: .name})')

    # Build field index (for field name resolution)
    local field_index
    field_index=$(echo "$fields_data" | jq_tool -c 'map({fieldId: .id, name: .name, valueType: .valueType, scope: .scope})')

    # Compose result
    local result
    result=$(jq_tool -n \
        --argjson listId "$list_id" \
        --arg listName "$list_name" \
        --arg listType "$list_type" \
        --argjson statusField "$status_field_output" \
        --argjson savedViews "$saved_views" \
        --argjson fieldIndex "$field_index" \
        '{
            list: {listId: $listId, name: $listName, type: $listType},
            statusField: $statusField,
            savedViews: $savedViews,
            fieldIndex: $fieldIndex
        }'
    )

    # Cache the result
    set_workflow_config_cached "$list_id" "$result" 2>/dev/null || true

    echo "$result"
}

# Resolve a list by name or ID
# Usage: resolve_list <name_or_id>
# Returns: list ID
resolve_list() {
    local name_or_id="$1"

    # If it looks like an ID, return it
    if [[ "$name_or_id" =~ ^[0-9]+$ ]]; then
        echo "$name_or_id"
        return 0
    fi

    # Search by name (capture stderr for error logging)
    local result stderr_file
    stderr_file=$(mktemp)
    if ! result=$(run_xaffinity_readonly list ls --output json --quiet \
        ${AFFINITY_SESSION_CACHE:+--session-cache "$AFFINITY_SESSION_CACHE"} 2>"$stderr_file"); then
        local cli_error
        cli_error=$(cat "$stderr_file" 2>/dev/null | head -c 200 || echo "unknown error")
        xaffinity_log_warn "resolve-list" "list ls failed: $cli_error"
        rm -f "$stderr_file"
        return 1
    fi
    rm -f "$stderr_file"

    local list_id
    list_id=$(echo "$result" | jq_tool -r --arg name "$name_or_id" \
        '.data.lists[] | select(.name == $name) | .id' | head -1)

    if [[ -n "$list_id" ]]; then
        echo "$list_id"
        return 0
    fi

    return 1
}
