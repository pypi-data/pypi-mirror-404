"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
import pydantic
from pydantic import model_serializer
from raindrop_query.types import BaseModel, UNSET_SENTINEL
from raindrop_query.utils import FieldMetadata, QueryParamMetadata
from typing import List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


FieldT = Literal[
    "event_name",
    "user_id",
    "signal",
]
r"""Field to get facets for"""


class EventsFacetsRequestTypedDict(TypedDict):
    field: NotRequired[FieldT]
    r"""Field to get facets for"""
    limit: NotRequired[int]
    user_id: NotRequired[str]
    event_name: NotRequired[str]
    signal: NotRequired[str]
    timestamp_gte: NotRequired[datetime]
    timestamp_lt: NotRequired[datetime]


class EventsFacetsRequest(BaseModel):
    field: Annotated[
        Optional[FieldT],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = "event_name"
    r"""Field to get facets for"""

    limit: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 20

    user_id: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    event_name: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    signal: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    timestamp_gte: Annotated[
        Optional[datetime],
        pydantic.Field(alias="timestamp.gte"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    timestamp_lt: Annotated[
        Optional[datetime],
        pydantic.Field(alias="timestamp.lt"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "field",
                "limit",
                "user_id",
                "event_name",
                "signal",
                "timestamp.gte",
                "timestamp.lt",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsFacetsDetailsTypedDict(TypedDict):
    field: NotRequired[str]
    allowed_fields: NotRequired[List[str]]


class EventsFacetsDetails(BaseModel):
    field: Optional[str] = None

    allowed_fields: Optional[List[str]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["field", "allowed_fields"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsFacetsErrorTypedDict(TypedDict):
    code: str
    r"""Error code"""
    message: str
    r"""Human-readable error message"""
    details: NotRequired[EventsFacetsDetailsTypedDict]


class EventsFacetsError(BaseModel):
    code: str
    r"""Error code"""

    message: str
    r"""Human-readable error message"""

    details: Optional[EventsFacetsDetails] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["details"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsFacetsDataTypedDict(TypedDict):
    value: str
    r"""The facet value"""
    count: int
    r"""Count of events with this value"""


class EventsFacetsData(BaseModel):
    value: str
    r"""The facet value"""

    count: int
    r"""Count of events with this value"""


class EventsFacetsResponseTypedDict(TypedDict):
    r"""Facet values"""

    data: List[EventsFacetsDataTypedDict]
    r"""Facet values with counts"""


class EventsFacetsResponse(BaseModel):
    r"""Facet values"""

    data: List[EventsFacetsData]
    r"""Facet values with counts"""
