"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
import pydantic
from pydantic import model_serializer
from raindrop_query.types import BaseModel, UNSET_SENTINEL
from raindrop_query.utils import FieldMetadata, QueryParamMetadata
from typing import Dict, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class EventsCountTimestampTypedDict(TypedDict):
    r"""Filter by event timestamp (e.g., timestamp[gte]=2024-01-01T00:00:00Z)"""

    gte: NotRequired[datetime]
    gt: NotRequired[datetime]
    lte: NotRequired[datetime]
    lt: NotRequired[datetime]


class EventsCountTimestamp(BaseModel):
    r"""Filter by event timestamp (e.g., timestamp[gte]=2024-01-01T00:00:00Z)"""

    gte: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    gt: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["gte", "gt", "lte", "lt"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsCountUserIDTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]
    starts_with: NotRequired[str]
    ends_with: NotRequired[str]
    contains: NotRequired[str]


class EventsCountUserID(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    starts_with: Annotated[
        Optional[str], pydantic.Field(alias="startsWith"), FieldMetadata(query=True)
    ] = None

    ends_with: Annotated[
        Optional[str], pydantic.Field(alias="endsWith"), FieldMetadata(query=True)
    ] = None

    contains: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "startsWith", "endsWith", "contains"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsCountConvoIDTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]
    starts_with: NotRequired[str]
    ends_with: NotRequired[str]
    contains: NotRequired[str]


class EventsCountConvoID(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    starts_with: Annotated[
        Optional[str], pydantic.Field(alias="startsWith"), FieldMetadata(query=True)
    ] = None

    ends_with: Annotated[
        Optional[str], pydantic.Field(alias="endsWith"), FieldMetadata(query=True)
    ] = None

    contains: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "startsWith", "endsWith", "contains"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsCountEventNameTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]
    starts_with: NotRequired[str]
    ends_with: NotRequired[str]
    contains: NotRequired[str]


class EventsCountEventName(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    starts_with: Annotated[
        Optional[str], pydantic.Field(alias="startsWith"), FieldMetadata(query=True)
    ] = None

    ends_with: Annotated[
        Optional[str], pydantic.Field(alias="endsWith"), FieldMetadata(query=True)
    ] = None

    contains: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "startsWith", "endsWith", "contains"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsCountUserIDUnionTypedDict = TypeAliasType(
    "EventsCountUserIDUnionTypedDict", Union[EventsCountUserIDTypedDict, str]
)
r"""Filter by user ID"""


EventsCountUserIDUnion = TypeAliasType(
    "EventsCountUserIDUnion", Union[EventsCountUserID, str]
)
r"""Filter by user ID"""


EventsCountConvoIDUnionTypedDict = TypeAliasType(
    "EventsCountConvoIDUnionTypedDict", Union[EventsCountConvoIDTypedDict, str]
)
r"""Filter by conversation ID"""


EventsCountConvoIDUnion = TypeAliasType(
    "EventsCountConvoIDUnion", Union[EventsCountConvoID, str]
)
r"""Filter by conversation ID"""


EventsCountEventNameUnionTypedDict = TypeAliasType(
    "EventsCountEventNameUnionTypedDict", Union[EventsCountEventNameTypedDict, str]
)
r"""Filter by event name"""


EventsCountEventNameUnion = TypeAliasType(
    "EventsCountEventNameUnion", Union[EventsCountEventName, str]
)
r"""Filter by event name"""


class EventsCountSignalTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]


class EventsCountSignal(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsCountSignalUnionTypedDict = TypeAliasType(
    "EventsCountSignalUnionTypedDict", Union[EventsCountSignalTypedDict, str]
)
r"""Filter by signal UUID"""


EventsCountSignalUnion = TypeAliasType(
    "EventsCountSignalUnion", Union[EventsCountSignal, str]
)
r"""Filter by signal UUID"""


EventsCountPropertiesEqTypedDict = TypeAliasType(
    "EventsCountPropertiesEqTypedDict", Union[str, float, bool]
)


EventsCountPropertiesEq = TypeAliasType(
    "EventsCountPropertiesEq", Union[str, float, bool]
)


EventsCountPropertiesNeqTypedDict = TypeAliasType(
    "EventsCountPropertiesNeqTypedDict", Union[str, float, bool]
)


EventsCountPropertiesNeq = TypeAliasType(
    "EventsCountPropertiesNeq", Union[str, float, bool]
)


class EventsCountPropertiesTypedDict(TypedDict):
    eq: NotRequired[EventsCountPropertiesEqTypedDict]
    neq: NotRequired[EventsCountPropertiesNeqTypedDict]
    gt: NotRequired[float]
    gte: NotRequired[float]
    lt: NotRequired[float]
    lte: NotRequired[float]


class EventsCountProperties(BaseModel):
    eq: Annotated[Optional[EventsCountPropertiesEq], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[EventsCountPropertiesNeq], FieldMetadata(query=True)] = None

    gt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    gte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "gt", "gte", "lt", "lte"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsCountPropertiesUnionTypedDict = TypeAliasType(
    "EventsCountPropertiesUnionTypedDict",
    Union[EventsCountPropertiesTypedDict, str, float, bool],
)


EventsCountPropertiesUnion = TypeAliasType(
    "EventsCountPropertiesUnion", Union[EventsCountProperties, str, float, bool]
)


EventsCountTraitsEqTypedDict = TypeAliasType(
    "EventsCountTraitsEqTypedDict", Union[str, float, bool]
)


EventsCountTraitsEq = TypeAliasType("EventsCountTraitsEq", Union[str, float, bool])


EventsCountTraitsNeqTypedDict = TypeAliasType(
    "EventsCountTraitsNeqTypedDict", Union[str, float, bool]
)


EventsCountTraitsNeq = TypeAliasType("EventsCountTraitsNeq", Union[str, float, bool])


class EventsCountTraitsTypedDict(TypedDict):
    eq: NotRequired[EventsCountTraitsEqTypedDict]
    neq: NotRequired[EventsCountTraitsNeqTypedDict]
    gt: NotRequired[float]
    gte: NotRequired[float]
    lt: NotRequired[float]
    lte: NotRequired[float]


class EventsCountTraits(BaseModel):
    eq: Annotated[Optional[EventsCountTraitsEq], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[EventsCountTraitsNeq], FieldMetadata(query=True)] = None

    gt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    gte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "gt", "gte", "lt", "lte"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsCountTraitsUnionTypedDict = TypeAliasType(
    "EventsCountTraitsUnionTypedDict",
    Union[EventsCountTraitsTypedDict, str, float, bool],
)


EventsCountTraitsUnion = TypeAliasType(
    "EventsCountTraitsUnion", Union[EventsCountTraits, str, float, bool]
)


class EventsCountRequestTypedDict(TypedDict):
    timestamp: NotRequired[EventsCountTimestampTypedDict]
    r"""Filter by event timestamp (e.g., timestamp[gte]=2024-01-01T00:00:00Z)"""
    user_id: NotRequired[EventsCountUserIDUnionTypedDict]
    r"""Filter by user ID"""
    convo_id: NotRequired[EventsCountConvoIDUnionTypedDict]
    r"""Filter by conversation ID"""
    event_name: NotRequired[EventsCountEventNameUnionTypedDict]
    r"""Filter by event name"""
    signal: NotRequired[EventsCountSignalUnionTypedDict]
    r"""Filter by signal UUID"""
    properties: NotRequired[Dict[str, EventsCountPropertiesUnionTypedDict]]
    traits: NotRequired[Dict[str, EventsCountTraitsUnionTypedDict]]


class EventsCountRequest(BaseModel):
    timestamp: Annotated[
        Optional[EventsCountTimestamp],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by event timestamp (e.g., timestamp[gte]=2024-01-01T00:00:00Z)"""

    user_id: Annotated[
        Optional[EventsCountUserIDUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by user ID"""

    convo_id: Annotated[
        Optional[EventsCountConvoIDUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by conversation ID"""

    event_name: Annotated[
        Optional[EventsCountEventNameUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by event name"""

    signal: Annotated[
        Optional[EventsCountSignalUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by signal UUID"""

    properties: Annotated[
        Optional[Dict[str, EventsCountPropertiesUnion]],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None

    traits: Annotated[
        Optional[Dict[str, EventsCountTraitsUnion]],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "timestamp",
                "user_id",
                "convo_id",
                "event_name",
                "signal",
                "properties",
                "traits",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsCountDataTypedDict(TypedDict):
    total: int
    r"""Total count"""


class EventsCountData(BaseModel):
    total: int
    r"""Total count"""


class EventsCountResponseTypedDict(TypedDict):
    r"""Event count"""

    data: EventsCountDataTypedDict


class EventsCountResponse(BaseModel):
    r"""Event count"""

    data: EventsCountData
