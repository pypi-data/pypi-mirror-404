"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
import pydantic
from pydantic import model_serializer
from raindrop_query.types import BaseModel, Nullable, UNSET_SENTINEL
from raindrop_query.utils import FieldMetadata, QueryParamMetadata
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class EventsListTimestampTypedDict(TypedDict):
    r"""Filter by event timestamp (e.g., timestamp[gte]=2024-01-01T00:00:00Z)"""

    gte: NotRequired[datetime]
    gt: NotRequired[datetime]
    lte: NotRequired[datetime]
    lt: NotRequired[datetime]


class EventsListTimestamp(BaseModel):
    r"""Filter by event timestamp (e.g., timestamp[gte]=2024-01-01T00:00:00Z)"""

    gte: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    gt: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["gte", "gt", "lte", "lt"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsListUserIDTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]
    starts_with: NotRequired[str]
    ends_with: NotRequired[str]
    contains: NotRequired[str]


class EventsListUserID(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    starts_with: Annotated[
        Optional[str], pydantic.Field(alias="startsWith"), FieldMetadata(query=True)
    ] = None

    ends_with: Annotated[
        Optional[str], pydantic.Field(alias="endsWith"), FieldMetadata(query=True)
    ] = None

    contains: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "startsWith", "endsWith", "contains"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsListConvoIDTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]
    starts_with: NotRequired[str]
    ends_with: NotRequired[str]
    contains: NotRequired[str]


class EventsListConvoID(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    starts_with: Annotated[
        Optional[str], pydantic.Field(alias="startsWith"), FieldMetadata(query=True)
    ] = None

    ends_with: Annotated[
        Optional[str], pydantic.Field(alias="endsWith"), FieldMetadata(query=True)
    ] = None

    contains: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "startsWith", "endsWith", "contains"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsListEventNameTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]
    starts_with: NotRequired[str]
    ends_with: NotRequired[str]
    contains: NotRequired[str]


class EventsListEventName(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    starts_with: Annotated[
        Optional[str], pydantic.Field(alias="startsWith"), FieldMetadata(query=True)
    ] = None

    ends_with: Annotated[
        Optional[str], pydantic.Field(alias="endsWith"), FieldMetadata(query=True)
    ] = None

    contains: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "startsWith", "endsWith", "contains"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsListUserIDUnionTypedDict = TypeAliasType(
    "EventsListUserIDUnionTypedDict", Union[EventsListUserIDTypedDict, str]
)
r"""Filter by user ID"""


EventsListUserIDUnion = TypeAliasType(
    "EventsListUserIDUnion", Union[EventsListUserID, str]
)
r"""Filter by user ID"""


EventsListConvoIDUnionTypedDict = TypeAliasType(
    "EventsListConvoIDUnionTypedDict", Union[EventsListConvoIDTypedDict, str]
)
r"""Filter by conversation ID"""


EventsListConvoIDUnion = TypeAliasType(
    "EventsListConvoIDUnion", Union[EventsListConvoID, str]
)
r"""Filter by conversation ID"""


EventsListEventNameUnionTypedDict = TypeAliasType(
    "EventsListEventNameUnionTypedDict", Union[EventsListEventNameTypedDict, str]
)
r"""Filter by event name"""


EventsListEventNameUnion = TypeAliasType(
    "EventsListEventNameUnion", Union[EventsListEventName, str]
)
r"""Filter by event name"""


class EventsListSignalQueryParamTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]


class EventsListSignalQueryParam(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsListSignalUnionTypedDict = TypeAliasType(
    "EventsListSignalUnionTypedDict", Union[EventsListSignalQueryParamTypedDict, str]
)
r"""Filter by signal UUID"""


EventsListSignalUnion = TypeAliasType(
    "EventsListSignalUnion", Union[EventsListSignalQueryParam, str]
)
r"""Filter by signal UUID"""


EventsListPropertiesEqTypedDict = TypeAliasType(
    "EventsListPropertiesEqTypedDict", Union[str, float, bool]
)


EventsListPropertiesEq = TypeAliasType(
    "EventsListPropertiesEq", Union[str, float, bool]
)


EventsListPropertiesNeqTypedDict = TypeAliasType(
    "EventsListPropertiesNeqTypedDict", Union[str, float, bool]
)


EventsListPropertiesNeq = TypeAliasType(
    "EventsListPropertiesNeq", Union[str, float, bool]
)


class EventsListPropertiesTypedDict(TypedDict):
    eq: NotRequired[EventsListPropertiesEqTypedDict]
    neq: NotRequired[EventsListPropertiesNeqTypedDict]
    gt: NotRequired[float]
    gte: NotRequired[float]
    lt: NotRequired[float]
    lte: NotRequired[float]


class EventsListProperties(BaseModel):
    eq: Annotated[Optional[EventsListPropertiesEq], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[EventsListPropertiesNeq], FieldMetadata(query=True)] = None

    gt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    gte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "gt", "gte", "lt", "lte"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsListPropertiesUnionTypedDict = TypeAliasType(
    "EventsListPropertiesUnionTypedDict",
    Union[EventsListPropertiesTypedDict, str, float, bool],
)


EventsListPropertiesUnion = TypeAliasType(
    "EventsListPropertiesUnion", Union[EventsListProperties, str, float, bool]
)


EventsListTraitsEqTypedDict = TypeAliasType(
    "EventsListTraitsEqTypedDict", Union[str, float, bool]
)


EventsListTraitsEq = TypeAliasType("EventsListTraitsEq", Union[str, float, bool])


EventsListTraitsNeqTypedDict = TypeAliasType(
    "EventsListTraitsNeqTypedDict", Union[str, float, bool]
)


EventsListTraitsNeq = TypeAliasType("EventsListTraitsNeq", Union[str, float, bool])


class EventsListTraitsTypedDict(TypedDict):
    eq: NotRequired[EventsListTraitsEqTypedDict]
    neq: NotRequired[EventsListTraitsNeqTypedDict]
    gt: NotRequired[float]
    gte: NotRequired[float]
    lt: NotRequired[float]
    lte: NotRequired[float]


class EventsListTraits(BaseModel):
    eq: Annotated[Optional[EventsListTraitsEq], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[EventsListTraitsNeq], FieldMetadata(query=True)] = None

    gt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    gte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "gt", "gte", "lt", "lte"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsListTraitsUnionTypedDict = TypeAliasType(
    "EventsListTraitsUnionTypedDict", Union[EventsListTraitsTypedDict, str, float, bool]
)


EventsListTraitsUnion = TypeAliasType(
    "EventsListTraitsUnion", Union[EventsListTraits, str, float, bool]
)


class EventsListRequestTypedDict(TypedDict):
    limit: NotRequired[float]
    cursor: NotRequired[str]
    order_by: NotRequired[str]
    timestamp: NotRequired[EventsListTimestampTypedDict]
    r"""Filter by event timestamp (e.g., timestamp[gte]=2024-01-01T00:00:00Z)"""
    user_id: NotRequired[EventsListUserIDUnionTypedDict]
    r"""Filter by user ID"""
    convo_id: NotRequired[EventsListConvoIDUnionTypedDict]
    r"""Filter by conversation ID"""
    event_name: NotRequired[EventsListEventNameUnionTypedDict]
    r"""Filter by event name"""
    signal: NotRequired[EventsListSignalUnionTypedDict]
    r"""Filter by signal UUID"""
    properties: NotRequired[Dict[str, EventsListPropertiesUnionTypedDict]]
    traits: NotRequired[Dict[str, EventsListTraitsUnionTypedDict]]


class EventsListRequest(BaseModel):
    limit: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 50

    cursor: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    order_by: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = "-timestamp"

    timestamp: Annotated[
        Optional[EventsListTimestamp],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by event timestamp (e.g., timestamp[gte]=2024-01-01T00:00:00Z)"""

    user_id: Annotated[
        Optional[EventsListUserIDUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by user ID"""

    convo_id: Annotated[
        Optional[EventsListConvoIDUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by conversation ID"""

    event_name: Annotated[
        Optional[EventsListEventNameUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by event name"""

    signal: Annotated[
        Optional[EventsListSignalUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by signal UUID"""

    properties: Annotated[
        Optional[Dict[str, EventsListPropertiesUnion]],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None

    traits: Annotated[
        Optional[Dict[str, EventsListTraitsUnion]],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "limit",
                "cursor",
                "order_by",
                "timestamp",
                "user_id",
                "convo_id",
                "event_name",
                "signal",
                "properties",
                "traits",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsListDetailsTypedDict(TypedDict):
    field: NotRequired[str]
    allowed_fields: NotRequired[List[str]]


class EventsListDetails(BaseModel):
    field: Optional[str] = None

    allowed_fields: Optional[List[str]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["field", "allowed_fields"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsListErrorTypedDict(TypedDict):
    code: str
    r"""Error code"""
    message: str
    r"""Human-readable error message"""
    details: NotRequired[EventsListDetailsTypedDict]


class EventsListError(BaseModel):
    code: str
    r"""Error code"""

    message: str
    r"""Human-readable error message"""

    details: Optional[EventsListDetails] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["details"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsListSignalResponseTypedDict(TypedDict):
    id: str
    name: str
    score: NotRequired[float]


class EventsListSignalResponse(BaseModel):
    id: str

    name: str

    score: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["score"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsListDataTypedDict(TypedDict):
    id: str
    event_name: str
    user_id: Nullable[str]
    convo_id: Nullable[str]
    timestamp: datetime
    user_input: Nullable[str]
    assistant_output: Nullable[str]
    received_at: NotRequired[datetime]
    signals: NotRequired[List[EventsListSignalResponseTypedDict]]
    properties: NotRequired[Dict[str, Nullable[Any]]]
    relevance_score: NotRequired[float]


class EventsListData(BaseModel):
    id: str

    event_name: str

    user_id: Nullable[str]

    convo_id: Nullable[str]

    timestamp: datetime

    user_input: Nullable[str]

    assistant_output: Nullable[str]

    received_at: Optional[datetime] = None

    signals: Optional[List[EventsListSignalResponse]] = None

    properties: Optional[Dict[str, Nullable[Any]]] = None

    relevance_score: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["received_at", "signals", "properties", "relevance_score"]
        )
        nullable_fields = set(["user_id", "convo_id", "user_input", "assistant_output"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class EventsListMetaTypedDict(TypedDict):
    cursor: Nullable[str]
    r"""Cursor for next page"""
    has_more: bool
    r"""Whether there are more results"""


class EventsListMeta(BaseModel):
    cursor: Nullable[str]
    r"""Cursor for next page"""

    has_more: bool
    r"""Whether there are more results"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class EventsListResponseTypedDict(TypedDict):
    r"""List of events"""

    data: List[EventsListDataTypedDict]
    r"""List of items"""
    meta: EventsListMetaTypedDict


class EventsListResponse(BaseModel):
    r"""List of events"""

    data: List[EventsListData]
    r"""List of items"""

    meta: EventsListMeta
