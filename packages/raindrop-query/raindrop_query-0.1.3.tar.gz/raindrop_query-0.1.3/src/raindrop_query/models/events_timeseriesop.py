"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
import pydantic
from pydantic import model_serializer
from raindrop_query.types import BaseModel, UNSET_SENTINEL
from raindrop_query.utils import FieldMetadata, QueryParamMetadata
from typing import Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class EventsTimeseriesTimestampTypedDict(TypedDict):
    r"""Filter by event timestamp"""

    gte: NotRequired[datetime]
    gt: NotRequired[datetime]
    lte: NotRequired[datetime]
    lt: NotRequired[datetime]


class EventsTimeseriesTimestamp(BaseModel):
    r"""Filter by event timestamp"""

    gte: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    gt: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[datetime], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["gte", "gt", "lte", "lt"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


QueryParamInterval = Literal[
    "minute",
    "hour",
    "day",
    "week",
    "month",
]
r"""Time bucket interval"""


class EventsTimeseriesEventNameTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]
    starts_with: NotRequired[str]
    ends_with: NotRequired[str]
    contains: NotRequired[str]


class EventsTimeseriesEventName(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    starts_with: Annotated[
        Optional[str], pydantic.Field(alias="startsWith"), FieldMetadata(query=True)
    ] = None

    ends_with: Annotated[
        Optional[str], pydantic.Field(alias="endsWith"), FieldMetadata(query=True)
    ] = None

    contains: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "startsWith", "endsWith", "contains"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EventsTimeseriesUserIDTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]
    starts_with: NotRequired[str]
    ends_with: NotRequired[str]
    contains: NotRequired[str]


class EventsTimeseriesUserID(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    starts_with: Annotated[
        Optional[str], pydantic.Field(alias="startsWith"), FieldMetadata(query=True)
    ] = None

    ends_with: Annotated[
        Optional[str], pydantic.Field(alias="endsWith"), FieldMetadata(query=True)
    ] = None

    contains: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "startsWith", "endsWith", "contains"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsTimeseriesEventNameUnionTypedDict = TypeAliasType(
    "EventsTimeseriesEventNameUnionTypedDict",
    Union[EventsTimeseriesEventNameTypedDict, str],
)
r"""Filter by event name"""


EventsTimeseriesEventNameUnion = TypeAliasType(
    "EventsTimeseriesEventNameUnion", Union[EventsTimeseriesEventName, str]
)
r"""Filter by event name"""


EventsTimeseriesUserIDUnionTypedDict = TypeAliasType(
    "EventsTimeseriesUserIDUnionTypedDict", Union[EventsTimeseriesUserIDTypedDict, str]
)
r"""Filter by user ID"""


EventsTimeseriesUserIDUnion = TypeAliasType(
    "EventsTimeseriesUserIDUnion", Union[EventsTimeseriesUserID, str]
)
r"""Filter by user ID"""


class EventsTimeseriesSignalTypedDict(TypedDict):
    eq: NotRequired[str]
    neq: NotRequired[str]


class EventsTimeseriesSignal(BaseModel):
    eq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[str], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsTimeseriesSignalUnionTypedDict = TypeAliasType(
    "EventsTimeseriesSignalUnionTypedDict", Union[EventsTimeseriesSignalTypedDict, str]
)
r"""Filter by signal UUID"""


EventsTimeseriesSignalUnion = TypeAliasType(
    "EventsTimeseriesSignalUnion", Union[EventsTimeseriesSignal, str]
)
r"""Filter by signal UUID"""


EventsTimeseriesPropertiesEqTypedDict = TypeAliasType(
    "EventsTimeseriesPropertiesEqTypedDict", Union[str, float, bool]
)


EventsTimeseriesPropertiesEq = TypeAliasType(
    "EventsTimeseriesPropertiesEq", Union[str, float, bool]
)


EventsTimeseriesPropertiesNeqTypedDict = TypeAliasType(
    "EventsTimeseriesPropertiesNeqTypedDict", Union[str, float, bool]
)


EventsTimeseriesPropertiesNeq = TypeAliasType(
    "EventsTimeseriesPropertiesNeq", Union[str, float, bool]
)


class EventsTimeseriesPropertiesTypedDict(TypedDict):
    eq: NotRequired[EventsTimeseriesPropertiesEqTypedDict]
    neq: NotRequired[EventsTimeseriesPropertiesNeqTypedDict]
    gt: NotRequired[float]
    gte: NotRequired[float]
    lt: NotRequired[float]
    lte: NotRequired[float]


class EventsTimeseriesProperties(BaseModel):
    eq: Annotated[Optional[EventsTimeseriesPropertiesEq], FieldMetadata(query=True)] = (
        None
    )

    neq: Annotated[
        Optional[EventsTimeseriesPropertiesNeq], FieldMetadata(query=True)
    ] = None

    gt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    gte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "gt", "gte", "lt", "lte"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsTimeseriesPropertiesUnionTypedDict = TypeAliasType(
    "EventsTimeseriesPropertiesUnionTypedDict",
    Union[EventsTimeseriesPropertiesTypedDict, str, float, bool],
)


EventsTimeseriesPropertiesUnion = TypeAliasType(
    "EventsTimeseriesPropertiesUnion",
    Union[EventsTimeseriesProperties, str, float, bool],
)


EventsTimeseriesTraitsEqTypedDict = TypeAliasType(
    "EventsTimeseriesTraitsEqTypedDict", Union[str, float, bool]
)


EventsTimeseriesTraitsEq = TypeAliasType(
    "EventsTimeseriesTraitsEq", Union[str, float, bool]
)


EventsTimeseriesTraitsNeqTypedDict = TypeAliasType(
    "EventsTimeseriesTraitsNeqTypedDict", Union[str, float, bool]
)


EventsTimeseriesTraitsNeq = TypeAliasType(
    "EventsTimeseriesTraitsNeq", Union[str, float, bool]
)


class EventsTimeseriesTraitsTypedDict(TypedDict):
    eq: NotRequired[EventsTimeseriesTraitsEqTypedDict]
    neq: NotRequired[EventsTimeseriesTraitsNeqTypedDict]
    gt: NotRequired[float]
    gte: NotRequired[float]
    lt: NotRequired[float]
    lte: NotRequired[float]


class EventsTimeseriesTraits(BaseModel):
    eq: Annotated[Optional[EventsTimeseriesTraitsEq], FieldMetadata(query=True)] = None

    neq: Annotated[Optional[EventsTimeseriesTraitsNeq], FieldMetadata(query=True)] = (
        None
    )

    gt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    gte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lt: Annotated[Optional[float], FieldMetadata(query=True)] = None

    lte: Annotated[Optional[float], FieldMetadata(query=True)] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["eq", "neq", "gt", "gte", "lt", "lte"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EventsTimeseriesTraitsUnionTypedDict = TypeAliasType(
    "EventsTimeseriesTraitsUnionTypedDict",
    Union[EventsTimeseriesTraitsTypedDict, str, float, bool],
)


EventsTimeseriesTraitsUnion = TypeAliasType(
    "EventsTimeseriesTraitsUnion", Union[EventsTimeseriesTraits, str, float, bool]
)


class EventsTimeseriesRequestTypedDict(TypedDict):
    timestamp: NotRequired[EventsTimeseriesTimestampTypedDict]
    r"""Filter by event timestamp"""
    interval: NotRequired[QueryParamInterval]
    r"""Time bucket interval"""
    event_name: NotRequired[EventsTimeseriesEventNameUnionTypedDict]
    r"""Filter by event name"""
    user_id: NotRequired[EventsTimeseriesUserIDUnionTypedDict]
    r"""Filter by user ID"""
    signal: NotRequired[EventsTimeseriesSignalUnionTypedDict]
    r"""Filter by signal UUID"""
    properties: NotRequired[Dict[str, EventsTimeseriesPropertiesUnionTypedDict]]
    traits: NotRequired[Dict[str, EventsTimeseriesTraitsUnionTypedDict]]


class EventsTimeseriesRequest(BaseModel):
    timestamp: Annotated[
        Optional[EventsTimeseriesTimestamp],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by event timestamp"""

    interval: Annotated[
        Optional[QueryParamInterval],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = "day"
    r"""Time bucket interval"""

    event_name: Annotated[
        Optional[EventsTimeseriesEventNameUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by event name"""

    user_id: Annotated[
        Optional[EventsTimeseriesUserIDUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by user ID"""

    signal: Annotated[
        Optional[EventsTimeseriesSignalUnion],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None
    r"""Filter by signal UUID"""

    properties: Annotated[
        Optional[Dict[str, EventsTimeseriesPropertiesUnion]],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None

    traits: Annotated[
        Optional[Dict[str, EventsTimeseriesTraitsUnion]],
        FieldMetadata(query=QueryParamMetadata(style="deepObject", explode=True)),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "timestamp",
                "interval",
                "event_name",
                "user_id",
                "signal",
                "properties",
                "traits",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class BucketTypedDict(TypedDict):
    timestamp: datetime
    r"""Start of the time bucket"""
    count: int
    r"""Count of events in this bucket"""


class Bucket(BaseModel):
    timestamp: datetime
    r"""Start of the time bucket"""

    count: int
    r"""Count of events in this bucket"""


class EventsTimeseriesDataTypedDict(TypedDict):
    buckets: List[BucketTypedDict]
    r"""Time buckets with counts"""
    total: int
    r"""Total count across all buckets"""


class EventsTimeseriesData(BaseModel):
    buckets: List[Bucket]
    r"""Time buckets with counts"""

    total: int
    r"""Total count across all buckets"""


IntervalResponse = Literal[
    "minute",
    "hour",
    "day",
    "week",
    "month",
]
r"""Time bucket interval"""


class EventsTimeseriesMetaTypedDict(TypedDict):
    interval: IntervalResponse
    r"""Time bucket interval"""


class EventsTimeseriesMeta(BaseModel):
    interval: IntervalResponse
    r"""Time bucket interval"""


class EventsTimeseriesResponseTypedDict(TypedDict):
    r"""Timeseries data"""

    data: EventsTimeseriesDataTypedDict
    meta: EventsTimeseriesMetaTypedDict


class EventsTimeseriesResponse(BaseModel):
    r"""Timeseries data"""

    data: EventsTimeseriesData

    meta: EventsTimeseriesMeta
