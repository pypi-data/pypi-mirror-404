"""
Hook primitive for waiting on external events.

Allows workflows to suspend and wait for external events such as
webhooks, manual approvals, or third-party callbacks.
"""

from collections.abc import Awaitable, Callable
from typing import Any

from loguru import logger
from pydantic import BaseModel

from pyworkflow.context import get_context, has_context


async def hook(
    name: str,
    *,
    timeout: str | int | None = None,
    on_created: Callable[[str], Awaitable[None]] | None = None,
    payload_schema: type[BaseModel] | None = None,
) -> Any:
    """
    Wait for an external event (webhook, approval, callback).

    The workflow suspends until resume_hook() is called with the token.
    Token is auto-generated in format "run_id:hook_id".

    Different contexts handle hooks differently:
    - MockContext: Returns mock payload immediately (configurable)
    - LocalContext (durable): Event-sourced hook with storage
    - LocalContext (transient): Raises NotImplementedError

    Args:
        name: Human-readable name for the hook (for logging/debugging)
        timeout: Optional maximum wait time:
            - str: Duration string ("24h", "7d")
            - int: Seconds
            - None: Wait forever
        on_created: Optional async callback invoked with the token when
            the hook is created. Use this to notify external systems.
        payload_schema: Optional Pydantic model class for payload validation.
            When provided, the schema is stored with the hook for CLI resume.

    Returns:
        Payload from resume_hook()

    Raises:
        RuntimeError: If called outside a workflow context
        NotImplementedError: If context doesn't support hooks

    Examples:
        # Simple hook with auto-generated token
        payload = await hook("approval")

        # With callback to notify external system
        async def notify_approver(token: str):
            await send_email(f"Approve at /webhook/{token}")

        payload = await hook("approval", on_created=notify_approver)

        # With timeout
        payload = await hook("approval", timeout="24h")
    """
    if not has_context():
        raise RuntimeError(
            "hook() must be called within a workflow context. "
            "Make sure you're using the @workflow decorator."
        )

    ctx = get_context()

    # Parse timeout to seconds
    timeout_seconds: int | None = None
    if timeout is not None:
        if isinstance(timeout, str):
            from pyworkflow.utils.duration import parse_duration

            timeout_seconds = parse_duration(timeout)
        else:
            timeout_seconds = int(timeout)

    logger.debug(
        f"Hook '{name}' via {ctx.__class__.__name__}",
        run_id=ctx.run_id,
        workflow_name=ctx.workflow_name,
    )

    # Call the context's hook method
    # Token is auto-generated by context, on_created is called before suspension
    return await ctx.hook(
        name,
        timeout=timeout_seconds,
        on_created=on_created,
        payload_schema=payload_schema,
    )
